<!-- 
GNU GENERAL PUBLIC LICENSE
Version 3, 19 November 2007

Copyright (C) 2025 GeoRoots

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.
 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Editor - GeoRoots</title>
    <style>


        /* Leaflet map styles section, copyright and disclaimer in script section*/

        .leaflet-pane,
        .leaflet-tile,
        .leaflet-marker-icon,
        .leaflet-marker-shadow,
        .leaflet-tile-container,
        .leaflet-pane > svg,
        .leaflet-pane > canvas,
        .leaflet-zoom-box,
        .leaflet-image-layer,
        .leaflet-layer {
            position: absolute;
            left: 0;
            top: 0;
            }
        .leaflet-container {
            overflow: hidden;
            }
        .leaflet-tile,
        .leaflet-marker-icon,
        .leaflet-marker-shadow {
            -webkit-user-select: none;
            -moz-user-select: none;
                    user-select: none;
            -webkit-user-drag: none;
            }
        /* Prevents IE11 from highlighting tiles in blue */
        .leaflet-tile::selection {
            background: transparent;
        }
        /* Safari renders non-retina tile on retina better with this, but Chrome is worse */
        .leaflet-safari .leaflet-tile {
            image-rendering: -webkit-optimize-contrast;
            }
        /* hack that prevents hw layers "stretching" when loading new tiles */
        .leaflet-safari .leaflet-tile-container {
            width: 1600px;
            height: 1600px;
            -webkit-transform-origin: 0 0;
            }
        .leaflet-marker-icon,
        .leaflet-marker-shadow {
            display: block;
            }
        /* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */
        /* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */
        .leaflet-container .leaflet-overlay-pane svg {
            max-width: none !important;
            max-height: none !important;
            }
        .leaflet-container .leaflet-marker-pane img,
        .leaflet-container .leaflet-shadow-pane img,
        .leaflet-container .leaflet-tile-pane img,
        .leaflet-container img.leaflet-image-layer,
        .leaflet-container .leaflet-tile {
            max-width: none !important;
            max-height: none !important;
            width: auto;
            padding: 0;
            }

        .leaflet-container img.leaflet-tile {
            /* See: https://bugs.chromium.org/p/chromium/issues/detail?id=600120 */
            mix-blend-mode: plus-lighter;
        }

        .leaflet-container.leaflet-touch-zoom {
            -ms-touch-action: pan-x pan-y;
            touch-action: pan-x pan-y;
            }
        .leaflet-container.leaflet-touch-drag {
            -ms-touch-action: pinch-zoom;
            /* Fallback for FF which doesn't support pinch-zoom */
            touch-action: none;
            touch-action: pinch-zoom;
        }
        .leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {
            -ms-touch-action: none;
            touch-action: none;
        }
        .leaflet-container {
            -webkit-tap-highlight-color: transparent;
        }
        .leaflet-container a {
            -webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);
        }
        .leaflet-tile {
            filter: inherit;
            visibility: hidden;
            }
        .leaflet-tile-loaded {
            visibility: inherit;
            }
        .leaflet-zoom-box {
            width: 0;
            height: 0;
            -moz-box-sizing: border-box;
                box-sizing: border-box;
            z-index: 800;
            }
        /* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */
        .leaflet-overlay-pane svg {
            -moz-user-select: none;
            }

        .leaflet-pane         { z-index: 400; }

        .leaflet-tile-pane    { z-index: 200; }
        .leaflet-overlay-pane { z-index: 400; }
        .leaflet-shadow-pane  { z-index: 500; }
        .leaflet-marker-pane  { z-index: 600; }
        .leaflet-tooltip-pane   { z-index: 650; }
        .leaflet-popup-pane   { z-index: 700; }

        .leaflet-map-pane canvas { z-index: 100; }
        .leaflet-map-pane svg    { z-index: 200; }

        .leaflet-vml-shape {
            width: 1px;
            height: 1px;
            }
        .lvml {
            behavior: url(#default#VML);
            display: inline-block;
            position: absolute;
            }


        /* control positioning */

        .leaflet-control {
            position: relative;
            z-index: 800;
            pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */
            pointer-events: auto;
            }
        .leaflet-top,
        .leaflet-bottom {
            position: absolute;
            z-index: 1000;
            pointer-events: none;
            }
        .leaflet-top {
            top: 0;
            }
        .leaflet-right {
            right: 0;
            }
        .leaflet-bottom {
            bottom: 0;
            }
        .leaflet-left {
            left: 0;
            }
        .leaflet-control {
            float: left;
            clear: both;
            }
        .leaflet-right .leaflet-control {
            float: right;
            }
        .leaflet-top .leaflet-control {
            margin-top: 10px;
            }
        .leaflet-bottom .leaflet-control {
            margin-bottom: 10px;
            }
        .leaflet-left .leaflet-control {
            margin-left: 10px;
            }
        .leaflet-right .leaflet-control {
            margin-right: 10px;
            }


        /* zoom and fade animations */

        .leaflet-fade-anim .leaflet-popup {
            opacity: 0;
            -webkit-transition: opacity 0.2s linear;
            -moz-transition: opacity 0.2s linear;
                    transition: opacity 0.2s linear;
            }
        .leaflet-fade-anim .leaflet-map-pane .leaflet-popup {
            opacity: 1;
            }
        .leaflet-zoom-animated {
            -webkit-transform-origin: 0 0;
                -ms-transform-origin: 0 0;
                    transform-origin: 0 0;
            }
        svg.leaflet-zoom-animated {
            will-change: transform;
        }

        .leaflet-zoom-anim .leaflet-zoom-animated {
            -webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);
            -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);
                    transition:         transform 0.25s cubic-bezier(0,0,0.25,1);
            }
        .leaflet-zoom-anim .leaflet-tile,
        .leaflet-pan-anim .leaflet-tile {
            -webkit-transition: none;
            -moz-transition: none;
                    transition: none;
            }

        .leaflet-zoom-anim .leaflet-zoom-hide {
            visibility: hidden;
            }


        /* cursors */

        .leaflet-interactive {
            cursor: pointer;
            }
        .leaflet-grab {
            cursor: -webkit-grab;
            cursor:    -moz-grab;
            cursor:         grab;
            }
        .leaflet-crosshair,
        .leaflet-crosshair .leaflet-interactive {
            cursor: crosshair;
            }
        .leaflet-popup-pane,
        .leaflet-control {
            cursor: auto;
            }
        .leaflet-dragging .leaflet-grab,
        .leaflet-dragging .leaflet-grab .leaflet-interactive,
        .leaflet-dragging .leaflet-marker-draggable {
            cursor: move;
            cursor: -webkit-grabbing;
            cursor:    -moz-grabbing;
            cursor:         grabbing;
            }

        /* marker & overlays interactivity */
        .leaflet-marker-icon,
        .leaflet-marker-shadow,
        .leaflet-image-layer,
        .leaflet-pane > svg path,
        .leaflet-tile-container {
            pointer-events: none;
            }

        .leaflet-marker-icon.leaflet-interactive,
        .leaflet-image-layer.leaflet-interactive,
        .leaflet-pane > svg path.leaflet-interactive,
        svg.leaflet-image-layer.leaflet-interactive path {
            pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */
            pointer-events: auto;
            }

        /* visual tweaks */

        .leaflet-container {
            background: #ddd;
            outline-offset: 1px;
            }
        .leaflet-container a {
            color: #0078A8;
            }
        .leaflet-zoom-box {
            border: 2px dotted #38f;
            background: rgba(255,255,255,0.5);
            }


        /* general typography */
        .leaflet-container {
            font-family: "Helvetica Neue", Arial, Helvetica, sans-serif;
            font-size: 12px;
            font-size: 0.75rem;
            line-height: 1.5;
            }


        /* general toolbar styles */

        .leaflet-bar {
            box-shadow: 0 1px 5px rgba(0,0,0,0.65);
            border-radius: 4px;
            }
        .leaflet-bar a {
            background-color: #fff;
            border-bottom: 1px solid #ccc;
            width: 26px;
            height: 26px;
            line-height: 26px;
            display: block;
            text-align: center;
            text-decoration: none;
            color: black;
            }
        .leaflet-bar a,
        .leaflet-control-layers-toggle {
            background-position: 50% 50%;
            background-repeat: no-repeat;
            display: block;
            }
        .leaflet-bar a:hover,
        .leaflet-bar a:focus {
            background-color: #f4f4f4;
            }
        .leaflet-bar a:first-child {
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
            }
        .leaflet-bar a:last-child {
            border-bottom-left-radius: 4px;
            border-bottom-right-radius: 4px;
            border-bottom: none;
            }
        .leaflet-bar a.leaflet-disabled {
            cursor: default;
            background-color: #f4f4f4;
            color: #bbb;
            }

        .leaflet-touch .leaflet-bar a {
            width: 30px;
            height: 30px;
            line-height: 30px;
            }
        .leaflet-touch .leaflet-bar a:first-child {
            border-top-left-radius: 2px;
            border-top-right-radius: 2px;
            }
        .leaflet-touch .leaflet-bar a:last-child {
            border-bottom-left-radius: 2px;
            border-bottom-right-radius: 2px;
            }

        /* zoom control */

        .leaflet-control-zoom-in,
        .leaflet-control-zoom-out {
            font: bold 18px 'Lucida Console', Monaco, monospace;
            text-indent: 1px;
            }

        .leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {
            font-size: 22px;
            }


        /* layers control */

        .leaflet-control-layers {
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            background: #fff;
            border-radius: 5px;
            }
        .leaflet-control-layers-toggle {
            background-image: url(images/layers.png);
            width: 36px;
            height: 36px;
            }
        .leaflet-retina .leaflet-control-layers-toggle {
            background-image: url(images/layers-2x.png);
            background-size: 26px 26px;
            }
        .leaflet-touch .leaflet-control-layers-toggle {
            width: 44px;
            height: 44px;
            }
        .leaflet-control-layers .leaflet-control-layers-list,
        .leaflet-control-layers-expanded .leaflet-control-layers-toggle {
            display: none;
            }
        .leaflet-control-layers-expanded .leaflet-control-layers-list {
            display: block;
            position: relative;
            }
        .leaflet-control-layers-expanded {
            padding: 6px 10px 6px 6px;
            color: #333;
            background: #fff;
            }
        .leaflet-control-layers-scrollbar {
            overflow-y: scroll;
            overflow-x: hidden;
            padding-right: 5px;
            }
        .leaflet-control-layers-selector {
            margin-top: 2px;
            position: relative;
            top: 1px;
            }
        .leaflet-control-layers label {
            display: block;
            font-size: 13px;
            font-size: 1.08333em;
            }
        .leaflet-control-layers-separator {
            height: 0;
            border-top: 1px solid #ddd;
            margin: 5px -10px 5px -6px;
            }

        /* Default icon URLs */
        .leaflet-default-icon-path { /* used only in path-guessing heuristic, see L.Icon.Default */
            background-image: url(images/marker-icon.png);
            }


        /* attribution and scale controls */

        .leaflet-container .leaflet-control-attribution {
            background: #fff;
            background: rgba(255, 255, 255, 0.8);
            margin: 0;
            }
        .leaflet-control-attribution,
        .leaflet-control-scale-line {
            padding: 0 5px;
            color: #333;
            line-height: 1.4;
            }
        .leaflet-control-attribution a {
            text-decoration: none;
            }
        .leaflet-control-attribution a:hover,
        .leaflet-control-attribution a:focus {
            text-decoration: underline;
            }
        .leaflet-attribution-flag {
            display: inline !important;
            vertical-align: baseline !important;
            width: 1em;
            height: 0.6669em;
            }
        .leaflet-left .leaflet-control-scale {
            margin-left: 5px;
            }
        .leaflet-bottom .leaflet-control-scale {
            margin-bottom: 5px;
            }
        .leaflet-control-scale-line {
            border: 2px solid #777;
            border-top: none;
            line-height: 1.1;
            padding: 2px 5px 1px;
            white-space: nowrap;
            -moz-box-sizing: border-box;
                box-sizing: border-box;
            background: rgba(255, 255, 255, 0.8);
            text-shadow: 1px 1px #fff;
            }
        .leaflet-control-scale-line:not(:first-child) {
            border-top: 2px solid #777;
            border-bottom: none;
            margin-top: -2px;
            }
        .leaflet-control-scale-line:not(:first-child):not(:last-child) {
            border-bottom: 2px solid #777;
            }

        .leaflet-touch .leaflet-control-attribution,
        .leaflet-touch .leaflet-control-layers,
        .leaflet-touch .leaflet-bar {
            box-shadow: none;
            }
        .leaflet-touch .leaflet-control-layers,
        .leaflet-touch .leaflet-bar {
            border: 2px solid rgba(0,0,0,0.2);
            background-clip: padding-box;
            }


        /* popup */

        .leaflet-popup {
            position: absolute;
            text-align: center;
            margin-bottom: 20px;
            }
        .leaflet-popup-content-wrapper {
            padding: 1px;
            text-align: left;
            border-radius: 12px;
            }
        .leaflet-popup-content {
            margin: 13px 24px 13px 20px;
            line-height: 1.3;
            font-size: 13px;
            font-size: 1.08333em;
            min-height: 1px;
            }
        .leaflet-popup-content p {
            margin: 17px 0;
            margin: 1.3em 0;
            }
        .leaflet-popup-tip-container {
            width: 40px;
            height: 20px;
            position: absolute;
            left: 50%;
            margin-top: -1px;
            margin-left: -20px;
            overflow: hidden;
            pointer-events: none;
            }
        .leaflet-popup-tip {
            width: 17px;
            height: 17px;
            padding: 1px;

            margin: -10px auto 0;
            pointer-events: auto;

            -webkit-transform: rotate(45deg);
            -moz-transform: rotate(45deg);
                -ms-transform: rotate(45deg);
                    transform: rotate(45deg);
            }
        .leaflet-popup-content-wrapper,
        .leaflet-popup-tip {
            background: white;
            color: #333;
            box-shadow: 0 3px 14px rgba(0,0,0,0.4);
            }
        .leaflet-container a.leaflet-popup-close-button {
            position: absolute;
            top: 0;
            right: 0;
            border: none;
            text-align: center;
            width: 24px;
            height: 24px;
            font: 16px/24px Tahoma, Verdana, sans-serif;
            color: #757575;
            text-decoration: none;
            background: transparent;
            }
        .leaflet-container a.leaflet-popup-close-button:hover,
        .leaflet-container a.leaflet-popup-close-button:focus {
            color: #585858;
            }
        .leaflet-popup-scrolled {
            overflow: auto;
            }

        .leaflet-oldie .leaflet-popup-content-wrapper {
            -ms-zoom: 1;
            }
        .leaflet-oldie .leaflet-popup-tip {
            width: 24px;
            margin: 0 auto;

            -ms-filter: "progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)";
            filter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);
            }

        .leaflet-oldie .leaflet-control-zoom,
        .leaflet-oldie .leaflet-control-layers,
        .leaflet-oldie .leaflet-popup-content-wrapper,
        .leaflet-oldie .leaflet-popup-tip {
            border: 1px solid #999;
            }


        /* div icon */

        .leaflet-div-icon {
            background: #fff;
            border: 1px solid #666;
            }


        /* Tooltip */
        /* Base styles for the element that has a tooltip */
        .leaflet-tooltip {
            position: absolute;
            padding: 6px;
            background-color: #fff;
            border: 1px solid #fff;
            border-radius: 3px;
            color: #222;
            white-space: nowrap;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            pointer-events: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.4);
            }
        .leaflet-tooltip.leaflet-interactive {
            cursor: pointer;
            pointer-events: auto;
            }
        .leaflet-tooltip-top:before,
        .leaflet-tooltip-bottom:before,
        .leaflet-tooltip-left:before,
        .leaflet-tooltip-right:before {
            position: absolute;
            pointer-events: none;
            border: 6px solid transparent;
            background: transparent;
            content: "";
            }

        /* Directions */

        .leaflet-tooltip-bottom {
            margin-top: 6px;
        }
        .leaflet-tooltip-top {
            margin-top: -6px;
        }
        .leaflet-tooltip-bottom:before,
        .leaflet-tooltip-top:before {
            left: 50%;
            margin-left: -6px;
            }
        .leaflet-tooltip-top:before {
            bottom: 0;
            margin-bottom: -12px;
            border-top-color: #fff;
            }
        .leaflet-tooltip-bottom:before {
            top: 0;
            margin-top: -12px;
            margin-left: -6px;
            border-bottom-color: #fff;
            }
        .leaflet-tooltip-left {
            margin-left: -6px;
        }
        .leaflet-tooltip-right {
            margin-left: 6px;
        }
        .leaflet-tooltip-left:before,
        .leaflet-tooltip-right:before {
            top: 50%;
            margin-top: -6px;
            }
        .leaflet-tooltip-left:before {
            right: 0;
            margin-right: -12px;
            border-left-color: #fff;
            }
        .leaflet-tooltip-right:before {
            left: 0;
            margin-left: -12px;
            border-right-color: #fff;
            }

        /* Printing */

        @media print {
            /* Prevent printers from removing background-images of controls. */
            .leaflet-control {
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                }
            }



        /* ===== MarkerCluster CSS ===== */
        /* Copyright and disclaimer below in script section */

        .leaflet-cluster-anim .leaflet-marker-icon, .leaflet-cluster-anim .leaflet-marker-shadow {
            -webkit-transition: -webkit-transform 0.3s ease-out, opacity 0.3s ease-in;
            -moz-transition: -moz-transform 0.3s ease-out, opacity 0.3s ease-in;
            -o-transition: -o-transform 0.3s ease-out, opacity 0.3s ease-in;
            transition: transform 0.3s ease-out, opacity 0.3s ease-in;
        }

        .leaflet-cluster-spider-leg {
            /* stroke-dashoffset (duration and function) should match with leaflet-marker-icon transform in order to track it exactly */
            -webkit-transition: -webkit-stroke-dashoffset 0.3s ease-out, -webkit-stroke-opacity 0.3s ease-in;
            -moz-transition: -moz-stroke-dashoffset 0.3s ease-out, -moz-stroke-opacity 0.3s ease-in;
            -o-transition: -o-stroke-dashoffset 0.3s ease-out, -o-stroke-opacity 0.3s ease-in;
            transition: stroke-dashoffset 0.3s ease-out, stroke-opacity 0.3s ease-in;
        }

        .marker-cluster-small {
	        background-color: rgba(181, 226, 140, 0.6);
        }   
        .marker-cluster-small div {
            background-color: rgba(110, 204, 57, 0.6);
        }

        .marker-cluster-medium {
            background-color: rgba(241, 211, 87, 0.6);
        }
        .marker-cluster-medium div {
            background-color: rgba(240, 194, 12, 0.6);
        }

        .marker-cluster-large {
            background-color: rgba(253, 156, 115, 0.6);
        }
        .marker-cluster-large div {
            background-color: rgba(241, 128, 23, 0.6);
        }

            /* IE 6-8 fallback colors */
        .leaflet-oldie .marker-cluster-small {
            background-color: rgb(181, 226, 140);
        }
        .leaflet-oldie .marker-cluster-small div {
            background-color: rgb(110, 204, 57);
        }

        .leaflet-oldie .marker-cluster-medium {
            background-color: rgb(241, 211, 87);
        }
        .leaflet-oldie .marker-cluster-medium div {
            background-color: rgb(240, 194, 12);
        }

        .leaflet-oldie .marker-cluster-large {
            background-color: rgb(253, 156, 115);
        }
        .leaflet-oldie .marker-cluster-large div {
            background-color: rgb(241, 128, 23);
        }

        .marker-cluster {
            background-clip: padding-box;
            border-radius: 20px;
        }
        .marker-cluster div {
            width: 30px;
            height: 30px;
            margin-left: 5px;
            margin-top: 5px;

            text-align: center;
            border-radius: 15px;
            font: 12px "Helvetica Neue", Arial, Helvetica, sans-serif;
        }
        .marker-cluster span {
            line-height: 30px;
        }





        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* CSS Variables for consistent color scheme */
        :root {
            --primary-color: #1b4332;
            --secondary-color: #40916c;
            --accent-color: #efffef;
            --dark-color: #1b4332;
            --light-color: #f8f9fa;
            --danger-color: #dc6575;
            --confirm-color: #40916c;
            --text-color: #333;
            --border-color: #e9ecef;
            --shadow-color: rgba(0, 0, 0, 0.1);
            
            /* Gray Scale */
            --gray-light: #f1f4f2;
            --gray-medium: #6c757d;
            --gray-dark: #495057;
            --gray-border: #e9ecef;
            --gray-input: #ddd;
            
            /* Basic Colors */
            --white: #ffffff;
            --black: #000000;
            
            /* Status Colors */
            --error-bg: #f8d7da;
            --error-border: #f5c6cb;
            --error-text: #721c24;
            --success-bg: #d4edda;
            --success-border: #c3e6cb;
            --success-text: #155724;
            --warning-bg: #fff3cd;
            --warning-border: #ffeaa7;
            --warning-text: #856404;
            
            /* Overlay and UI Colors */
            --modal-overlay: rgba(0, 0, 0, 0.7);
            --loading-overlay: rgba(0, 0, 0, 0.6);
            --spinner-bg: #f3f3f3;
            
            /* Hover States */
            --danger-hover: #d14a5a;
            --success-hover: #4a9f6b;
            --secondary-hover: #2d5a3d;
            
            /* Special Elements */
            --drop-border: #ccc;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-color);
            background: var(--light-color);
            min-height: 100vh;
            overflow: hidden;
        }

        #map {
            height: 100vh;
            width: 100%;
        }

        /* Coordinate display at bottom center */
        #coordinate-display {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(128, 128, 128, 0.85);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 500;
            pointer-events: none;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            white-space: nowrap;
        }

        /* Crosshair cursor mode for precise placement */
        .leaflet-container.cursor-crosshair { cursor: crosshair !important; }
        .leaflet-container.cursor-crosshair.leaflet-grab { cursor: crosshair !important; }
        .leaflet-container.cursor-crosshair.leaflet-dragging { cursor: crosshair !important; }
        .leaflet-container.cursor-crosshair * { cursor: crosshair !important; }
        /* Body-level override to defeat any grab/grabbing from Leaflet */
        body.crosshair-mode, body.crosshair-mode * { cursor: crosshair !important; }

        .welcome-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease;
        }

        .welcome-container {
            max-width: 800px;
            background: var(--white);
            border-radius: 16px;
            box-shadow: 0 20px 60px var(--shadow-color);
            overflow: hidden;
            margin: 20px;
        }

        .welcome-header {
            background: var(--secondary-color);
            color: var(--white);
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .language-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .language-selector select {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(10px);
        }

        .language-selector select option {
            background: var(--white);
            color: var(--text-color);
        }

        .language-selector label {
            font-size: 14px;
            opacity: 0.9;
        }

        .welcome-header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .collaboration-subtitle {
            font-size: 1.1rem !important;
            opacity: 0.85;
            font-style: italic;
            margin-top: -13px;
            margin-bottom: 22px !important;
        }

        .collaboration-subtitle a {
            color: var(--white);
            text-decoration: none;
            font-weight: 500;
        }

        .collaboration-subtitle a:hover {
            text-decoration: underline;
        }

        .welcome-header p {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .welcome-header .small-print {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 8px;
            line-height: 1.3;
        }

        .welcome-header .small-print a {
            color: var(--white);
            transition: color 0.3s ease;
        }

        .welcome-content {
            padding: 30px;
        }

        .welcome-content > p {
            font-size: 1.1rem;
            color: var(--gray-medium);
            margin-bottom: 15px;
            text-align: center;
        }

        .file-drop-area {
            width: 100%;
            height: 280px;
            border: 3px dashed var(--drop-border);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
            padding: 20px;
            transition: all 0.3s ease;
            background-color: var(--gray-light);
        }

        .file-drop-area.is-active {
            border-color: var(--confirm-color);
            background-color: rgba(64, 145, 108, 0.1);
        }

        .upload-icon {
            font-size: 3rem;
            color: var(--gray-medium);
            margin-bottom: 1rem;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .file-drop-area p {
            font-size: 1.1rem;
            color: var(--gray-dark);
            margin-bottom: 10px;
        }

        .file-drop-area .or-text {
            font-size: 0.9rem;
            color: var(--gray-medium);
            margin-bottom: 15px;
        }

        .upload-button {
            background: var(--confirm-color);
            color: var(--white);
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .upload-button:hover {
            background: var(--success-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(64, 145, 108, 0.3);
        }



        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--loading-overlay);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 999;
            flex-direction: column;
            color: var(--white);
        }

        .loading-overlay.show {
            display: flex;
        }

        .loading-spinner {
            border: 8px solid var(--spinner-bg);
            border-top: 8px solid var(--confirm-color);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .loading-overlay p {
            font-size: 1.2rem;
            font-weight: 600;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .invalid-features-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10001;
        }

        .invalid-features-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            max-width: 500px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .invalid-features-content h2 {
            margin-top: 0;
            color: var(--primary-color);
        }

        .invalid-features-content p {
            margin-bottom: 20px;
        }

        .invalid-features-content .button-group {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        .invalid-features-content .button {
            background-color: var(--secondary-color);
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            font-size: 1em;
        }

        .invalid-features-content .button:hover {
            background-color: var(--primary-color);
        }

        .hidden {
            display: none;
        }

        .info-box {
            padding: 10px;
            background-color: var(--white);
            border-radius: 5px;
            box-shadow: none; /* simplified: no inner shadow inside Leaflet popup */
            max-width: 300px;
        }

        .info-title {
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .info-content {
            font-size: 14px;
            word-break: break-word;
            overflow-wrap: anywhere;
        }

        .info-content a {
            color: var(--secondary-color);
            text-decoration: underline;
            transition: color 0.2s ease;
        }

        .info-content a:hover {
            color: var(--primary-color);
            text-decoration: underline;
        }

        .info-content a:visited {
            color: #2d6b4f;
        }

        .area-circle {
            stroke: #3388ff;
            stroke-width: 2;
            stroke-opacity: 0.8;
            fill: #3388ff;
            fill-opacity: 0.15;
        }

        /* Custom cluster styling to match app theme */
        .marker-cluster-small {
            background-color: rgba(51, 136, 255, 0.6);
            border: 2px solid #3388ff;
        }

        .marker-cluster-small div {
            background-color: rgba(51, 136, 255, 0.8);
            color: white;
            font-weight: 600;
        }

        .marker-cluster-medium {
            background-color: rgba(25, 85, 204, 0.6);
            border: 2px solid #1955cc;
        }

        .marker-cluster-medium div {
            background-color: rgba(25, 85, 204, 0.8);
            color: white;
            font-weight: 600;
        }

        .marker-cluster-large {
            background-color: rgba(12, 51, 153, 0.6);
            border: 2px solid #0c3399;
        }

        .marker-cluster-large div {
            background-color: rgba(12, 51, 153, 0.8);
            color: white;
            font-weight: 600;
        }

        /* Validation cluster styling (red) */
        .marker-cluster-validation-small {
            background-color: rgba(220, 101, 117, 0.6);
            border: 2px solid var(--danger-color);
        }

        .marker-cluster-validation-small div {
            background-color: rgba(220, 101, 117, 0.8);
            color: white;
            font-weight: 600;
        }

        .marker-cluster-validation-medium {
            background-color: rgba(200, 50, 70, 0.6);
            border: 2px solid #c83246;
        }

        .marker-cluster-validation-medium div {
            background-color: rgba(200, 50, 70, 0.8);
            color: white;
            font-weight: 600;
        }

        .marker-cluster-validation-large {
            background-color: rgba(180, 20, 40, 0.6);
            border: 2px solid #b41428;
        }

        .marker-cluster-validation-large div {
            background-color: rgba(180, 20, 40, 0.8);
            color: white;
            font-weight: 600;
        }

        .year-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 12px;
            border-radius: 8px;
            z-index: 1000;
            box-shadow: 0 4px 12px var(--shadow-color);
            max-width: 280px;
        }

        .year-controls h3 {
            margin-bottom: 11px;
            color: var(--gray-dark);
            font-size: 1.1rem;
        }

        .year-controls h4 {
            margin-bottom: 6px;
            padding-bottom: 4px;
            color: var(--gray-dark);
            font-size: 0.9rem;
            font-weight: 600;
            text-align: center;
            border-bottom: 1px solid #e4e4e4;
        }

        .control-group {
            margin-bottom: 5px;
        }

        .control-group button {
            background: var(--gray-light);
            color: var(--gray-dark);
            border: 1px solid var(--gray-border);
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            margin-right: 8px;
            margin-bottom: 6px;
            transition: all 0.3s ease;
        }

        .control-group button:hover {
            background: var(--gray-border);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px var(--shadow-color);
        }

        .control-group button.active {
            background: var(--confirm-color);
            color: var(--white);
            border-color: var(--confirm-color);
        }

        .control-group button.active:hover {
            background: var(--success-hover);
            box-shadow: 0 2px 8px rgba(64, 145, 108, 0.3);
        }

        /* Feature Actions specific styling */
        .action-group-frame {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .action-group-frame button {
            margin: 0;
            flex: 1;
        }

        /* Add buttons - light green tint */
        .btn-add {
            background: rgba(64, 145, 108, 0.1) !important;
            color: var(--secondary-color) !important;
            border-color: rgba(64, 145, 108, 0.3) !important;
        }

        .btn-add:hover {
            background: rgba(64, 145, 108, 0.2) !important;
        }

        .btn-add.active {
            background: var(--confirm-color) !important;
            color: var(--white) !important;
            border-color: var(--confirm-color) !important;
        }

        .btn-add.active:hover {
            background: var(--success-hover) !important;
        }

        /* Remove button - red tint */
        .btn-remove {
            background: rgba(220, 101, 117, 0.1) !important;
            color: #c85565 !important;
            border-color: rgba(220, 101, 117, 0.3) !important;
            width: 100%;
        }

        .btn-remove:hover {
            background: rgba(220, 101, 117, 0.2) !important;
        }

        .btn-remove.active {
            background: var(--danger-color) !important;
            color: var(--white) !important;
            border-color: var(--danger-color) !important;
        }

        .btn-remove.active:hover {
            background: #c85565 !important;
        }

        .legend {
            position: absolute;
            bottom: 30px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
            box-shadow: 0 4px 12px var(--shadow-color);
            max-width: 250px;
        }

        .legend h4 {
            margin-bottom: 10px;
            color: var(--gray-dark);
            font-size: 1.1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 3px;
        }

        #year-buttons button {
            padding: 6px 8px;
            margin: 2px;
            background-color: var(--gray-light);
            border: 1px solid var(--gray-border);
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #year-buttons button:hover {
            background-color: var(--gray-border);
            transform: translateY(-1px);
        }

        #year-buttons button.active {
            background-color: var(--confirm-color);
            color: var(--white);
            border-color: var(--confirm-color);
        }

        .controls-toggle {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: #ff9800;
            color: var(--white);
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .controls-toggle:hover {
            background: #fb8c00;
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.3);
        }

        /* Large screens */
        @media (min-width: 1200px) {
            .welcome-container {
                max-width: 900px;
            }
        }

        /* Medium screens */
        @media (max-width: 1024px) {
            .welcome-container {
                max-width: 700px;
                margin: 15px;
            }
            
            .welcome-header h1 {
                font-size: 2.2rem;
            }
        }

        /* Small screens */
        @media (max-width: 768px) {
            .welcome-header h1 {
                font-size: 2rem;
            }
            
            .welcome-container {
                margin: 10px;
            }
            
            .welcome-header,
            .welcome-content {
                padding: 20px;
            }

            .language-selector {
                position: static;
                justify-content: center;
                margin-bottom: 15px;
            }
            
            .file-drop-area {
                height: 200px;
                min-height: 44px;
            }
            
            .upload-button {
                min-height: 44px;
            }
            
            .year-controls {
                max-width: 200px;
                padding: 10px;
            }
            
            .legend {
                max-width: 200px;
                padding: 10px;
            }
        }

        /* Very small screens */
        @media (max-width: 480px) {
            .welcome-header h1 {
                font-size: 1.8rem;
            }
            
            .welcome-header,
            .welcome-content {
                padding: 15px;
            }
            
            .file-drop-area {
                height: 180px;
            }
        }

        /* Editing Controls Styles */
        .snap-toggle {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .snap-toggle input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }

        .snap-radius-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
        }

        .snap-radius-container label {
            font-size: 12px;
            color: var(--gray-dark);
            white-space: nowrap;
        }

        #snap-radius {
            flex: 1;
            min-width: 80px;
        }

        #snap-radius-value {
            font-size: 12px;
            color: var(--gray-dark);
            min-width: 20px;
        }

        /* Properties Modal */
        .properties-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-overlay);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10002;
        }

        .properties-modal.show {
            display: flex;
        }

        .properties-content {
            background: var(--white);
            border-radius: 12px;
            padding: 20px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px var(--shadow-color);
        }

        /* Auto-Clean Modal and Progress */
        .autoclean-content {
            background: var(--white);
            border-radius: 12px;
            width: min(520px, 92vw);
            box-shadow: 0 20px 60px var(--shadow-color);
            overflow: hidden;
        }
        .autoclean-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            border-bottom: 1px solid var(--gray-border);
        }
        .autoclean-header h3 {
            margin: 0;
        }
        .autoclean-body {
            padding: 16px;
        }
        .autoclean-warning {
            background: var(--warning-bg);
            border: 1px solid var(--warning-border);
            color: var(--warning-text);
            padding: 10px 12px;
            border-radius: 6px;
            margin-bottom: 14px;
            font-weight: 600;
        }
        .autoclean-options {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }
        .autoclean-option {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .autoclean-option-mandatory {
            opacity: 0.7;
            font-style: italic;
        }
        .mandatory-badge {
            font-size: 0.85em;
            color: #666;
            font-weight: 600;
        }
        .autoclean-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 12px 16px;
            border-top: 1px solid var(--gray-border);
            background: var(--light);
        }

        /* Validation Report Modal */
        .validation-report-content {
            background: var(--white);
            border-radius: 12px;
            width: min(600px, 92vw);
            max-height: 80vh;
            box-shadow: 0 20px 60px var(--shadow-color);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .validation-report-content .properties-header {
            padding: 20px 20px 10px 20px;
            margin-bottom: 0;
        }
        .validation-report-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }
        .validation-report-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--gray-border);
            background: var(--light-color);
            display: flex;
            justify-content: flex-end;
        }
        .validation-report-section {
            margin-bottom: 20px;
        }
        .validation-report-section h4 {
            color: var(--primary-color);
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        .validation-stat-grid {
            display: flex;
            flex-direction: column;
            gap: 0;
            border: 1px solid var(--gray-border);
            border-radius: 6px;
            background: var(--white);
            overflow: hidden;
        }
        .validation-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            border-bottom: 1px solid var(--gray-border);
        }
        .validation-stat-row:last-child {
            border-bottom: none;
        }
        .validation-stat-label {
            font-weight: 500;
            color: var(--text-color);
        }
        .validation-stat-value {
            font-weight: 600;
        }
        .validation-stat-value.success {
            color: var(--success-color);
        }
        .validation-stat-value.warning {
            color: #f59e0b;
        }
        .validation-stat-value.danger {
            color: var(--danger-color);
        }
        .validation-warning-box {
            background: #fef3c7;
            border: 2px solid #f59e0b;
            border-radius: 8px;
            padding: 12px 14px;
            margin: 16px 0;
        }
        .validation-warning-box h4 {
            color: #d97706;
            margin: 0 0 8px 0;
            font-size: 1em;
        }
        .validation-warning-box p {
            margin: 0;
            color: #92400e;
            line-height: 1.5;
        }
        .validation-success-box {
            background: #d1fae5;
            border: 2px solid var(--success-color);
            border-radius: 8px;
            padding: 12px 14px;
            margin: 16px 0;
        }
        .validation-success-box h4 {
            color: var(--success-color);
            margin: 0 0 8px 0;
            font-size: 1em;
        }
        .validation-success-box p {
            margin: 0;
            color: #065f46;
            line-height: 1.5;
        }

        /* Export Modal */
        .export-content {
            background: var(--white);
            border-radius: 12px;
            width: min(480px, 92vw);
            box-shadow: 0 20px 60px var(--shadow-color);
            overflow: hidden;
        }
        .export-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            background: var(--primary-color);
            color: var(--white);
        }
        .export-header h3 {
            margin: 0;
            color: var(--white);
        }
        .export-header .properties-close {
            color: var(--white);
            opacity: 0.9;
        }
        .export-header .properties-close:hover {
            opacity: 1;
        }
        .export-body {
            padding: 20px 16px;
        }
        .export-field {
            margin-bottom: 16px;
        }
        .export-field label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-color);
        }
        .export-filename-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--gray-border);
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            box-sizing: border-box;
        }
        .export-filename-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(27, 67, 50, 0.1);
        }
        .export-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-weight: normal;
        }
        .export-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .export-footer {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            padding: 12px 16px;
            border-top: 1px solid var(--gray-border);
            background: var(--light);
        }
        .export-btn {
            flex: 1;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .export-geojson-btn, .export-csv-btn {
            background: var(--secondary-color);
            color: var(--white);
        }
        .export-geojson-btn:hover, .export-csv-btn:hover {
            background: var(--primary-color);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        .export-cancel-btn {
            background: #dc3545;
            color: var(--white);
        }
        .export-cancel-btn:hover {
            background: #c82333;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .progress-container {
            padding: 20px 16px 16px 16px;
        }
        .progress-stage {
            font-weight: 600;
            margin-bottom: 10px;
        }
        .progress-bar {
            width: 100%;
            height: 12px;
            background: var(--gray-200);
            border-radius: 6px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            width: 0%;
            background: var(--primary-color);
            transition: width 0.2s ease;
        }

        .properties-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--gray-border);
            padding-bottom: 10px;
        }

        .properties-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--gray-medium);
        }

        .property-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .property-key, .property-value {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--gray-border);
            border-radius: 4px;
            font-size: 14px;
        }

        .property-remove {
            background: var(--danger-color);
            color: var(--white);
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .property-remove:hover {
            background: var(--danger-hover);
        }

        .add-property-btn, .save-properties-btn {
            background: var(--confirm-color);
            color: var(--white);
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            margin-top: 10px;
        }

        .add-property-btn:hover, .save-properties-btn:hover {
            background: var(--success-hover);
        }


        /* Inline tool hint */
        .tool-hint {
            font-size: 13px;
            color: var(--dark-color);
            margin-top: 10px;
            padding: 10px 12px;
            border: 2px solid #ff9800; /* orange highlight */
            background: rgba(255, 152, 0, 0.08);
            border-radius: 8px;
            font-weight: 600;
            line-height: 1.3;
            min-height: 20px;
            display: none; /* hidden until a tool hint is set */
        }


        /* Custom marker styles */
        .vertex-marker {
            cursor: move !important;
        }

        .edge-marker {
            cursor: pointer !important;
        }

        .vertex-marker:hover div {
            transform: scale(1.2);
            transition: transform 0.2s ease;
        }

        .edge-marker:hover div {
            transform: scale(1.3);
            transition: transform 0.2s ease;
        }

        /* Additional classes for inline styles */
        .button-margin-top {
            margin-top: 10px;
        }

        .button-full-width {
            width: 100%;
            justify-content: center;
        }

        .button-full-width-margin {
            width: 100%;
            justify-content: center;
            margin-bottom: 10px;
        }

        .multipolygon-selection {
            display: none;
        }

        .flex-center-gap {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .flex-center-gap-margin {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }

        .select-flex {
            flex: 1;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .modal-button-container {
            margin-top: 12px;
            display: flex;
            gap: 10px;
        }

        .danger-button {
            background: var(--danger-color);
        }

        .number-input-small {
            width: 90px;
            margin: 0 3px;
            padding: 2px 4px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        .progress-fill-initial {
            width: 0%;
        }

        .tooltip-header {
            font-weight: 700;
            margin-bottom: 6px;
        }

        .tooltip-content {
            min-width: 240px;
            max-width: 360px;
            white-space: pre-wrap;
        }

        /* Leaflet marker icon styles */
        .point-edit-marker div {
            background: #ff7800;
            border: 2px solid #000;
            border-radius: 50%;
            width: 16px;
            height: 16px;
        }

        .vertex-marker div {
            background-color: #ff7800;
            border: 2px solid #000;
            border-radius: 50%;
            width: 16px;
            height: 16px;
        }

        /* Distinct styling for hole vertices */
        .vertex-marker-hole div {
            background-color: #ff9933 !important;
            border: 2px solid #666 !important;
        }

        .edge-marker div {
            background-color: #4CAF50;
            border: 1px solid #000;
            border-radius: 50%;
            width: 10px;
            height: 10px;
            cursor: pointer;
            opacity: 0.8;
        }

    </style>
</head>
<body>
    <!--
        ============================================================================
        Turf.js - MIT License
        ============================================================================
        
        Copyright (c) 2019 Morgan Herlocker
        
        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in
        all copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
        ============================================================================
    -->
    <script>
        !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).turf={})}(this,(function(t){"use strict";function e(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=Array(e);n<e;n++)r[n]=t[n];return r}function n(t){if(Array.isArray(t))return t}function r(t,e,n){return e=l(e),function(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,c()?Reflect.construct(e,n||[],l(t).constructor):e.apply(t,n))}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,y(r.key),r)}}function s(t,e,n){return e&&o(t.prototype,e),n&&o(t,n),Object.defineProperty(t,"prototype",{writable:!1}),t}function a(t,e){var n="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!n){if(Array.isArray(t)||(n=_(t))||e){n&&(t=n);var r=0,i=function(){};return{s:i,n:function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}},e:function(t){throw t},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,s=!0,a=!1;return{s:function(){n=n.call(t)},n:function(){var t=n.next();return s=t.done,t},e:function(t){a=!0,o=t},f:function(){try{s||null==n.return||n.return()}finally{if(a)throw o}}}}function u(t,e,n){return(e=y(e))in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function l(t){return l=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},l(t)}function h(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&p(t,e)}function c(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(c=function(){return!!t})()}function f(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}function g(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function p(t,e){return p=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},p(t,e)}function v(t,e){return n(t)||function(t,e){var n=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=n){var r,i,o,s,a=[],u=!0,l=!1;try{if(o=(n=n.call(t)).next,0===e){if(Object(n)!==n)return;u=!1}else for(;!(u=(r=o.call(n)).done)&&(a.push(r.value),a.length!==e);u=!0);}catch(t){l=!0,i=t}finally{try{if(!u&&null!=n.return&&(s=n.return(),Object(s)!==s))return}finally{if(l)throw i}}return a}}(t,e)||_(t,e)||g()}function d(t){return function(t){if(Array.isArray(t))return e(t)}(t)||f(t)||_(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function y(t){var e=function(t,e){if("object"!=typeof t||!t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,e||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:e+""}function m(t){return m="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},m(t)}function _(t,n){if(t){if("string"==typeof t)return e(t,n);var r={}.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?e(t,n):void 0}}var x=6371008.8,E={centimeters:100*x,centimetres:100*x,degrees:360/(2*Math.PI),feet:3.28084*x,inches:39.37*x,kilometers:x/1e3,kilometres:x/1e3,meters:x,metres:x,miles:x/1609.344,millimeters:1e3*x,millimetres:1e3*x,nauticalmiles:x/1852,radians:1,yards:1.0936*x},k={acres:247105e-9,centimeters:1e4,centimetres:1e4,feet:10.763910417,hectares:1e-4,inches:1550.003100006,kilometers:1e-6,kilometres:1e-6,meters:1,metres:1,miles:386e-9,nauticalmiles:2.9155334959812285e-7,millimeters:1e6,millimetres:1e6,yards:1.195990046};function b(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r={type:"Feature"};return(0===n.id||n.id)&&(r.id=n.id),n.bbox&&(r.bbox=n.bbox),r.properties=e||{},r.geometry=t,r}function w(t,e){switch(t){case"Point":return I(e).geometry;case"LineString":return L(e).geometry;case"Polygon":return S(e).geometry;case"MultiPoint":return O(e).geometry;case"MultiLineString":return T(e).geometry;case"MultiPolygon":return R(e).geometry;default:throw new Error(t+" is invalid")}}function I(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!t)throw new Error("coordinates is required");if(!Array.isArray(t))throw new Error("coordinates must be an Array");if(t.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!U(t[0])||!U(t[1]))throw new Error("coordinates must contain numbers");return b({type:"Point",coordinates:t},e,n)}function N(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return C(t.map((function(t){return I(t,e)})),n)}function S(t,e){var n,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=a(t);try{for(i.s();!(n=i.n()).done;){var o=n.value;if(o.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(o[o.length-1].length!==o[0].length)throw new Error("First and last Position are not equivalent.");for(var s=0;s<o[o.length-1].length;s++)if(o[o.length-1][s]!==o[0][s])throw new Error("First and last Position are not equivalent.")}}catch(t){i.e(t)}finally{i.f()}return b({type:"Polygon",coordinates:t},e,r)}function M(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return C(t.map((function(t){return S(t,e)})),n)}function L(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(t.length<2)throw new Error("coordinates must be an array of two or more positions");return b({type:"LineString",coordinates:t},e,n)}function P(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return C(t.map((function(t){return L(t,e)})),n)}function C(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n={type:"FeatureCollection"};return e.id&&(n.id=e.id),e.bbox&&(n.bbox=e.bbox),n.features=t,n}function T(t,e){return b({type:"MultiLineString",coordinates:t},e,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}function O(t,e){return b({type:"MultiPoint",coordinates:t},e,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}function R(t,e){return b({type:"MultiPolygon",coordinates:t},e,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}function A(t,e){return b({type:"GeometryCollection",geometries:t},e,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}function D(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(e&&!(e>=0))throw new Error("precision must be a positive number");var n=Math.pow(10,e||0);return Math.round(t*n)/n}function F(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"kilometers",n=E[e];if(!n)throw new Error(e+" units is invalid");return t*n}function q(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"kilometers",n=E[e];if(!n)throw new Error(e+" units is invalid");return t/n}function V(t,e){return Y(q(t,e))}function G(t){var e=t%360;return e<0&&(e+=360),e}function B(t){return(t%=360)>180?t-360:t<-180?t+360:t}function Y(t){return 180*(t%(2*Math.PI))/Math.PI}function z(t){return t%360*Math.PI/180}function j(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"kilometers",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"kilometers";if(!(t>=0))throw new Error("length must be a positive number");return F(q(t,e),n)}function X(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"meters",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"kilometers";if(!(t>=0))throw new Error("area must be a positive number");var r=k[e];if(!r)throw new Error("invalid original units");var i=k[n];if(!i)throw new Error("invalid final units");return t/r*i}function U(t){return!isNaN(t)&&null!==t&&!Array.isArray(t)}function Z(t){return null!==t&&"object"===m(t)&&!Array.isArray(t)}function H(t){if(!t)throw new Error("bbox is required");if(!Array.isArray(t))throw new Error("bbox must be an Array");if(4!==t.length&&6!==t.length)throw new Error("bbox must be an Array of 4 or 6 numbers");t.forEach((function(t){if(!U(t))throw new Error("bbox must only contain numbers")}))}function W(t){if(!t)throw new Error("id is required");if(-1===["string","number"].indexOf(m(t)))throw new Error("id must be a number or a string")}var J=Object.freeze({__proto__:null,areaFactors:k,azimuthToBearing:B,bearingToAzimuth:G,convertArea:X,convertLength:j,degreesToRadians:z,earthRadius:x,factors:E,feature:b,featureCollection:C,geometry:w,geometryCollection:A,isNumber:U,isObject:Z,lengthToDegrees:V,lengthToRadians:q,lineString:L,lineStrings:P,multiLineString:T,multiPoint:O,multiPolygon:R,point:I,points:N,polygon:S,polygons:M,radiansToDegrees:Y,radiansToLength:F,round:D,validateBBox:H,validateId:W});function K(t){if(!t)throw new Error("coord is required");if(!Array.isArray(t)){if("Feature"===t.type&&null!==t.geometry&&"Point"===t.geometry.type)return d(t.geometry.coordinates);if("Point"===t.type)return d(t.coordinates)}if(Array.isArray(t)&&t.length>=2&&!Array.isArray(t[0])&&!Array.isArray(t[1]))return d(t);throw new Error("coord must be GeoJSON Point or an Array of numbers")}function Q(t){if(Array.isArray(t))return t;if("Feature"===t.type){if(null!==t.geometry)return t.geometry.coordinates}else if(t.coordinates)return t.coordinates;throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")}function $(t){if(t.length>1&&U(t[0])&&U(t[1]))return!0;if(Array.isArray(t[0])&&t[0].length)return $(t[0]);throw new Error("coordinates must only contain numbers")}function tt(t,e,n){if(!e||!n)throw new Error("type and name required");if(!t||t.type!==e)throw new Error("Invalid input to "+n+": must be a "+e+", given "+t.type)}function et(t,e,n){if(!t)throw new Error("No feature passed");if(!n)throw new Error(".featureOf() requires a name");if(!t||"Feature"!==t.type||!t.geometry)throw new Error("Invalid input to "+n+", Feature with geometry required");if(!t.geometry||t.geometry.type!==e)throw new Error("Invalid input to "+n+": must be a "+e+", given "+t.geometry.type)}function nt(t,e,n){if(!t)throw new Error("No featureCollection passed");if(!n)throw new Error(".collectionOf() requires a name");if(!t||"FeatureCollection"!==t.type)throw new Error("Invalid input to "+n+", FeatureCollection required");var r,i=a(t.features);try{for(i.s();!(r=i.n()).done;){var o=r.value;if(!o||"Feature"!==o.type||!o.geometry)throw new Error("Invalid input to "+n+", Feature with geometry required");if(!o.geometry||o.geometry.type!==e)throw new Error("Invalid input to "+n+": must be a "+e+", given "+o.geometry.type)}}catch(t){i.e(t)}finally{i.f()}}function rt(t){return"Feature"===t.type?t.geometry:t}function it(t,e){return"FeatureCollection"===t.type?"FeatureCollection":"GeometryCollection"===t.type?"GeometryCollection":"Feature"===t.type&&null!==t.geometry?t.geometry.type:t.type}var ot=Object.freeze({__proto__:null,collectionOf:nt,containsNumber:$,featureOf:et,geojsonType:tt,getCoord:K,getCoords:Q,getGeom:rt,getType:it});function st(t,e){if(!0===(arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}).final)return function(t,e){var n=st(e,t);return n=(n+180)%360}(t,e);var n=K(t),r=K(e),i=z(n[0]),o=z(r[0]),s=z(n[1]),a=z(r[1]),u=Math.sin(o-i)*Math.cos(a),l=Math.cos(s)*Math.sin(a)-Math.sin(s)*Math.cos(a)*Math.cos(o-i);return Y(Math.atan2(u,l))}function at(t,e,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=K(t),o=z(i[0]),s=z(i[1]),a=z(n),u=q(e,r.units),l=Math.asin(Math.sin(s)*Math.cos(u)+Math.cos(s)*Math.sin(u)*Math.cos(a));return I([Y(o+Math.atan2(Math.sin(a)*Math.sin(u)*Math.cos(s),Math.cos(u)-Math.sin(s)*Math.sin(l))),Y(l)],r.properties)}function ut(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=K(t),i=K(e),o=z(i[1]-r[1]),s=z(i[0]-r[0]),a=z(r[1]),u=z(i[1]),l=Math.pow(Math.sin(o/2),2)+Math.pow(Math.sin(s/2),2)*Math.cos(a)*Math.cos(u);return F(2*Math.atan2(Math.sqrt(l),Math.sqrt(1-l)),n.units)}function lt(t,e){var n;return(n=(arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}).final?ht(K(e),K(t)):ht(K(t),K(e)))>180?-(360-n):n}function ht(t,e){var n=z(t[1]),r=z(e[1]),i=z(e[0]-t[0]);i>Math.PI&&(i-=2*Math.PI),i<-Math.PI&&(i+=2*Math.PI);var o=Math.log(Math.tan(r/2+Math.PI/4)/Math.tan(n/2+Math.PI/4));return(Y(Math.atan2(i,o))+360)%360}function ct(t,e,n){if(null!==t)for(var r,i,o,s,a,u,l,h,c=0,f=0,g=t.type,p="FeatureCollection"===g,v="Feature"===g,d=p?t.features.length:1,y=0;y<d;y++){a=(h=!!(l=p?t.features[y].geometry:v?t.geometry:t)&&"GeometryCollection"===l.type)?l.geometries.length:1;for(var m=0;m<a;m++){var _=0,x=0;if(null!==(s=h?l.geometries[m]:l)){u=s.coordinates;var E=s.type;switch(c=!n||"Polygon"!==E&&"MultiPolygon"!==E?0:1,E){case null:break;case"Point":if(!1===e(u,f,y,_,x))return!1;f++,_++;break;case"LineString":case"MultiPoint":for(r=0;r<u.length;r++){if(!1===e(u[r],f,y,_,x))return!1;f++,"MultiPoint"===E&&_++}"LineString"===E&&_++;break;case"Polygon":case"MultiLineString":for(r=0;r<u.length;r++){for(i=0;i<u[r].length-c;i++){if(!1===e(u[r][i],f,y,_,x))return!1;f++}"MultiLineString"===E&&_++,"Polygon"===E&&x++}"Polygon"===E&&_++;break;case"MultiPolygon":for(r=0;r<u.length;r++){for(x=0,i=0;i<u[r].length;i++){for(o=0;o<u[r][i].length-c;o++){if(!1===e(u[r][i][o],f,y,_,x))return!1;f++}x++}_++}break;case"GeometryCollection":for(r=0;r<s.geometries.length;r++)if(!1===ct(s.geometries[r],e,n))return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function ft(t,e,n,r){var i=n;return ct(t,(function(t,r,o,s,a){i=0===r&&void 0===n?t:e(i,t,r,o,s,a)}),r),i}function gt(t,e){var n;switch(t.type){case"FeatureCollection":for(n=0;n<t.features.length&&!1!==e(t.features[n].properties,n);n++);break;case"Feature":e(t.properties,0)}}function pt(t,e,n){var r=n;return gt(t,(function(t,i){r=0===i&&void 0===n?t:e(r,t,i)})),r}function vt(t,e){if("Feature"===t.type)e(t,0);else if("FeatureCollection"===t.type)for(var n=0;n<t.features.length&&!1!==e(t.features[n],n);n++);}function dt(t,e,n){var r=n;return vt(t,(function(t,i){r=0===i&&void 0===n?t:e(r,t,i)})),r}function yt(t){var e=[];return ct(t,(function(t){e.push(t)})),e}function mt(t,e){var n,r,i,o,s,a,u,l,h,c,f=0,g="FeatureCollection"===t.type,p="Feature"===t.type,v=g?t.features.length:1;for(n=0;n<v;n++){for(a=g?t.features[n].geometry:p?t.geometry:t,l=g?t.features[n].properties:p?t.properties:{},h=g?t.features[n].bbox:p?t.bbox:void 0,c=g?t.features[n].id:p?t.id:void 0,s=(u=!!a&&"GeometryCollection"===a.type)?a.geometries.length:1,i=0;i<s;i++)if(null!==(o=u?a.geometries[i]:a))switch(o.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":if(!1===e(o,f,l,h,c))return!1;break;case"GeometryCollection":for(r=0;r<o.geometries.length;r++)if(!1===e(o.geometries[r],f,l,h,c))return!1;break;default:throw new Error("Unknown Geometry Type")}else if(!1===e(null,f,l,h,c))return!1;f++}}function _t(t,e,n){var r=n;return mt(t,(function(t,i,o,s,a){r=0===i&&void 0===n?t:e(r,t,i,o,s,a)})),r}function xt(t,e){mt(t,(function(t,n,r,i,o){var s,a=null===t?null:t.type;switch(a){case null:case"Point":case"LineString":case"Polygon":return!1!==e(b(t,r,{bbox:i,id:o}),n,0)&&void 0}switch(a){case"MultiPoint":s="Point";break;case"MultiLineString":s="LineString";break;case"MultiPolygon":s="Polygon"}for(var u=0;u<t.coordinates.length;u++){var l=t.coordinates[u];if(!1===e(b({type:s,coordinates:l},r),n,u))return!1}}))}function Et(t,e,n){var r=n;return xt(t,(function(t,i,o){r=0===i&&0===o&&void 0===n?t:e(r,t,i,o)})),r}function kt(t,e){xt(t,(function(t,n,r){var i=0;if(t.geometry){var o=t.geometry.type;if("Point"!==o&&"MultiPoint"!==o){var s,a=0,u=0,l=0;return!1!==ct(t,(function(o,h,c,f,g){if(void 0===s||n>a||f>u||g>l)return s=o,a=n,u=f,l=g,void(i=0);var p=L([s,o],t.properties);if(!1===e(p,n,r,g,i))return!1;i++,s=o}))&&void 0}}}))}function bt(t,e,n){var r=n,i=!1;return kt(t,(function(t,o,s,a,u){r=!1===i&&void 0===n?t:e(r,t,o,s,a,u),i=!0})),r}function wt(t,e){if(!t)throw new Error("geojson is required");xt(t,(function(t,n,r){if(null!==t.geometry){var i=t.geometry.type,o=t.geometry.coordinates;switch(i){case"LineString":if(!1===e(t,n,r,0,0))return!1;break;case"Polygon":for(var s=0;s<o.length;s++)if(!1===e(L(o[s],t.properties),n,r,s))return!1}}}))}function It(t,e,n){var r=n;return wt(t,(function(t,i,o,s){r=0===i&&void 0===n?t:e(r,t,i,o,s)})),r}function Nt(t,e){if(!Z(e=e||{}))throw new Error("options is invalid");var n,r=e.featureIndex||0,i=e.multiFeatureIndex||0,o=e.geometryIndex||0,s=e.segmentIndex||0,a=e.properties;switch(t.type){case"FeatureCollection":r<0&&(r=t.features.length+r),a=a||t.features[r].properties,n=t.features[r].geometry;break;case"Feature":a=a||t.properties,n=t.geometry;break;case"Point":case"MultiPoint":return null;case"LineString":case"Polygon":case"MultiLineString":case"MultiPolygon":n=t;break;default:throw new Error("geojson is invalid")}if(null===n)return null;var u=n.coordinates;switch(n.type){case"Point":case"MultiPoint":return null;case"LineString":return s<0&&(s=u.length+s-1),L([u[s],u[s+1]],a,e);case"Polygon":return o<0&&(o=u.length+o),s<0&&(s=u[o].length+s-1),L([u[o][s],u[o][s+1]],a,e);case"MultiLineString":return i<0&&(i=u.length+i),s<0&&(s=u[i].length+s-1),L([u[i][s],u[i][s+1]],a,e);case"MultiPolygon":return i<0&&(i=u.length+i),o<0&&(o=u[i].length+o),s<0&&(s=u[i][o].length-s-1),L([u[i][o][s],u[i][o][s+1]],a,e)}throw new Error("geojson is invalid")}function St(t,e){if(!Z(e=e||{}))throw new Error("options is invalid");var n,r=e.featureIndex||0,i=e.multiFeatureIndex||0,o=e.geometryIndex||0,s=e.coordIndex||0,a=e.properties;switch(t.type){case"FeatureCollection":r<0&&(r=t.features.length+r),a=a||t.features[r].properties,n=t.features[r].geometry;break;case"Feature":a=a||t.properties,n=t.geometry;break;case"Point":case"MultiPoint":return null;case"LineString":case"Polygon":case"MultiLineString":case"MultiPolygon":n=t;break;default:throw new Error("geojson is invalid")}if(null===n)return null;var u=n.coordinates;switch(n.type){case"Point":return I(u,a,e);case"MultiPoint":return i<0&&(i=u.length+i),I(u[i],a,e);case"LineString":return s<0&&(s=u.length+s),I(u[s],a,e);case"Polygon":return o<0&&(o=u.length+o),s<0&&(s=u[o].length+s),I(u[o][s],a,e);case"MultiLineString":return i<0&&(i=u.length+i),s<0&&(s=u[i].length+s),I(u[i][s],a,e);case"MultiPolygon":return i<0&&(i=u.length+i),o<0&&(o=u[i].length+o),s<0&&(s=u[i][o].length-s),I(u[i][o][s],a,e)}throw new Error("geojson is invalid")}var Mt=Object.freeze({__proto__:null,coordAll:yt,coordEach:ct,coordReduce:ft,featureEach:vt,featureReduce:dt,findPoint:St,findSegment:Nt,flattenEach:xt,flattenReduce:Et,geomEach:mt,geomReduce:_t,lineEach:wt,lineReduce:It,propEach:gt,propReduce:pt,segmentEach:kt,segmentReduce:bt});function Lt(t){return _t(t,(function(t,e){return t+function(t){var e,n=0;switch(t.type){case"Polygon":return Pt(t.coordinates);case"MultiPolygon":for(e=0;e<t.coordinates.length;e++)n+=Pt(t.coordinates[e]);return n;case"Point":case"MultiPoint":case"LineString":case"MultiLineString":return 0}return 0}(e)}),0)}function Pt(t){var e=0;if(t&&t.length>0){e+=Math.abs(Ot(t[0]));for(var n=1;n<t.length;n++)e-=Math.abs(Ot(t[n]))}return e}var Ct=x*x/2,Tt=Math.PI/180;function Ot(t){var e=t.length-1;if(e<=2)return 0;for(var n=0,r=0;r<e;){var i=t[r],o=t[r+1===e?0:r+1],s=t[r+2>=e?(r+2)%e:r+2],a=i[0]*Tt,u=o[1]*Tt;n+=(s[0]*Tt-a)*Math.sin(u),r++}return n*Ct}function Rt(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null!=t.bbox&&!0!==e.recompute)return t.bbox;var n=[1/0,1/0,-1/0,-1/0];return ct(t,(function(t){n[0]>t[0]&&(n[0]=t[0]),n[1]>t[1]&&(n[1]=t[1]),n[2]<t[0]&&(n[2]=t[0]),n[3]<t[1]&&(n[3]=t[1])})),n}function At(t,e){var n,r,i,o,s,a,u;for(r=1;r<=8;r*=2){for(n=[],o=!(Ft(i=t[t.length-1],e)&r),s=0;s<t.length;s++)(u=!(Ft(a=t[s],e)&r))!==o&&n.push(Dt(i,a,r,e)),u&&n.push(a),i=a,o=u;if(!(t=n).length)break}return n}function Dt(t,e,n,r){return 8&n?[t[0]+(e[0]-t[0])*(r[3]-t[1])/(e[1]-t[1]),r[3]]:4&n?[t[0]+(e[0]-t[0])*(r[1]-t[1])/(e[1]-t[1]),r[1]]:2&n?[r[2],t[1]+(e[1]-t[1])*(r[2]-t[0])/(e[0]-t[0])]:1&n?[r[0],t[1]+(e[1]-t[1])*(r[0]-t[0])/(e[0]-t[0])]:null}function Ft(t,e){var n=0;return t[0]<e[0]?n|=1:t[0]>e[2]&&(n|=2),t[1]<e[1]?n|=4:t[1]>e[3]&&(n|=8),n}function qt(t,e){var n,r=[],i=a(t);try{for(i.s();!(n=i.n()).done;){var o=At(n.value,e);o.length>0&&(o[0][0]===o[o.length-1][0]&&o[0][1]===o[o.length-1][1]||o.push(o[0]),o.length>=4&&r.push(o))}}catch(t){i.e(t)}finally{i.f()}return r}function Vt(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=Number(t[0]),r=Number(t[1]),i=Number(t[2]),o=Number(t[3]);if(6===t.length)throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");var s=[n,r];return S([[s,[i,r],[i,o],[n,o],s]],e.properties,{bbox:t,id:e.id})}var Gt=function(){return s((function t(e){i(this,t),this.points=e.points||[],this.duration=e.duration||1e4,this.sharpness=e.sharpness||.85,this.centers=[],this.controls=[],this.stepLength=e.stepLength||60,this.length=this.points.length,this.delay=0;for(var n=0;n<this.length;n++)this.points[n].z=this.points[n].z||0;for(var r=0;r<this.length-1;r++){var o=this.points[r],s=this.points[r+1];this.centers.push({x:(o.x+s.x)/2,y:(o.y+s.y)/2,z:(o.z+s.z)/2})}this.controls.push([this.points[0],this.points[0]]);for(var a=0;a<this.centers.length-1;a++){var u=this.points[a+1].x-(this.centers[a].x+this.centers[a+1].x)/2,l=this.points[a+1].y-(this.centers[a].y+this.centers[a+1].y)/2,h=this.points[a+1].z-(this.centers[a].y+this.centers[a+1].z)/2;this.controls.push([{x:(1-this.sharpness)*this.points[a+1].x+this.sharpness*(this.centers[a].x+u),y:(1-this.sharpness)*this.points[a+1].y+this.sharpness*(this.centers[a].y+l),z:(1-this.sharpness)*this.points[a+1].z+this.sharpness*(this.centers[a].z+h)},{x:(1-this.sharpness)*this.points[a+1].x+this.sharpness*(this.centers[a+1].x+u),y:(1-this.sharpness)*this.points[a+1].y+this.sharpness*(this.centers[a+1].y+l),z:(1-this.sharpness)*this.points[a+1].z+this.sharpness*(this.centers[a+1].z+h)}])}return this.controls.push([this.points[this.length-1],this.points[this.length-1]]),this.steps=this.cacheSteps(this.stepLength),this}),[{key:"cacheSteps",value:function(t){var e=[],n=this.pos(0);e.push(0);for(var r=0;r<this.duration;r+=10){var i=this.pos(r);Math.sqrt((i.x-n.x)*(i.x-n.x)+(i.y-n.y)*(i.y-n.y)+(i.z-n.z)*(i.z-n.z))>t&&(e.push(r),n=i)}return e}},{key:"vector",value:function(t){var e=this.pos(t+10),n=this.pos(t-10);return{angle:180*Math.atan2(e.y-n.y,e.x-n.x)/3.14,speed:Math.sqrt((n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y)+(n.z-e.z)*(n.z-e.z))}}},{key:"pos",value:function(t){var e=t-this.delay;e<0&&(e=0),e>this.duration&&(e=this.duration-1);var n=e/this.duration;if(n>=1)return this.points[this.length-1];var r=Math.floor((this.points.length-1)*n);return function(t,e,n,r,i){var o=function(t){var e=t*t,n=e*t;return[n,3*e*(1-t),3*t*(1-t)*(1-t),(1-t)*(1-t)*(1-t)]}(t),s={x:i.x*o[0]+r.x*o[1]+n.x*o[2]+e.x*o[3],y:i.y*o[0]+r.y*o[1]+n.y*o[2]+e.y*o[3],z:i.z*o[0]+r.z*o[1]+n.z*o[2]+e.z*o[3]};return s}((this.length-1)*n-r,this.points[r],this.controls[r][1],this.controls[r+1][0],this.points[r+1])}}])}();function Bt(t){for(var e,n,r=Q(t),i=0,o=1;o<r.length;)e=n||r[0],i+=((n=r[o])[0]-e[0])*(n[1]+e[1]),o++;return i>0}function Yt(t,e){for(var n=0,r=0,i=0,o=0,s=0,a=0,u=0,l=0,h=null,c=null,f=t[0],g=t[1],p=e.length;n<p;n++){r=0;var v=e[n].length-1,d=e[n];if((h=d[0])[0]!==d[v][0]&&h[1]!==d[v][1])throw new Error("First and last coordinates in a ring must be the same");for(s=h[0]-f,a=h[1]-g;r<v;r++)if(l=(c=d[r+1])[1]-g,a<0&&l<0||a>0&&l>0)a=l,s=(h=c)[0]-f;else{if(u=c[0]-t[0],l>0&&a<=0){if((o=s*l-u*a)>0)i+=1;else if(0===o)return 0}else if(a>0&&l<=0){if((o=s*l-u*a)<0)i+=1;else if(0===o)return 0}else if(0===l&&a<0){if(0===(o=s*l-u*a))return 0}else if(0===a&&l<0){if(0===(o=s*l-u*a))return 0}else if(0===a&&0===l){if(u<=0&&s>=0)return 0;if(s<=0&&u>=0)return 0}h=c,a=l,s=u}}return i%2!=0}function zt(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!t)throw new Error("point is required");if(!e)throw new Error("polygon is required");var r=K(t),i=rt(e),o=i.type,s=e.bbox,a=i.coordinates;if(s&&!1===function(t,e){return e[0]<=t[0]&&e[1]<=t[1]&&e[2]>=t[0]&&e[3]>=t[1]}(r,s))return!1;"Polygon"===o&&(a=[a]);for(var u=!1,l=0;l<a.length;++l){var h=Yt(r,a[l]);if(0===h)return!n.ignoreBoundary;h&&(u=!0)}return u}function jt(t,e){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=K(t),i=Q(e),o=0;o<i.length-1;o++){var s=!1;if(n.ignoreEndVertices&&(0===o&&(s="start"),o===i.length-2&&(s="end"),0===o&&o+1===i.length-1&&(s="both")),Xt(i[o],i[o+1],r,s,void 0===n.epsilon?null:n.epsilon))return!0}return!1}function Xt(t,e,n,r,i){var o=n[0],s=n[1],a=t[0],u=t[1],l=e[0],h=e[1],c=l-a,f=h-u,g=(n[0]-a)*f-(n[1]-u)*c;if(null!==i){if(Math.abs(g)>i)return!1}else if(0!==g)return!1;return Math.abs(c)===Math.abs(f)&&0===Math.abs(c)?!r&&(n[0]===t[0]&&n[1]===t[1]):r?"start"===r?Math.abs(c)>=Math.abs(f)?c>0?a<o&&o<=l:l<=o&&o<a:f>0?u<s&&s<=h:h<=s&&s<u:"end"===r?Math.abs(c)>=Math.abs(f)?c>0?a<=o&&o<l:l<o&&o<=a:f>0?u<=s&&s<h:h<s&&s<=u:"both"===r&&(Math.abs(c)>=Math.abs(f)?c>0?a<o&&o<l:l<o&&o<a:f>0?u<s&&s<h:h<s&&s<u):Math.abs(c)>=Math.abs(f)?c>0?a<=o&&o<=l:l<=o&&o<=a:f>0?u<=s&&s<=h:h<=s&&s<=u}function Ut(t,e){if("Feature"===t.type&&null===t.geometry)return!1;if("Feature"===e.type&&null===e.geometry)return!1;if(!Zt(Rt(t),Rt(e)))return!1;var n,r=a(rt(e).coordinates);try{for(r.s();!(n=r.n()).done;){var i,o=a(n.value);try{for(o.s();!(i=o.n()).done;){if(!zt(i.value,t))return!1}}catch(t){o.e(t)}finally{o.f()}}}catch(t){r.e(t)}finally{r.f()}return!0}function Zt(t,e){return!(t[0]>e[0])&&(!(t[2]<e[2])&&(!(t[1]>e[1])&&!(t[3]<e[3])))}function Ht(t,e){return t[0]===e[0]&&t[1]===e[1]}function Wt(t,e){return[(t[0]+e[0])/2,(t[1]+e[1])/2]}var Jt=function(){return s((function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Kt;if(i(this,t),this.data=e,this.length=this.data.length,this.compare=n,this.length>0)for(var r=(this.length>>1)-1;r>=0;r--)this._down(r)}),[{key:"push",value:function(t){this.data.push(t),this.length++,this._up(this.length-1)}},{key:"pop",value:function(){if(0!==this.length){var t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}}},{key:"peek",value:function(){return this.data[0]}},{key:"_up",value:function(t){for(var e=this.data,n=this.compare,r=e[t];t>0;){var i=t-1>>1,o=e[i];if(n(r,o)>=0)break;e[t]=o,t=i}e[t]=r}},{key:"_down",value:function(t){for(var e=this.data,n=this.compare,r=this.length>>1,i=e[t];t<r;){var o=1+(t<<1),s=e[o],a=o+1;if(a<this.length&&n(e[a],s)<0&&(o=a,s=e[a]),n(s,i)>=0)break;e[t]=s,t=o}e[t]=i}}])}();function Kt(t,e){return t<e?-1:t>e?1:0}function Qt(t,e){return t.p.x>e.p.x?1:t.p.x<e.p.x?-1:t.p.y!==e.p.y?t.p.y>e.p.y?1:-1:1}function $t(t,e){return t.rightSweepEvent.p.x>e.rightSweepEvent.p.x?1:t.rightSweepEvent.p.x<e.rightSweepEvent.p.x?-1:t.rightSweepEvent.p.y!==e.rightSweepEvent.p.y?t.rightSweepEvent.p.y<e.rightSweepEvent.p.y?1:-1:1}var te=function(){return s((function t(e,n,r,o){i(this,t),this.p={x:e[0],y:e[1]},this.featureId=n,this.ringId=r,this.eventId=o,this.otherEvent=null,this.isLeftEndpoint=null}),[{key:"isSamePoint",value:function(t){return this.p.x===t.p.x&&this.p.y===t.p.y}}])}();var ee=0,ne=0,re=0;function ie(t,e){var n="Feature"===t.type?t.geometry:t,r=n.coordinates;"Polygon"!==n.type&&"MultiLineString"!==n.type||(r=[r]),"LineString"===n.type&&(r=[[r]]);for(var i=0;i<r.length;i++)for(var o=0;o<r[i].length;o++){var s=r[i][o][0],a=null;ne+=1;for(var u=0;u<r[i][o].length-1;u++){a=r[i][o][u+1];var l=new te(s,ee,ne,re),h=new te(a,ee,ne,re+1);l.otherEvent=h,h.otherEvent=l,Qt(l,h)>0?(h.isLeftEndpoint=!0,l.isLeftEndpoint=!1):(l.isLeftEndpoint=!0,h.isLeftEndpoint=!1),e.push(l),e.push(h),s=a,re+=1}}ee+=1}var oe=s((function t(e){i(this,t),this.leftSweepEvent=e,this.rightSweepEvent=e.otherEvent}));function se(t,e){if(null===t||null===e)return!1;if(t.leftSweepEvent.ringId===e.leftSweepEvent.ringId&&(t.rightSweepEvent.isSamePoint(e.leftSweepEvent)||t.rightSweepEvent.isSamePoint(e.leftSweepEvent)||t.rightSweepEvent.isSamePoint(e.rightSweepEvent)||t.leftSweepEvent.isSamePoint(e.leftSweepEvent)||t.leftSweepEvent.isSamePoint(e.rightSweepEvent)))return!1;var n=t.leftSweepEvent.p.x,r=t.leftSweepEvent.p.y,i=t.rightSweepEvent.p.x,o=t.rightSweepEvent.p.y,s=e.leftSweepEvent.p.x,a=e.leftSweepEvent.p.y,u=e.rightSweepEvent.p.x,l=e.rightSweepEvent.p.y,h=(l-a)*(i-n)-(u-s)*(o-r),c=(u-s)*(r-a)-(l-a)*(n-s),f=(i-n)*(r-a)-(o-r)*(n-s);if(0===h)return!1;var g=c/h,p=f/h;return g>=0&&g<=1&&p>=0&&p<=1&&[n+g*(i-n),r+g*(o-r)]}var ae=function(t,e){var n=new Jt([],Qt);return function(t,e){if("FeatureCollection"===t.type)for(var n=t.features,r=0;r<n.length;r++)ie(n[r],e);else ie(t,e)}(t,n),function(t,e){e=e||!1;for(var n=[],r=new Jt([],$t);t.length;){var i=t.pop();if(i.isLeftEndpoint){for(var o=new oe(i),s=0;s<r.data.length;s++){var a=r.data[s];if(!e||a.leftSweepEvent.featureId!==i.featureId){var u=se(o,a);!1!==u&&n.push(u)}}r.push(o)}else!1===i.isLeftEndpoint&&r.pop()}return n}(n,e)};function ue(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=n.removeDuplicates,i=void 0===r||r,o=n.ignoreSelfIntersections,s=void 0===o||o,a=[];"FeatureCollection"===t.type?a=a.concat(t.features):"Feature"===t.type?a.push(t):"LineString"!==t.type&&"Polygon"!==t.type&&"MultiLineString"!==t.type&&"MultiPolygon"!==t.type||a.push(b(t)),"FeatureCollection"===e.type?a=a.concat(e.features):"Feature"===e.type?a.push(e):"LineString"!==e.type&&"Polygon"!==e.type&&"MultiLineString"!==e.type&&"MultiPolygon"!==e.type||a.push(b(e));var u=ae(C(a),s),l=[];if(i){var h={};u.forEach((function(t){var e=t.join(",");h[e]||(h[e]=!0,l.push(t))}))}else l=u;return C(l.map((function(t){return I(t)})))}function le(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=rt(t);switch(e.properties||"Feature"!==t.type||(e.properties=t.properties),n.type){case"Polygon":return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=rt(t),r=n.coordinates,i=e.properties?e.properties:"Feature"===t.type?t.properties:{};return he(r,i)}(n,e);case"MultiPolygon":return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=rt(t),r=n.coordinates,i=e.properties?e.properties:"Feature"===t.type?t.properties:{},o=[];return r.forEach((function(t){o.push(he(t,i))})),C(o)}(n,e);default:throw new Error("invalid poly")}}function he(t,e){return t.length>1?T(t,e):L(t[0],e)}function ce(t,e){var n=rt(t),r=rt(e),i=n.type,o=r.type;switch(i){case"MultiPoint":switch(o){case"LineString":return fe(n,r);case"Polygon":return pe(n,r);default:throw new Error("feature2 "+o+" geometry not supported")}case"LineString":switch(o){case"MultiPoint":return fe(r,n);case"LineString":return function(t,e){if(ue(t,e).features.length>0)for(var n=0;n<t.coordinates.length-1;n++)for(var r=0;r<e.coordinates.length-1;r++){var i=!0;if(0!==r&&r!==e.coordinates.length-2||(i=!1),ve(t.coordinates[n],t.coordinates[n+1],e.coordinates[r],i))return!0}return!1}(n,r);case"Polygon":return ge(n,r);default:throw new Error("feature2 "+o+" geometry not supported")}case"Polygon":switch(o){case"MultiPoint":return pe(r,n);case"LineString":return ge(r,n);default:throw new Error("feature2 "+o+" geometry not supported")}default:throw new Error("feature1 "+i+" geometry not supported")}}function fe(t,e){for(var n=!1,r=!1,i=t.coordinates.length,o=0;o<i&&!n&&!r;){for(var s=0;s<e.coordinates.length-1;s++){var a=!0;0!==s&&s!==e.coordinates.length-2||(a=!1),ve(e.coordinates[s],e.coordinates[s+1],t.coordinates[o],a)?n=!0:r=!0}o++}return n&&r}function ge(t,e){return ue(t,le(e)).features.length>0}function pe(t,e){for(var n=!1,r=!1,i=t.coordinates.length,o=0;o<i&&(!n||!r);o++)zt(I(t.coordinates[o]),e)?n=!0:r=!0;return r&&n}function ve(t,e,n,r){var i=n[0]-t[0],o=n[1]-t[1],s=e[0]-t[0],a=e[1]-t[1];return 0==i*a-o*s&&(r?Math.abs(s)>=Math.abs(a)?s>0?t[0]<=n[0]&&n[0]<=e[0]:e[0]<=n[0]&&n[0]<=t[0]:a>0?t[1]<=n[1]&&n[1]<=e[1]:e[1]<=n[1]&&n[1]<=t[1]:Math.abs(s)>=Math.abs(a)?s>0?t[0]<n[0]&&n[0]<e[0]:e[0]<n[0]&&n[0]<t[0]:a>0?t[1]<n[1]&&n[1]<e[1]:e[1]<n[1]&&n[1]<t[1])}function de(t,e){var n=(arguments.length>2&&void 0!==arguments[2]?arguments[2]:{ignoreSelfIntersections:!0}).ignoreSelfIntersections,r=void 0===n||n,i=!0;return xt(t,(function(t){xt(e,(function(e){if(!1===i)return!1;i=function(t,e,n){switch(t.type){case"Point":switch(e.type){case"Point":return r=t.coordinates,i=e.coordinates,!(r[0]===i[0]&&r[1]===i[1]);case"LineString":return!ye(e,t);case"Polygon":return!zt(t,e)}break;case"LineString":switch(e.type){case"Point":return!ye(t,e);case"LineString":return!function(t,e,n){var r=ue(t,e,{ignoreSelfIntersections:n});if(r.features.length>0)return!0;return!1}(t,e,n);case"Polygon":return!me(e,t,n)}break;case"Polygon":switch(e.type){case"Point":return!zt(e,t);case"LineString":return!me(t,e,n);case"Polygon":return!function(t,e,n){var r,i=a(t.coordinates[0]);try{for(i.s();!(r=i.n()).done;){if(zt(r.value,e))return!0}}catch(t){i.e(t)}finally{i.f()}var o,s=a(e.coordinates[0]);try{for(s.s();!(o=s.n()).done;){if(zt(o.value,t))return!0}}catch(t){s.e(t)}finally{s.f()}var u=ue(le(t),le(e),{ignoreSelfIntersections:n});if(u.features.length>0)return!0;return!1}(e,t,n)}}var r,i;return!1}(t.geometry,e.geometry,r)}))})),i}function ye(t,e){for(var n=0;n<t.coordinates.length-1;n++)if(_e(t.coordinates[n],t.coordinates[n+1],e.coordinates))return!0;return!1}function me(t,e,n){var r,i=a(e.coordinates);try{for(i.s();!(r=i.n()).done;){if(zt(r.value,t))return!0}}catch(t){i.e(t)}finally{i.f()}return ue(e,le(t),{ignoreSelfIntersections:n}).features.length>0}function _e(t,e,n){var r=n[0]-t[0],i=n[1]-t[1],o=e[0]-t[0],s=e[1]-t[1];return 0==r*s-i*o&&(Math.abs(o)>=Math.abs(s)?o>0?t[0]<=n[0]&&n[0]<=e[0]:e[0]<=n[0]&&n[0]<=t[0]:s>0?t[1]<=n[1]&&n[1]<=e[1]:e[1]<=n[1]&&n[1]<=t[1])}var xe=Object.defineProperty,Ee=function(t,e){return xe(t,"name",{value:e,configurable:!0})},ke=function(){return s((function t(e){var n,r,o;i(this,t),this.direction=!1,this.compareProperties=!0,this.precision=Math.pow(10,-(null!=(n=null==e?void 0:e.precision)?n:17)),this.direction=null!=(r=null==e?void 0:e.direction)&&r,this.compareProperties=null==(o=null==e?void 0:e.compareProperties)||o}),[{key:"compare",value:function(t,e){var n=this;if(t.type!==e.type)return!1;if(!we(t,e))return!1;switch(t.type){case"Point":return this.compareCoord(t.coordinates,e.coordinates);case"LineString":return this.compareLine(t.coordinates,e.coordinates);case"Polygon":return this.comparePolygon(t,e);case"GeometryCollection":return this.compareGeometryCollection(t,e);case"Feature":return this.compareFeature(t,e);case"FeatureCollection":return this.compareFeatureCollection(t,e);default:if(t.type.startsWith("Multi")){var r=Ie(t),i=Ie(e);return r.every((function(t){return i.some((function(e){return n.compare(t,e)}))}))}}return!1}},{key:"compareCoord",value:function(t,e){var n=this;return t.length===e.length&&t.every((function(t,r){return Math.abs(t-e[r])<n.precision}))}},{key:"compareLine",value:function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(!we(t,e))return!1;var i=t,o=e;if(r&&!this.compareCoord(i[0],o[0])){var s=this.fixStartIndex(o,i);if(!s)return!1;o=s}var a=this.compareCoord(i[n],o[n]);return this.direction||a?this.comparePath(i,o):!!this.compareCoord(i[n],o[o.length-(1+n)])&&this.comparePath(i.slice().reverse(),o)}},{key:"fixStartIndex",value:function(t,e){for(var n,r=-1,i=0;i<t.length;i++)if(this.compareCoord(t[i],e[0])){r=i;break}return r>=0&&(n=[].concat(t.slice(r,t.length),t.slice(1,r+1))),n}},{key:"comparePath",value:function(t,e){var n=this;return t.every((function(t,r){return n.compareCoord(t,e[r])}))}},{key:"comparePolygon",value:function(t,e){var n=this;if(this.compareLine(t.coordinates[0],e.coordinates[0],1,!0)){var r=t.coordinates.slice(1,t.coordinates.length),i=e.coordinates.slice(1,e.coordinates.length);return r.every((function(t){return i.some((function(e){return n.compareLine(t,e,1,!0)}))}))}return!1}},{key:"compareGeometryCollection",value:function(t,e){var n=this;return we(t.geometries,e.geometries)&&this.compareBBox(t,e)&&t.geometries.every((function(t,r){return n.compare(t,e.geometries[r])}))}},{key:"compareFeature",value:function(t,e){return t.id===e.id&&(!this.compareProperties||Se(t.properties,e.properties))&&this.compareBBox(t,e)&&this.compare(t.geometry,e.geometry)}},{key:"compareFeatureCollection",value:function(t,e){var n=this;return we(t.features,e.features)&&this.compareBBox(t,e)&&t.features.every((function(t,r){return n.compare(t,e.features[r])}))}},{key:"compareBBox",value:function(t,e){return Boolean(!t.bbox&&!e.bbox)||!(!t.bbox||!e.bbox)&&this.compareCoord(t.bbox,e.bbox)}}])}();Ee(ke,"GeojsonEquality");var be=ke;function we(t,e){return t.coordinates?t.coordinates.length===e.coordinates.length:t.length===e.length}function Ie(t){return t.coordinates.map((function(e){return{type:t.type.replace("Multi",""),coordinates:e}}))}function Ne(t,e,n){return new be(n).compare(t,e)}function Se(t,e){if(null===t&&null===e)return!0;if(null===t||null===e)return!1;var n=Object.keys(t),r=Object.keys(e);if(n.length!==r.length)return!1;for(var i=0,o=n;i<o.length;i++){var s=o[i],a=t[s],u=e[s],l=Me(a)&&Me(u);if(l&&!Se(a,u)||!l&&a!==u)return!1}return!0}Ee(we,"sameLength"),Ee(Ie,"explode"),Ee(Ne,"geojsonEquality"),Ee(Se,"equal");var Me=Ee((function(t){return null!=t&&"object"===m(t)}),"isObject");function Le(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n="object"===m(e)?e.mutate:e;if(!t)throw new Error("geojson is required");var r=it(t),i=[];switch(r){case"LineString":i=Pe(t,r);break;case"MultiLineString":case"Polygon":Q(t).forEach((function(t){i.push(Pe(t,r))}));break;case"MultiPolygon":Q(t).forEach((function(t){var e=[];t.forEach((function(t){e.push(Pe(t,r))})),i.push(e)}));break;case"Point":return t;case"MultiPoint":var o={};Q(t).forEach((function(t){var e=t.join("-");Object.prototype.hasOwnProperty.call(o,e)||(i.push(t),o[e]=!0)}));break;default:throw new Error(r+" geometry not supported")}return t.coordinates?!0===n?(t.coordinates=i,t):{type:r,coordinates:i}:!0===n?(t.geometry.coordinates=i,t):b({type:r,coordinates:i},t.properties,{bbox:t.bbox,id:t.id})}function Pe(t,e){var n=Q(t);if(2===n.length&&!Ce(n[0],n[1]))return n;var r=[],i=n.length-1,o=r.length;r.push(n[0]);for(var s=1;s<i;s++){var a=r[r.length-1];n[s][0]===a[0]&&n[s][1]===a[1]||(r.push(n[s]),(o=r.length)>2&&Te(r[o-3],r[o-1],r[o-2])&&r.splice(r.length-2,1))}if(r.push(n[n.length-1]),o=r.length,("Polygon"===e||"MultiPolygon"===e)&&Ce(n[0],n[n.length-1])&&o<4)throw new Error("invalid polygon");return"LineString"===e&&o<3||Te(r[o-3],r[o-1],r[o-2])&&r.splice(r.length-2,1),r}function Ce(t,e){return t[0]===e[0]&&t[1]===e[1]}function Te(t,e,n){var r=n[0],i=n[1],o=t[0],s=t[1],a=e[0],u=e[1],l=a-o,h=u-s;return 0===(r-o)*h-(i-s)*l&&(Math.abs(l)>=Math.abs(h)?l>0?o<=r&&r<=a:a<=r&&r<=o:h>0?s<=i&&i<=u:u<=i&&i<=s)}function Oe(t,e){var n=(arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}).ignoreSelfIntersections,r=void 0===n||n,i=!1;return xt(t,(function(t){xt(e,(function(e){if(!0===i)return!0;i=!de(t.geometry,e.geometry,{ignoreSelfIntersections:r})}))})),i}function Re(t,e,n,r,i){Ae(t,e,n||0,r||t.length-1,i||Fe)}function Ae(t,e,n,r,i){for(;r>n;){if(r-n>600){var o=r-n+1,s=e-n+1,a=Math.log(o),u=.5*Math.exp(2*a/3),l=.5*Math.sqrt(a*u*(o-u)/o)*(s-o/2<0?-1:1);Ae(t,e,Math.max(n,Math.floor(e-s*u/o+l)),Math.min(r,Math.floor(e+(o-s)*u/o+l)),i)}var h=t[e],c=n,f=r;for(De(t,n,e),i(t[r],h)>0&&De(t,n,r);c<f;){for(De(t,c,f),c++,f--;i(t[c],h)<0;)c++;for(;i(t[f],h)>0;)f--}0===i(t[n],h)?De(t,n,f):De(t,++f,r),f<=e&&(n=f+1),e<=f&&(r=f-1)}}function De(t,e,n){var r=t[e];t[e]=t[n],t[n]=r}function Fe(t,e){return t<e?-1:t>e?1:0}var qe=function(){return s((function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:9;i(this,t),this._maxEntries=Math.max(4,e),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()}),[{key:"all",value:function(){return this._all(this.data,[])}},{key:"search",value:function(t){var e=this.data,n=[];if(!He(t,e))return n;for(var r=this.toBBox,i=[];e;){for(var o=0;o<e.children.length;o++){var s=e.children[o],a=e.leaf?r(s):s;He(t,a)&&(e.leaf?n.push(s):Ze(t,a)?this._all(s,n):i.push(s))}e=i.pop()}return n}},{key:"collides",value:function(t){var e=this.data;if(!He(t,e))return!1;for(var n=[];e;){for(var r=0;r<e.children.length;r++){var i=e.children[r],o=e.leaf?this.toBBox(i):i;if(He(t,o)){if(e.leaf||Ze(t,o))return!0;n.push(i)}}e=n.pop()}return!1}},{key:"load",value:function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var e=0;e<t.length;e++)this.insert(t[e]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this}},{key:"insert",value:function(t){return t&&this._insert(t,this.data.height-1),this}},{key:"clear",value:function(){return this.data=We([]),this}},{key:"remove",value:function(t,e){if(!t)return this;for(var n,r,i,o=this.data,s=this.toBBox(t),a=[],u=[];o||a.length;){if(o||(o=a.pop(),r=a[a.length-1],n=u.pop(),i=!0),o.leaf){var l=Ve(t,o.children,e);if(-1!==l)return o.children.splice(l,1),a.push(o),this._condense(a),this}i||o.leaf||!Ze(o,s)?r?(n++,o=r.children[n],i=!1):o=null:(a.push(o),u.push(n),n=0,r=o,o=o.children[0])}return this}},{key:"toBBox",value:function(t){return t}},{key:"compareMinX",value:function(t,e){return t.minX-e.minX}},{key:"compareMinY",value:function(t,e){return t.minY-e.minY}},{key:"toJSON",value:function(){return this.data}},{key:"fromJSON",value:function(t){return this.data=t,this}},{key:"_all",value:function(t,e){for(var n=[];t;)t.leaf?e.push.apply(e,d(t.children)):n.push.apply(n,d(t.children)),t=n.pop();return e}},{key:"_build",value:function(t,e,n,r){var i,o=n-e+1,s=this._maxEntries;if(o<=s)return Ge(i=We(t.slice(e,n+1)),this.toBBox),i;r||(r=Math.ceil(Math.log(o)/Math.log(s)),s=Math.ceil(o/Math.pow(s,r-1))),(i=We([])).leaf=!1,i.height=r;var a=Math.ceil(o/s),u=a*Math.ceil(Math.sqrt(s));Je(t,e,n,u,this.compareMinX);for(var l=e;l<=n;l+=u){var h=Math.min(l+u-1,n);Je(t,l,h,a,this.compareMinY);for(var c=l;c<=h;c+=a){var f=Math.min(c+a-1,h);i.children.push(this._build(t,c,f,r-1))}}return Ge(i,this.toBBox),i}},{key:"_chooseSubtree",value:function(t,e,n,r){for(;r.push(e),!e.leaf&&r.length-1!==n;){for(var i=1/0,o=1/0,s=void 0,a=0;a<e.children.length;a++){var u=e.children[a],l=Xe(u),h=(c=t,f=u,(Math.max(f.maxX,c.maxX)-Math.min(f.minX,c.minX))*(Math.max(f.maxY,c.maxY)-Math.min(f.minY,c.minY))-l);h<o?(o=h,i=l<i?l:i,s=u):h===o&&l<i&&(i=l,s=u)}e=s||e.children[0]}var c,f;return e}},{key:"_insert",value:function(t,e,n){var r=n?t:this.toBBox(t),i=[],o=this._chooseSubtree(r,this.data,e,i);for(o.children.push(t),Ye(o,r);e>=0&&i[e].children.length>this._maxEntries;)this._split(i,e),e--;this._adjustParentBBoxes(r,i,e)}},{key:"_split",value:function(t,e){var n=t[e],r=n.children.length,i=this._minEntries;this._chooseSplitAxis(n,i,r);var o=this._chooseSplitIndex(n,i,r),s=We(n.children.splice(o,n.children.length-o));s.height=n.height,s.leaf=n.leaf,Ge(n,this.toBBox),Ge(s,this.toBBox),e?t[e-1].children.push(s):this._splitRoot(n,s)}},{key:"_splitRoot",value:function(t,e){this.data=We([t,e]),this.data.height=t.height+1,this.data.leaf=!1,Ge(this.data,this.toBBox)}},{key:"_chooseSplitIndex",value:function(t,e,n){for(var r,i,o,s,a,u,l,h=1/0,c=1/0,f=e;f<=n-e;f++){var g=Be(t,0,f,this.toBBox),p=Be(t,f,n,this.toBBox),v=(i=g,o=p,s=void 0,a=void 0,u=void 0,l=void 0,s=Math.max(i.minX,o.minX),a=Math.max(i.minY,o.minY),u=Math.min(i.maxX,o.maxX),l=Math.min(i.maxY,o.maxY),Math.max(0,u-s)*Math.max(0,l-a)),d=Xe(g)+Xe(p);v<h?(h=v,r=f,c=d<c?d:c):v===h&&d<c&&(c=d,r=f)}return r||n-e}},{key:"_chooseSplitAxis",value:function(t,e,n){var r=t.leaf?this.compareMinX:ze,i=t.leaf?this.compareMinY:je;this._allDistMargin(t,e,n,r)<this._allDistMargin(t,e,n,i)&&t.children.sort(r)}},{key:"_allDistMargin",value:function(t,e,n,r){t.children.sort(r);for(var i=this.toBBox,o=Be(t,0,e,i),s=Be(t,n-e,n,i),a=Ue(o)+Ue(s),u=e;u<n-e;u++){var l=t.children[u];Ye(o,t.leaf?i(l):l),a+=Ue(o)}for(var h=n-e-1;h>=e;h--){var c=t.children[h];Ye(s,t.leaf?i(c):c),a+=Ue(s)}return a}},{key:"_adjustParentBBoxes",value:function(t,e,n){for(var r=n;r>=0;r--)Ye(e[r],t)}},{key:"_condense",value:function(t){for(var e,n=t.length-1;n>=0;n--)0===t[n].children.length?n>0?(e=t[n-1].children).splice(e.indexOf(t[n]),1):this.clear():Ge(t[n],this.toBBox)}}])}();function Ve(t,e,n){if(!n)return e.indexOf(t);for(var r=0;r<e.length;r++)if(n(t,e[r]))return r;return-1}function Ge(t,e){Be(t,0,t.children.length,e,t)}function Be(t,e,n,r,i){i||(i=We(null)),i.minX=1/0,i.minY=1/0,i.maxX=-1/0,i.maxY=-1/0;for(var o=e;o<n;o++){var s=t.children[o];Ye(i,t.leaf?r(s):s)}return i}function Ye(t,e){return t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY),t}function ze(t,e){return t.minX-e.minX}function je(t,e){return t.minY-e.minY}function Xe(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function Ue(t){return t.maxX-t.minX+(t.maxY-t.minY)}function Ze(t,e){return t.minX<=e.minX&&t.minY<=e.minY&&e.maxX<=t.maxX&&e.maxY<=t.maxY}function He(t,e){return e.minX<=t.maxX&&e.minY<=t.maxY&&e.maxX>=t.minX&&e.maxY>=t.minY}function We(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function Je(t,e,n,r,i){for(var o=[e,n];o.length;)if(!((n=o.pop())-(e=o.pop())<=r)){var s=e+Math.ceil((n-e)/r/2)*r;Re(t,s,e,n,i),o.push(e,s,s,n)}}var Ke=Object.freeze({__proto__:null,default:qe});function Qe(t){var e=new qe(t);return e.insert=function(t){if("Feature"!==t.type)throw new Error("invalid feature");return t.bbox=t.bbox?t.bbox:Rt(t),qe.prototype.insert.call(this,t)},e.load=function(t){var e=[];return Array.isArray(t)?t.forEach((function(t){if("Feature"!==t.type)throw new Error("invalid features");t.bbox=t.bbox?t.bbox:Rt(t),e.push(t)})):vt(t,(function(t){if("Feature"!==t.type)throw new Error("invalid features");t.bbox=t.bbox?t.bbox:Rt(t),e.push(t)})),qe.prototype.load.call(this,e)},e.remove=function(t,e){if("Feature"!==t.type)throw new Error("invalid feature");return t.bbox=t.bbox?t.bbox:Rt(t),qe.prototype.remove.call(this,t,e)},e.clear=function(){return qe.prototype.clear.call(this)},e.search=function(t){return C(qe.prototype.search.call(this,this.toBBox(t)))},e.collides=function(t){return qe.prototype.collides.call(this,this.toBBox(t))},e.all=function(){return C(qe.prototype.all.call(this))},e.toJSON=function(){return qe.prototype.toJSON.call(this)},e.fromJSON=function(t){return qe.prototype.fromJSON.call(this,t)},e.toBBox=function(t){var e;if(t.bbox)e=t.bbox;else if(Array.isArray(t)&&4===t.length)e=t;else if(Array.isArray(t)&&6===t.length)e=[t[0],t[1],t[3],t[4]];else if("Feature"===t.type)e=Rt(t);else{if("FeatureCollection"!==t.type)throw new Error("invalid geojson");e=Rt(t)}return{minX:e[0],minY:e[1],maxX:e[2],maxY:e[3]}},e}function $e(t){if(!t)throw new Error("geojson is required");var e=[];return xt(t,(function(t){!function(t,e){var n=[],r=t.geometry;if(null!==r){switch(r.type){case"Polygon":n=Q(r);break;case"LineString":n=[Q(r)]}n.forEach((function(n){var r=function(t,e){var n=[];return t.reduce((function(t,r){var i=L([t,r],e);return i.bbox=function(t,e){var n=t[0],r=t[1],i=e[0],o=e[1],s=n<i?n:i,a=r<o?r:o,u=n>i?n:i,l=r>o?r:o;return[s,a,u,l]}(t,r),n.push(i),r})),n}(n,t.properties);r.forEach((function(t){t.id=e.length,e.push(t)}))}))}}(t,e)})),C(e)}var tn,en,nn=Object.defineProperty,rn=Object.defineProperties,on=Object.getOwnPropertyDescriptors,sn=Object.getOwnPropertySymbols,an=Object.prototype.hasOwnProperty,un=Object.prototype.propertyIsEnumerable,ln=function(t,e,n){return e in t?nn(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n},hn=function(t,e){for(var n in e||(e={}))an.call(e,n)&&ln(t,n,e[n]);if(sn){var r,i=a(sn(e));try{for(i.s();!(r=i.n()).done;){n=r.value;un.call(e,n)&&ln(t,n,e[n])}}catch(t){i.e(t)}finally{i.f()}}return t},cn=function(t,e){return rn(t,on(e))};function fn(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!t||!e)throw new Error("lines and pt are required arguments");var r=K(e),i=I([1/0,1/0],{dist:1/0,index:-1,multiFeatureIndex:-1,location:-1}),o=0;return xt(t,(function(t,s,a){for(var u=Q(t),l=0;l<u.length-1;l++){var h=I(u[l]);h.properties.dist=ut(e,h,n);var c=K(h),f=I(u[l+1]);f.properties.dist=ut(e,f,n);var g=K(f),p=ut(h,f,n),d=void 0,y=void 0;if(c[0]===r[0]&&c[1]===r[1]){var m=[c,void 0,!1];d=m[0],y=m[2]}else if(g[0]===r[0]&&g[1]===r[1]){var _=[g,void 0,!0];d=_[0],y=_[2]}else{var x=v(yn(h.geometry.coordinates,f.geometry.coordinates,K(e)),3);d=x[0],y=x[2]}var E=void 0;d&&(E=I(d,{dist:ut(e,d,n),multiFeatureIndex:a,location:o+ut(h,d,n)})),E&&E.properties.dist<i.properties.dist&&(i=cn(hn({},E),{properties:cn(hn({},E.properties),{index:y?l+1:l})})),o+=p}})),i}function gn(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2))}function pn(t,e){var n=function(t,e){var n=v(t,3),r=n[0],i=n[1],o=n[2],s=v(e,3);return r*s[0]+i*s[1]+o*s[2]}(t,e)/(gn(t)*gn(e));return Math.acos(Math.min(Math.max(n,-1),1))}function vn(t){var e=z(t[1]),n=z(t[0]);return[Math.cos(e)*Math.cos(n),Math.cos(e)*Math.sin(n),Math.sin(e)]}function dn(t){var e=v(t,3),n=e[0],r=e[1],i=e[2],o=Y(Math.asin(i));return[Y(Math.atan2(r,n)),o]}function yn(t,e,n){var r,i,o,s,a,u,l,h,c,f,g=vn(t),p=vn(e),d=v(vn(n),3),y=d[0],m=d[1],_=d[2],x=(r=p,i=v(g,3),o=i[0],s=i[1],a=i[2],u=v(r,3),l=u[0],h=u[1],c=u[2],[s*c-a*h,a*l-o*c,o*h-s*l]),E=v(x,3),k=E[0],b=E[1],w=E[2],I=b*_-w*m,N=w*y-k*_,S=k*m-b*y,M=S*b-N*w,L=I*w-S*k,P=N*k-I*b,C=1/Math.sqrt(Math.pow(M,2)+Math.pow(L,2)+Math.pow(P,2)),T=[M*C,L*C,P*C],O=[-1*M*C,-1*L*C,-1*P*C],R=pn(g,p),A=pn(g,T),D=pn(p,T),F=pn(g,O),q=pn(p,O);return pn(g,f=A<F&&A<q||D<F&&D<q?T:O)>R||pn(p,f)>R?ut(dn(f),dn(g))<=ut(dn(f),dn(p))?[dn(g),!0,!1]:[dn(p),!1,!0]:[dn(f),!1,!1]}function mn(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function _n(t){if(t.__esModule)return t;var e=t.default;if("function"==typeof e){var n=function t(){return this instanceof t?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(t).forEach((function(e){var r=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(n,e,r.get?r:{enumerable:!0,get:function(){return t[e]}})})),n}var xn=(en||(en=1,tn=function t(e,n){if(e===n)return!0;if(e&&n&&"object"==m(e)&&"object"==m(n)){if(e.constructor!==n.constructor)return!1;var r,i,o;if(Array.isArray(e)){if((r=e.length)!=n.length)return!1;for(i=r;0!=i--;)if(!t(e[i],n[i]))return!1;return!0}if(e.constructor===RegExp)return e.source===n.source&&e.flags===n.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===n.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===n.toString();if((r=(o=Object.keys(e)).length)!==Object.keys(n).length)return!1;for(i=r;0!=i--;)if(!Object.prototype.hasOwnProperty.call(n,o[i]))return!1;for(i=r;0!=i--;){var s=o[i];if(!t(e[s],n[s]))return!1}return!0}return e!=e&&n!=n}),tn),En=mn(xn);function kn(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!Z(n=n||{}))throw new Error("options is invalid");var r,i=n.tolerance||0,o=[],s=Qe(),a=$e(t);s.load(a);var u=[];return kt(e,(function(t){var e=!1;t&&(vt(s.search(t),(function(n){if(!1===e){var o=Q(t).sort(),s=Q(n).sort();if(En(o,s))e=!0,r=r?bn(r,t)||r:t;else if(0===i?jt(o[0],n)&&jt(o[1],n):fn(n,o[0]).properties.dist<=i&&fn(n,o[1]).properties.dist<=i)e=!0,r=r?bn(r,t)||r:t;else if(0===i?jt(s[0],t)&&jt(s[1],t):fn(t,s[0]).properties.dist<=i&&fn(t,s[1]).properties.dist<=i)if(r){var a=bn(r,n);a?r=a:u.push(n)}else r=n}})),!1===e&&r&&(o.push(r),u.length&&(o=o.concat(u),u=[]),r=void 0))})),r&&o.push(r),C(o)}function bn(t,e){var n=Q(e),r=Q(t),i=r[0],o=r[r.length-1],s=t.geometry.coordinates;if(En(n[0],i))s.unshift(n[1]);else if(En(n[0],o))s.push(n[1]);else if(En(n[1],i))s.unshift(n[0]);else{if(!En(n[1],o))return;s.push(n[0])}return t}function wn(t,e){var n=G(lt(t[0],t[1])),r=G(lt(e[0],e[1]));return n===r||(r-n)%180==0}function In(t,e){if(t.geometry&&t.geometry.type)return t.geometry.type;if(t.type)return t.type;throw new Error("Invalid GeoJSON object for "+e)}function Nn(t,e){return!!Sn(e.coordinates[0],t.coordinates)||!!Sn(e.coordinates[e.coordinates.length-1],t.coordinates)}function Sn(t,e){return t[0]===e[0]&&t[1]===e[1]}function Mn(t){return t[0][0]===t[t.length-1][0]&&t[0][1]===t[t.length-1][1]}function Ln(t){for(var e=0;e<t.length-1;e++)for(var n=t[e],r=e+1;r<t.length-2;r++){if(jt(n,L([t[r],t[r+1]])))return!0}return!1}function Pn(t,e,n){for(var r=S(t),i=n+1;i<e.length;i++)if(!de(r,S(e[i]))&&ce(r,L(e[i][0])))return!1;return!0}function Cn(t,e){var n=rt(t),r=rt(e),i=n.type,o=r.type;switch(i){case"Point":switch(o){case"MultiPoint":return function(t,e){var n,r=!1;for(n=0;n<e.coordinates.length;n++)if(On(e.coordinates[n],t.coordinates)){r=!0;break}return r}(n,r);case"LineString":return jt(n,r,{ignoreEndVertices:!0});case"Polygon":case"MultiPolygon":return zt(n,r,{ignoreBoundary:!0});default:throw new Error("feature2 "+o+" geometry not supported")}case"MultiPoint":switch(o){case"MultiPoint":return function(t,e){for(var n=0;n<t.coordinates.length;n++){for(var r=!1,i=0;i<e.coordinates.length;i++)On(t.coordinates[n],e.coordinates[i])&&(r=!0);if(!r)return!1}return!0}(n,r);case"LineString":return function(t,e){for(var n=!1,r=0;r<t.coordinates.length;r++){if(!jt(t.coordinates[r],e))return!1;n||(n=jt(t.coordinates[r],e,{ignoreEndVertices:!0}))}return n}(n,r);case"Polygon":case"MultiPolygon":return function(t,e){for(var n=!0,r=!1,i=0;i<t.coordinates.length;i++){if(!(r=zt(t.coordinates[i],e))){n=!1;break}r=zt(t.coordinates[i],e,{ignoreBoundary:!0})}return n&&r}(n,r);default:throw new Error("feature2 "+o+" geometry not supported")}case"LineString":switch(o){case"LineString":return function(t,e){for(var n=0;n<t.coordinates.length;n++)if(!jt(t.coordinates[n],e))return!1;return!0}(n,r);case"Polygon":case"MultiPolygon":return function(t,e){var n=Rt(e),r=Rt(t);if(!Tn(n,r))return!1;for(var i=!1,o=0;o<t.coordinates.length;o++){if(!zt(t.coordinates[o],e))return!1;if(i||(i=zt(t.coordinates[o],e,{ignoreBoundary:!0})),!i&&o<t.coordinates.length-1)i=zt(Rn(t.coordinates[o],t.coordinates[o+1]),e,{ignoreBoundary:!0})}return i}(n,r);default:throw new Error("feature2 "+o+" geometry not supported")}case"Polygon":switch(o){case"Polygon":case"MultiPolygon":return function(t,e){var n=Rt(t);if(!Tn(Rt(e),n))return!1;for(var r=0;r<t.coordinates[0].length;r++)if(!zt(t.coordinates[0][r],e))return!1;return!0}(n,r);default:throw new Error("feature2 "+o+" geometry not supported")}default:throw new Error("feature1 "+i+" geometry not supported")}}function Tn(t,e){return!(t[0]>e[0])&&(!(t[2]<e[2])&&(!(t[1]>e[1])&&!(t[3]<e[3])))}function On(t,e){return t[0]===e[0]&&t[1]===e[1]}function Rn(t,e){return[(t[0]+e[0])/2,(t[1]+e[1])/2]}function An(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=Rt(t);return I([(n[0]+n[2])/2,(n[1]+n[3])/2],e.properties,e)}var Dn,Fn={exports:{}};var qn=(Dn||(Dn=1,function(t,e){t.exports=function(){function t(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function e(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function n(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}function r(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&o(t,e)}function i(t){return i=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},i(t)}function o(t,e){return o=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},o(t,e)}function s(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function a(t,e,n){return a=s()?Reflect.construct:function(t,e,n){var r=[null];r.push.apply(r,e);var i=new(Function.bind.apply(t,r));return n&&o(i,n.prototype),i},a.apply(null,arguments)}function u(t){var e="function"==typeof Map?new Map:void 0;return u=function(t){if(null===t||(n=t,-1===Function.toString.call(n).indexOf("[native code]")))return t;var n;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,r)}function r(){return a(t,arguments,i(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),o(r,t)},u(t)}function l(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function h(t,e){if(e&&("object"==m(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return l(t)}function c(t){var e=s();return function(){var n,r=i(t);if(e){var o=i(this).constructor;n=Reflect.construct(r,arguments,o)}else n=r.apply(this,arguments);return h(this,n)}}function f(t,e,n){return f="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=i(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}},f(t,e,n||t)}function g(t){return function(t){if(Array.isArray(t))return v(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||p(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function p(t,e){if(t){if("string"==typeof t)return v(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?v(t,e):void 0}}function v(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function d(t,e){var n="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!n){if(Array.isArray(t)||(n=p(t))||e){n&&(t=n);var r=0,i=function(){};return{s:i,n:function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}},e:function(t){throw t},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,s=!0,a=!1;return{s:function(){n=n.call(t)},n:function(){var t=n.next();return s=t.done,t},e:function(t){a=!0,o=t},f:function(){try{s||null==n.return||n.return()}finally{if(a)throw o}}}}var y=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getEndCapStyle",value:function(){return this._endCapStyle}},{key:"isSingleSided",value:function(){return this._isSingleSided}},{key:"setQuadrantSegments",value:function(t){this._quadrantSegments=t,0===this._quadrantSegments&&(this._joinStyle=e.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=e.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),t<=0&&(this._quadrantSegments=1),this._joinStyle!==e.JOIN_ROUND&&(this._quadrantSegments=e.DEFAULT_QUADRANT_SEGMENTS)}},{key:"getJoinStyle",value:function(){return this._joinStyle}},{key:"setJoinStyle",value:function(t){this._joinStyle=t}},{key:"setSimplifyFactor",value:function(t){this._simplifyFactor=t<0?0:t}},{key:"getSimplifyFactor",value:function(){return this._simplifyFactor}},{key:"getQuadrantSegments",value:function(){return this._quadrantSegments}},{key:"setEndCapStyle",value:function(t){this._endCapStyle=t}},{key:"getMitreLimit",value:function(){return this._mitreLimit}},{key:"setMitreLimit",value:function(t){this._mitreLimit=t}},{key:"setSingleSided",value:function(t){this._isSingleSided=t}}],[{key:"constructor_",value:function(){if(this._quadrantSegments=e.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=e.CAP_ROUND,this._joinStyle=e.JOIN_ROUND,this._mitreLimit=e.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=e.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){var n=arguments[0],r=arguments[1];this.setQuadrantSegments(n),this.setEndCapStyle(r)}else if(4===arguments.length){var i=arguments[0],o=arguments[1],s=arguments[2],a=arguments[3];this.setQuadrantSegments(i),this.setEndCapStyle(o),this.setJoinStyle(s),this.setMitreLimit(a)}}},{key:"bufferDistanceError",value:function(t){var e=Math.PI/2/t;return 1-Math.cos(e/2)}}]),e}();y.CAP_ROUND=1,y.CAP_FLAT=2,y.CAP_SQUARE=3,y.JOIN_ROUND=1,y.JOIN_MITRE=2,y.JOIN_BEVEL=3,y.DEFAULT_QUADRANT_SEGMENTS=8,y.DEFAULT_MITRE_LIMIT=5,y.DEFAULT_SIMPLIFY_FACTOR=.01;var _=function(e){r(o,e);var i=c(o);function o(e){var n;return t(this,o),(n=i.call(this,e)).name=Object.keys({Exception:o})[0],n}return n(o,[{key:"toString",value:function(){return this.message}}]),o}(u(Error)),x=function(e){r(i,e);var n=c(i);function i(e){var r;return t(this,i),(r=n.call(this,e)).name=Object.keys({IllegalArgumentException:i})[0],r}return i}(_),E=function(){function e(){t(this,e)}return n(e,[{key:"filter",value:function(t){}}]),e}();function k(){}function b(){}function w(){}var I,N,S,M,L,P,C,T,O=function(){function e(){t(this,e)}return n(e,null,[{key:"equalsWithTolerance",value:function(t,e,n){return Math.abs(t-e)<=n}}]),e}(),R=function(){function e(n,r){t(this,e),this.low=r||0,this.high=n||0}return n(e,null,[{key:"toBinaryString",value:function(t){var e,n="";for(e=2147483648;e>0;e>>>=1)n+=(t.high&e)===e?"1":"0";for(e=2147483648;e>0;e>>>=1)n+=(t.low&e)===e?"1":"0";return n}}]),e}();function A(){}function D(){}A.NaN=NaN,A.isNaN=function(t){return Number.isNaN(t)},A.isInfinite=function(t){return!Number.isFinite(t)},A.MAX_VALUE=Number.MAX_VALUE,A.POSITIVE_INFINITY=Number.POSITIVE_INFINITY,A.NEGATIVE_INFINITY=Number.NEGATIVE_INFINITY,"function"==typeof Float64Array&&"function"==typeof Int32Array?(P=2146435072,C=new Float64Array(1),T=new Int32Array(C.buffer),A.doubleToLongBits=function(t){C[0]=t;var e=0|T[0],n=0|T[1];return(n&P)===P&&0!=(1048575&n)&&0!==e&&(e=0,n=2146959360),new R(n,e)},A.longBitsToDouble=function(t){return T[0]=t.low,T[1]=t.high,C[0]}):(I=1023,N=Math.log2,S=Math.floor,M=Math.pow,L=function(){for(var t=53;t>0;t--){var e=M(2,t)-1;if(S(N(e))+1===t)return e}return 0}(),A.doubleToLongBits=function(t){var e,n,r,i,o,s,a,u,l;if(t<0||1/t===Number.NEGATIVE_INFINITY?(s=1<<31,t=-t):s=0,0===t)return new R(u=s,l=0);if(t===1/0)return new R(u=2146435072|s,l=0);if(t!=t)return new R(u=2146959360,l=0);if(i=0,l=0,(e=S(t))>1)if(e<=L)(i=S(N(e)))<=20?(l=0,u=e<<20-i&1048575):(l=e%(n=M(2,r=i-20))<<32-r,u=e/n&1048575);else for(r=e,l=0;0!==(r=S(n=r/2));)i++,l>>>=1,l|=(1&u)<<31,u>>>=1,n!==r&&(u|=524288);if(a=i+I,o=0===e,e=t-e,i<52&&0!==e)for(r=0;;){if((n=2*e)>=1?(e=n-1,o?(a--,o=!1):(r<<=1,r|=1,i++)):(e=n,o?0==--a&&(i++,o=!1):(r<<=1,i++)),20===i)u|=r,r=0;else if(52===i){l|=r;break}if(1===n){i<20?u|=r<<20-i:i<52&&(l|=r<<52-i);break}}return u|=a<<20,new R(u|=s,l)},A.longBitsToDouble=function(t){var e,n,r,i,o=t.high,s=t.low,a=o&1<<31?-1:1;for(r=((2146435072&o)>>20)-I,i=0,n=1<<19,e=1;e<=20;e++)o&n&&(i+=M(2,-e)),n>>>=1;for(n=1<<31,e=21;e<=52;e++)s&n&&(i+=M(2,-e)),n>>>=1;if(-1023===r){if(0===i)return 0*a;r=-1022}else{if(1024===r)return 0===i?a/0:NaN;i+=1}return a*i*M(2,r)});var F=function(e){r(i,e);var n=c(i);function i(e){var r;return t(this,i),(r=n.call(this,e)).name=Object.keys({RuntimeException:i})[0],r}return i}(_),q=function(e){r(o,e);var i=c(o);function o(){var e;return t(this,o),e=i.call(this),o.constructor_.apply(l(e),arguments),e}return n(o,null,[{key:"constructor_",value:function(){if(0===arguments.length)F.constructor_.call(this);else if(1===arguments.length){var t=arguments[0];F.constructor_.call(this,t)}}}]),o}(F),V=function(){function e(){t(this,e)}return n(e,null,[{key:"shouldNeverReachHere",value:function(){if(0===arguments.length)e.shouldNeverReachHere(null);else if(1===arguments.length){var t=arguments[0];throw new q("Should never reach here"+(null!==t?": "+t:""))}}},{key:"isTrue",value:function(){if(1===arguments.length){var t=arguments[0];e.isTrue(t,null)}else if(2===arguments.length){var n=arguments[1];if(!arguments[0])throw null===n?new q:new q(n)}}},{key:"equals",value:function(){if(2===arguments.length){var t=arguments[0],n=arguments[1];e.equals(t,n,null)}else if(3===arguments.length){var r=arguments[0],i=arguments[1],o=arguments[2];if(!i.equals(r))throw new q("Expected "+r+" but encountered "+i+(null!==o?": "+o:""))}}}]),e}(),G=new ArrayBuffer(8),B=new Float64Array(G),Y=new Int32Array(G),z=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getM",value:function(){return A.NaN}},{key:"setOrdinate",value:function(t,n){switch(t){case e.X:this.x=n;break;case e.Y:this.y=n;break;case e.Z:this.setZ(n);break;default:throw new x("Invalid ordinate index: "+t)}}},{key:"equals2D",value:function(){if(1===arguments.length){var t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){var e=arguments[0],n=arguments[1];return!!O.equalsWithTolerance(this.x,e.x,n)&&!!O.equalsWithTolerance(this.y,e.y,n)}}},{key:"setM",value:function(t){throw new x("Invalid ordinate index: "+e.M)}},{key:"getZ",value:function(){return this.z}},{key:"getOrdinate",value:function(t){switch(t){case e.X:return this.x;case e.Y:return this.y;case e.Z:return this.getZ()}throw new x("Invalid ordinate index: "+t)}},{key:"equals3D",value:function(t){return this.x===t.x&&this.y===t.y&&(this.getZ()===t.getZ()||A.isNaN(this.getZ())&&A.isNaN(t.getZ()))}},{key:"equals",value:function(t){return t instanceof e&&this.equals2D(t)}},{key:"equalInZ",value:function(t,e){return O.equalsWithTolerance(this.getZ(),t.getZ(),e)}},{key:"setX",value:function(t){this.x=t}},{key:"compareTo",value:function(t){var e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0}},{key:"getX",value:function(){return this.x}},{key:"setZ",value:function(t){this.z=t}},{key:"clone",value:function(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return V.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}},{key:"copy",value:function(){return new e(this)}},{key:"toString",value:function(){return"("+this.x+", "+this.y+", "+this.getZ()+")"}},{key:"distance3D",value:function(t){var e=this.x-t.x,n=this.y-t.y,r=this.getZ()-t.getZ();return Math.sqrt(e*e+n*n+r*r)}},{key:"getY",value:function(){return this.y}},{key:"setY",value:function(t){this.y=t}},{key:"distance",value:function(t){var e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}},{key:"hashCode",value:function(){var t=17;return 37*(t=37*t+e.hashCode(this.x))+e.hashCode(this.y)}},{key:"setCoordinate",value:function(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}},{key:"interfaces_",get:function(){return[k,b,w]}}],[{key:"constructor_",value:function(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)e.constructor_.call(this,0,0);else if(1===arguments.length){var t=arguments[0];e.constructor_.call(this,t.x,t.y,t.getZ())}else if(2===arguments.length){var n=arguments[0],r=arguments[1];e.constructor_.call(this,n,r,e.NULL_ORDINATE)}else if(3===arguments.length){var i=arguments[0],o=arguments[1],s=arguments[2];this.x=i,this.y=o,this.z=s}}},{key:"hashCode",value:function(t){return B[0]=t,Y[0]^Y[1]}}]),e}(),j=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"compare",value:function(t,n){var r=e.compare(t.x,n.x);if(0!==r)return r;var i=e.compare(t.y,n.y);return 0!==i?i:this._dimensionsToTest<=2?0:e.compare(t.getZ(),n.getZ())}},{key:"interfaces_",get:function(){return[D]}}],[{key:"constructor_",value:function(){if(this._dimensionsToTest=2,0===arguments.length)e.constructor_.call(this,2);else if(1===arguments.length){var t=arguments[0];if(2!==t&&3!==t)throw new x("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}}},{key:"compare",value:function(t,e){return t<e?-1:t>e?1:A.isNaN(t)?A.isNaN(e)?0:-1:A.isNaN(e)?1:0}}]),e}();z.DimensionalComparator=j,z.NULL_ORDINATE=A.NaN,z.X=0,z.Y=1,z.Z=2,z.M=3;var X=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getArea",value:function(){return this.getWidth()*this.getHeight()}},{key:"equals",value:function(t){if(!(t instanceof e))return!1;var n=t;return this.isNull()?n.isNull():this._maxx===n.getMaxX()&&this._maxy===n.getMaxY()&&this._minx===n.getMinX()&&this._miny===n.getMinY()}},{key:"intersection",value:function(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new e;var n=this._minx>t._minx?this._minx:t._minx,r=this._miny>t._miny?this._miny:t._miny;return new e(n,this._maxx<t._maxx?this._maxx:t._maxx,r,this._maxy<t._maxy?this._maxy:t._maxy)}},{key:"isNull",value:function(){return this._maxx<this._minx}},{key:"getMaxX",value:function(){return this._maxx}},{key:"covers",value:function(){if(1===arguments.length){if(arguments[0]instanceof z){var t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof e){var n=arguments[0];return!this.isNull()&&!n.isNull()&&n.getMinX()>=this._minx&&n.getMaxX()<=this._maxx&&n.getMinY()>=this._miny&&n.getMaxY()<=this._maxy}}else if(2===arguments.length){var r=arguments[0],i=arguments[1];return!this.isNull()&&r>=this._minx&&r<=this._maxx&&i>=this._miny&&i<=this._maxy}}},{key:"intersects",value:function(){if(1===arguments.length){if(arguments[0]instanceof e){var t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof z){var n=arguments[0];return this.intersects(n.x,n.y)}}else if(2===arguments.length){if(arguments[0]instanceof z&&arguments[1]instanceof z){var r=arguments[0],i=arguments[1];return!(this.isNull()||(r.x<i.x?r.x:i.x)>this._maxx||(r.x>i.x?r.x:i.x)<this._minx||(r.y<i.y?r.y:i.y)>this._maxy||(r.y>i.y?r.y:i.y)<this._miny)}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var o=arguments[0],s=arguments[1];return!this.isNull()&&!(o>this._maxx||o<this._minx||s>this._maxy||s<this._miny)}}}},{key:"getMinY",value:function(){return this._miny}},{key:"getDiameter",value:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return Math.sqrt(t*t+e*e)}},{key:"getMinX",value:function(){return this._minx}},{key:"expandToInclude",value:function(){if(1===arguments.length){if(arguments[0]instanceof z){var t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof e){var n=arguments[0];if(n.isNull())return null;this.isNull()?(this._minx=n.getMinX(),this._maxx=n.getMaxX(),this._miny=n.getMinY(),this._maxy=n.getMaxY()):(n._minx<this._minx&&(this._minx=n._minx),n._maxx>this._maxx&&(this._maxx=n._maxx),n._miny<this._miny&&(this._miny=n._miny),n._maxy>this._maxy&&(this._maxy=n._maxy))}}else if(2===arguments.length){var r=arguments[0],i=arguments[1];this.isNull()?(this._minx=r,this._maxx=r,this._miny=i,this._maxy=i):(r<this._minx&&(this._minx=r),r>this._maxx&&(this._maxx=r),i<this._miny&&(this._miny=i),i>this._maxy&&(this._maxy=i))}}},{key:"minExtent",value:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return t<e?t:e}},{key:"getWidth",value:function(){return this.isNull()?0:this._maxx-this._minx}},{key:"compareTo",value:function(t){var e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0}},{key:"translate",value:function(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)}},{key:"copy",value:function(){return new e(this)}},{key:"toString",value:function(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}},{key:"setToNull",value:function(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}},{key:"disjoint",value:function(t){return!(!this.isNull()&&!t.isNull())||t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny}},{key:"getHeight",value:function(){return this.isNull()?0:this._maxy-this._miny}},{key:"maxExtent",value:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return t>e?t:e}},{key:"expandBy",value:function(){if(1===arguments.length){var t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this.isNull())return null;this._minx-=e,this._maxx+=e,this._miny-=n,this._maxy+=n,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}},{key:"contains",value:function(){if(1===arguments.length){if(arguments[0]instanceof e){var t=arguments[0];return this.covers(t)}if(arguments[0]instanceof z){var n=arguments[0];return this.covers(n)}}else if(2===arguments.length){var r=arguments[0],i=arguments[1];return this.covers(r,i)}}},{key:"centre",value:function(){return this.isNull()?null:new z((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}},{key:"init",value:function(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof z){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof e){var n=arguments[0];this._minx=n._minx,this._maxx=n._maxx,this._miny=n._miny,this._maxy=n._maxy}}else if(2===arguments.length){var r=arguments[0],i=arguments[1];this.init(r.x,i.x,r.y,i.y)}else if(4===arguments.length){var o=arguments[0],s=arguments[1],a=arguments[2],u=arguments[3];o<s?(this._minx=o,this._maxx=s):(this._minx=s,this._maxx=o),a<u?(this._miny=a,this._maxy=u):(this._miny=u,this._maxy=a)}}},{key:"getMaxY",value:function(){return this._maxy}},{key:"distance",value:function(t){if(this.intersects(t))return 0;var e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);var n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)}},{key:"hashCode",value:function(){var t=17;return 37*(t=37*(t=37*(t=37*t+z.hashCode(this._minx))+z.hashCode(this._maxx))+z.hashCode(this._miny))+z.hashCode(this._maxy)}},{key:"interfaces_",get:function(){return[k,w]}}],[{key:"constructor_",value:function(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof z){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof e){var n=arguments[0];this.init(n)}}else if(2===arguments.length){var r=arguments[0],i=arguments[1];this.init(r.x,i.x,r.y,i.y)}else if(4===arguments.length){var o=arguments[0],s=arguments[1],a=arguments[2],u=arguments[3];this.init(o,s,a,u)}}},{key:"intersects",value:function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){var r=arguments[0],i=arguments[1],o=arguments[2],s=arguments[3],a=Math.min(o.x,s.x),u=Math.max(o.x,s.x),l=Math.min(r.x,i.x),h=Math.max(r.x,i.x);return!(l>u||h<a||(a=Math.min(o.y,s.y),u=Math.max(o.y,s.y),l=Math.min(r.y,i.y),h=Math.max(r.y,i.y),l>u||h<a))}}}]),e}(),U=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"isGeometryCollection",value:function(){return this.getTypeCode()===e.TYPECODE_GEOMETRYCOLLECTION}},{key:"getFactory",value:function(){return this._factory}},{key:"getGeometryN",value:function(t){return this}},{key:"getArea",value:function(){return 0}},{key:"isRectangle",value:function(){return!1}},{key:"equalsExact",value:function(t){return this===t||this.equalsExact(t,0)}},{key:"geometryChanged",value:function(){this.apply(e.geometryChangedFilter)}},{key:"geometryChangedAction",value:function(){this._envelope=null}},{key:"equalsNorm",value:function(t){return null!==t&&this.norm().equalsExact(t.norm())}},{key:"getLength",value:function(){return 0}},{key:"getNumGeometries",value:function(){return 1}},{key:"compareTo",value:function(){var t;if(1===arguments.length){var e=arguments[0];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e)}if(2===arguments.length){var n=arguments[0],r=arguments[1];return t=n,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(n,r)}}},{key:"getUserData",value:function(){return this._userData}},{key:"getSRID",value:function(){return this._SRID}},{key:"getEnvelope",value:function(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}},{key:"checkNotGeometryCollection",value:function(t){if(t.getTypeCode()===e.TYPECODE_GEOMETRYCOLLECTION)throw new x("This method does not support GeometryCollection arguments")}},{key:"equal",value:function(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n}},{key:"norm",value:function(){var t=this.copy();return t.normalize(),t}},{key:"reverse",value:function(){var t=this.reverseInternal();return null!=this.envelope&&(t.envelope=this.envelope.copy()),t.setSRID(this.getSRID()),t}},{key:"copy",value:function(){var t=this.copyInternal();return t.envelope=null==this._envelope?null:this._envelope.copy(),t._SRID=this._SRID,t._userData=this._userData,t}},{key:"getPrecisionModel",value:function(){return this._factory.getPrecisionModel()}},{key:"getEnvelopeInternal",value:function(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new X(this._envelope)}},{key:"setSRID",value:function(t){this._SRID=t}},{key:"setUserData",value:function(t){this._userData=t}},{key:"compare",value:function(t,e){for(var n=t.iterator(),r=e.iterator();n.hasNext()&&r.hasNext();){var i=n.next(),o=r.next(),s=i.compareTo(o);if(0!==s)return s}return n.hasNext()?1:r.hasNext()?-1:0}},{key:"hashCode",value:function(){return this.getEnvelopeInternal().hashCode()}},{key:"isEquivalentClass",value:function(t){return this.getClass()===t.getClass()}},{key:"isGeometryCollectionOrDerived",value:function(){return this.getTypeCode()===e.TYPECODE_GEOMETRYCOLLECTION||this.getTypeCode()===e.TYPECODE_MULTIPOINT||this.getTypeCode()===e.TYPECODE_MULTILINESTRING||this.getTypeCode()===e.TYPECODE_MULTIPOLYGON}},{key:"interfaces_",get:function(){return[b,k,w]}},{key:"getClass",value:function(){return e}}],[{key:"hasNonEmptyElements",value:function(t){for(var e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1}},{key:"hasNullElements",value:function(t){for(var e=0;e<t.length;e++)if(null===t[e])return!0;return!1}}]),e}();U.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},U.TYPECODE_POINT=0,U.TYPECODE_MULTIPOINT=1,U.TYPECODE_LINESTRING=2,U.TYPECODE_LINEARRING=3,U.TYPECODE_MULTILINESTRING=4,U.TYPECODE_POLYGON=5,U.TYPECODE_MULTIPOLYGON=6,U.TYPECODE_GEOMETRYCOLLECTION=7,U.TYPENAME_POINT="Point",U.TYPENAME_MULTIPOINT="MultiPoint",U.TYPENAME_LINESTRING="LineString",U.TYPENAME_LINEARRING="LinearRing",U.TYPENAME_MULTILINESTRING="MultiLineString",U.TYPENAME_POLYGON="Polygon",U.TYPENAME_MULTIPOLYGON="MultiPolygon",U.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",U.geometryChangedFilter={get interfaces_(){return[E]},filter:function(t){t.geometryChangedAction()}};var Z=function(){function e(){t(this,e)}return n(e,null,[{key:"toLocationSymbol",value:function(t){switch(t){case e.EXTERIOR:return"e";case e.BOUNDARY:return"b";case e.INTERIOR:return"i";case e.NONE:return"-"}throw new x("Unknown location value: "+t)}}]),e}();Z.INTERIOR=0,Z.BOUNDARY=1,Z.EXTERIOR=2,Z.NONE=-1;var H=function(){function e(){t(this,e)}return n(e,[{key:"add",value:function(){}},{key:"addAll",value:function(){}},{key:"isEmpty",value:function(){}},{key:"iterator",value:function(){}},{key:"size",value:function(){}},{key:"toArray",value:function(){}},{key:"remove",value:function(){}}]),e}(),W=function(e){r(i,e);var n=c(i);function i(e){var r;return t(this,i),(r=n.call(this,e)).name=Object.keys({NoSuchElementException:i})[0],r}return i}(_),J=function(e){r(i,e);var n=c(i);function i(e){var r;return t(this,i),(r=n.call(this,e)).name=Object.keys({UnsupportedOperationException:i})[0],r}return i}(_),K=function(e){r(o,e);var i=c(o);function o(){return t(this,o),i.apply(this,arguments)}return n(o,[{key:"contains",value:function(){}}]),o}(H),Q=function(e,i){r(s,e);var o=c(s);function s(e){var n;return t(this,s),(n=o.call(this)).map=new Map,e instanceof H&&n.addAll(e),n}return n(s,[{key:"contains",value:function(t){var e=t.hashCode?t.hashCode():t;return!!this.map.has(e)}},{key:"add",value:function(t){var e=t.hashCode?t.hashCode():t;return!this.map.has(e)&&!!this.map.set(e,t)}},{key:"addAll",value:function(t){var e,n=d(t);try{for(n.s();!(e=n.n()).done;){var r=e.value;this.add(r)}}catch(t){n.e(t)}finally{n.f()}return!0}},{key:"remove",value:function(){throw new J}},{key:"size",value:function(){return this.map.size}},{key:"isEmpty",value:function(){return 0===this.map.size}},{key:"toArray",value:function(){return Array.from(this.map.values())}},{key:"iterator",value:function(){return new $(this.map)}},{key:i,value:function(){return this.map}}]),s}(K,Symbol.iterator),$=function(){function e(n){t(this,e),this.iterator=n.values();var r=this.iterator.next(),i=r.done,o=r.value;this.done=i,this.value=o}return n(e,[{key:"next",value:function(){if(this.done)throw new W;var t=this.value,e=this.iterator.next(),n=e.done,r=e.value;return this.done=n,this.value=r,t}},{key:"hasNext",value:function(){return!this.done}},{key:"remove",value:function(){throw new J}}]),e}(),tt=function(){function e(){t(this,e)}return n(e,null,[{key:"opposite",value:function(t){return t===e.LEFT?e.RIGHT:t===e.RIGHT?e.LEFT:t}}]),e}();tt.ON=0,tt.LEFT=1,tt.RIGHT=2;var et=function(e){r(i,e);var n=c(i);function i(e){var r;return t(this,i),(r=n.call(this,e)).name=Object.keys({EmptyStackException:i})[0],r}return i}(_),nt=function(e){r(i,e);var n=c(i);function i(e){var r;return t(this,i),(r=n.call(this,e)).name=Object.keys({IndexOutOfBoundsException:i})[0],r}return i}(_),rt=function(e){r(o,e);var i=c(o);function o(){return t(this,o),i.apply(this,arguments)}return n(o,[{key:"get",value:function(){}},{key:"set",value:function(){}},{key:"isEmpty",value:function(){}}]),o}(H),it=function(e){r(o,e);var i=c(o);function o(){var e;return t(this,o),(e=i.call(this)).array=[],e}return n(o,[{key:"add",value:function(t){return this.array.push(t),!0}},{key:"get",value:function(t){if(t<0||t>=this.size())throw new nt;return this.array[t]}},{key:"push",value:function(t){return this.array.push(t),t}},{key:"pop",value:function(){if(0===this.array.length)throw new et;return this.array.pop()}},{key:"peek",value:function(){if(0===this.array.length)throw new et;return this.array[this.array.length-1]}},{key:"empty",value:function(){return 0===this.array.length}},{key:"isEmpty",value:function(){return this.empty()}},{key:"search",value:function(t){return this.array.indexOf(t)}},{key:"size",value:function(){return this.array.length}},{key:"toArray",value:function(){return this.array.slice()}}]),o}(rt);function ot(t,e){return t.interfaces_&&t.interfaces_.indexOf(e)>-1}var st=function(){function e(n){t(this,e),this.str=n}return n(e,[{key:"append",value:function(t){this.str+=t}},{key:"setCharAt",value:function(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}},{key:"toString",value:function(){return this.str}}]),e}(),at=function(){function e(n){t(this,e),this.value=n}return n(e,[{key:"intValue",value:function(){return this.value}},{key:"compareTo",value:function(t){return this.value<t?-1:this.value>t?1:0}}],[{key:"compare",value:function(t,e){return t<e?-1:t>e?1:0}},{key:"isNan",value:function(t){return Number.isNaN(t)}},{key:"valueOf",value:function(t){return new e(t)}}]),e}(),ut=function(){function e(){t(this,e)}return n(e,null,[{key:"isWhitespace",value:function(t){return t<=32&&t>=0||127===t}},{key:"toUpperCase",value:function(t){return t.toUpperCase()}}]),e}(),lt=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"le",value:function(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}},{key:"extractSignificantDigits",value:function(t,n){var r=this.abs(),i=e.magnitude(r._hi),o=e.TEN.pow(i);(r=r.divide(o)).gt(e.TEN)?(r=r.divide(e.TEN),i+=1):r.lt(e.ONE)&&(r=r.multiply(e.TEN),i-=1);for(var s=i+1,a=new st,u=e.MAX_PRINT_DIGITS-1,l=0;l<=u;l++){t&&l===s&&a.append(".");var h=Math.trunc(r._hi);if(h<0)break;var c=!1,f=0;h>9?(c=!0,f="9"):f="0"+h,a.append(f),r=r.subtract(e.valueOf(h)).multiply(e.TEN),c&&r.selfAdd(e.TEN);var g=!0,p=e.magnitude(r._hi);if(p<0&&Math.abs(p)>=u-l&&(g=!1),!g)break}return n[0]=i,a.toString()}},{key:"sqr",value:function(){return this.multiply(this)}},{key:"doubleValue",value:function(){return this._hi+this._lo}},{key:"subtract",value:function(){if(arguments[0]instanceof e){var t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){var n=arguments[0];return this.add(-n)}}},{key:"equals",value:function(){if(1===arguments.length&&arguments[0]instanceof e){var t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}},{key:"isZero",value:function(){return 0===this._hi&&0===this._lo}},{key:"selfSubtract",value:function(){if(arguments[0]instanceof e){var t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){var n=arguments[0];return this.isNaN()?this:this.selfAdd(-n,0)}}},{key:"getSpecialNumberString",value:function(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}},{key:"min",value:function(t){return this.le(t)?this:t}},{key:"selfDivide",value:function(){if(1===arguments.length){if(arguments[0]instanceof e){var t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){var n=arguments[0];return this.selfDivide(n,0)}}else if(2===arguments.length){var r=arguments[0],i=arguments[1],o=null,s=null,a=null,u=null,l=null,h=null,c=null,f=null;return l=this._hi/r,f=(o=(h=e.SPLIT*l)-(o=h-l))*(a=(f=e.SPLIT*r)-(a=f-r))-(c=l*r)+o*(u=r-a)+(s=l-o)*a+s*u,f=l+(h=(this._hi-c-f+this._lo-l*i)/r),this._hi=f,this._lo=l-f+h,this}}},{key:"dump",value:function(){return"DD<"+this._hi+", "+this._lo+">"}},{key:"divide",value:function(){if(arguments[0]instanceof e){var t=arguments[0],n=null,r=null,i=null,o=null,s=null,a=null,u=null,l=null;return r=(s=this._hi/t._hi)-(n=(a=e.SPLIT*s)-(n=a-s)),l=n*(i=(l=e.SPLIT*t._hi)-(i=l-t._hi))-(u=s*t._hi)+n*(o=t._hi-i)+r*i+r*o,new e(l=s+(a=(this._hi-u-l+this._lo-s*t._lo)/t._hi),s-l+a)}if("number"==typeof arguments[0]){var h=arguments[0];return A.isNaN(h)?e.createNaN():e.copy(this).selfDivide(h,0)}}},{key:"ge",value:function(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}},{key:"pow",value:function(t){if(0===t)return e.valueOf(1);var n=new e(this),r=e.valueOf(1),i=Math.abs(t);if(i>1)for(;i>0;)i%2==1&&r.selfMultiply(n),(i/=2)>0&&(n=n.sqr());else r=n;return t<0?r.reciprocal():r}},{key:"ceil",value:function(){if(this.isNaN())return e.NaN;var t=Math.ceil(this._hi),n=0;return t===this._hi&&(n=Math.ceil(this._lo)),new e(t,n)}},{key:"compareTo",value:function(t){var e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0}},{key:"rint",value:function(){return this.isNaN()?this:this.add(.5).floor()}},{key:"setValue",value:function(){if(arguments[0]instanceof e){var t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){var n=arguments[0];return this.init(n),this}}},{key:"max",value:function(t){return this.ge(t)?this:t}},{key:"sqrt",value:function(){if(this.isZero())return e.valueOf(0);if(this.isNegative())return e.NaN;var t=1/Math.sqrt(this._hi),n=this._hi*t,r=e.valueOf(n),i=this.subtract(r.sqr())._hi*(.5*t);return r.add(i)}},{key:"selfAdd",value:function(){if(1===arguments.length){if(arguments[0]instanceof e){var t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){var n=arguments[0],r=null,i=null,o=null,s=null,a=null,u=null;return s=(o=this._hi+n)-(a=o-this._hi),i=(u=(s=n-a+(this._hi-s))+this._lo)+(o-(r=o+u)),this._hi=r+i,this._lo=i+(r-this._hi),this}}else if(2===arguments.length){var l=arguments[0],h=arguments[1],c=null,f=null,g=null,p=null,v=null,d=null,y=null;p=this._hi+l,f=this._lo+h,v=p-(d=p-this._hi),g=f-(y=f-this._lo);var m=(c=p+(d=(v=l-d+(this._hi-v))+f))+(d=(g=h-y+(this._lo-g))+(d+(p-c))),_=d+(c-m);return this._hi=m,this._lo=_,this}}},{key:"selfMultiply",value:function(){if(1===arguments.length){if(arguments[0]instanceof e){var t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){var n=arguments[0];return this.selfMultiply(n,0)}}else if(2===arguments.length){var r=arguments[0],i=arguments[1],o=null,s=null,a=null,u=null,l=null,h=null;o=(l=e.SPLIT*this._hi)-this._hi,h=e.SPLIT*r,o=l-o,s=this._hi-o,a=h-r;var c=(l=this._hi*r)+(h=o*(a=h-a)-l+o*(u=r-a)+s*a+s*u+(this._hi*i+this._lo*r)),f=h+(o=l-c);return this._hi=c,this._lo=f,this}}},{key:"selfSqr",value:function(){return this.selfMultiply(this)}},{key:"floor",value:function(){if(this.isNaN())return e.NaN;var t=Math.floor(this._hi),n=0;return t===this._hi&&(n=Math.floor(this._lo)),new e(t,n)}},{key:"negate",value:function(){return this.isNaN()?this:new e(-this._hi,-this._lo)}},{key:"clone",value:function(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}},{key:"multiply",value:function(){if(arguments[0]instanceof e){var t=arguments[0];return t.isNaN()?e.createNaN():e.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){var n=arguments[0];return A.isNaN(n)?e.createNaN():e.copy(this).selfMultiply(n,0)}}},{key:"isNaN",value:function(){return A.isNaN(this._hi)}},{key:"intValue",value:function(){return Math.trunc(this._hi)}},{key:"toString",value:function(){var t=e.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}},{key:"toStandardNotation",value:function(){var t=this.getSpecialNumberString();if(null!==t)return t;var n=new Array(1).fill(null),r=this.extractSignificantDigits(!0,n),i=n[0]+1,o=r;if("."===r.charAt(0))o="0"+r;else if(i<0)o="0."+e.stringOfChar("0",-i)+r;else if(-1===r.indexOf(".")){var s=i-r.length;o=r+e.stringOfChar("0",s)+".0"}return this.isNegative()?"-"+o:o}},{key:"reciprocal",value:function(){var t,n,r,i,o=null,s=null,a=null,u=null;t=(r=1/this._hi)-(o=(a=e.SPLIT*r)-(o=a-r)),s=(u=e.SPLIT*this._hi)-this._hi;var l=r+(a=(1-(i=r*this._hi)-(u=o*(s=u-s)-i+o*(n=this._hi-s)+t*s+t*n)-r*this._lo)/this._hi);return new e(l,r-l+a)}},{key:"toSciNotation",value:function(){if(this.isZero())return e.SCI_NOT_ZERO;var t=this.getSpecialNumberString();if(null!==t)return t;var n=new Array(1).fill(null),r=this.extractSignificantDigits(!1,n),i=e.SCI_NOT_EXPONENT_CHAR+n[0];if("0"===r.charAt(0))throw new IllegalStateException("Found leading zero: "+r);var o="";r.length>1&&(o=r.substring(1));var s=r.charAt(0)+"."+o;return this.isNegative()?"-"+s+i:s+i}},{key:"abs",value:function(){return this.isNaN()?e.NaN:this.isNegative()?this.negate():new e(this)}},{key:"isPositive",value:function(){return this._hi>0||0===this._hi&&this._lo>0}},{key:"lt",value:function(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}},{key:"add",value:function(){if(arguments[0]instanceof e){var t=arguments[0];return e.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){var n=arguments[0];return e.copy(this).selfAdd(n)}}},{key:"init",value:function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof e){var n=arguments[0];this._hi=n._hi,this._lo=n._lo}}else if(2===arguments.length){var r=arguments[0],i=arguments[1];this._hi=r,this._lo=i}}},{key:"gt",value:function(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}},{key:"isNegative",value:function(){return this._hi<0||0===this._hi&&this._lo<0}},{key:"trunc",value:function(){return this.isNaN()?e.NaN:this.isPositive()?this.floor():this.ceil()}},{key:"signum",value:function(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}},{key:"interfaces_",get:function(){return[w,k,b]}}],[{key:"constructor_",value:function(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this.init(t)}else if(arguments[0]instanceof e){var n=arguments[0];this.init(n)}else if("string"==typeof arguments[0]){var r=arguments[0];e.constructor_.call(this,e.parse(r))}}else if(2===arguments.length){var i=arguments[0],o=arguments[1];this.init(i,o)}}},{key:"determinant",value:function(){if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],n=arguments[1],r=arguments[2],i=arguments[3];return e.determinant(e.valueOf(t),e.valueOf(n),e.valueOf(r),e.valueOf(i))}if(arguments[3]instanceof e&&arguments[2]instanceof e&&arguments[0]instanceof e&&arguments[1]instanceof e){var o=arguments[1],s=arguments[2],a=arguments[3];return arguments[0].multiply(a).selfSubtract(o.multiply(s))}}},{key:"sqr",value:function(t){return e.valueOf(t).selfMultiply(t)}},{key:"valueOf",value:function(){if("string"==typeof arguments[0]){var t=arguments[0];return e.parse(t)}if("number"==typeof arguments[0])return new e(arguments[0])}},{key:"sqrt",value:function(t){return e.valueOf(t).sqrt()}},{key:"parse",value:function(t){for(var n=0,r=t.length;ut.isWhitespace(t.charAt(n));)n++;var i=!1;if(n<r){var o=t.charAt(n);"-"!==o&&"+"!==o||(n++,"-"===o&&(i=!0))}for(var s=new e,a=0,u=0,l=0,h=!1;!(n>=r);){var c=t.charAt(n);if(n++,ut.isDigit(c)){var f=c-"0";s.selfMultiply(e.TEN),s.selfAdd(f),a++}else{if("."!==c){if("e"===c||"E"===c){var g=t.substring(n);try{l=at.parseInt(g)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+g+" in string "+t):e}break}throw new NumberFormatException("Unexpected character '"+c+"' at position "+n+" in string "+t)}u=a,h=!0}}var p=s;h||(u=a);var v=a-u-l;if(0===v)p=s;else if(v>0){var d=e.TEN.pow(v);p=s.divide(d)}else if(v<0){var y=e.TEN.pow(-v);p=s.multiply(y)}return i?p.negate():p}},{key:"createNaN",value:function(){return new e(A.NaN,A.NaN)}},{key:"copy",value:function(t){return new e(t)}},{key:"magnitude",value:function(t){var e=Math.abs(t),n=Math.log(e)/Math.log(10),r=Math.trunc(Math.floor(n));return 10*Math.pow(10,r)<=e&&(r+=1),r}},{key:"stringOfChar",value:function(t,e){for(var n=new st,r=0;r<e;r++)n.append(t);return n.toString()}}]),e}();lt.PI=new lt(3.141592653589793,12246467991473532e-32),lt.TWO_PI=new lt(6.283185307179586,24492935982947064e-32),lt.PI_2=new lt(1.5707963267948966,6123233995736766e-32),lt.E=new lt(2.718281828459045,14456468917292502e-32),lt.NaN=new lt(A.NaN,A.NaN),lt.EPS=123259516440783e-46,lt.SPLIT=134217729,lt.MAX_PRINT_DIGITS=32,lt.TEN=lt.valueOf(10),lt.ONE=lt.valueOf(1),lt.SCI_NOT_EXPONENT_CHAR="E",lt.SCI_NOT_ZERO="0.0E0";var ht=function(){function e(){t(this,e)}return n(e,null,[{key:"orientationIndex",value:function(t,n,r){var i=e.orientationIndexFilter(t,n,r);if(i<=1)return i;var o=lt.valueOf(n.x).selfAdd(-t.x),s=lt.valueOf(n.y).selfAdd(-t.y),a=lt.valueOf(r.x).selfAdd(-n.x),u=lt.valueOf(r.y).selfAdd(-n.y);return o.selfMultiply(u).selfSubtract(s.selfMultiply(a)).signum()}},{key:"signOfDet2x2",value:function(){if(arguments[3]instanceof lt&&arguments[2]instanceof lt&&arguments[0]instanceof lt&&arguments[1]instanceof lt){var t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){var r=arguments[0],i=arguments[1],o=arguments[2],s=arguments[3],a=lt.valueOf(r),u=lt.valueOf(i),l=lt.valueOf(o),h=lt.valueOf(s);return a.multiply(h).selfSubtract(u.multiply(l)).signum()}}},{key:"intersection",value:function(t,e,n,r){var i=new lt(t.y).selfSubtract(e.y),o=new lt(e.x).selfSubtract(t.x),s=new lt(t.x).selfMultiply(e.y).selfSubtract(new lt(e.x).selfMultiply(t.y)),a=new lt(n.y).selfSubtract(r.y),u=new lt(r.x).selfSubtract(n.x),l=new lt(n.x).selfMultiply(r.y).selfSubtract(new lt(r.x).selfMultiply(n.y)),h=o.multiply(l).selfSubtract(u.multiply(s)),c=a.multiply(s).selfSubtract(i.multiply(l)),f=i.multiply(u).selfSubtract(a.multiply(o)),g=h.selfDivide(f).doubleValue(),p=c.selfDivide(f).doubleValue();return A.isNaN(g)||A.isInfinite(g)||A.isNaN(p)||A.isInfinite(p)?null:new z(g,p)}},{key:"orientationIndexFilter",value:function(t,n,r){var i=null,o=(t.x-r.x)*(n.y-r.y),s=(t.y-r.y)*(n.x-r.x),a=o-s;if(o>0){if(s<=0)return e.signum(a);i=o+s}else{if(!(o<0))return e.signum(a);if(s>=0)return e.signum(a);i=-o-s}var u=e.DP_SAFE_EPSILON*i;return a>=u||-a>=u?e.signum(a):2}},{key:"signum",value:function(t){return t>0?1:t<0?-1:0}}]),e}();ht.DP_SAFE_EPSILON=1e-15;var ct=function(){function e(){t(this,e)}return n(e,[{key:"getM",value:function(t){if(this.hasM()){var e=this.getDimension()-this.getMeasures();return this.getOrdinate(t,e)}return A.NaN}},{key:"setOrdinate",value:function(t,e,n){}},{key:"getZ",value:function(t){return this.hasZ()?this.getOrdinate(t,2):A.NaN}},{key:"size",value:function(){}},{key:"getOrdinate",value:function(t,e){}},{key:"getCoordinate",value:function(){}},{key:"getCoordinateCopy",value:function(t){}},{key:"createCoordinate",value:function(){}},{key:"getDimension",value:function(){}},{key:"hasM",value:function(){return this.getMeasures()>0}},{key:"getX",value:function(t){}},{key:"hasZ",value:function(){return this.getDimension()-this.getMeasures()>2}},{key:"getMeasures",value:function(){return 0}},{key:"expandEnvelope",value:function(t){}},{key:"copy",value:function(){}},{key:"getY",value:function(t){}},{key:"toCoordinateArray",value:function(){}},{key:"interfaces_",get:function(){return[b]}}]),e}();ct.X=0,ct.Y=1,ct.Z=2,ct.M=3;var ft=function(){function e(){t(this,e)}return n(e,null,[{key:"index",value:function(t,e,n){return ht.orientationIndex(t,e,n)}},{key:"isCCW",value:function(){if(arguments[0]instanceof Array){var t=arguments[0],n=t.length-1;if(n<3)throw new x("Ring has fewer than 4 points, so orientation cannot be determined");for(var r=t[0],i=0,o=1;o<=n;o++){var s=t[o];s.y>r.y&&(r=s,i=o)}var a=i;do{(a-=1)<0&&(a=n)}while(t[a].equals2D(r)&&a!==i);var u=i;do{u=(u+1)%n}while(t[u].equals2D(r)&&u!==i);var l=t[a],h=t[u];if(l.equals2D(r)||h.equals2D(r)||l.equals2D(h))return!1;var c=e.index(l,r,h);return 0===c?l.x>h.x:c>0}if(ot(arguments[0],ct)){var f=arguments[0],g=f.size()-1;if(g<3)throw new x("Ring has fewer than 4 points, so orientation cannot be determined");for(var p=f.getCoordinate(0),v=0,d=1;d<=g;d++){var y=f.getCoordinate(d);y.y>p.y&&(p=y,v=d)}var m=null,_=v;do{(_-=1)<0&&(_=g),m=f.getCoordinate(_)}while(m.equals2D(p)&&_!==v);var E=null,k=v;do{k=(k+1)%g,E=f.getCoordinate(k)}while(E.equals2D(p)&&k!==v);if(m.equals2D(p)||E.equals2D(p)||m.equals2D(E))return!1;var b=e.index(m,p,E);return 0===b?m.x>E.x:b>0}}}]),e}();ft.CLOCKWISE=-1,ft.RIGHT=ft.CLOCKWISE,ft.COUNTERCLOCKWISE=1,ft.LEFT=ft.COUNTERCLOCKWISE,ft.COLLINEAR=0,ft.STRAIGHT=ft.COLLINEAR;var gt=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getCoordinate",value:function(){return this._minCoord}},{key:"getRightmostSide",value:function(t,e){var n=this.getRightmostSideOfSegment(t,e);return n<0&&(n=this.getRightmostSideOfSegment(t,e-1)),n<0&&(this._minCoord=null,this.checkForRightmostCoordinate(t)),n}},{key:"findRightmostEdgeAtVertex",value:function(){var t=this._minDe.getEdge().getCoordinates();V.isTrue(this._minIndex>0&&this._minIndex<t.length,"rightmost point expected to be interior vertex of edge");var e=t[this._minIndex-1],n=t[this._minIndex+1],r=ft.index(this._minCoord,n,e),i=!1;(e.y<this._minCoord.y&&n.y<this._minCoord.y&&r===ft.COUNTERCLOCKWISE||e.y>this._minCoord.y&&n.y>this._minCoord.y&&r===ft.CLOCKWISE)&&(i=!0),i&&(this._minIndex=this._minIndex-1)}},{key:"getRightmostSideOfSegment",value:function(t,e){var n=t.getEdge().getCoordinates();if(e<0||e+1>=n.length)return-1;if(n[e].y===n[e+1].y)return-1;var r=tt.LEFT;return n[e].y<n[e+1].y&&(r=tt.RIGHT),r}},{key:"getEdge",value:function(){return this._orientedDe}},{key:"checkForRightmostCoordinate",value:function(t){for(var e=t.getEdge().getCoordinates(),n=0;n<e.length-1;n++)(null===this._minCoord||e[n].x>this._minCoord.x)&&(this._minDe=t,this._minIndex=n,this._minCoord=e[n])}},{key:"findRightmostEdgeAtNode",value:function(){var t=this._minDe.getNode().getEdges();this._minDe=t.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)}},{key:"findEdge",value:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.isForward()&&this.checkForRightmostCoordinate(n)}V.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe,this.getRightmostSide(this._minDe,this._minIndex)===tt.LEFT&&(this._orientedDe=this._minDe.getSym())}}],[{key:"constructor_",value:function(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null}}]),e}(),pt=function(e){r(o,e);var i=c(o);function o(e,n){var r;return t(this,o),(r=i.call(this,n?e+" [ "+n+" ]":e)).pt=n?new z(n):void 0,r.name=Object.keys({TopologyException:o})[0],r}return n(o,[{key:"getCoordinate",value:function(){return this.pt}}]),o}(F),vt=function(){function e(){t(this,e),this.array=[]}return n(e,[{key:"addLast",value:function(t){this.array.push(t)}},{key:"removeFirst",value:function(){return this.array.shift()}},{key:"isEmpty",value:function(){return 0===this.array.length}}]),e}(),dt=function(e,i){r(s,e);var o=c(s);function s(e){var n;return t(this,s),(n=o.call(this)).array=[],e instanceof H&&n.addAll(e),n}return n(s,[{key:"interfaces_",get:function(){return[rt,H]}},{key:"ensureCapacity",value:function(){}},{key:"add",value:function(t){return 1===arguments.length?this.array.push(t):this.array.splice(arguments[0],0,arguments[1]),!0}},{key:"clear",value:function(){this.array=[]}},{key:"addAll",value:function(t){var e,n=d(t);try{for(n.s();!(e=n.n()).done;){var r=e.value;this.array.push(r)}}catch(t){n.e(t)}finally{n.f()}}},{key:"set",value:function(t,e){var n=this.array[t];return this.array[t]=e,n}},{key:"iterator",value:function(){return new yt(this)}},{key:"get",value:function(t){if(t<0||t>=this.size())throw new nt;return this.array[t]}},{key:"isEmpty",value:function(){return 0===this.array.length}},{key:"sort",value:function(t){t?this.array.sort((function(e,n){return t.compare(e,n)})):this.array.sort()}},{key:"size",value:function(){return this.array.length}},{key:"toArray",value:function(){return this.array.slice()}},{key:"remove",value:function(t){for(var e=0,n=this.array.length;e<n;e++)if(this.array[e]===t)return!!this.array.splice(e,1);return!1}},{key:i,value:function(){return this.array.values()}}]),s}(rt,Symbol.iterator),yt=function(){function e(n){t(this,e),this.arrayList=n,this.position=0}return n(e,[{key:"next",value:function(){if(this.position===this.arrayList.size())throw new W;return this.arrayList.get(this.position++)}},{key:"hasNext",value:function(){return this.position<this.arrayList.size()}},{key:"set",value:function(t){return this.arrayList.set(this.position-1,t)}},{key:"remove",value:function(){this.arrayList.remove(this.arrayList.get(this.position))}}]),e}(),mt=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"clearVisitedEdges",value:function(){for(var t=this._dirEdgeList.iterator();t.hasNext();)t.next().setVisited(!1)}},{key:"getRightmostCoordinate",value:function(){return this._rightMostCoord}},{key:"computeNodeDepth",value:function(t){for(var e=null,n=t.getEdges().iterator();n.hasNext();){var r=n.next();if(r.isVisited()||r.getSym().isVisited()){e=r;break}}if(null===e)throw new pt("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(var i=t.getEdges().iterator();i.hasNext();){var o=i.next();o.setVisited(!0),this.copySymDepths(o)}}},{key:"computeDepth",value:function(t){this.clearVisitedEdges();var e=this._finder.getEdge();e.getNode(),e.getLabel(),e.setEdgeDepths(tt.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)}},{key:"create",value:function(t){this.addReachable(t),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()}},{key:"findResultEdges",value:function(){for(var t=this._dirEdgeList.iterator();t.hasNext();){var e=t.next();e.getDepth(tt.RIGHT)>=1&&e.getDepth(tt.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}}},{key:"computeDepths",value:function(t){var e=new Q,n=new vt,r=t.getNode();for(n.addLast(r),e.add(r),t.setVisited(!0);!n.isEmpty();){var i=n.removeFirst();e.add(i),this.computeNodeDepth(i);for(var o=i.getEdges().iterator();o.hasNext();){var s=o.next().getSym();if(!s.isVisited()){var a=s.getNode();e.contains(a)||(n.addLast(a),e.add(a))}}}}},{key:"compareTo",value:function(t){var e=t;return this._rightMostCoord.x<e._rightMostCoord.x?-1:this._rightMostCoord.x>e._rightMostCoord.x?1:0}},{key:"getEnvelope",value:function(){if(null===this._env){for(var t=new X,e=this._dirEdgeList.iterator();e.hasNext();)for(var n=e.next().getEdge().getCoordinates(),r=0;r<n.length-1;r++)t.expandToInclude(n[r]);this._env=t}return this._env}},{key:"addReachable",value:function(t){var e=new it;for(e.add(t);!e.empty();){var n=e.pop();this.add(n,e)}}},{key:"copySymDepths",value:function(t){var e=t.getSym();e.setDepth(tt.LEFT,t.getDepth(tt.RIGHT)),e.setDepth(tt.RIGHT,t.getDepth(tt.LEFT))}},{key:"add",value:function(t,e){t.setVisited(!0),this._nodes.add(t);for(var n=t.getEdges().iterator();n.hasNext();){var r=n.next();this._dirEdgeList.add(r);var i=r.getSym().getNode();i.isVisited()||e.push(i)}}},{key:"getNodes",value:function(){return this._nodes}},{key:"getDirectedEdges",value:function(){return this._dirEdgeList}},{key:"interfaces_",get:function(){return[k]}}],[{key:"constructor_",value:function(){this._finder=null,this._dirEdgeList=new dt,this._nodes=new dt,this._rightMostCoord=null,this._env=null,this._finder=new gt}}]),e}(),_t=function(){function e(){t(this,e)}return n(e,null,[{key:"intersection",value:function(t,e,n,r){var i=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,s=t.x>e.x?t.x:e.x,a=t.y>e.y?t.y:e.y,u=n.x<r.x?n.x:r.x,l=n.y<r.y?n.y:r.y,h=n.x>r.x?n.x:r.x,c=n.y>r.y?n.y:r.y,f=((i>u?i:u)+(s<h?s:h))/2,g=((o>l?o:l)+(a<c?a:c))/2,p=t.x-f,v=t.y-g,d=e.x-f,y=e.y-g,m=n.x-f,_=n.y-g,x=r.x-f,E=r.y-g,k=v-y,b=d-p,w=p*y-d*v,I=_-E,N=x-m,S=m*E-x*_,M=k*N-I*b,L=(b*S-N*w)/M,P=(I*w-k*S)/M;return A.isNaN(L)||A.isInfinite(L)||A.isNaN(P)||A.isInfinite(P)?null:new z(L+f,P+g)}}]),e}(),xt=function(){function e(){t(this,e)}return n(e,null,[{key:"arraycopy",value:function(t,e,n,r,i){for(var o=0,s=e;s<e+i;s++)n[r+o]=t[s],o++}},{key:"getProperty",value:function(t){return{"line.separator":"\n"}[t]}}]),e}(),Et=function(){function e(){t(this,e)}return n(e,null,[{key:"log10",value:function(t){var n=Math.log(t);return A.isInfinite(n)||A.isNaN(n)?n:n/e.LOG_10}},{key:"min",value:function(t,e,n,r){var i=t;return e<i&&(i=e),n<i&&(i=n),r<i&&(i=r),i}},{key:"clamp",value:function(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var r=arguments[0],i=arguments[1],o=arguments[2];return r<i?i:r>o?o:r}}},{key:"wrap",value:function(t,e){return t<0?e- -t%e:t%e}},{key:"max",value:function(){if(3===arguments.length){var t=arguments[1],e=arguments[2],n=arguments[0];return t>n&&(n=t),e>n&&(n=e),n}if(4===arguments.length){var r=arguments[1],i=arguments[2],o=arguments[3],s=arguments[0];return r>s&&(s=r),i>s&&(s=i),o>s&&(s=o),s}}},{key:"average",value:function(t,e){return(t+e)/2}}]),e}();Et.LOG_10=Math.log(10);var kt=function(){function e(){t(this,e)}return n(e,null,[{key:"segmentToSegment",value:function(t,n,r,i){if(t.equals(n))return e.pointToSegment(t,r,i);if(r.equals(i))return e.pointToSegment(i,t,n);var o=!1;if(X.intersects(t,n,r,i)){var s=(n.x-t.x)*(i.y-r.y)-(n.y-t.y)*(i.x-r.x);if(0===s)o=!0;else{var a=(t.y-r.y)*(i.x-r.x)-(t.x-r.x)*(i.y-r.y),u=((t.y-r.y)*(n.x-t.x)-(t.x-r.x)*(n.y-t.y))/s,l=a/s;(l<0||l>1||u<0||u>1)&&(o=!0)}}else o=!0;return o?Et.min(e.pointToSegment(t,r,i),e.pointToSegment(n,r,i),e.pointToSegment(r,t,n),e.pointToSegment(i,t,n)):0}},{key:"pointToSegment",value:function(t,e,n){if(e.x===n.x&&e.y===n.y)return t.distance(e);var r=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((t.x-e.x)*(n.x-e.x)+(t.y-e.y)*(n.y-e.y))/r;if(i<=0)return t.distance(e);if(i>=1)return t.distance(n);var o=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/r;return Math.abs(o)*Math.sqrt(r)}},{key:"pointToLinePerpendicular",value:function(t,e,n){var r=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/r;return Math.abs(i)*Math.sqrt(r)}},{key:"pointToSegmentString",value:function(t,n){if(0===n.length)throw new x("Line array must contain at least one vertex");for(var r=t.distance(n[0]),i=0;i<n.length-1;i++){var o=e.pointToSegment(t,n[i],n[i+1]);o<r&&(r=o)}return r}}]),e}(),bt=function(){function e(){t(this,e)}return n(e,[{key:"create",value:function(){if(1===arguments.length)arguments[0]instanceof Array||ot(arguments[0],ct);else if(2===arguments.length);else if(3===arguments.length){var t=arguments[0],e=arguments[1];return this.create(t,e)}}}]),e}(),wt=function(){function e(){t(this,e)}return n(e,[{key:"filter",value:function(t){}}]),e}(),It=function(){function e(){t(this,e)}return n(e,null,[{key:"ofLine",value:function(t){var e=t.size();if(e<=1)return 0;var n=0,r=new z;t.getCoordinate(0,r);for(var i=r.x,o=r.y,s=1;s<e;s++){t.getCoordinate(s,r);var a=r.x,u=r.y,l=a-i,h=u-o;n+=Math.sqrt(l*l+h*h),i=a,o=u}return n}}]),e}(),Nt=function e(){t(this,e)},St=function(){function e(){t(this,e)}return n(e,null,[{key:"copyCoord",value:function(t,e,n,r){for(var i=Math.min(t.getDimension(),n.getDimension()),o=0;o<i;o++)n.setOrdinate(r,o,t.getOrdinate(e,o))}},{key:"isRing",value:function(t){var e=t.size();return 0===e||!(e<=3)&&t.getOrdinate(0,ct.X)===t.getOrdinate(e-1,ct.X)&&t.getOrdinate(0,ct.Y)===t.getOrdinate(e-1,ct.Y)}},{key:"scroll",value:function(){if(2===arguments.length){if(ot(arguments[0],ct)&&Number.isInteger(arguments[1])){var t=arguments[0],n=arguments[1];e.scroll(t,n,e.isRing(t))}else if(ot(arguments[0],ct)&&arguments[1]instanceof z){var r=arguments[0],i=arguments[1],o=e.indexOf(i,r);if(o<=0)return null;e.scroll(r,o)}}else if(3===arguments.length){var s=arguments[0],a=arguments[1],u=arguments[2];if(a<=0)return null;for(var l=s.copy(),h=u?s.size()-1:s.size(),c=0;c<h;c++)for(var f=0;f<s.getDimension();f++)s.setOrdinate(c,f,l.getOrdinate((a+c)%h,f));if(u)for(var g=0;g<s.getDimension();g++)s.setOrdinate(h,g,s.getOrdinate(0,g))}}},{key:"isEqual",value:function(t,e){var n=t.size();if(n!==e.size())return!1;for(var r=Math.min(t.getDimension(),e.getDimension()),i=0;i<n;i++)for(var o=0;o<r;o++){var s=t.getOrdinate(i,o),a=e.getOrdinate(i,o);if(!(t.getOrdinate(i,o)===e.getOrdinate(i,o)||A.isNaN(s)&&A.isNaN(a)))return!1}return!0}},{key:"minCoordinateIndex",value:function(){if(1===arguments.length){var t=arguments[0];return e.minCoordinateIndex(t,0,t.size()-1)}if(3===arguments.length){for(var n=arguments[0],r=arguments[2],i=-1,o=null,s=arguments[1];s<=r;s++){var a=n.getCoordinate(s);(null===o||o.compareTo(a)>0)&&(o=a,i=s)}return i}}},{key:"extend",value:function(t,n,r){var i=t.create(r,n.getDimension()),o=n.size();if(e.copy(n,0,i,0,o),o>0)for(var s=o;s<r;s++)e.copy(n,o-1,i,s,1);return i}},{key:"reverse",value:function(t){for(var n=t.size()-1,r=Math.trunc(n/2),i=0;i<=r;i++)e.swap(t,i,n-i)}},{key:"swap",value:function(t,e,n){if(e===n)return null;for(var r=0;r<t.getDimension();r++){var i=t.getOrdinate(e,r);t.setOrdinate(e,r,t.getOrdinate(n,r)),t.setOrdinate(n,r,i)}}},{key:"copy",value:function(t,n,r,i,o){for(var s=0;s<o;s++)e.copyCoord(t,n+s,r,i+s)}},{key:"ensureValidRing",value:function(t,n){var r=n.size();return 0===r?n:r<=3?e.createClosedRing(t,n,4):n.getOrdinate(0,ct.X)===n.getOrdinate(r-1,ct.X)&&n.getOrdinate(0,ct.Y)===n.getOrdinate(r-1,ct.Y)?n:e.createClosedRing(t,n,r+1)}},{key:"indexOf",value:function(t,e){for(var n=0;n<e.size();n++)if(t.x===e.getOrdinate(n,ct.X)&&t.y===e.getOrdinate(n,ct.Y))return n;return-1}},{key:"createClosedRing",value:function(t,n,r){var i=t.create(r,n.getDimension()),o=n.size();e.copy(n,0,i,0,o);for(var s=o;s<r;s++)e.copy(n,0,i,s,1);return i}},{key:"minCoordinate",value:function(t){for(var e=null,n=0;n<t.size();n++){var r=t.getCoordinate(n);(null===e||e.compareTo(r)>0)&&(e=r)}return e}}]),e}(),Mt=function(){function e(){t(this,e)}return n(e,null,[{key:"toDimensionSymbol",value:function(t){switch(t){case e.FALSE:return e.SYM_FALSE;case e.TRUE:return e.SYM_TRUE;case e.DONTCARE:return e.SYM_DONTCARE;case e.P:return e.SYM_P;case e.L:return e.SYM_L;case e.A:return e.SYM_A}throw new x("Unknown dimension value: "+t)}},{key:"toDimensionValue",value:function(t){switch(ut.toUpperCase(t)){case e.SYM_FALSE:return e.FALSE;case e.SYM_TRUE:return e.TRUE;case e.SYM_DONTCARE:return e.DONTCARE;case e.SYM_P:return e.P;case e.SYM_L:return e.L;case e.SYM_A:return e.A}throw new x("Unknown dimension symbol: "+t)}}]),e}();Mt.P=0,Mt.L=1,Mt.A=2,Mt.FALSE=-1,Mt.TRUE=-2,Mt.DONTCARE=-3,Mt.SYM_FALSE="F",Mt.SYM_TRUE="T",Mt.SYM_DONTCARE="*",Mt.SYM_P="0",Mt.SYM_L="1",Mt.SYM_A="2";var Lt=function(){function e(){t(this,e)}return n(e,[{key:"filter",value:function(t){}}]),e}(),Pt=function(){function e(){t(this,e)}return n(e,[{key:"filter",value:function(t,e){}},{key:"isDone",value:function(){}},{key:"isGeometryChanged",value:function(){}}]),e}(),Ct=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"computeEnvelopeInternal",value:function(){return this.isEmpty()?new X:this._points.expandEnvelope(new X)}},{key:"isRing",value:function(){return this.isClosed()&&this.isSimple()}},{key:"getCoordinates",value:function(){return this._points.toCoordinateArray()}},{key:"copyInternal",value:function(){return new s(this._points.copy(),this._factory)}},{key:"equalsExact",value:function(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t;if(this._points.size()!==n._points.size())return!1;for(var r=0;r<this._points.size();r++)if(!this.equal(this._points.getCoordinate(r),n._points.getCoordinate(r),e))return!1;return!0}return f(i(s.prototype),"equalsExact",this).apply(this,arguments)}},{key:"normalize",value:function(){for(var t=0;t<Math.trunc(this._points.size()/2);t++){var e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0){var n=this._points.copy();St.reverse(n),this._points=n}return null}}}},{key:"getCoordinate",value:function(){return this.isEmpty()?null:this._points.getCoordinate(0)}},{key:"getBoundaryDimension",value:function(){return this.isClosed()?Mt.FALSE:0}},{key:"isClosed",value:function(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}},{key:"reverseInternal",value:function(){var t=this._points.copy();return St.reverse(t),this.getFactory().createLineString(t)}},{key:"getEndPoint",value:function(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}},{key:"getTypeCode",value:function(){return U.TYPECODE_LINESTRING}},{key:"getDimension",value:function(){return 1}},{key:"getLength",value:function(){return It.ofLine(this._points)}},{key:"getNumPoints",value:function(){return this._points.size()}},{key:"compareToSameClass",value:function(){if(1===arguments.length){for(var t=arguments[0],e=0,n=0;e<this._points.size()&&n<t._points.size();){var r=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==r)return r;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){var i=arguments[0];return arguments[1].compare(this._points,i._points)}}},{key:"apply",value:function(){if(ot(arguments[0],wt))for(var t=arguments[0],e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e));else if(ot(arguments[0],Pt)){var n=arguments[0];if(0===this._points.size())return null;for(var r=0;r<this._points.size()&&(n.filter(this._points,r),!n.isDone());r++);n.isGeometryChanged()&&this.geometryChanged()}else(ot(arguments[0],Lt)||ot(arguments[0],E))&&arguments[0].filter(this)}},{key:"getBoundary",value:function(){throw new J}},{key:"isEquivalentClass",value:function(t){return t instanceof s}},{key:"getCoordinateN",value:function(t){return this._points.getCoordinate(t)}},{key:"getGeometryType",value:function(){return U.TYPENAME_LINESTRING}},{key:"getCoordinateSequence",value:function(){return this._points}},{key:"isEmpty",value:function(){return 0===this._points.size()}},{key:"init",value:function(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new x("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}},{key:"isCoordinate",value:function(t){for(var e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1}},{key:"getStartPoint",value:function(){return this.isEmpty()?null:this.getPointN(0)}},{key:"getPointN",value:function(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}},{key:"interfaces_",get:function(){return[Nt]}}],[{key:"constructor_",value:function(){if(this._points=null,0===arguments.length);else if(2===arguments.length){var t=arguments[0],e=arguments[1];U.constructor_.call(this,e),this.init(t)}}}]),s}(U),Tt=function e(){t(this,e)},Ot=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"computeEnvelopeInternal",value:function(){if(this.isEmpty())return new X;var t=new X;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}},{key:"getCoordinates",value:function(){return this.isEmpty()?[]:[this.getCoordinate()]}},{key:"copyInternal",value:function(){return new s(this._coordinates.copy(),this._factory)}},{key:"equalsExact",value:function(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){var t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return f(i(s.prototype),"equalsExact",this).apply(this,arguments)}},{key:"normalize",value:function(){}},{key:"getCoordinate",value:function(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}},{key:"getBoundaryDimension",value:function(){return Mt.FALSE}},{key:"reverseInternal",value:function(){return this.getFactory().createPoint(this._coordinates.copy())}},{key:"getTypeCode",value:function(){return U.TYPECODE_POINT}},{key:"getDimension",value:function(){return 0}},{key:"getNumPoints",value:function(){return this.isEmpty()?0:1}},{key:"getX",value:function(){if(null===this.getCoordinate())throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x}},{key:"compareToSameClass",value:function(){if(1===arguments.length){var t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){var e=arguments[0];return arguments[1].compare(this._coordinates,e._coordinates)}}},{key:"apply",value:function(){if(ot(arguments[0],wt)){var t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(ot(arguments[0],Pt)){var e=arguments[0];if(this.isEmpty())return null;e.filter(this._coordinates,0),e.isGeometryChanged()&&this.geometryChanged()}else(ot(arguments[0],Lt)||ot(arguments[0],E))&&arguments[0].filter(this)}},{key:"getBoundary",value:function(){return this.getFactory().createGeometryCollection()}},{key:"getGeometryType",value:function(){return U.TYPENAME_POINT}},{key:"getCoordinateSequence",value:function(){return this._coordinates}},{key:"getY",value:function(){if(null===this.getCoordinate())throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y}},{key:"isEmpty",value:function(){return 0===this._coordinates.size()}},{key:"init",value:function(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),V.isTrue(t.size()<=1),this._coordinates=t}},{key:"isSimple",value:function(){return!0}},{key:"interfaces_",get:function(){return[Tt]}}],[{key:"constructor_",value:function(){this._coordinates=null;var t=arguments[0],e=arguments[1];U.constructor_.call(this,e),this.init(t)}}]),s}(U),Rt=function(){function e(){t(this,e)}return n(e,null,[{key:"ofRing",value:function(){if(arguments[0]instanceof Array){var t=arguments[0];return Math.abs(e.ofRingSigned(t))}if(ot(arguments[0],ct)){var n=arguments[0];return Math.abs(e.ofRingSigned(n))}}},{key:"ofRingSigned",value:function(){if(arguments[0]instanceof Array){var t=arguments[0];if(t.length<3)return 0;for(var e=0,n=t[0].x,r=1;r<t.length-1;r++){var i=t[r].x-n,o=t[r+1].y;e+=i*(t[r-1].y-o)}return e/2}if(ot(arguments[0],ct)){var s=arguments[0],a=s.size();if(a<3)return 0;var u=new z,l=new z,h=new z;s.getCoordinate(0,l),s.getCoordinate(1,h);var c=l.x;h.x-=c;for(var f=0,g=1;g<a-1;g++)u.y=l.y,l.x=h.x,l.y=h.y,s.getCoordinate(g+1,h),h.x-=c,f+=l.x*(u.y-h.y);return f/2}}}]),e}(),At=function(){function e(){t(this,e)}return n(e,null,[{key:"sort",value:function(){var t=arguments,e=arguments[0];if(1===arguments.length)e.sort((function(t,e){return t.compareTo(e)}));else if(2===arguments.length)e.sort((function(e,n){return t[1].compare(e,n)}));else if(3===arguments.length){var n=e.slice(arguments[1],arguments[2]);n.sort();var r=e.slice(0,arguments[1]).concat(n,e.slice(arguments[2],e.length));e.splice(0,e.length);var i,o=d(r);try{for(o.s();!(i=o.n()).done;){var s=i.value;e.push(s)}}catch(t){o.e(t)}finally{o.f()}}else if(4===arguments.length){var a=e.slice(arguments[1],arguments[2]);a.sort((function(e,n){return t[3].compare(e,n)}));var u=e.slice(0,arguments[1]).concat(a,e.slice(arguments[2],e.length));e.splice(0,e.length);var l,h=d(u);try{for(h.s();!(l=h.n()).done;){var c=l.value;e.push(c)}}catch(t){h.e(t)}finally{h.f()}}}},{key:"asList",value:function(t){var e,n=new dt,r=d(t);try{for(r.s();!(e=r.n()).done;){var i=e.value;n.add(i)}}catch(t){r.e(t)}finally{r.f()}return n}},{key:"copyOf",value:function(t,e){return t.slice(0,e)}}]),e}(),Dt=function e(){t(this,e)},Ft=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"computeEnvelopeInternal",value:function(){return this._shell.getEnvelopeInternal()}},{key:"getCoordinates",value:function(){if(this.isEmpty())return[];for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=this._shell.getCoordinates(),r=0;r<n.length;r++)t[++e]=n[r];for(var i=0;i<this._holes.length;i++)for(var o=this._holes[i].getCoordinates(),s=0;s<o.length;s++)t[++e]=o[s];return t}},{key:"getArea",value:function(){var t=0;t+=Rt.ofRing(this._shell.getCoordinateSequence());for(var e=0;e<this._holes.length;e++)t-=Rt.ofRing(this._holes[e].getCoordinateSequence());return t}},{key:"copyInternal",value:function(){for(var t=this._shell.copy(),e=new Array(this._holes.length).fill(null),n=0;n<this._holes.length;n++)e[n]=this._holes[n].copy();return new s(t,e,this._factory)}},{key:"isRectangle",value:function(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;for(var t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal(),n=0;n<5;n++){var r=t.getX(n);if(r!==e.getMinX()&&r!==e.getMaxX())return!1;var i=t.getY(n);if(i!==e.getMinY()&&i!==e.getMaxY())return!1}for(var o=t.getX(0),s=t.getY(0),a=1;a<=4;a++){var u=t.getX(a),l=t.getY(a);if(u!==o==(l!==s))return!1;o=u,s=l}return!0}},{key:"equalsExact",value:function(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t,r=this._shell,o=n._shell;if(!r.equalsExact(o,e))return!1;if(this._holes.length!==n._holes.length)return!1;for(var a=0;a<this._holes.length;a++)if(!this._holes[a].equalsExact(n._holes[a],e))return!1;return!0}return f(i(s.prototype),"equalsExact",this).apply(this,arguments)}},{key:"normalize",value:function(){if(0===arguments.length){this._shell=this.normalized(this._shell,!0);for(var t=0;t<this._holes.length;t++)this._holes[t]=this.normalized(this._holes[t],!1);At.sort(this._holes)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(e.isEmpty())return null;var r=e.getCoordinateSequence(),i=St.minCoordinateIndex(r,0,r.size()-2);St.scroll(r,i,!0),ft.isCCW(r)===n&&St.reverse(r)}}},{key:"getCoordinate",value:function(){return this._shell.getCoordinate()}},{key:"getNumInteriorRing",value:function(){return this._holes.length}},{key:"getBoundaryDimension",value:function(){return 1}},{key:"reverseInternal",value:function(){for(var t=this.getExteriorRing().reverse(),e=new Array(this.getNumInteriorRing()).fill(null),n=0;n<e.length;n++)e[n]=this.getInteriorRingN(n).reverse();return this.getFactory().createPolygon(t,e)}},{key:"getTypeCode",value:function(){return U.TYPECODE_POLYGON}},{key:"getDimension",value:function(){return 2}},{key:"getLength",value:function(){var t=0;t+=this._shell.getLength();for(var e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t}},{key:"getNumPoints",value:function(){for(var t=this._shell.getNumPoints(),e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t}},{key:"convexHull",value:function(){return this.getExteriorRing().convexHull()}},{key:"normalized",value:function(t,e){var n=t.copy();return this.normalize(n,e),n}},{key:"compareToSameClass",value:function(){if(1===arguments.length){var t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){var r=arguments[1],i=arguments[0],o=this._shell,s=i._shell,a=o.compareToSameClass(s,r);if(0!==a)return a;for(var u=this.getNumInteriorRing(),l=i.getNumInteriorRing(),h=0;h<u&&h<l;){var c=this.getInteriorRingN(h),f=i.getInteriorRingN(h),g=c.compareToSameClass(f,r);if(0!==g)return g;h++}return h<u?1:h<l?-1:0}}},{key:"apply",value:function(){if(ot(arguments[0],wt)){var t=arguments[0];this._shell.apply(t);for(var e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(ot(arguments[0],Pt)){var n=arguments[0];if(this._shell.apply(n),!n.isDone())for(var r=0;r<this._holes.length&&(this._holes[r].apply(n),!n.isDone());r++);n.isGeometryChanged()&&this.geometryChanged()}else if(ot(arguments[0],Lt))arguments[0].filter(this);else if(ot(arguments[0],E)){var i=arguments[0];i.filter(this),this._shell.apply(i);for(var o=0;o<this._holes.length;o++)this._holes[o].apply(i)}}},{key:"getBoundary",value:function(){if(this.isEmpty())return this.getFactory().createMultiLineString();var t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(var e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}},{key:"getGeometryType",value:function(){return U.TYPENAME_POLYGON}},{key:"getExteriorRing",value:function(){return this._shell}},{key:"isEmpty",value:function(){return this._shell.isEmpty()}},{key:"getInteriorRingN",value:function(t){return this._holes[t]}},{key:"interfaces_",get:function(){return[Dt]}}],[{key:"constructor_",value:function(){this._shell=null,this._holes=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(U.constructor_.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),U.hasNullElements(e))throw new x("holes must not contain null elements");if(t.isEmpty()&&U.hasNonEmptyElements(e))throw new x("shell is empty but holes are not");this._shell=t,this._holes=e}}]),s}(U),qt=function(e){r(i,e);var n=c(i);function i(){return t(this,i),n.apply(this,arguments)}return i}(K),Vt=function(e){r(o,e);var i=c(o);function o(e){var n;return t(this,o),(n=i.call(this)).array=[],e instanceof H&&n.addAll(e),n}return n(o,[{key:"contains",value:function(t){var e,n=d(this.array);try{for(n.s();!(e=n.n()).done;)if(0===e.value.compareTo(t))return!0}catch(t){n.e(t)}finally{n.f()}return!1}},{key:"add",value:function(t){if(this.contains(t))return!1;for(var e=0,n=this.array.length;e<n;e++)if(1===this.array[e].compareTo(t))return!!this.array.splice(e,0,t);return this.array.push(t),!0}},{key:"addAll",value:function(t){var e,n=d(t);try{for(n.s();!(e=n.n()).done;){var r=e.value;this.add(r)}}catch(t){n.e(t)}finally{n.f()}return!0}},{key:"remove",value:function(){throw new J}},{key:"size",value:function(){return this.array.length}},{key:"isEmpty",value:function(){return 0===this.array.length}},{key:"toArray",value:function(){return this.array.slice()}},{key:"iterator",value:function(){return new Gt(this.array)}}]),o}(qt),Gt=function(){function e(n){t(this,e),this.array=n,this.position=0}return n(e,[{key:"next",value:function(){if(this.position===this.array.length)throw new W;return this.array[this.position++]}},{key:"hasNext",value:function(){return this.position<this.array.length}},{key:"remove",value:function(){throw new J}}]),e}(),Bt=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"computeEnvelopeInternal",value:function(){for(var t=new X,e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t}},{key:"getGeometryN",value:function(t){return this._geometries[t]}},{key:"getCoordinates",value:function(){for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=0;n<this._geometries.length;n++)for(var r=this._geometries[n].getCoordinates(),i=0;i<r.length;i++)t[++e]=r[i];return t}},{key:"getArea",value:function(){for(var t=0,e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t}},{key:"copyInternal",value:function(){for(var t=new Array(this._geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new s(t,this._factory)}},{key:"equalsExact",value:function(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t;if(this._geometries.length!==n._geometries.length)return!1;for(var r=0;r<this._geometries.length;r++)if(!this._geometries[r].equalsExact(n._geometries[r],e))return!1;return!0}return f(i(s.prototype),"equalsExact",this).apply(this,arguments)}},{key:"normalize",value:function(){for(var t=0;t<this._geometries.length;t++)this._geometries[t].normalize();At.sort(this._geometries)}},{key:"getCoordinate",value:function(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}},{key:"getBoundaryDimension",value:function(){for(var t=Mt.FALSE,e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t}},{key:"reverseInternal",value:function(){for(var t=this._geometries.length,e=new dt(t),n=0;n<t;n++)e.add(this._geometries[n].reverse());return this.getFactory().buildGeometry(e)}},{key:"getTypeCode",value:function(){return U.TYPECODE_GEOMETRYCOLLECTION}},{key:"getDimension",value:function(){for(var t=Mt.FALSE,e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t}},{key:"getLength",value:function(){for(var t=0,e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t}},{key:"getNumPoints",value:function(){for(var t=0,e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t}},{key:"getNumGeometries",value:function(){return this._geometries.length}},{key:"compareToSameClass",value:function(){if(1===arguments.length){var t=arguments[0],e=new Vt(At.asList(this._geometries)),n=new Vt(At.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){for(var r=arguments[1],i=arguments[0],o=this.getNumGeometries(),s=i.getNumGeometries(),a=0;a<o&&a<s;){var u=this.getGeometryN(a),l=i.getGeometryN(a),h=u.compareToSameClass(l,r);if(0!==h)return h;a++}return a<o?1:a<s?-1:0}}},{key:"apply",value:function(){if(ot(arguments[0],wt))for(var t=arguments[0],e=0;e<this._geometries.length;e++)this._geometries[e].apply(t);else if(ot(arguments[0],Pt)){var n=arguments[0];if(0===this._geometries.length)return null;for(var r=0;r<this._geometries.length&&(this._geometries[r].apply(n),!n.isDone());r++);n.isGeometryChanged()&&this.geometryChanged()}else if(ot(arguments[0],Lt)){var i=arguments[0];i.filter(this);for(var o=0;o<this._geometries.length;o++)this._geometries[o].apply(i)}else if(ot(arguments[0],E)){var s=arguments[0];s.filter(this);for(var a=0;a<this._geometries.length;a++)this._geometries[a].apply(s)}}},{key:"getBoundary",value:function(){return U.checkNotGeometryCollection(this),V.shouldNeverReachHere(),null}},{key:"getGeometryType",value:function(){return U.TYPENAME_GEOMETRYCOLLECTION}},{key:"isEmpty",value:function(){for(var t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}}],[{key:"constructor_",value:function(){if(this._geometries=null,0===arguments.length);else if(2===arguments.length){var t=arguments[0],e=arguments[1];if(U.constructor_.call(this,e),null===t&&(t=[]),U.hasNullElements(t))throw new x("geometries must not contain null elements");this._geometries=t}}}]),s}(U),Yt=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"copyInternal",value:function(){for(var t=new Array(this._geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new s(t,this._factory)}},{key:"isValid",value:function(){return!0}},{key:"equalsExact",value:function(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){var t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&f(i(s.prototype),"equalsExact",this).call(this,t,e)}return f(i(s.prototype),"equalsExact",this).apply(this,arguments)}},{key:"getCoordinate",value:function(){if(1===arguments.length&&Number.isInteger(arguments[0])){var t=arguments[0];return this._geometries[t].getCoordinate()}return f(i(s.prototype),"getCoordinate",this).apply(this,arguments)}},{key:"getBoundaryDimension",value:function(){return Mt.FALSE}},{key:"getTypeCode",value:function(){return U.TYPECODE_MULTIPOINT}},{key:"getDimension",value:function(){return 0}},{key:"getBoundary",value:function(){return this.getFactory().createGeometryCollection()}},{key:"getGeometryType",value:function(){return U.TYPENAME_MULTIPOINT}},{key:"interfaces_",get:function(){return[Tt]}}],[{key:"constructor_",value:function(){var t=arguments[0],e=arguments[1];Bt.constructor_.call(this,t,e)}}]),s}(Bt),zt=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"copyInternal",value:function(){return new s(this._points.copy(),this._factory)}},{key:"getBoundaryDimension",value:function(){return Mt.FALSE}},{key:"isClosed",value:function(){return!!this.isEmpty()||f(i(s.prototype),"isClosed",this).call(this)}},{key:"reverseInternal",value:function(){var t=this._points.copy();return St.reverse(t),this.getFactory().createLinearRing(t)}},{key:"getTypeCode",value:function(){return U.TYPECODE_LINEARRING}},{key:"validateConstruction",value:function(){if(!this.isEmpty()&&!f(i(s.prototype),"isClosed",this).call(this))throw new x("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<s.MINIMUM_VALID_SIZE)throw new x("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}},{key:"getGeometryType",value:function(){return U.TYPENAME_LINEARRING}}],[{key:"constructor_",value:function(){var t=arguments[0],e=arguments[1];Ct.constructor_.call(this,t,e),this.validateConstruction()}}]),s}(Ct);zt.MINIMUM_VALID_SIZE=4;var jt=function(e){r(o,e);var i=c(o);function o(){var e;return t(this,o),e=i.call(this),o.constructor_.apply(l(e),arguments),e}return n(o,[{key:"setOrdinate",value:function(t,e){switch(t){case o.X:this.x=e;break;case o.Y:this.y=e;break;default:throw new x("Invalid ordinate index: "+t)}}},{key:"getZ",value:function(){return z.NULL_ORDINATE}},{key:"getOrdinate",value:function(t){switch(t){case o.X:return this.x;case o.Y:return this.y}throw new x("Invalid ordinate index: "+t)}},{key:"setZ",value:function(t){throw new x("CoordinateXY dimension 2 does not support z-ordinate")}},{key:"copy",value:function(){return new o(this)}},{key:"toString",value:function(){return"("+this.x+", "+this.y+")"}},{key:"setCoordinate",value:function(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}}],[{key:"constructor_",value:function(){if(0===arguments.length)z.constructor_.call(this);else if(1===arguments.length){if(arguments[0]instanceof o){var t=arguments[0];z.constructor_.call(this,t.x,t.y)}else if(arguments[0]instanceof z){var e=arguments[0];z.constructor_.call(this,e.x,e.y)}}else if(2===arguments.length){var n=arguments[0],r=arguments[1];z.constructor_.call(this,n,r,z.NULL_ORDINATE)}}}]),o}(z);jt.X=0,jt.Y=1,jt.Z=-1,jt.M=-1;var Xt=function(e){r(o,e);var i=c(o);function o(){var e;return t(this,o),e=i.call(this),o.constructor_.apply(l(e),arguments),e}return n(o,[{key:"getM",value:function(){return this._m}},{key:"setOrdinate",value:function(t,e){switch(t){case o.X:this.x=e;break;case o.Y:this.y=e;break;case o.M:this._m=e;break;default:throw new x("Invalid ordinate index: "+t)}}},{key:"setM",value:function(t){this._m=t}},{key:"getZ",value:function(){return z.NULL_ORDINATE}},{key:"getOrdinate",value:function(t){switch(t){case o.X:return this.x;case o.Y:return this.y;case o.M:return this._m}throw new x("Invalid ordinate index: "+t)}},{key:"setZ",value:function(t){throw new x("CoordinateXY dimension 2 does not support z-ordinate")}},{key:"copy",value:function(){return new o(this)}},{key:"toString",value:function(){return"("+this.x+", "+this.y+" m="+this.getM()+")"}},{key:"setCoordinate",value:function(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}}],[{key:"constructor_",value:function(){if(this._m=null,0===arguments.length)z.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof o){var t=arguments[0];z.constructor_.call(this,t.x,t.y),this._m=t._m}else if(arguments[0]instanceof z){var e=arguments[0];z.constructor_.call(this,e.x,e.y),this._m=this.getM()}}else if(3===arguments.length){var n=arguments[0],r=arguments[1],i=arguments[2];z.constructor_.call(this,n,r,z.NULL_ORDINATE),this._m=i}}}]),o}(z);Xt.X=0,Xt.Y=1,Xt.Z=-1,Xt.M=2;var Ut=function(e){r(o,e);var i=c(o);function o(){var e;return t(this,o),e=i.call(this),o.constructor_.apply(l(e),arguments),e}return n(o,[{key:"getM",value:function(){return this._m}},{key:"setOrdinate",value:function(t,e){switch(t){case z.X:this.x=e;break;case z.Y:this.y=e;break;case z.Z:this.z=e;break;case z.M:this._m=e;break;default:throw new x("Invalid ordinate index: "+t)}}},{key:"setM",value:function(t){this._m=t}},{key:"getOrdinate",value:function(t){switch(t){case z.X:return this.x;case z.Y:return this.y;case z.Z:return this.getZ();case z.M:return this.getM()}throw new x("Invalid ordinate index: "+t)}},{key:"copy",value:function(){return new o(this)}},{key:"toString",value:function(){return"("+this.x+", "+this.y+", "+this.getZ()+" m="+this.getM()+")"}},{key:"setCoordinate",value:function(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}}],[{key:"constructor_",value:function(){if(this._m=null,0===arguments.length)z.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof o){var t=arguments[0];z.constructor_.call(this,t),this._m=t._m}else if(arguments[0]instanceof z){var e=arguments[0];z.constructor_.call(this,e),this._m=this.getM()}}else if(4===arguments.length){var n=arguments[0],r=arguments[1],i=arguments[2],s=arguments[3];z.constructor_.call(this,n,r,i),this._m=s}}}]),o}(z),Zt=function(){function e(){t(this,e)}return n(e,null,[{key:"measures",value:function(t){return t instanceof jt?0:t instanceof Xt||t instanceof Ut?1:0}},{key:"dimension",value:function(t){return t instanceof jt?2:t instanceof Xt?3:t instanceof Ut?4:3}},{key:"create",value:function(){if(1===arguments.length){var t=arguments[0];return e.create(t,0)}if(2===arguments.length){var n=arguments[0],r=arguments[1];return 2===n?new jt:3===n&&0===r?new z:3===n&&1===r?new Xt:4===n&&1===r?new Ut:new z}}}]),e}(),Ht=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"getCoordinate",value:function(t){return this.get(t)}},{key:"addAll",value:function(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&ot(arguments[0],H)){for(var t=arguments[1],e=!1,n=arguments[0].iterator();n.hasNext();)this.add(n.next(),t),e=!0;return e}return f(i(s.prototype),"addAll",this).apply(this,arguments)}},{key:"clone",value:function(){for(var t=f(i(s.prototype),"clone",this).call(this),e=0;e<this.size();e++)t.add(e,this.get(e).clone());return t}},{key:"toCoordinateArray",value:function(){if(0===arguments.length)return this.toArray(s.coordArrayType);if(1===arguments.length){if(arguments[0])return this.toArray(s.coordArrayType);for(var t=this.size(),e=new Array(t).fill(null),n=0;n<t;n++)e[n]=this.get(t-n-1);return e}}},{key:"add",value:function(){if(1===arguments.length){var t=arguments[0];return f(i(s.prototype),"add",this).call(this,t)}if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var e=arguments[0],n=arguments[1];return this.add(e,n,!0),!0}if(arguments[0]instanceof z&&"boolean"==typeof arguments[1]){var r=arguments[0];if(!arguments[1]&&this.size()>=1&&this.get(this.size()-1).equals2D(r))return null;f(i(s.prototype),"add",this).call(this,r)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){var o=arguments[0],a=arguments[1];return this.add(o,a),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var u=arguments[0],l=arguments[1];if(arguments[2])for(var h=0;h<u.length;h++)this.add(u[h],l);else for(var c=u.length-1;c>=0;c--)this.add(u[c],l);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof z){var g=arguments[0],p=arguments[1];if(!arguments[2]){var v=this.size();if(v>0){if(g>0&&this.get(g-1).equals2D(p))return null;if(g<v&&this.get(g).equals2D(p))return null}}f(i(s.prototype),"add",this).call(this,g,p)}}else if(4===arguments.length){var d=arguments[0],y=arguments[1],m=arguments[2],_=arguments[3],x=1;m>_&&(x=-1);for(var E=m;E!==_;E+=x)this.add(d[E],y);return!0}}},{key:"closeRing",value:function(){if(this.size()>0){var t=this.get(0).copy();this.add(t,!1)}}}],[{key:"constructor_",value:function(){if(0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.ensureCapacity(e.length),this.add(e,n)}}}]),s}(dt);Ht.coordArrayType=new Array(0).fill(null);var Wt=function(){function e(){t(this,e)}return n(e,null,[{key:"isRing",value:function(t){return!(t.length<4||!t[0].equals2D(t[t.length-1]))}},{key:"ptNotInList",value:function(t,n){for(var r=0;r<t.length;r++){var i=t[r];if(e.indexOf(i,n)<0)return i}return null}},{key:"scroll",value:function(t,n){var r=e.indexOf(n,t);if(r<0)return null;var i=new Array(t.length).fill(null);xt.arraycopy(t,r,i,0,t.length-r),xt.arraycopy(t,0,i,t.length-r,r),xt.arraycopy(i,0,t,0,t.length)}},{key:"equals",value:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){var r=arguments[0],i=arguments[1],o=arguments[2];if(r===i)return!0;if(null===r||null===i)return!1;if(r.length!==i.length)return!1;for(var s=0;s<r.length;s++)if(0!==o.compare(r[s],i[s]))return!1;return!0}}},{key:"intersection",value:function(t,e){for(var n=new Ht,r=0;r<t.length;r++)e.intersects(t[r])&&n.add(t[r],!0);return n.toCoordinateArray()}},{key:"measures",value:function(t){if(null===t||0===t.length)return 0;var e,n=0,r=d(t);try{for(r.s();!(e=r.n()).done;){var i=e.value;n=Math.max(n,Zt.measures(i))}}catch(t){r.e(t)}finally{r.f()}return n}},{key:"hasRepeatedPoints",value:function(t){for(var e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1}},{key:"removeRepeatedPoints",value:function(t){return e.hasRepeatedPoints(t)?new Ht(t,!1).toCoordinateArray():t}},{key:"reverse",value:function(t){for(var e=t.length-1,n=Math.trunc(e/2),r=0;r<=n;r++){var i=t[r];t[r]=t[e-r],t[e-r]=i}}},{key:"removeNull",value:function(t){for(var e=0,n=0;n<t.length;n++)null!==t[n]&&e++;var r=new Array(e).fill(null);if(0===e)return r;for(var i=0,o=0;o<t.length;o++)null!==t[o]&&(r[i++]=t[o]);return r}},{key:"copyDeep",value:function(){if(1===arguments.length){for(var t=arguments[0],e=new Array(t.length).fill(null),n=0;n<t.length;n++)e[n]=t[n].copy();return e}if(5===arguments.length)for(var r=arguments[0],i=arguments[1],o=arguments[2],s=arguments[3],a=arguments[4],u=0;u<a;u++)o[s+u]=r[i+u].copy()}},{key:"isEqualReversed",value:function(t,e){for(var n=0;n<t.length;n++){var r=t[n],i=e[t.length-n-1];if(0!==r.compareTo(i))return!1}return!0}},{key:"envelope",value:function(t){for(var e=new X,n=0;n<t.length;n++)e.expandToInclude(t[n]);return e}},{key:"toCoordinateArray",value:function(t){return t.toArray(e.coordArrayType)}},{key:"dimension",value:function(t){if(null===t||0===t.length)return 3;var e,n=0,r=d(t);try{for(r.s();!(e=r.n()).done;){var i=e.value;n=Math.max(n,Zt.dimension(i))}}catch(t){r.e(t)}finally{r.f()}return n}},{key:"atLeastNCoordinatesOrNothing",value:function(t,e){return e.length>=t?e:[]}},{key:"indexOf",value:function(t,e){for(var n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1}},{key:"increasingDirection",value:function(t){for(var e=0;e<Math.trunc(t.length/2);e++){var n=t.length-1-e,r=t[e].compareTo(t[n]);if(0!==r)return r}return 1}},{key:"compare",value:function(t,e){for(var n=0;n<t.length&&n<e.length;){var r=t[n].compareTo(e[n]);if(0!==r)return r;n++}return n<e.length?-1:n<t.length?1:0}},{key:"minCoordinate",value:function(t){for(var e=null,n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e}},{key:"extract",value:function(t,e,n){e=Et.clamp(e,0,t.length);var r=(n=Et.clamp(n,-1,t.length))-e+1;n<0&&(r=0),e>=t.length&&(r=0),n<e&&(r=0);var i=new Array(r).fill(null);if(0===r)return i;for(var o=0,s=e;s<=n;s++)i[o++]=t[s];return i}}]),e}(),Jt=function(){function e(){t(this,e)}return n(e,[{key:"compare",value:function(t,e){var n=t,r=e;return Wt.compare(n,r)}},{key:"interfaces_",get:function(){return[D]}}]),e}(),Kt=function(){function e(){t(this,e)}return n(e,[{key:"compare",value:function(t,e){var n=t,r=e;if(n.length<r.length)return-1;if(n.length>r.length)return 1;if(0===n.length)return 0;var i=Wt.compare(n,r);return Wt.isEqualReversed(n,r)?0:i}},{key:"OLDcompare",value:function(t,e){var n=t,r=e;if(n.length<r.length)return-1;if(n.length>r.length)return 1;if(0===n.length)return 0;for(var i=Wt.increasingDirection(n),o=Wt.increasingDirection(r),s=i>0?0:n.length-1,a=o>0?0:n.length-1,u=0;u<n.length;u++){var l=n[s].compareTo(r[a]);if(0!==l)return l;s+=i,a+=o}return 0}},{key:"interfaces_",get:function(){return[D]}}]),e}();Wt.ForwardComparator=Jt,Wt.BidirectionalComparator=Kt,Wt.coordArrayType=new Array(0).fill(null);var Qt=function(){function e(n){t(this,e),this.str=n}return n(e,[{key:"append",value:function(t){this.str+=t}},{key:"setCharAt",value:function(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}},{key:"toString",value:function(){return this.str}}]),e}(),$t=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getM",value:function(t){return this.hasM()?this._coordinates[t].getM():A.NaN}},{key:"setOrdinate",value:function(t,e,n){switch(e){case ct.X:this._coordinates[t].x=n;break;case ct.Y:this._coordinates[t].y=n;break;default:this._coordinates[t].setOrdinate(e,n)}}},{key:"getZ",value:function(t){return this.hasZ()?this._coordinates[t].getZ():A.NaN}},{key:"size",value:function(){return this._coordinates.length}},{key:"getOrdinate",value:function(t,e){switch(e){case ct.X:return this._coordinates[t].x;case ct.Y:return this._coordinates[t].y;default:return this._coordinates[t].getOrdinate(e)}}},{key:"getCoordinate",value:function(){if(1===arguments.length){var t=arguments[0];return this._coordinates[t]}if(2===arguments.length){var e=arguments[0];arguments[1].setCoordinate(this._coordinates[e])}}},{key:"getCoordinateCopy",value:function(t){var e=this.createCoordinate();return e.setCoordinate(this._coordinates[t]),e}},{key:"createCoordinate",value:function(){return Zt.create(this.getDimension(),this.getMeasures())}},{key:"getDimension",value:function(){return this._dimension}},{key:"getX",value:function(t){return this._coordinates[t].x}},{key:"getMeasures",value:function(){return this._measures}},{key:"expandEnvelope",value:function(t){for(var e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t}},{key:"copy",value:function(){for(var t=new Array(this.size()).fill(null),n=0;n<this._coordinates.length;n++){var r=this.createCoordinate();r.setCoordinate(this._coordinates[n]),t[n]=r}return new e(t,this._dimension,this._measures)}},{key:"toString",value:function(){if(this._coordinates.length>0){var t=new Qt(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(var e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"}},{key:"getY",value:function(t){return this._coordinates[t].y}},{key:"toCoordinateArray",value:function(){return this._coordinates}},{key:"interfaces_",get:function(){return[ct,w]}}],[{key:"constructor_",value:function(){if(this._dimension=3,this._measures=0,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];e.constructor_.call(this,t,Wt.dimension(t),Wt.measures(t))}else if(Number.isInteger(arguments[0])){var n=arguments[0];this._coordinates=new Array(n).fill(null);for(var r=0;r<n;r++)this._coordinates[r]=new z}else if(ot(arguments[0],ct)){var i=arguments[0];if(null===i)return this._coordinates=new Array(0).fill(null),null;this._dimension=i.getDimension(),this._measures=i.getMeasures(),this._coordinates=new Array(i.size()).fill(null);for(var o=0;o<this._coordinates.length;o++)this._coordinates[o]=i.getCoordinateCopy(o)}}else if(2===arguments.length){if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){var s=arguments[0],a=arguments[1];e.constructor_.call(this,s,a,Wt.measures(s))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var u=arguments[0],l=arguments[1];this._coordinates=new Array(u).fill(null),this._dimension=l;for(var h=0;h<u;h++)this._coordinates[h]=Zt.create(l)}}else if(3===arguments.length)if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){var c=arguments[0],f=arguments[1],g=arguments[2];this._dimension=f,this._measures=g,this._coordinates=null===c?new Array(0).fill(null):c}else if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var p=arguments[0],v=arguments[1],d=arguments[2];this._coordinates=new Array(p).fill(null),this._dimension=v,this._measures=d;for(var y=0;y<p;y++)this._coordinates[y]=this.createCoordinate()}}}]),e}(),te=function(){function e(){t(this,e)}return n(e,[{key:"readResolve",value:function(){return e.instance()}},{key:"create",value:function(){if(1===arguments.length){if(arguments[0]instanceof Array)return new $t(arguments[0]);if(ot(arguments[0],ct))return new $t(arguments[0])}else{if(2===arguments.length){var t=arguments[1];return t>3&&(t=3),t<2&&(t=2),new $t(arguments[0],t)}if(3===arguments.length){var e=arguments[2],n=arguments[1]-e;return e>1&&(e=1),n>3&&(n=3),n<2&&(n=2),new $t(arguments[0],n+e,e)}}}},{key:"interfaces_",get:function(){return[bt,w]}}],[{key:"instance",value:function(){return e.instanceObject}}]),e}();te.instanceObject=new te;var ee=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"copyInternal",value:function(){for(var t=new Array(this._geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new s(t,this._factory)}},{key:"equalsExact",value:function(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){var t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&f(i(s.prototype),"equalsExact",this).call(this,t,e)}return f(i(s.prototype),"equalsExact",this).apply(this,arguments)}},{key:"getBoundaryDimension",value:function(){return 1}},{key:"getTypeCode",value:function(){return U.TYPECODE_MULTIPOLYGON}},{key:"getDimension",value:function(){return 2}},{key:"getBoundary",value:function(){if(this.isEmpty())return this.getFactory().createMultiLineString();for(var t=new dt,e=0;e<this._geometries.length;e++)for(var n=this._geometries[e].getBoundary(),r=0;r<n.getNumGeometries();r++)t.add(n.getGeometryN(r));var i=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(i))}},{key:"getGeometryType",value:function(){return U.TYPENAME_MULTIPOLYGON}},{key:"interfaces_",get:function(){return[Dt]}}],[{key:"constructor_",value:function(){var t=arguments[0],e=arguments[1];Bt.constructor_.call(this,t,e)}}]),s}(Bt),ne=function(){function e(){t(this,e)}return n(e,[{key:"get",value:function(){}},{key:"put",value:function(){}},{key:"size",value:function(){}},{key:"values",value:function(){}},{key:"entrySet",value:function(){}}]),e}(),re=function(e){r(o,e);var i=c(o);function o(){var e;return t(this,o),(e=i.call(this)).map=new Map,e}return n(o,[{key:"get",value:function(t){return this.map.get(t)||null}},{key:"put",value:function(t,e){return this.map.set(t,e),e}},{key:"values",value:function(){for(var t=new dt,e=this.map.values(),n=e.next();!n.done;)t.add(n.value),n=e.next();return t}},{key:"entrySet",value:function(){var t=new Q;return this.map.entries().forEach((function(e){return t.add(e)})),t}},{key:"size",value:function(){return this.map.size()}}]),o}(ne),ie=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"equals",value:function(t){if(!(t instanceof e))return!1;var n=t;return this._modelType===n._modelType&&this._scale===n._scale}},{key:"compareTo",value:function(t){var e=t,n=this.getMaximumSignificantDigits(),r=e.getMaximumSignificantDigits();return at.compare(n,r)}},{key:"getScale",value:function(){return this._scale}},{key:"isFloating",value:function(){return this._modelType===e.FLOATING||this._modelType===e.FLOATING_SINGLE}},{key:"getType",value:function(){return this._modelType}},{key:"toString",value:function(){var t="UNKNOWN";return this._modelType===e.FLOATING?t="Floating":this._modelType===e.FLOATING_SINGLE?t="Floating-Single":this._modelType===e.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}},{key:"makePrecise",value:function(){if("number"==typeof arguments[0]){var t=arguments[0];return A.isNaN(t)||this._modelType===e.FLOATING_SINGLE?t:this._modelType===e.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof z){var n=arguments[0];if(this._modelType===e.FLOATING)return null;n.x=this.makePrecise(n.x),n.y=this.makePrecise(n.y)}}},{key:"getMaximumSignificantDigits",value:function(){var t=16;return this._modelType===e.FLOATING?t=16:this._modelType===e.FLOATING_SINGLE?t=6:this._modelType===e.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}},{key:"setScale",value:function(t){this._scale=Math.abs(t)}},{key:"interfaces_",get:function(){return[w,k]}}],[{key:"constructor_",value:function(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=e.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof oe){var t=arguments[0];this._modelType=t,t===e.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){var n=arguments[0];this._modelType=e.FIXED,this.setScale(n)}else if(arguments[0]instanceof e){var r=arguments[0];this._modelType=r._modelType,this._scale=r._scale}}},{key:"mostPrecise",value:function(t,e){return t.compareTo(e)>=0?t:e}}]),e}(),oe=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"readResolve",value:function(){return e.nameToTypeMap.get(this._name)}},{key:"toString",value:function(){return this._name}},{key:"interfaces_",get:function(){return[w]}}],[{key:"constructor_",value:function(){this._name=null;var t=arguments[0];this._name=t,e.nameToTypeMap.put(t,this)}}]),e}();oe.nameToTypeMap=new re,ie.Type=oe,ie.FIXED=new oe("FIXED"),ie.FLOATING=new oe("FLOATING"),ie.FLOATING_SINGLE=new oe("FLOATING SINGLE"),ie.maximumPreciseValue=9007199254740992;var se=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"copyInternal",value:function(){for(var t=new Array(this._geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new s(t,this._factory)}},{key:"equalsExact",value:function(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){var t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&f(i(s.prototype),"equalsExact",this).call(this,t,e)}return f(i(s.prototype),"equalsExact",this).apply(this,arguments)}},{key:"getBoundaryDimension",value:function(){return this.isClosed()?Mt.FALSE:0}},{key:"isClosed",value:function(){if(this.isEmpty())return!1;for(var t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}},{key:"getTypeCode",value:function(){return U.TYPECODE_MULTILINESTRING}},{key:"getDimension",value:function(){return 1}},{key:"getBoundary",value:function(){throw new J}},{key:"getGeometryType",value:function(){return U.TYPENAME_MULTILINESTRING}},{key:"interfaces_",get:function(){return[Nt]}}],[{key:"constructor_",value:function(){var t=arguments[0],e=arguments[1];Bt.constructor_.call(this,t,e)}}]),s}(Bt),ae=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"createEmpty",value:function(t){switch(t){case-1:return this.createGeometryCollection();case 0:return this.createPoint();case 1:return this.createLineString();case 2:return this.createPolygon();default:throw new x("Invalid dimension: "+t)}}},{key:"toGeometry",value:function(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new z(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new z(t.getMinX(),t.getMinY()),new z(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new z(t.getMinX(),t.getMinY()),new z(t.getMinX(),t.getMaxY()),new z(t.getMaxX(),t.getMaxY()),new z(t.getMaxX(),t.getMinY()),new z(t.getMinX(),t.getMinY())]),null)}},{key:"createLineString",value:function(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(ot(arguments[0],ct))return new Ct(arguments[0],this)}}},{key:"createMultiLineString",value:function(){return 0===arguments.length?new se(null,this):1===arguments.length?new se(arguments[0],this):void 0}},{key:"buildGeometry",value:function(t){for(var n=null,r=!1,i=!1,o=t.iterator();o.hasNext();){var s=o.next(),a=s.getTypeCode();null===n&&(n=a),a!==n&&(r=!0),s instanceof Bt&&(i=!0)}if(null===n)return this.createGeometryCollection();if(r||i)return this.createGeometryCollection(e.toGeometryArray(t));var u=t.iterator().next();if(t.size()>1){if(u instanceof Ft)return this.createMultiPolygon(e.toPolygonArray(t));if(u instanceof Ct)return this.createMultiLineString(e.toLineStringArray(t));if(u instanceof Ot)return this.createMultiPoint(e.toPointArray(t));V.shouldNeverReachHere("Unhandled geometry type: "+u.getGeometryType())}return u}},{key:"createMultiPointFromCoords",value:function(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}},{key:"createPoint",value:function(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof z){var t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(ot(arguments[0],ct))return new Ot(arguments[0],this)}}},{key:"getCoordinateSequenceFactory",value:function(){return this._coordinateSequenceFactory}},{key:"createPolygon",value:function(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(ot(arguments[0],ct)){var t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){var e=arguments[0];return this.createPolygon(this.createLinearRing(e))}if(arguments[0]instanceof zt){var n=arguments[0];return this.createPolygon(n,null)}}else if(2===arguments.length)return new Ft(arguments[0],arguments[1],this)}},{key:"getSRID",value:function(){return this._SRID}},{key:"createGeometryCollection",value:function(){return 0===arguments.length?new Bt(null,this):1===arguments.length?new Bt(arguments[0],this):void 0}},{key:"getPrecisionModel",value:function(){return this._precisionModel}},{key:"createLinearRing",value:function(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(ot(arguments[0],ct))return new zt(arguments[0],this)}}},{key:"createMultiPolygon",value:function(){return 0===arguments.length?new ee(null,this):1===arguments.length?new ee(arguments[0],this):void 0}},{key:"createMultiPoint",value:function(){if(0===arguments.length)return new Yt(null,this);if(1===arguments.length){if(arguments[0]instanceof Array)return new Yt(arguments[0],this);if(ot(arguments[0],ct)){var t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));for(var e=new Array(t.size()).fill(null),n=0;n<t.size();n++){var r=this.getCoordinateSequenceFactory().create(1,t.getDimension(),t.getMeasures());St.copy(t,n,r,0,1),e[n]=this.createPoint(r)}return this.createMultiPoint(e)}}}},{key:"interfaces_",get:function(){return[w]}}],[{key:"constructor_",value:function(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0===arguments.length)e.constructor_.call(this,new ie,0);else if(1===arguments.length){if(ot(arguments[0],bt)){var t=arguments[0];e.constructor_.call(this,new ie,0,t)}else if(arguments[0]instanceof ie){var n=arguments[0];e.constructor_.call(this,n,0,e.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){var r=arguments[0],i=arguments[1];e.constructor_.call(this,r,i,e.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){var o=arguments[0],s=arguments[1],a=arguments[2];this._precisionModel=o,this._coordinateSequenceFactory=a,this._SRID=s}}},{key:"toMultiPolygonArray",value:function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)}},{key:"toGeometryArray",value:function(t){if(null===t)return null;var e=new Array(t.size()).fill(null);return t.toArray(e)}},{key:"getDefaultCoordinateSequenceFactory",value:function(){return te.instance()}},{key:"toMultiLineStringArray",value:function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)}},{key:"toLineStringArray",value:function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)}},{key:"toMultiPointArray",value:function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)}},{key:"toLinearRingArray",value:function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)}},{key:"toPointArray",value:function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)}},{key:"toPolygonArray",value:function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)}},{key:"createPointFromInternalCoord",value:function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)}}]),e}(),ue="XY",le="XYZ",he="XYM",ce="XYZM",fe={POINT:"Point",LINE_STRING:"LineString",LINEAR_RING:"LinearRing",POLYGON:"Polygon",MULTI_POINT:"MultiPoint",MULTI_LINE_STRING:"MultiLineString",MULTI_POLYGON:"MultiPolygon",GEOMETRY_COLLECTION:"GeometryCollection",CIRCLE:"Circle"},ge="EMPTY",pe=1,ve=2,de=3,ye=4,me=5,_e=6;for(var xe in fe)fe[xe].toUpperCase();var Ee=function(){function e(n){t(this,e),this.wkt=n,this.index_=-1}return n(e,[{key:"isAlpha_",value:function(t){return t>="a"&&t<="z"||t>="A"&&t<="Z"}},{key:"isNumeric_",value:function(t,e){return t>="0"&&t<="9"||"."==t&&!(void 0!==e&&e)}},{key:"isWhiteSpace_",value:function(t){return" "==t||"\t"==t||"\r"==t||"\n"==t}},{key:"nextChar_",value:function(){return this.wkt.charAt(++this.index_)}},{key:"nextToken",value:function(){var t,e=this.nextChar_(),n=this.index_,r=e;if("("==e)t=ve;else if(","==e)t=me;else if(")"==e)t=de;else if(this.isNumeric_(e)||"-"==e)t=ye,r=this.readNumber_();else if(this.isAlpha_(e))t=pe,r=this.readText_();else{if(this.isWhiteSpace_(e))return this.nextToken();if(""!==e)throw new Error("Unexpected character: "+e);t=_e}return{position:n,value:r,type:t}}},{key:"readNumber_",value:function(){var t,e=this.index_,n=!1,r=!1;do{"."==t?n=!0:"e"!=t&&"E"!=t||(r=!0),t=this.nextChar_()}while(this.isNumeric_(t,n)||!r&&("e"==t||"E"==t)||r&&("-"==t||"+"==t));return parseFloat(this.wkt.substring(e,this.index_--))}},{key:"readText_",value:function(){var t,e=this.index_;do{t=this.nextChar_()}while(this.isAlpha_(t));return this.wkt.substring(e,this.index_--).toUpperCase()}}]),e}(),ke=function(){function e(n,r){t(this,e),this.lexer_=n,this.token_,this.layout_=ue,this.factory=r}return n(e,[{key:"consume_",value:function(){this.token_=this.lexer_.nextToken()}},{key:"isTokenType",value:function(t){return this.token_.type==t}},{key:"match",value:function(t){var e=this.isTokenType(t);return e&&this.consume_(),e}},{key:"parse",value:function(){return this.consume_(),this.parseGeometry_()}},{key:"parseGeometryLayout_",value:function(){var t=ue,e=this.token_;if(this.isTokenType(pe)){var n=e.value;"Z"===n?t=le:"M"===n?t=he:"ZM"===n&&(t=ce),t!==ue&&this.consume_()}return t}},{key:"parseGeometryCollectionText_",value:function(){if(this.match(ve)){var t=[];do{t.push(this.parseGeometry_())}while(this.match(me));if(this.match(de))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}},{key:"parsePointText_",value:function(){if(this.match(ve)){var t=this.parsePoint_();if(this.match(de))return t}else if(this.isEmptyGeometry_())return null;throw new Error(this.formatErrorMessage_())}},{key:"parseLineStringText_",value:function(){if(this.match(ve)){var t=this.parsePointList_();if(this.match(de))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}},{key:"parsePolygonText_",value:function(){if(this.match(ve)){var t=this.parseLineStringTextList_();if(this.match(de))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}},{key:"parseMultiPointText_",value:function(){var t;if(this.match(ve)){if(t=this.token_.type==ve?this.parsePointTextList_():this.parsePointList_(),this.match(de))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}},{key:"parseMultiLineStringText_",value:function(){if(this.match(ve)){var t=this.parseLineStringTextList_();if(this.match(de))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}},{key:"parseMultiPolygonText_",value:function(){if(this.match(ve)){var t=this.parsePolygonTextList_();if(this.match(de))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}},{key:"parsePoint_",value:function(){for(var t=[],e=this.layout_.length,n=0;n<e;++n){var r=this.token_;if(!this.match(ye))break;t.push(r.value)}if(t.length==e)return t;throw new Error(this.formatErrorMessage_())}},{key:"parsePointList_",value:function(){for(var t=[this.parsePoint_()];this.match(me);)t.push(this.parsePoint_());return t}},{key:"parsePointTextList_",value:function(){for(var t=[this.parsePointText_()];this.match(me);)t.push(this.parsePointText_());return t}},{key:"parseLineStringTextList_",value:function(){for(var t=[this.parseLineStringText_()];this.match(me);)t.push(this.parseLineStringText_());return t}},{key:"parsePolygonTextList_",value:function(){for(var t=[this.parsePolygonText_()];this.match(me);)t.push(this.parsePolygonText_());return t}},{key:"isEmptyGeometry_",value:function(){var t=this.isTokenType(pe)&&this.token_.value==ge;return t&&this.consume_(),t}},{key:"formatErrorMessage_",value:function(){return"Unexpected `"+this.token_.value+"` at position "+this.token_.position+" in `"+this.lexer_.wkt+"`"}},{key:"parseGeometry_",value:function(){var t=this.factory,e=function(t){return a(z,g(t))},n=function(n){var r=n.map((function(n){return t.createLinearRing(n.map(e))}));return r.length>1?t.createPolygon(r[0],r.slice(1)):t.createPolygon(r[0])},r=this.token_;if(this.match(pe)){var i=r.value;if(this.layout_=this.parseGeometryLayout_(),"GEOMETRYCOLLECTION"==i){var o=this.parseGeometryCollectionText_();return t.createGeometryCollection(o)}switch(i){case"POINT":var s=this.parsePointText_();return s?t.createPoint(a(z,g(s))):t.createPoint();case"LINESTRING":var u=this.parseLineStringText_().map(e);return t.createLineString(u);case"LINEARRING":var l=this.parseLineStringText_().map(e);return t.createLinearRing(l);case"POLYGON":var h=this.parsePolygonText_();return h&&0!==h.length?n(h):t.createPolygon();case"MULTIPOINT":var c=this.parseMultiPointText_();if(!c||0===c.length)return t.createMultiPoint();var f=c.map(e).map((function(e){return t.createPoint(e)}));return t.createMultiPoint(f);case"MULTILINESTRING":var p=this.parseMultiLineStringText_().map((function(n){return t.createLineString(n.map(e))}));return t.createMultiLineString(p);case"MULTIPOLYGON":var v=this.parseMultiPolygonText_();if(!v||0===v.length)return t.createMultiPolygon();var d=v.map(n);return t.createMultiPolygon(d);default:throw new Error("Invalid geometry type: "+i)}}throw new Error(this.formatErrorMessage_())}}]),e}();function be(t){if(t.isEmpty())return"";var e=t.getCoordinate(),n=[e.x,e.y];return void 0===e.z||Number.isNaN(e.z)||n.push(e.z),void 0===e.m||Number.isNaN(e.m)||n.push(e.m),n.join(" ")}function we(t){for(var e=t.getCoordinates().map((function(t){var e=[t.x,t.y];return void 0===t.z||Number.isNaN(t.z)||e.push(t.z),void 0===t.m||Number.isNaN(t.m)||e.push(t.m),e})),n=[],r=0,i=e.length;r<i;++r)n.push(e[r].join(" "));return n.join(", ")}function Ie(t){var e=[];e.push("("+we(t.getExteriorRing())+")");for(var n=0,r=t.getNumInteriorRing();n<r;++n)e.push("("+we(t.getInteriorRingN(n))+")");return e.join(", ")}var Ne={Point:be,LineString:we,LinearRing:we,Polygon:Ie,MultiPoint:function(t){for(var e=[],n=0,r=t.getNumGeometries();n<r;++n)e.push("("+be(t.getGeometryN(n))+")");return e.join(", ")},MultiLineString:function(t){for(var e=[],n=0,r=t.getNumGeometries();n<r;++n)e.push("("+we(t.getGeometryN(n))+")");return e.join(", ")},MultiPolygon:function(t){for(var e=[],n=0,r=t.getNumGeometries();n<r;++n)e.push("("+Ie(t.getGeometryN(n))+")");return e.join(", ")},GeometryCollection:function(t){for(var e=[],n=0,r=t.getNumGeometries();n<r;++n)e.push(Se(t.getGeometryN(n)));return e.join(", ")}};function Se(t){var e=t.getGeometryType(),n=Ne[e];e=e.toUpperCase();var r=function(t){var e="";if(t.isEmpty())return e;var n=t.getCoordinate();return void 0===n.z||Number.isNaN(n.z)||(e+="Z"),void 0===n.m||Number.isNaN(n.m)||(e+="M"),e}(t);return r.length>0&&(e+=" "+r),t.isEmpty()?e+" "+ge:e+" ("+n(t)+")"}var Me=function(){function e(n){t(this,e),this.geometryFactory=n||new ae,this.precisionModel=this.geometryFactory.getPrecisionModel()}return n(e,[{key:"read",value:function(t){var e=new Ee(t);return new ke(e,this.geometryFactory).parse()}},{key:"write",value:function(t){return Se(t)}}]),e}(),Le=function(){function e(n){t(this,e),this.parser=new Me(n)}return n(e,[{key:"write",value:function(t){return this.parser.write(t)}}],[{key:"toLineString",value:function(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}]),e}(),Pe=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getIndexAlongSegment",value:function(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]}},{key:"getTopologySummary",value:function(){var t=new Qt;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}},{key:"computeIntersection",value:function(t,e,n,r){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=r,this._result=this.computeIntersect(t,e,n,r)}},{key:"getIntersectionNum",value:function(){return this._result}},{key:"computeIntLineIndex",value:function(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map((function(){return Array(2)})),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){var t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}}},{key:"isProper",value:function(){return this.hasIntersection()&&this._isProper}},{key:"setPrecisionModel",value:function(t){this._precisionModel=t}},{key:"isInteriorIntersection",value:function(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){for(var t=arguments[0],e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return!0;return!1}}},{key:"getIntersection",value:function(t){return this._intPt[t]}},{key:"isEndPoint",value:function(){return this.hasIntersection()&&!this._isProper}},{key:"hasIntersection",value:function(){return this._result!==e.NO_INTERSECTION}},{key:"getEdgeDistance",value:function(t,n){return e.computeEdgeDistance(this._intPt[n],this._inputLines[t][0],this._inputLines[t][1])}},{key:"isCollinear",value:function(){return this._result===e.COLLINEAR_INTERSECTION}},{key:"toString",value:function(){return Le.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Le.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()}},{key:"getEndpoint",value:function(t,e){return this._inputLines[t][e]}},{key:"isIntersection",value:function(t){for(var e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return!0;return!1}},{key:"getIntersectionAlongSegment",value:function(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]}}],[{key:"constructor_",value:function(){this._result=null,this._inputLines=Array(2).fill().map((function(){return Array(2)})),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new z,this._intPt[1]=new z,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0}},{key:"computeEdgeDistance",value:function(t,e,n){var r=Math.abs(n.x-e.x),i=Math.abs(n.y-e.y),o=-1;if(t.equals(e))o=0;else if(t.equals(n))o=r>i?r:i;else{var s=Math.abs(t.x-e.x),a=Math.abs(t.y-e.y);0!==(o=r>i?s:a)||t.equals(e)||(o=Math.max(s,a))}return V.isTrue(!(0===o&&!t.equals(e)),"Bad distance calculation"),o}},{key:"nonRobustComputeEdgeDistance",value:function(t,e,n){var r=t.x-e.x,i=t.y-e.y,o=Math.sqrt(r*r+i*i);return V.isTrue(!(0===o&&!t.equals(e)),"Invalid distance calculation"),o}}]),e}();Pe.DONT_INTERSECT=0,Pe.DO_INTERSECT=1,Pe.COLLINEAR=2,Pe.NO_INTERSECTION=0,Pe.POINT_INTERSECTION=1,Pe.COLLINEAR_INTERSECTION=2;var Ce=function(e){r(s,e);var o=c(s);function s(){return t(this,s),o.call(this)}return n(s,[{key:"isInSegmentEnvelopes",value:function(t){var e=new X(this._inputLines[0][0],this._inputLines[0][1]),n=new X(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)}},{key:"computeIntersection",value:function(){if(3!==arguments.length)return f(i(s.prototype),"computeIntersection",this).apply(this,arguments);var t=arguments[0],e=arguments[1],n=arguments[2];if(this._isProper=!1,X.intersects(e,n,t)&&0===ft.index(e,n,t)&&0===ft.index(n,e,t))return this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this._result=Pe.POINT_INTERSECTION,null;this._result=Pe.NO_INTERSECTION}},{key:"intersection",value:function(t,e,n,r){var i=this.intersectionSafe(t,e,n,r);return this.isInSegmentEnvelopes(i)||(i=new z(s.nearestEndpoint(t,e,n,r))),null!==this._precisionModel&&this._precisionModel.makePrecise(i),i}},{key:"checkDD",value:function(t,e,n,r,i){var o=ht.intersection(t,e,n,r),s=this.isInSegmentEnvelopes(o);xt.out.println("DD in env = "+s+"  --------------------- "+o),i.distance(o)>1e-4&&xt.out.println("Distance = "+i.distance(o))}},{key:"intersectionSafe",value:function(t,e,n,r){var i=_t.intersection(t,e,n,r);return null===i&&(i=s.nearestEndpoint(t,e,n,r)),i}},{key:"computeCollinearIntersection",value:function(t,e,n,r){var i=X.intersects(t,e,n),o=X.intersects(t,e,r),s=X.intersects(n,r,t),a=X.intersects(n,r,e);return i&&o?(this._intPt[0]=n,this._intPt[1]=r,Pe.COLLINEAR_INTERSECTION):s&&a?(this._intPt[0]=t,this._intPt[1]=e,Pe.COLLINEAR_INTERSECTION):i&&s?(this._intPt[0]=n,this._intPt[1]=t,!n.equals(t)||o||a?Pe.COLLINEAR_INTERSECTION:Pe.POINT_INTERSECTION):i&&a?(this._intPt[0]=n,this._intPt[1]=e,!n.equals(e)||o||s?Pe.COLLINEAR_INTERSECTION:Pe.POINT_INTERSECTION):o&&s?(this._intPt[0]=r,this._intPt[1]=t,!r.equals(t)||i||a?Pe.COLLINEAR_INTERSECTION:Pe.POINT_INTERSECTION):o&&a?(this._intPt[0]=r,this._intPt[1]=e,!r.equals(e)||i||s?Pe.COLLINEAR_INTERSECTION:Pe.POINT_INTERSECTION):Pe.NO_INTERSECTION}},{key:"computeIntersect",value:function(t,e,n,r){if(this._isProper=!1,!X.intersects(t,e,n,r))return Pe.NO_INTERSECTION;var i=ft.index(t,e,n),o=ft.index(t,e,r);if(i>0&&o>0||i<0&&o<0)return Pe.NO_INTERSECTION;var s=ft.index(n,r,t),a=ft.index(n,r,e);return s>0&&a>0||s<0&&a<0?Pe.NO_INTERSECTION:0===i&&0===o&&0===s&&0===a?this.computeCollinearIntersection(t,e,n,r):(0===i||0===o||0===s||0===a?(this._isProper=!1,t.equals2D(n)||t.equals2D(r)?this._intPt[0]=t:e.equals2D(n)||e.equals2D(r)?this._intPt[0]=e:0===i?this._intPt[0]=new z(n):0===o?this._intPt[0]=new z(r):0===s?this._intPt[0]=new z(t):0===a&&(this._intPt[0]=new z(e))):(this._isProper=!0,this._intPt[0]=this.intersection(t,e,n,r)),Pe.POINT_INTERSECTION)}}],[{key:"nearestEndpoint",value:function(t,e,n,r){var i=t,o=kt.pointToSegment(t,n,r),s=kt.pointToSegment(e,n,r);return s<o&&(o=s,i=e),(s=kt.pointToSegment(n,t,e))<o&&(o=s,i=n),(s=kt.pointToSegment(r,t,e))<o&&(o=s,i=r),i}}]),s}(Pe),Te=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"countSegment",value:function(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){var n=t.x,r=e.x;return n>r&&(n=e.x,r=t.x),this._p.x>=n&&this._p.x<=r&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){var i=ft.index(t,e,this._p);if(i===ft.COLLINEAR)return this._isPointOnSegment=!0,null;e.y<t.y&&(i=-i),i===ft.LEFT&&this._crossingCount++}}},{key:"isPointInPolygon",value:function(){return this.getLocation()!==Z.EXTERIOR}},{key:"getLocation",value:function(){return this._isPointOnSegment?Z.BOUNDARY:this._crossingCount%2==1?Z.INTERIOR:Z.EXTERIOR}},{key:"isOnSegment",value:function(){return this._isPointOnSegment}}],[{key:"constructor_",value:function(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;var t=arguments[0];this._p=t}},{key:"locatePointInRing",value:function(){if(arguments[0]instanceof z&&ot(arguments[1],ct)){for(var t=arguments[1],n=new e(arguments[0]),r=new z,i=new z,o=1;o<t.size();o++)if(t.getCoordinate(o,r),t.getCoordinate(o-1,i),n.countSegment(r,i),n.isOnSegment())return n.getLocation();return n.getLocation()}if(arguments[0]instanceof z&&arguments[1]instanceof Array){for(var s=arguments[1],a=new e(arguments[0]),u=1;u<s.length;u++){var l=s[u],h=s[u-1];if(a.countSegment(l,h),a.isOnSegment())return a.getLocation()}return a.getLocation()}}}]),e}(),Oe=function(){function e(){t(this,e)}return n(e,null,[{key:"isOnLine",value:function(){if(arguments[0]instanceof z&&ot(arguments[1],ct)){for(var t=arguments[0],e=arguments[1],n=new Ce,r=new z,i=new z,o=e.size(),s=1;s<o;s++)if(e.getCoordinate(s-1,r),e.getCoordinate(s,i),n.computeIntersection(t,r,i),n.hasIntersection())return!0;return!1}if(arguments[0]instanceof z&&arguments[1]instanceof Array){for(var a=arguments[0],u=arguments[1],l=new Ce,h=1;h<u.length;h++){var c=u[h-1],f=u[h];if(l.computeIntersection(a,c,f),l.hasIntersection())return!0}return!1}}},{key:"locateInRing",value:function(t,e){return Te.locatePointInRing(t,e)}},{key:"isInRing",value:function(t,n){return e.locateInRing(t,n)!==Z.EXTERIOR}}]),e}(),Re=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"setAllLocations",value:function(t){for(var e=0;e<this.location.length;e++)this.location[e]=t}},{key:"isNull",value:function(){for(var t=0;t<this.location.length;t++)if(this.location[t]!==Z.NONE)return!1;return!0}},{key:"setAllLocationsIfNull",value:function(t){for(var e=0;e<this.location.length;e++)this.location[e]===Z.NONE&&(this.location[e]=t)}},{key:"isLine",value:function(){return 1===this.location.length}},{key:"merge",value:function(t){if(t.location.length>this.location.length){var e=new Array(3).fill(null);e[tt.ON]=this.location[tt.ON],e[tt.LEFT]=Z.NONE,e[tt.RIGHT]=Z.NONE,this.location=e}for(var n=0;n<this.location.length;n++)this.location[n]===Z.NONE&&n<t.location.length&&(this.location[n]=t.location[n])}},{key:"getLocations",value:function(){return this.location}},{key:"flip",value:function(){if(this.location.length<=1)return null;var t=this.location[tt.LEFT];this.location[tt.LEFT]=this.location[tt.RIGHT],this.location[tt.RIGHT]=t}},{key:"toString",value:function(){var t=new st;return this.location.length>1&&t.append(Z.toLocationSymbol(this.location[tt.LEFT])),t.append(Z.toLocationSymbol(this.location[tt.ON])),this.location.length>1&&t.append(Z.toLocationSymbol(this.location[tt.RIGHT])),t.toString()}},{key:"setLocations",value:function(t,e,n){this.location[tt.ON]=t,this.location[tt.LEFT]=e,this.location[tt.RIGHT]=n}},{key:"get",value:function(t){return t<this.location.length?this.location[t]:Z.NONE}},{key:"isArea",value:function(){return this.location.length>1}},{key:"isAnyNull",value:function(){for(var t=0;t<this.location.length;t++)if(this.location[t]===Z.NONE)return!0;return!1}},{key:"setLocation",value:function(){if(1===arguments.length){var t=arguments[0];this.setLocation(tt.ON,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.location[e]=n}}},{key:"init",value:function(t){this.location=new Array(t).fill(null),this.setAllLocations(Z.NONE)}},{key:"isEqualOnSide",value:function(t,e){return this.location[e]===t.location[e]}},{key:"allPositionsEqual",value:function(t){for(var e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0}}],[{key:"constructor_",value:function(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){var n=arguments[0];this.init(1),this.location[tt.ON]=n}else if(arguments[0]instanceof e){var r=arguments[0];if(this.init(r.location.length),null!==r)for(var i=0;i<this.location.length;i++)this.location[i]=r.location[i]}}else if(3===arguments.length){var o=arguments[0],s=arguments[1],a=arguments[2];this.init(3),this.location[tt.ON]=o,this.location[tt.LEFT]=s,this.location[tt.RIGHT]=a}}}]),e}(),Ae=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getGeometryCount",value:function(){var t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}},{key:"setAllLocations",value:function(t,e){this.elt[t].setAllLocations(e)}},{key:"isNull",value:function(t){return this.elt[t].isNull()}},{key:"setAllLocationsIfNull",value:function(){if(1===arguments.length){var t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.elt[e].setAllLocationsIfNull(n)}}},{key:"isLine",value:function(t){return this.elt[t].isLine()}},{key:"merge",value:function(t){for(var e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new Re(t.elt[e]):this.elt[e].merge(t.elt[e])}},{key:"flip",value:function(){this.elt[0].flip(),this.elt[1].flip()}},{key:"getLocation",value:function(){if(1===arguments.length){var t=arguments[0];return this.elt[t].get(tt.ON)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.elt[e].get(n)}}},{key:"toString",value:function(){var t=new st;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}},{key:"isArea",value:function(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){var t=arguments[0];return this.elt[t].isArea()}}},{key:"isAnyNull",value:function(t){return this.elt[t].isAnyNull()}},{key:"setLocation",value:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.elt[t].setLocation(tt.ON,e)}else if(3===arguments.length){var n=arguments[0],r=arguments[1],i=arguments[2];this.elt[n].setLocation(r,i)}}},{key:"isEqualOnSide",value:function(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)}},{key:"allPositionsEqual",value:function(t,e){return this.elt[t].allPositionsEqual(e)}},{key:"toLine",value:function(t){this.elt[t].isArea()&&(this.elt[t]=new Re(this.elt[t].location[0]))}}],[{key:"constructor_",value:function(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){var t=arguments[0];this.elt[0]=new Re(t),this.elt[1]=new Re(t)}else if(arguments[0]instanceof e){var n=arguments[0];this.elt[0]=new Re(n.elt[0]),this.elt[1]=new Re(n.elt[1])}}else if(2===arguments.length){var r=arguments[0],i=arguments[1];this.elt[0]=new Re(Z.NONE),this.elt[1]=new Re(Z.NONE),this.elt[r].setLocation(i)}else if(3===arguments.length){var o=arguments[0],s=arguments[1],a=arguments[2];this.elt[0]=new Re(o,s,a),this.elt[1]=new Re(o,s,a)}else if(4===arguments.length){var u=arguments[0],l=arguments[1],h=arguments[2],c=arguments[3];this.elt[0]=new Re(Z.NONE,Z.NONE,Z.NONE),this.elt[1]=new Re(Z.NONE,Z.NONE,Z.NONE),this.elt[u].setLocations(l,h,c)}}},{key:"toLineLabel",value:function(t){for(var n=new e(Z.NONE),r=0;r<2;r++)n.setLocation(r,t.getLocation(r));return n}}]),e}(),De=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"computeRing",value:function(){if(null!==this._ring)return null;for(var t=new Array(this._pts.size()).fill(null),e=0;e<this._pts.size();e++)t[e]=this._pts.get(e);this._ring=this._geometryFactory.createLinearRing(t),this._isHole=ft.isCCW(this._ring.getCoordinates())}},{key:"isIsolated",value:function(){return 1===this._label.getGeometryCount()}},{key:"computePoints",value:function(t){this._startDe=t;var e=t,n=!0;do{if(null===e)throw new pt("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new pt("Directed Edge visited twice during ring-building at "+e.getCoordinate());this._edges.add(e);var r=e.getLabel();V.isTrue(r.isArea()),this.mergeLabel(r),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this._startDe)}},{key:"getLinearRing",value:function(){return this._ring}},{key:"getCoordinate",value:function(t){return this._pts.get(t)}},{key:"computeMaxNodeDegree",value:function(){this._maxNodeDegree=0;var t=this._startDe;do{var e=t.getNode().getEdges().getOutgoingDegree(this);e>this._maxNodeDegree&&(this._maxNodeDegree=e),t=this.getNext(t)}while(t!==this._startDe);this._maxNodeDegree*=2}},{key:"addPoints",value:function(t,e,n){var r=t.getCoordinates();if(e){var i=1;n&&(i=0);for(var o=i;o<r.length;o++)this._pts.add(r[o])}else{var s=r.length-2;n&&(s=r.length-1);for(var a=s;a>=0;a--)this._pts.add(r[a])}}},{key:"isHole",value:function(){return this._isHole}},{key:"setInResult",value:function(){var t=this._startDe;do{t.getEdge().setInResult(!0),t=t.getNext()}while(t!==this._startDe)}},{key:"containsPoint",value:function(t){var e=this.getLinearRing();if(!e.getEnvelopeInternal().contains(t))return!1;if(!Oe.isInRing(t,e.getCoordinates()))return!1;for(var n=this._holes.iterator();n.hasNext();)if(n.next().containsPoint(t))return!1;return!0}},{key:"addHole",value:function(t){this._holes.add(t)}},{key:"isShell",value:function(){return null===this._shell}},{key:"getLabel",value:function(){return this._label}},{key:"getEdges",value:function(){return this._edges}},{key:"getMaxNodeDegree",value:function(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree}},{key:"getShell",value:function(){return this._shell}},{key:"mergeLabel",value:function(){if(1===arguments.length){var t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){var e=arguments[1],n=arguments[0].getLocation(e,tt.RIGHT);if(n===Z.NONE)return null;if(this._label.getLocation(e)===Z.NONE)return this._label.setLocation(e,n),null}}},{key:"setShell",value:function(t){this._shell=t,null!==t&&t.addHole(this)}},{key:"toPolygon",value:function(t){for(var e=new Array(this._holes.size()).fill(null),n=0;n<this._holes.size();n++)e[n]=this._holes.get(n).getLinearRing();return t.createPolygon(this.getLinearRing(),e)}}],[{key:"constructor_",value:function(){if(this._startDe=null,this._maxNodeDegree=-1,this._edges=new dt,this._pts=new dt,this._label=new Ae(Z.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new dt,this._geometryFactory=null,0===arguments.length);else if(2===arguments.length){var t=arguments[0],e=arguments[1];this._geometryFactory=e,this.computePoints(t),this.computeRing()}}}]),e}(),Fe=function(e){r(o,e);var i=c(o);function o(){var e;return t(this,o),e=i.call(this),o.constructor_.apply(l(e),arguments),e}return n(o,[{key:"setEdgeRing",value:function(t,e){t.setMinEdgeRing(e)}},{key:"getNext",value:function(t){return t.getNextMin()}}],[{key:"constructor_",value:function(){var t=arguments[0],e=arguments[1];De.constructor_.call(this,t,e)}}]),o}(De),qe=function(e){r(o,e);var i=c(o);function o(){var e;return t(this,o),e=i.call(this),o.constructor_.apply(l(e),arguments),e}return n(o,[{key:"buildMinimalRings",value:function(){var t=new dt,e=this._startDe;do{if(null===e.getMinEdgeRing()){var n=new Fe(e,this._geometryFactory);t.add(n)}e=e.getNext()}while(e!==this._startDe);return t}},{key:"setEdgeRing",value:function(t,e){t.setEdgeRing(e)}},{key:"linkDirectedEdgesForMinimalEdgeRings",value:function(){var t=this._startDe;do{t.getNode().getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this._startDe)}},{key:"getNext",value:function(t){return t.getNext()}}],[{key:"constructor_",value:function(){var t=arguments[0],e=arguments[1];De.constructor_.call(this,t,e)}}]),o}(De),Ve=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"setVisited",value:function(t){this._isVisited=t}},{key:"setInResult",value:function(t){this._isInResult=t}},{key:"isCovered",value:function(){return this._isCovered}},{key:"isCoveredSet",value:function(){return this._isCoveredSet}},{key:"setLabel",value:function(t){this._label=t}},{key:"getLabel",value:function(){return this._label}},{key:"setCovered",value:function(t){this._isCovered=t,this._isCoveredSet=!0}},{key:"updateIM",value:function(t){V.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}},{key:"isInResult",value:function(){return this._isInResult}},{key:"isVisited",value:function(){return this._isVisited}}],[{key:"constructor_",value:function(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this._label=t}}}]),e}(),Ge=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"isIncidentEdgeInResult",value:function(){for(var t=this.getEdges().getEdges().iterator();t.hasNext();)if(t.next().getEdge().isInResult())return!0;return!1}},{key:"isIsolated",value:function(){return 1===this._label.getGeometryCount()}},{key:"getCoordinate",value:function(){return this._coord}},{key:"print",value:function(t){t.println("node "+this._coord+" lbl: "+this._label)}},{key:"computeIM",value:function(t){}},{key:"computeMergedLocation",value:function(t,e){var n=Z.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){var r=t.getLocation(e);n!==Z.BOUNDARY&&(n=r)}return n}},{key:"setLabel",value:function(){if(2!==arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return f(i(s.prototype),"setLabel",this).apply(this,arguments);var t=arguments[0],e=arguments[1];null===this._label?this._label=new Ae(t,e):this._label.setLocation(t,e)}},{key:"getEdges",value:function(){return this._edges}},{key:"mergeLabel",value:function(){if(arguments[0]instanceof s){var t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof Ae)for(var e=arguments[0],n=0;n<2;n++){var r=this.computeMergedLocation(e,n);this._label.getLocation(n)===Z.NONE&&this._label.setLocation(n,r)}}},{key:"add",value:function(t){this._edges.insert(t),t.setNode(this)}},{key:"setLabelBoundary",value:function(t){if(null===this._label)return null;var e=Z.NONE;null!==this._label&&(e=this._label.getLocation(t));var n=null;switch(e){case Z.BOUNDARY:n=Z.INTERIOR;break;case Z.INTERIOR:default:n=Z.BOUNDARY}this._label.setLocation(t,n)}}],[{key:"constructor_",value:function(){this._coord=null,this._edges=null;var t=arguments[0],e=arguments[1];this._coord=t,this._edges=e,this._label=new Ae(0,Z.NONE)}}]),s}(Ve),Be=function(e){r(i,e);var n=c(i);function i(){return t(this,i),n.apply(this,arguments)}return i}(ne);function Ye(t){return null==t?0:t.color}function ze(t){return null==t?null:t.parent}function je(t,e){null!==t&&(t.color=e)}function Xe(t){return null==t?null:t.left}function Ue(t){return null==t?null:t.right}var Ze=function(e){r(o,e);var i=c(o);function o(){var e;return t(this,o),(e=i.call(this)).root_=null,e.size_=0,e}return n(o,[{key:"get",value:function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null}},{key:"put",value:function(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:0,getValue:function(){return this.value},getKey:function(){return this.key}},this.size_=1,null;var n,r,i=this.root_;do{if(n=i,(r=t.compareTo(i.key))<0)i=i.left;else{if(!(r>0)){var o=i.value;return i.value=e,o}i=i.right}}while(null!==i);var s={key:t,left:null,right:null,value:e,parent:n,color:0,getValue:function(){return this.value},getKey:function(){return this.key}};return r<0?n.left=s:n.right=s,this.fixAfterInsertion(s),this.size_++,null}},{key:"fixAfterInsertion",value:function(t){var e;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)ze(t)===Xe(ze(ze(t)))?1===Ye(e=Ue(ze(ze(t))))?(je(ze(t),0),je(e,0),je(ze(ze(t)),1),t=ze(ze(t))):(t===Ue(ze(t))&&(t=ze(t),this.rotateLeft(t)),je(ze(t),0),je(ze(ze(t)),1),this.rotateRight(ze(ze(t)))):1===Ye(e=Xe(ze(ze(t))))?(je(ze(t),0),je(e,0),je(ze(ze(t)),1),t=ze(ze(t))):(t===Xe(ze(t))&&(t=ze(t),this.rotateRight(t)),je(ze(t),0),je(ze(ze(t)),1),this.rotateLeft(ze(ze(t))));this.root_.color=0}},{key:"values",value:function(){var t=new dt,e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=o.successor(e));)t.add(e.value);return t}},{key:"entrySet",value:function(){var t=new Q,e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=o.successor(e));)t.add(e);return t}},{key:"rotateLeft",value:function(t){if(null!=t){var e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}}},{key:"rotateRight",value:function(t){if(null!=t){var e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}}},{key:"getFirstEntry",value:function(){var t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t}},{key:"size",value:function(){return this.size_}},{key:"containsKey",value:function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return!0;e=e.right}}return!1}}],[{key:"successor",value:function(t){var e;if(null===t)return null;if(null!==t.right){for(e=t.right;null!==e.left;)e=e.left;return e}e=t.parent;for(var n=t;null!==e&&n===e.right;)n=e,e=e.parent;return e}}]),o}(Be),He=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"find",value:function(t){return this.nodeMap.get(t)}},{key:"addNode",value:function(){if(arguments[0]instanceof z){var t=arguments[0],e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof Ge){var n=arguments[0],r=this.nodeMap.get(n.getCoordinate());return null===r?(this.nodeMap.put(n.getCoordinate(),n),n):(r.mergeLabel(n),r)}}},{key:"print",value:function(t){for(var e=this.iterator();e.hasNext();)e.next().print(t)}},{key:"iterator",value:function(){return this.nodeMap.values().iterator()}},{key:"values",value:function(){return this.nodeMap.values()}},{key:"getBoundaryNodes",value:function(t){for(var e=new dt,n=this.iterator();n.hasNext();){var r=n.next();r.getLabel().getLocation(t)===Z.BOUNDARY&&e.add(r)}return e}},{key:"add",value:function(t){var e=t.getCoordinate();this.addNode(e).add(t)}}],[{key:"constructor_",value:function(){this.nodeMap=new Ze,this.nodeFact=null;var t=arguments[0];this.nodeFact=t}}]),e}(),We=function(){function e(){t(this,e)}return n(e,null,[{key:"isNorthern",value:function(t){return t===e.NE||t===e.NW}},{key:"isOpposite",value:function(t,e){return t!==e&&2==(t-e+4)%4}},{key:"commonHalfPlane",value:function(t,e){if(t===e)return t;if(2==(t-e+4)%4)return-1;var n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n}},{key:"isInHalfPlane",value:function(t,n){return n===e.SE?t===e.SE||t===e.SW:t===n||t===n+1}},{key:"quadrant",value:function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],n=arguments[1];if(0===t&&0===n)throw new x("Cannot compute the quadrant for point ( "+t+", "+n+" )");return t>=0?n>=0?e.NE:e.SE:n>=0?e.NW:e.SW}if(arguments[0]instanceof z&&arguments[1]instanceof z){var r=arguments[0],i=arguments[1];if(i.x===r.x&&i.y===r.y)throw new x("Cannot compute the quadrant for two identical points "+r);return i.x>=r.x?i.y>=r.y?e.NE:e.SE:i.y>=r.y?e.NW:e.SW}}}]),e}();We.NE=0,We.NW=1,We.SW=2,We.SE=3;var Je=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"compareDirection",value:function(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:ft.index(t._p0,t._p1,this._p1)}},{key:"getDy",value:function(){return this._dy}},{key:"getCoordinate",value:function(){return this._p0}},{key:"setNode",value:function(t){this._node=t}},{key:"print",value:function(t){var e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),r=n.lastIndexOf("."),i=n.substring(r+1);t.print("  "+i+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label)}},{key:"compareTo",value:function(t){var e=t;return this.compareDirection(e)}},{key:"getDirectedCoordinate",value:function(){return this._p1}},{key:"getDx",value:function(){return this._dx}},{key:"getLabel",value:function(){return this._label}},{key:"getEdge",value:function(){return this._edge}},{key:"getQuadrant",value:function(){return this._quadrant}},{key:"getNode",value:function(){return this._node}},{key:"toString",value:function(){var t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return"  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label}},{key:"computeLabel",value:function(t){}},{key:"init",value:function(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=We.quadrant(this._dx,this._dy),V.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")}},{key:"interfaces_",get:function(){return[k]}}],[{key:"constructor_",value:function(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){var t=arguments[0];this._edge=t}else if(3===arguments.length){var n=arguments[0],r=arguments[1],i=arguments[2];e.constructor_.call(this,n,r,i,null)}else if(4===arguments.length){var o=arguments[0],s=arguments[1],a=arguments[2],u=arguments[3];e.constructor_.call(this,o),this.init(s,a),this._label=u}}}]),e}(),Ke=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"getNextMin",value:function(){return this._nextMin}},{key:"getDepth",value:function(t){return this._depth[t]}},{key:"setVisited",value:function(t){this._isVisited=t}},{key:"computeDirectedLabel",value:function(){this._label=new Ae(this._edge.getLabel()),this._isForward||this._label.flip()}},{key:"getNext",value:function(){return this._next}},{key:"setDepth",value:function(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new pt("assigned depths do not match",this.getCoordinate());this._depth[t]=e}},{key:"isInteriorAreaEdge",value:function(){for(var t=!0,e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,tt.LEFT)===Z.INTERIOR&&this._label.getLocation(e,tt.RIGHT)===Z.INTERIOR||(t=!1);return t}},{key:"setNextMin",value:function(t){this._nextMin=t}},{key:"print",value:function(t){f(i(s.prototype),"print",this).call(this,t),t.print(" "+this._depth[tt.LEFT]+"/"+this._depth[tt.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")}},{key:"setMinEdgeRing",value:function(t){this._minEdgeRing=t}},{key:"isLineEdge",value:function(){var t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,Z.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,Z.EXTERIOR);return t&&e&&n}},{key:"setEdgeRing",value:function(t){this._edgeRing=t}},{key:"getMinEdgeRing",value:function(){return this._minEdgeRing}},{key:"getDepthDelta",value:function(){var t=this._edge.getDepthDelta();return this._isForward||(t=-t),t}},{key:"setInResult",value:function(t){this._isInResult=t}},{key:"getSym",value:function(){return this._sym}},{key:"isForward",value:function(){return this._isForward}},{key:"getEdge",value:function(){return this._edge}},{key:"printEdge",value:function(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)}},{key:"setSym",value:function(t){this._sym=t}},{key:"setVisitedEdge",value:function(t){this.setVisited(t),this._sym.setVisited(t)}},{key:"setEdgeDepths",value:function(t,e){var n=this.getEdge().getDepthDelta();this._isForward||(n=-n);var r=1;t===tt.LEFT&&(r=-1);var i=tt.opposite(t),o=e+n*r;this.setDepth(t,e),this.setDepth(i,o)}},{key:"getEdgeRing",value:function(){return this._edgeRing}},{key:"isInResult",value:function(){return this._isInResult}},{key:"setNext",value:function(t){this._next=t}},{key:"isVisited",value:function(){return this._isVisited}}],[{key:"constructor_",value:function(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999];var t=arguments[0],e=arguments[1];if(Je.constructor_.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{var n=t.getNumPoints()-1;this.init(t.getCoordinate(n),t.getCoordinate(n-1))}this.computeDirectedLabel()}},{key:"depthFactor",value:function(t,e){return t===Z.EXTERIOR&&e===Z.INTERIOR?1:t===Z.INTERIOR&&e===Z.EXTERIOR?-1:0}}]),s}(Je),Qe=function(){function e(){t(this,e)}return n(e,[{key:"createNode",value:function(t){return new Ge(t,null)}}]),e}(),$e=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"printEdges",value:function(t){t.println("Edges:");for(var e=0;e<this._edges.size();e++){t.println("edge "+e+":");var n=this._edges.get(e);n.print(t),n.eiList.print(t)}}},{key:"find",value:function(t){return this._nodes.find(t)}},{key:"addNode",value:function(){if(arguments[0]instanceof Ge){var t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof z){var e=arguments[0];return this._nodes.addNode(e)}}},{key:"getNodeIterator",value:function(){return this._nodes.iterator()}},{key:"linkResultDirectedEdges",value:function(){for(var t=this._nodes.iterator();t.hasNext();)t.next().getEdges().linkResultDirectedEdges()}},{key:"debugPrintln",value:function(t){xt.out.println(t)}},{key:"isBoundaryNode",value:function(t,e){var n=this._nodes.find(e);if(null===n)return!1;var r=n.getLabel();return null!==r&&r.getLocation(t)===Z.BOUNDARY}},{key:"linkAllDirectedEdges",value:function(){for(var t=this._nodes.iterator();t.hasNext();)t.next().getEdges().linkAllDirectedEdges()}},{key:"matchInSameDirection",value:function(t,e,n,r){return!!t.equals(n)&&ft.index(t,e,r)===ft.COLLINEAR&&We.quadrant(t,e)===We.quadrant(n,r)}},{key:"getEdgeEnds",value:function(){return this._edgeEndList}},{key:"debugPrint",value:function(t){xt.out.print(t)}},{key:"getEdgeIterator",value:function(){return this._edges.iterator()}},{key:"findEdgeInSameDirection",value:function(t,e){for(var n=0;n<this._edges.size();n++){var r=this._edges.get(n),i=r.getCoordinates();if(this.matchInSameDirection(t,e,i[0],i[1]))return r;if(this.matchInSameDirection(t,e,i[i.length-1],i[i.length-2]))return r}return null}},{key:"insertEdge",value:function(t){this._edges.add(t)}},{key:"findEdgeEnd",value:function(t){for(var e=this.getEdgeEnds().iterator();e.hasNext();){var n=e.next();if(n.getEdge()===t)return n}return null}},{key:"addEdges",value:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this._edges.add(n);var r=new Ke(n,!0),i=new Ke(n,!1);r.setSym(i),i.setSym(r),this.add(r),this.add(i)}}},{key:"add",value:function(t){this._nodes.add(t),this._edgeEndList.add(t)}},{key:"getNodes",value:function(){return this._nodes.values()}},{key:"findEdge",value:function(t,e){for(var n=0;n<this._edges.size();n++){var r=this._edges.get(n),i=r.getCoordinates();if(t.equals(i[0])&&e.equals(i[1]))return r}return null}}],[{key:"constructor_",value:function(){if(this._edges=new dt,this._nodes=null,this._edgeEndList=new dt,0===arguments.length)this._nodes=new He(new Qe);else if(1===arguments.length){var t=arguments[0];this._nodes=new He(t)}}},{key:"linkResultDirectedEdges",value:function(t){for(var e=t.iterator();e.hasNext();)e.next().getEdges().linkResultDirectedEdges()}}]),e}(),tn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"sortShellsAndHoles",value:function(t,e,n){for(var r=t.iterator();r.hasNext();){var i=r.next();i.isHole()?n.add(i):e.add(i)}}},{key:"computePolygons",value:function(t){for(var e=new dt,n=t.iterator();n.hasNext();){var r=n.next().toPolygon(this._geometryFactory);e.add(r)}return e}},{key:"placeFreeHoles",value:function(t,n){for(var r=n.iterator();r.hasNext();){var i=r.next();if(null===i.getShell()){var o=e.findEdgeRingContaining(i,t);if(null===o)throw new pt("unable to assign hole to a shell",i.getCoordinate(0));i.setShell(o)}}}},{key:"buildMinimalEdgeRings",value:function(t,e,n){for(var r=new dt,i=t.iterator();i.hasNext();){var o=i.next();if(o.getMaxNodeDegree()>2){o.linkDirectedEdgesForMinimalEdgeRings();var s=o.buildMinimalRings(),a=this.findShell(s);null!==a?(this.placePolygonHoles(a,s),e.add(a)):n.addAll(s)}else r.add(o)}return r}},{key:"buildMaximalEdgeRings",value:function(t){for(var e=new dt,n=t.iterator();n.hasNext();){var r=n.next();if(r.isInResult()&&r.getLabel().isArea()&&null===r.getEdgeRing()){var i=new qe(r,this._geometryFactory);e.add(i),i.setInResult()}}return e}},{key:"placePolygonHoles",value:function(t,e){for(var n=e.iterator();n.hasNext();){var r=n.next();r.isHole()&&r.setShell(t)}}},{key:"getPolygons",value:function(){return this.computePolygons(this._shellList)}},{key:"findShell",value:function(t){for(var e=0,n=null,r=t.iterator();r.hasNext();){var i=r.next();i.isHole()||(n=i,e++)}return V.isTrue(e<=1,"found two shells in MinimalEdgeRing list"),n}},{key:"add",value:function(){if(1===arguments.length){var t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){var e=arguments[0],n=arguments[1];$e.linkResultDirectedEdges(n);var r=this.buildMaximalEdgeRings(e),i=new dt,o=this.buildMinimalEdgeRings(r,this._shellList,i);this.sortShellsAndHoles(o,this._shellList,i),this.placeFreeHoles(this._shellList,i)}}}],[{key:"constructor_",value:function(){this._geometryFactory=null,this._shellList=new dt;var t=arguments[0];this._geometryFactory=t}},{key:"findEdgeRingContaining",value:function(t,e){for(var n=t.getLinearRing(),r=n.getEnvelopeInternal(),i=n.getCoordinateN(0),o=null,s=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getLinearRing(),h=l.getEnvelopeInternal();if(!h.equals(r)&&h.contains(r)){i=Wt.ptNotInList(n.getCoordinates(),l.getCoordinates());var c=!1;Oe.isInRing(i,l.getCoordinates())&&(c=!0),c&&(null===o||s.contains(h))&&(s=(o=u).getLinearRing().getEnvelopeInternal())}}return o}}]),e}(),en=function(){function e(){t(this,e)}return n(e,[{key:"getBounds",value:function(){}}]),e}(),nn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getItem",value:function(){return this._item}},{key:"getBounds",value:function(){return this._bounds}},{key:"interfaces_",get:function(){return[en,w]}}],[{key:"constructor_",value:function(){this._bounds=null,this._item=null;var t=arguments[0],e=arguments[1];this._bounds=t,this._item=e}}]),e}(),rn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"poll",value:function(){if(this.isEmpty())return null;var t=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),t}},{key:"size",value:function(){return this._size}},{key:"reorder",value:function(t){for(var e=null,n=this._items.get(t);2*t<=this._size&&((e=2*t)!==this._size&&this._items.get(e+1).compareTo(this._items.get(e))<0&&e++,this._items.get(e).compareTo(n)<0);t=e)this._items.set(t,this._items.get(e));this._items.set(t,n)}},{key:"clear",value:function(){this._size=0,this._items.clear()}},{key:"peek",value:function(){return this.isEmpty()?null:this._items.get(1)}},{key:"isEmpty",value:function(){return 0===this._size}},{key:"add",value:function(t){this._items.add(null),this._size+=1;var e=this._size;for(this._items.set(0,t);t.compareTo(this._items.get(Math.trunc(e/2)))<0;e/=2)this._items.set(e,this._items.get(Math.trunc(e/2)));this._items.set(e,t)}}],[{key:"constructor_",value:function(){this._size=null,this._items=null,this._size=0,this._items=new dt,this._items.add(null)}}]),e}(),on=function(){function e(){t(this,e)}return n(e,[{key:"insert",value:function(t,e){}},{key:"remove",value:function(t,e){}},{key:"query",value:function(){}}]),e}(),sn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getLevel",value:function(){return this._level}},{key:"size",value:function(){return this._childBoundables.size()}},{key:"getChildBoundables",value:function(){return this._childBoundables}},{key:"addChildBoundable",value:function(t){V.isTrue(null===this._bounds),this._childBoundables.add(t)}},{key:"isEmpty",value:function(){return this._childBoundables.isEmpty()}},{key:"getBounds",value:function(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds}},{key:"interfaces_",get:function(){return[en,w]}}],[{key:"constructor_",value:function(){if(this._childBoundables=new dt,this._bounds=null,this._level=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this._level=t}}}]),e}(),an={reverseOrder:function(){return{compare:function(t,e){return e.compareTo(t)}}},min:function(t){return an.sort(t),t.get(0)},sort:function(t,e){var n=t.toArray();e?At.sort(n,e):At.sort(n);for(var r=t.iterator(),i=0,o=n.length;i<o;i++)r.next(),r.set(n[i])},singletonList:function(t){var e=new dt;return e.add(t),e}},un=function(){function e(){t(this,e)}return n(e,null,[{key:"maxDistance",value:function(t,n,r,i,o,s,a,u){var l=e.distance(t,n,o,s);return l=Math.max(l,e.distance(t,n,a,u)),l=Math.max(l,e.distance(r,i,o,s)),Math.max(l,e.distance(r,i,a,u))}},{key:"distance",value:function(t,e,n,r){var i=n-t,o=r-e;return Math.sqrt(i*i+o*o)}},{key:"maximumDistance",value:function(t,n){var r=Math.min(t.getMinX(),n.getMinX()),i=Math.min(t.getMinY(),n.getMinY()),o=Math.max(t.getMaxX(),n.getMaxX()),s=Math.max(t.getMaxY(),n.getMaxY());return e.distance(r,i,o,s)}},{key:"minMaxDistance",value:function(t,n){var r=t.getMinX(),i=t.getMinY(),o=t.getMaxX(),s=t.getMaxY(),a=n.getMinX(),u=n.getMinY(),l=n.getMaxX(),h=n.getMaxY(),c=e.maxDistance(r,i,r,s,a,u,a,h);return c=Math.min(c,e.maxDistance(r,i,r,s,a,u,l,u)),c=Math.min(c,e.maxDistance(r,i,r,s,l,h,a,h)),c=Math.min(c,e.maxDistance(r,i,r,s,l,h,l,u)),c=Math.min(c,e.maxDistance(r,i,o,i,a,u,a,h)),c=Math.min(c,e.maxDistance(r,i,o,i,a,u,l,u)),c=Math.min(c,e.maxDistance(r,i,o,i,l,h,a,h)),c=Math.min(c,e.maxDistance(r,i,o,i,l,h,l,u)),c=Math.min(c,e.maxDistance(o,s,r,s,a,u,a,h)),c=Math.min(c,e.maxDistance(o,s,r,s,a,u,l,u)),c=Math.min(c,e.maxDistance(o,s,r,s,l,h,a,h)),c=Math.min(c,e.maxDistance(o,s,r,s,l,h,l,u)),c=Math.min(c,e.maxDistance(o,s,o,i,a,u,a,h)),c=Math.min(c,e.maxDistance(o,s,o,i,a,u,l,u)),c=Math.min(c,e.maxDistance(o,s,o,i,l,h,a,h)),Math.min(c,e.maxDistance(o,s,o,i,l,h,l,u))}}]),e}(),ln=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"maximumDistance",value:function(){return un.maximumDistance(this._boundable1.getBounds(),this._boundable2.getBounds())}},{key:"expandToQueue",value:function(t,n){var r=e.isComposite(this._boundable1),i=e.isComposite(this._boundable2);if(r&&i)return e.area(this._boundable1)>e.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,!1,t,n),null):(this.expand(this._boundable2,this._boundable1,!0,t,n),null);if(r)return this.expand(this._boundable1,this._boundable2,!1,t,n),null;if(i)return this.expand(this._boundable2,this._boundable1,!0,t,n),null;throw new x("neither boundable is composite")}},{key:"isLeaves",value:function(){return!(e.isComposite(this._boundable1)||e.isComposite(this._boundable2))}},{key:"compareTo",value:function(t){var e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0}},{key:"expand",value:function(t,n,r,i,o){for(var s=t.getChildBoundables().iterator();s.hasNext();){var a=s.next(),u=null;(u=r?new e(n,a,this._itemDistance):new e(a,n,this._itemDistance)).getDistance()<o&&i.add(u)}}},{key:"getBoundable",value:function(t){return 0===t?this._boundable1:this._boundable2}},{key:"getDistance",value:function(){return this._distance}},{key:"distance",value:function(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())}},{key:"interfaces_",get:function(){return[k]}}],[{key:"constructor_",value:function(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;var t=arguments[0],e=arguments[1],n=arguments[2];this._boundable1=t,this._boundable2=e,this._itemDistance=n,this._distance=this.distance()}},{key:"area",value:function(t){return t.getBounds().getArea()}},{key:"isComposite",value:function(t){return t instanceof sn}}]),e}(),hn=function(){function e(){t(this,e)}return n(e,[{key:"visitItem",value:function(t){}}]),e}(),cn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"queryInternal",value:function(){if(ot(arguments[2],hn)&&arguments[0]instanceof Object&&arguments[1]instanceof sn)for(var t=arguments[0],e=arguments[2],n=arguments[1].getChildBoundables(),r=0;r<n.size();r++){var i=n.get(r);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof sn?this.queryInternal(t,i,e):i instanceof nn?e.visitItem(i.getItem()):V.shouldNeverReachHere())}else if(ot(arguments[2],rt)&&arguments[0]instanceof Object&&arguments[1]instanceof sn)for(var o=arguments[0],s=arguments[2],a=arguments[1].getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),o)&&(l instanceof sn?this.queryInternal(o,l,s):l instanceof nn?s.add(l.getItem()):V.shouldNeverReachHere())}}},{key:"getNodeCapacity",value:function(){return this._nodeCapacity}},{key:"lastNode",value:function(t){return t.get(t.size()-1)}},{key:"size",value:function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){for(var t=0,e=arguments[0].getChildBoundables().iterator();e.hasNext();){var n=e.next();n instanceof sn?t+=this.size(n):n instanceof nn&&(t+=1)}return t}}},{key:"removeItem",value:function(t,e){for(var n=null,r=t.getChildBoundables().iterator();r.hasNext();){var i=r.next();i instanceof nn&&i.getItem()===e&&(n=i)}return null!==n&&(t.getChildBoundables().remove(n),!0)}},{key:"itemsTree",value:function(){if(0===arguments.length){this.build();var t=this.itemsTree(this._root);return null===t?new dt:t}if(1===arguments.length){for(var e=arguments[0],n=new dt,r=e.getChildBoundables().iterator();r.hasNext();){var i=r.next();if(i instanceof sn){var o=this.itemsTree(i);null!==o&&n.add(o)}else i instanceof nn?n.add(i.getItem()):V.shouldNeverReachHere()}return n.size()<=0?null:n}}},{key:"insert",value:function(t,e){V.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new nn(t,e))}},{key:"boundablesAtLevel",value:function(){if(1===arguments.length){var t=arguments[0],e=new dt;return this.boundablesAtLevel(t,this._root,e),e}if(3===arguments.length){var n=arguments[0],r=arguments[1],i=arguments[2];if(V.isTrue(n>-2),r.getLevel()===n)return i.add(r),null;for(var o=r.getChildBoundables().iterator();o.hasNext();){var s=o.next();s instanceof sn?this.boundablesAtLevel(n,s,i):(V.isTrue(s instanceof nn),-1===n&&i.add(s))}return null}}},{key:"query",value:function(){if(1===arguments.length){var t=arguments[0];this.build();var e=new dt;return this.isEmpty()||this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e),e}if(2===arguments.length){var n=arguments[0],r=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),n)&&this.queryInternal(n,this._root,r)}}},{key:"build",value:function(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0}},{key:"getRoot",value:function(){return this.build(),this._root}},{key:"remove",value:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.remove(t,this._root,e)}if(3===arguments.length){var n=arguments[0],r=arguments[1],i=arguments[2],o=this.removeItem(r,i);if(o)return!0;for(var s=null,a=r.getChildBoundables().iterator();a.hasNext();){var u=a.next();if(this.getIntersectsOp().intersects(u.getBounds(),n)&&u instanceof sn&&(o=this.remove(n,u,i))){s=u;break}}return null!==s&&s.getChildBoundables().isEmpty()&&r.getChildBoundables().remove(s),o}}},{key:"createHigherLevels",value:function(t,e){V.isTrue(!t.isEmpty());var n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)}},{key:"depth",value:function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){for(var t=0,e=arguments[0].getChildBoundables().iterator();e.hasNext();){var n=e.next();if(n instanceof sn){var r=this.depth(n);r>t&&(t=r)}}return t+1}}},{key:"createParentBoundables",value:function(t,e){V.isTrue(!t.isEmpty());var n=new dt;n.add(this.createNode(e));var r=new dt(t);an.sort(r,this.getComparator());for(var i=r.iterator();i.hasNext();){var o=i.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(o)}return n}},{key:"isEmpty",value:function(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()}},{key:"interfaces_",get:function(){return[w]}}],[{key:"constructor_",value:function(){if(this._root=null,this._built=!1,this._itemBoundables=new dt,this._nodeCapacity=null,0===arguments.length)e.constructor_.call(this,e.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){var t=arguments[0];V.isTrue(t>1,"Node capacity must be greater than 1"),this._nodeCapacity=t}}},{key:"compareDoubles",value:function(t,e){return t>e?1:t<e?-1:0}}]),e}();cn.IntersectsOp=function(){},cn.DEFAULT_NODE_CAPACITY=10;var fn=function(){function e(){t(this,e)}return n(e,[{key:"distance",value:function(t,e){}}]),e}(),gn=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"createParentBoundablesFromVerticalSlices",value:function(t,e){V.isTrue(t.length>0);for(var n=new dt,r=0;r<t.length;r++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[r],e));return n}},{key:"nearestNeighbourK",value:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.nearestNeighbourK(t,A.POSITIVE_INFINITY,e)}if(3===arguments.length){var n=arguments[0],r=arguments[2],i=arguments[1],o=new rn;o.add(n);for(var a=new rn;!o.isEmpty()&&i>=0;){var u=o.poll(),l=u.getDistance();if(l>=i)break;u.isLeaves()?a.size()<r?a.add(u):(a.peek().getDistance()>l&&(a.poll(),a.add(u)),i=a.peek().getDistance()):u.expandToQueue(o,i)}return s.getItems(a)}}},{key:"createNode",value:function(t){return new pn(t)}},{key:"size",value:function(){return 0===arguments.length?f(i(s.prototype),"size",this).call(this):f(i(s.prototype),"size",this).apply(this,arguments)}},{key:"insert",value:function(){if(!(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof X))return f(i(s.prototype),"insert",this).apply(this,arguments);var t=arguments[0],e=arguments[1];if(t.isNull())return null;f(i(s.prototype),"insert",this).call(this,t,e)}},{key:"getIntersectsOp",value:function(){return s.intersectsOp}},{key:"verticalSlices",value:function(t,e){for(var n=Math.trunc(Math.ceil(t.size()/e)),r=new Array(e).fill(null),i=t.iterator(),o=0;o<e;o++){r[o]=new dt;for(var s=0;i.hasNext()&&s<n;){var a=i.next();r[o].add(a),s++}}return r}},{key:"query",value:function(){if(1===arguments.length){var t=arguments[0];return f(i(s.prototype),"query",this).call(this,t)}if(2===arguments.length){var e=arguments[0],n=arguments[1];f(i(s.prototype),"query",this).call(this,e,n)}}},{key:"getComparator",value:function(){return s.yComparator}},{key:"createParentBoundablesFromVerticalSlice",value:function(t,e){return f(i(s.prototype),"createParentBoundables",this).call(this,t,e)}},{key:"remove",value:function(){if(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof X){var t=arguments[0],e=arguments[1];return f(i(s.prototype),"remove",this).call(this,t,e)}return f(i(s.prototype),"remove",this).apply(this,arguments)}},{key:"depth",value:function(){return 0===arguments.length?f(i(s.prototype),"depth",this).call(this):f(i(s.prototype),"depth",this).apply(this,arguments)}},{key:"createParentBoundables",value:function(t,e){V.isTrue(!t.isEmpty());var n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),r=new dt(t);an.sort(r,s.xComparator);var i=this.verticalSlices(r,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(i,e)}},{key:"nearestNeighbour",value:function(){if(1===arguments.length){if(ot(arguments[0],fn)){var t=arguments[0];if(this.isEmpty())return null;var e=new ln(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof ln){var n=arguments[0],r=A.POSITIVE_INFINITY,i=null,o=new rn;for(o.add(n);!o.isEmpty()&&r>0;){var s=o.poll(),a=s.getDistance();if(a>=r)break;s.isLeaves()?(r=a,i=s):s.expandToQueue(o,r)}return null===i?null:[i.getBoundable(0).getItem(),i.getBoundable(1).getItem()]}}else{if(2===arguments.length){var u=arguments[0],l=arguments[1];if(this.isEmpty()||u.isEmpty())return null;var h=new ln(this.getRoot(),u.getRoot(),l);return this.nearestNeighbour(h)}if(3===arguments.length){var c=arguments[2],f=new nn(arguments[0],arguments[1]),g=new ln(this.getRoot(),f,c);return this.nearestNeighbour(g)[0]}if(4===arguments.length){var p=arguments[2],v=arguments[3],d=new nn(arguments[0],arguments[1]),y=new ln(this.getRoot(),d,p);return this.nearestNeighbourK(y,v)}}}},{key:"isWithinDistance",value:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=A.POSITIVE_INFINITY,r=new rn;for(r.add(t);!r.isEmpty();){var i=r.poll(),o=i.getDistance();if(o>e)return!1;if(i.maximumDistance()<=e)return!0;if(i.isLeaves()){if((n=o)<=e)return!0}else i.expandToQueue(r,n)}return!1}if(3===arguments.length){var s=arguments[0],a=arguments[1],u=arguments[2],l=new ln(this.getRoot(),s.getRoot(),a);return this.isWithinDistance(l,u)}}},{key:"interfaces_",get:function(){return[on,w]}}],[{key:"constructor_",value:function(){if(0===arguments.length)s.constructor_.call(this,s.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){var t=arguments[0];cn.constructor_.call(this,t)}}},{key:"centreX",value:function(t){return s.avg(t.getMinX(),t.getMaxX())}},{key:"avg",value:function(t,e){return(t+e)/2}},{key:"getItems",value:function(t){for(var e=new Array(t.size()).fill(null),n=0;!t.isEmpty();){var r=t.poll();e[n]=r.getBoundable(0).getItem(),n++}return e}},{key:"centreY",value:function(t){return s.avg(t.getMinY(),t.getMaxY())}}]),s}(cn),pn=function(e){r(o,e);var i=c(o);function o(){var e;return t(this,o),e=i.call(this),o.constructor_.apply(l(e),arguments),e}return n(o,[{key:"computeBounds",value:function(){for(var t=null,e=this.getChildBoundables().iterator();e.hasNext();){var n=e.next();null===t?t=new X(n.getBounds()):t.expandToInclude(n.getBounds())}return t}}],[{key:"constructor_",value:function(){var t=arguments[0];sn.constructor_.call(this,t)}}]),o}(sn);gn.STRtreeNode=pn,gn.xComparator=new(function(){function e(){t(this,e)}return n(e,[{key:"interfaces_",get:function(){return[D]}},{key:"compare",value:function(t,e){return cn.compareDoubles(gn.centreX(t.getBounds()),gn.centreX(e.getBounds()))}}]),e}()),gn.yComparator=new(function(){function e(){t(this,e)}return n(e,[{key:"interfaces_",get:function(){return[D]}},{key:"compare",value:function(t,e){return cn.compareDoubles(gn.centreY(t.getBounds()),gn.centreY(e.getBounds()))}}]),e}()),gn.intersectsOp=new(function(){function e(){t(this,e)}return n(e,[{key:"interfaces_",get:function(){return[IntersectsOp]}},{key:"intersects",value:function(t,e){return t.intersects(e)}}]),e}()),gn.DEFAULT_NODE_CAPACITY=10;var vn=function(){function e(){t(this,e)}return n(e,null,[{key:"relativeSign",value:function(t,e){return t<e?-1:t>e?1:0}},{key:"compare",value:function(t,n,r){if(n.equals2D(r))return 0;var i=e.relativeSign(n.x,r.x),o=e.relativeSign(n.y,r.y);switch(t){case 0:return e.compareValue(i,o);case 1:return e.compareValue(o,i);case 2:return e.compareValue(o,-i);case 3:return e.compareValue(-i,o);case 4:return e.compareValue(-i,-o);case 5:return e.compareValue(-o,-i);case 6:return e.compareValue(-o,i);case 7:return e.compareValue(i,-o)}return V.shouldNeverReachHere("invalid octant value"),0}},{key:"compareValue",value:function(t,e){return t<0?-1:t>0?1:e<0?-1:e>0?1:0}}]),e}(),dn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getCoordinate",value:function(){return this.coord}},{key:"print",value:function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)}},{key:"compareTo",value:function(t){var e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:this._isInterior?e._isInterior?vn.compare(this._segmentOctant,this.coord,e.coord):1:-1}},{key:"isEndPoint",value:function(t){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===t}},{key:"toString",value:function(){return this.segmentIndex+":"+this.coord.toString()}},{key:"isInterior",value:function(){return this._isInterior}},{key:"interfaces_",get:function(){return[k]}}],[{key:"constructor_",value:function(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;var t=arguments[0],e=arguments[1],n=arguments[2],r=arguments[3];this._segString=t,this.coord=new z(e),this.segmentIndex=n,this._segmentOctant=r,this._isInterior=!e.equals2D(t.getCoordinate(n))}}]),e}(),yn=function(){function e(){t(this,e)}return n(e,[{key:"hasNext",value:function(){}},{key:"next",value:function(){}},{key:"remove",value:function(){}}]),e}(),mn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getSplitCoordinates",value:function(){var t=new Ht;this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var r=e.next();this.addEdgeCoordinates(n,r,t),n=r}return t.toCoordinateArray()}},{key:"addCollapsedNodes",value:function(){var t=new dt;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(var e=t.iterator();e.hasNext();){var n=e.next().intValue();this.add(this._edge.getCoordinate(n),n)}}},{key:"createSplitEdgePts",value:function(t,e){var n=e.segmentIndex-t.segmentIndex+2;if(2===n)return[new z(t.coord),new z(e.coord)];var r=this._edge.getCoordinate(e.segmentIndex),i=e.isInterior()||!e.coord.equals2D(r);i||n--;var o=new Array(n).fill(null),s=0;o[s++]=new z(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)o[s++]=this._edge.getCoordinate(a);return i&&(o[s]=new z(e.coord)),o}},{key:"print",value:function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();)e.next().print(t)}},{key:"findCollapsesFromExistingVertices",value:function(t){for(var e=0;e<this._edge.size()-2;e++){var n=this._edge.getCoordinate(e);this._edge.getCoordinate(e+1);var r=this._edge.getCoordinate(e+2);n.equals2D(r)&&t.add(at.valueOf(e+1))}}},{key:"addEdgeCoordinates",value:function(t,e,n){var r=this.createSplitEdgePts(t,e);n.add(r,!1)}},{key:"iterator",value:function(){return this._nodeMap.values().iterator()}},{key:"addSplitEdges",value:function(t){this.addEndpoints(),this.addCollapsedNodes();for(var e=this.iterator(),n=e.next();e.hasNext();){var r=e.next(),i=this.createSplitEdge(n,r);t.add(i),n=r}}},{key:"findCollapseIndex",value:function(t,e,n){if(!t.coord.equals2D(e.coord))return!1;var r=e.segmentIndex-t.segmentIndex;return e.isInterior()||r--,1===r&&(n[0]=t.segmentIndex+1,!0)}},{key:"findCollapsesFromInsertedNodes",value:function(t){for(var e=new Array(1).fill(null),n=this.iterator(),r=n.next();n.hasNext();){var i=n.next();this.findCollapseIndex(r,i,e)&&t.add(at.valueOf(e[0])),r=i}}},{key:"getEdge",value:function(){return this._edge}},{key:"addEndpoints",value:function(){var t=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(t),t)}},{key:"createSplitEdge",value:function(t,e){var n=this.createSplitEdgePts(t,e);return new kn(n,this._edge.getData())}},{key:"add",value:function(t,e){var n=new dn(this._edge,t,e,this._edge.getSegmentOctant(e)),r=this._nodeMap.get(n);return null!==r?(V.isTrue(r.coord.equals2D(t),"Found equal nodes with different coordinates"),r):(this._nodeMap.put(n,n),n)}},{key:"checkSplitEdgesCorrectness",value:function(t){var e=this._edge.getCoordinates(),n=t.get(0).getCoordinate(0);if(!n.equals2D(e[0]))throw new F("bad split edge start point at "+n);var r=t.get(t.size()-1).getCoordinates(),i=r[r.length-1];if(!i.equals2D(e[e.length-1]))throw new F("bad split edge end point at "+i)}}],[{key:"constructor_",value:function(){this._nodeMap=new Ze,this._edge=null;var t=arguments[0];this._edge=t}}]),e}(),_n=function(){function e(){t(this,e)}return n(e,null,[{key:"octant",value:function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],n=arguments[1];if(0===t&&0===n)throw new x("Cannot compute the octant for point ( "+t+", "+n+" )");var r=Math.abs(t),i=Math.abs(n);return t>=0?n>=0?r>=i?0:1:r>=i?7:6:n>=0?r>=i?3:2:r>=i?4:5}if(arguments[0]instanceof z&&arguments[1]instanceof z){var o=arguments[0],s=arguments[1],a=s.x-o.x,u=s.y-o.y;if(0===a&&0===u)throw new x("Cannot compute the octant for two identical points "+o);return e.octant(a,u)}}}]),e}(),xn=function(){function e(){t(this,e)}return n(e,[{key:"getCoordinates",value:function(){}},{key:"size",value:function(){}},{key:"getCoordinate",value:function(t){}},{key:"isClosed",value:function(){}},{key:"setData",value:function(t){}},{key:"getData",value:function(){}}]),e}(),En=function(){function e(){t(this,e)}return n(e,[{key:"addIntersection",value:function(t,e){}},{key:"interfaces_",get:function(){return[xn]}}]),e}(),kn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getCoordinates",value:function(){return this._pts}},{key:"size",value:function(){return this._pts.length}},{key:"getCoordinate",value:function(t){return this._pts[t]}},{key:"isClosed",value:function(){return this._pts[0].equals(this._pts[this._pts.length-1])}},{key:"getSegmentOctant",value:function(t){return t===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))}},{key:"setData",value:function(t){this._data=t}},{key:"safeOctant",value:function(t,e){return t.equals2D(e)?0:_n.octant(t,e)}},{key:"getData",value:function(){return this._data}},{key:"addIntersection",value:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){var n=arguments[1],r=arguments[3],i=new z(arguments[0].getIntersection(r));this.addIntersection(i,n)}}},{key:"toString",value:function(){return Le.toLineString(new $t(this._pts))}},{key:"getNodeList",value:function(){return this._nodeList}},{key:"addIntersectionNode",value:function(t,e){var n=e,r=n+1;if(r<this._pts.length){var i=this._pts[r];t.equals2D(i)&&(n=r)}return this._nodeList.add(t,n)}},{key:"addIntersections",value:function(t,e,n){for(var r=0;r<t.getIntersectionNum();r++)this.addIntersection(t,e,n,r)}},{key:"interfaces_",get:function(){return[En]}}],[{key:"constructor_",value:function(){this._nodeList=new mn(this),this._pts=null,this._data=null;var t=arguments[0],e=arguments[1];this._pts=t,this._data=e}},{key:"getNodedSubstrings",value:function(){if(1===arguments.length){var t=arguments[0],n=new dt;return e.getNodedSubstrings(t,n),n}if(2===arguments.length)for(var r=arguments[1],i=arguments[0].iterator();i.hasNext();)i.next().getNodeList().addSplitEdges(r)}}]),e}(),bn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"minX",value:function(){return Math.min(this.p0.x,this.p1.x)}},{key:"orientationIndex",value:function(){if(arguments[0]instanceof e){var t=arguments[0],n=ft.index(this.p0,this.p1,t.p0),r=ft.index(this.p0,this.p1,t.p1);return n>=0&&r>=0||n<=0&&r<=0?Math.max(n,r):0}if(arguments[0]instanceof z){var i=arguments[0];return ft.index(this.p0,this.p1,i)}}},{key:"toGeometry",value:function(t){return t.createLineString([this.p0,this.p1])}},{key:"isVertical",value:function(){return this.p0.x===this.p1.x}},{key:"equals",value:function(t){if(!(t instanceof e))return!1;var n=t;return this.p0.equals(n.p0)&&this.p1.equals(n.p1)}},{key:"intersection",value:function(t){var e=new Ce;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null}},{key:"project",value:function(){if(arguments[0]instanceof z){var t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new z(t);var n=this.projectionFactor(t),r=new z;return r.x=this.p0.x+n*(this.p1.x-this.p0.x),r.y=this.p0.y+n*(this.p1.y-this.p0.y),r}if(arguments[0]instanceof e){var i=arguments[0],o=this.projectionFactor(i.p0),s=this.projectionFactor(i.p1);if(o>=1&&s>=1)return null;if(o<=0&&s<=0)return null;var a=this.project(i.p0);o<0&&(a=this.p0),o>1&&(a=this.p1);var u=this.project(i.p1);return s<0&&(u=this.p0),s>1&&(u=this.p1),new e(a,u)}}},{key:"normalize",value:function(){this.p1.compareTo(this.p0)<0&&this.reverse()}},{key:"angle",value:function(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}},{key:"getCoordinate",value:function(t){return 0===t?this.p0:this.p1}},{key:"distancePerpendicular",value:function(t){return kt.pointToLinePerpendicular(t,this.p0,this.p1)}},{key:"minY",value:function(){return Math.min(this.p0.y,this.p1.y)}},{key:"midPoint",value:function(){return e.midPoint(this.p0,this.p1)}},{key:"projectionFactor",value:function(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;var e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,r=e*e+n*n;return r<=0?A.NaN:((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/r}},{key:"closestPoints",value:function(t){var e=this.intersection(t);if(null!==e)return[e,e];var n=new Array(2).fill(null),r=A.MAX_VALUE,i=null,o=this.closestPoint(t.p0);r=o.distance(t.p0),n[0]=o,n[1]=t.p0;var s=this.closestPoint(t.p1);(i=s.distance(t.p1))<r&&(r=i,n[0]=s,n[1]=t.p1);var a=t.closestPoint(this.p0);(i=a.distance(this.p0))<r&&(r=i,n[0]=this.p0,n[1]=a);var u=t.closestPoint(this.p1);return(i=u.distance(this.p1))<r&&(r=i,n[0]=this.p1,n[1]=u),n}},{key:"closestPoint",value:function(t){var e=this.projectionFactor(t);return e>0&&e<1?this.project(t):this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}},{key:"maxX",value:function(){return Math.max(this.p0.x,this.p1.x)}},{key:"getLength",value:function(){return this.p0.distance(this.p1)}},{key:"compareTo",value:function(t){var e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)}},{key:"reverse",value:function(){var t=this.p0;this.p0=this.p1,this.p1=t}},{key:"equalsTopo",value:function(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}},{key:"lineIntersection",value:function(t){return _t.intersection(this.p0,this.p1,t.p0,t.p1)}},{key:"maxY",value:function(){return Math.max(this.p0.y,this.p1.y)}},{key:"pointAlongOffset",value:function(t,e){var n=this.p0.x+t*(this.p1.x-this.p0.x),r=this.p0.y+t*(this.p1.y-this.p0.y),i=this.p1.x-this.p0.x,o=this.p1.y-this.p0.y,s=Math.sqrt(i*i+o*o),a=0,u=0;if(0!==e){if(s<=0)throw new IllegalStateException("Cannot compute offset from zero-length line segment");a=e*i/s,u=e*o/s}return new z(n-u,r+a)}},{key:"setCoordinates",value:function(){if(1===arguments.length){var t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0.x=e.x,this.p0.y=e.y,this.p1.x=n.x,this.p1.y=n.y}}},{key:"segmentFraction",value:function(t){var e=this.projectionFactor(t);return e<0?e=0:(e>1||A.isNaN(e))&&(e=1),e}},{key:"toString",value:function(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}},{key:"isHorizontal",value:function(){return this.p0.y===this.p1.y}},{key:"reflect",value:function(t){var e=this.p1.getY()-this.p0.getY(),n=this.p0.getX()-this.p1.getX(),r=this.p0.getY()*(this.p1.getX()-this.p0.getX())-this.p0.getX()*(this.p1.getY()-this.p0.getY()),i=e*e+n*n,o=e*e-n*n,s=t.getX(),a=t.getY();return new z((-o*s-2*e*n*a-2*e*r)/i,(o*a-2*e*n*s-2*n*r)/i)}},{key:"distance",value:function(){if(arguments[0]instanceof e){var t=arguments[0];return kt.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof z){var n=arguments[0];return kt.pointToSegment(n,this.p0,this.p1)}}},{key:"pointAlong",value:function(t){var e=new z;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e}},{key:"hashCode",value:function(){var t=A.doubleToLongBits(this.p0.x);t^=31*A.doubleToLongBits(this.p0.y);var e=Math.trunc(t)^Math.trunc(t>>32),n=A.doubleToLongBits(this.p1.x);return n^=31*A.doubleToLongBits(this.p1.y),e^Math.trunc(n)^Math.trunc(n>>32)}},{key:"interfaces_",get:function(){return[k,w]}}],[{key:"constructor_",value:function(){if(this.p0=null,this.p1=null,0===arguments.length)e.constructor_.call(this,new z,new z);else if(1===arguments.length){var t=arguments[0];e.constructor_.call(this,t.p0,t.p1)}else if(2===arguments.length){var n=arguments[0],r=arguments[1];this.p0=n,this.p1=r}else if(4===arguments.length){var i=arguments[0],o=arguments[1],s=arguments[2],a=arguments[3];e.constructor_.call(this,new z(i,o),new z(s,a))}}},{key:"midPoint",value:function(t,e){return new z((t.x+e.x)/2,(t.y+e.y)/2)}}]),e}(),wn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"overlap",value:function(){if(2===arguments.length);else if(4===arguments.length){var t=arguments[1],e=arguments[2],n=arguments[3];arguments[0].getLineSegment(t,this._overlapSeg1),e.getLineSegment(n,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}}}],[{key:"constructor_",value:function(){this._overlapSeg1=new bn,this._overlapSeg2=new bn}}]),e}(),In=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getLineSegment",value:function(t,e){e.p0=this._pts[t],e.p1=this._pts[t+1]}},{key:"computeSelect",value:function(t,e,n,r){var i=this._pts[e],o=this._pts[n];if(n-e==1)return r.select(this,e),null;if(!t.intersects(i,o))return null;var s=Math.trunc((e+n)/2);e<s&&this.computeSelect(t,e,s,r),s<n&&this.computeSelect(t,s,n,r)}},{key:"getCoordinates",value:function(){for(var t=new Array(this._end-this._start+1).fill(null),e=0,n=this._start;n<=this._end;n++)t[e++]=this._pts[n];return t}},{key:"computeOverlaps",value:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.computeOverlaps(this._start,this._end,t,t._start,t._end,e)}else if(6===arguments.length){var n=arguments[0],r=arguments[1],i=arguments[2],o=arguments[3],s=arguments[4],a=arguments[5];if(r-n==1&&s-o==1)return a.overlap(this,n,i,o),null;if(!this.overlaps(n,r,i,o,s))return null;var u=Math.trunc((n+r)/2),l=Math.trunc((o+s)/2);n<u&&(o<l&&this.computeOverlaps(n,u,i,o,l,a),l<s&&this.computeOverlaps(n,u,i,l,s,a)),u<r&&(o<l&&this.computeOverlaps(u,r,i,o,l,a),l<s&&this.computeOverlaps(u,r,i,l,s,a))}}},{key:"setId",value:function(t){this._id=t}},{key:"select",value:function(t,e){this.computeSelect(t,this._start,this._end,e)}},{key:"getEnvelope",value:function(){if(null===this._env){var t=this._pts[this._start],e=this._pts[this._end];this._env=new X(t,e)}return this._env}},{key:"overlaps",value:function(t,e,n,r,i){return X.intersects(this._pts[t],this._pts[e],n._pts[r],n._pts[i])}},{key:"getEndIndex",value:function(){return this._end}},{key:"getStartIndex",value:function(){return this._start}},{key:"getContext",value:function(){return this._context}},{key:"getId",value:function(){return this._id}}],[{key:"constructor_",value:function(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;var t=arguments[0],e=arguments[1],n=arguments[2],r=arguments[3];this._pts=t,this._start=e,this._end=n,this._context=r}}]),e}(),Nn=function(){function e(){t(this,e)}return n(e,null,[{key:"findChainEnd",value:function(t,e){for(var n=e;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;for(var r=We.quadrant(t[n],t[n+1]),i=e+1;i<t.length&&(t[i-1].equals2D(t[i])||We.quadrant(t[i-1],t[i])===r);)i++;return i-1}},{key:"getChains",value:function(){if(1===arguments.length){var t=arguments[0];return e.getChains(t,null)}if(2===arguments.length){var n=arguments[0],r=arguments[1],i=new dt,o=0;do{var s=e.findChainEnd(n,o),a=new In(n,o,s,r);i.add(a),o=s}while(o<n.length-1);return i}}}]),e}(),Sn=function(){function e(){t(this,e)}return n(e,[{key:"computeNodes",value:function(t){}},{key:"getNodedSubstrings",value:function(){}}]),e}(),Mn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"setSegmentIntersector",value:function(t){this._segInt=t}},{key:"interfaces_",get:function(){return[Sn]}}],[{key:"constructor_",value:function(){if(this._segInt=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setSegmentIntersector(t)}}}]),e}(),Ln=function(e){r(o,e);var i=c(o);function o(){var e;return t(this,o),e=i.call(this),o.constructor_.apply(l(e),arguments),e}return n(o,[{key:"getMonotoneChains",value:function(){return this._monoChains}},{key:"getNodedSubstrings",value:function(){return kn.getNodedSubstrings(this._nodedSegStrings)}},{key:"getIndex",value:function(){return this._index}},{key:"add",value:function(t){for(var e=Nn.getChains(t.getCoordinates(),t).iterator();e.hasNext();){var n=e.next();n.setId(this._idCounter++),this._index.insert(n.getEnvelope(),n),this._monoChains.add(n)}}},{key:"computeNodes",value:function(t){this._nodedSegStrings=t;for(var e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()}},{key:"intersectChains",value:function(){for(var t=new Pn(this._segInt),e=this._monoChains.iterator();e.hasNext();)for(var n=e.next(),r=this._index.query(n.getEnvelope()).iterator();r.hasNext();){var i=r.next();if(i.getId()>n.getId()&&(n.computeOverlaps(i,t),this._nOverlaps++),this._segInt.isDone())return null}}}],[{key:"constructor_",value:function(){if(this._monoChains=new dt,this._index=new gn,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0,0===arguments.length);else if(1===arguments.length){var t=arguments[0];Mn.constructor_.call(this,t)}}}]),o}(Mn),Pn=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"overlap",value:function(){if(4!==arguments.length)return f(i(s.prototype),"overlap",this).apply(this,arguments);var t=arguments[1],e=arguments[2],n=arguments[3],r=arguments[0].getContext(),o=e.getContext();this._si.processIntersections(r,t,o,n)}}],[{key:"constructor_",value:function(){this._si=null;var t=arguments[0];this._si=t}}]),s}(wn);Ln.SegmentOverlapAction=Pn;var Cn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"isDeletable",value:function(t,e,n,r){var i=this._inputLine[t],o=this._inputLine[e],s=this._inputLine[n];return!!this.isConcave(i,o,s)&&!!this.isShallow(i,o,s,r)&&this.isShallowSampled(i,o,t,n,r)}},{key:"deleteShallowConcavities",value:function(){for(var t=1,n=this.findNextNonDeletedIndex(t),r=this.findNextNonDeletedIndex(n),i=!1;r<this._inputLine.length;){var o=!1;this.isDeletable(t,n,r,this._distanceTol)&&(this._isDeleted[n]=e.DELETE,o=!0,i=!0),t=o?r:n,n=this.findNextNonDeletedIndex(t),r=this.findNextNonDeletedIndex(n)}return i}},{key:"isShallowConcavity",value:function(t,e,n,r){return ft.index(t,e,n)===this._angleOrientation&&kt.pointToSegment(e,t,n)<r}},{key:"isShallowSampled",value:function(t,n,r,i,o){var s=Math.trunc((i-r)/e.NUM_PTS_TO_CHECK);s<=0&&(s=1);for(var a=r;a<i;a+=s)if(!this.isShallow(t,n,this._inputLine[a],o))return!1;return!0}},{key:"isConcave",value:function(t,e,n){return ft.index(t,e,n)===this._angleOrientation}},{key:"simplify",value:function(t){this._distanceTol=Math.abs(t),t<0&&(this._angleOrientation=ft.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);var e=!1;do{e=this.deleteShallowConcavities()}while(e);return this.collapseLine()}},{key:"findNextNonDeletedIndex",value:function(t){for(var n=t+1;n<this._inputLine.length&&this._isDeleted[n]===e.DELETE;)n++;return n}},{key:"isShallow",value:function(t,e,n,r){return kt.pointToSegment(e,t,n)<r}},{key:"collapseLine",value:function(){for(var t=new Ht,n=0;n<this._inputLine.length;n++)this._isDeleted[n]!==e.DELETE&&t.add(this._inputLine[n]);return t.toCoordinateArray()}}],[{key:"constructor_",value:function(){this._inputLine=null,this._distanceTol=null,this._isDeleted=null,this._angleOrientation=ft.COUNTERCLOCKWISE;var t=arguments[0];this._inputLine=t}},{key:"simplify",value:function(t,n){return new e(t).simplify(n)}}]),e}();Cn.INIT=0,Cn.DELETE=1,Cn.KEEP=1,Cn.NUM_PTS_TO_CHECK=10;var Tn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getCoordinates",value:function(){return this._ptList.toArray(e.COORDINATE_ARRAY_TYPE)}},{key:"setPrecisionModel",value:function(t){this._precisionModel=t}},{key:"addPt",value:function(t){var e=new z(t);if(this._precisionModel.makePrecise(e),this.isRedundant(e))return null;this._ptList.add(e)}},{key:"reverse",value:function(){}},{key:"addPts",value:function(t,e){if(e)for(var n=0;n<t.length;n++)this.addPt(t[n]);else for(var r=t.length-1;r>=0;r--)this.addPt(t[r])}},{key:"isRedundant",value:function(t){if(this._ptList.size()<1)return!1;var e=this._ptList.get(this._ptList.size()-1);return t.distance(e)<this._minimimVertexDistance}},{key:"toString",value:function(){return(new ae).createLineString(this.getCoordinates()).toString()}},{key:"closeRing",value:function(){if(this._ptList.size()<1)return null;var t=new z(this._ptList.get(0)),e=this._ptList.get(this._ptList.size()-1);if(t.equals(e))return null;this._ptList.add(t)}},{key:"setMinimumVertexDistance",value:function(t){this._minimimVertexDistance=t}}],[{key:"constructor_",value:function(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new dt}}]),e}();Tn.COORDINATE_ARRAY_TYPE=new Array(0).fill(null);var On=function(){function e(){t(this,e)}return n(e,null,[{key:"toDegrees",value:function(t){return 180*t/Math.PI}},{key:"normalize",value:function(t){for(;t>Math.PI;)t-=e.PI_TIMES_2;for(;t<=-Math.PI;)t+=e.PI_TIMES_2;return t}},{key:"angle",value:function(){if(1===arguments.length){var t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){var e=arguments[0],n=arguments[1],r=n.x-e.x,i=n.y-e.y;return Math.atan2(i,r)}}},{key:"isAcute",value:function(t,e,n){var r=t.x-e.x,i=t.y-e.y;return r*(n.x-e.x)+i*(n.y-e.y)>0}},{key:"isObtuse",value:function(t,e,n){var r=t.x-e.x,i=t.y-e.y;return r*(n.x-e.x)+i*(n.y-e.y)<0}},{key:"interiorAngle",value:function(t,n,r){var i=e.angle(n,t),o=e.angle(n,r);return Math.abs(o-i)}},{key:"normalizePositive",value:function(t){if(t<0){for(;t<0;)t+=e.PI_TIMES_2;t>=e.PI_TIMES_2&&(t=0)}else{for(;t>=e.PI_TIMES_2;)t-=e.PI_TIMES_2;t<0&&(t=0)}return t}},{key:"angleBetween",value:function(t,n,r){var i=e.angle(n,t),o=e.angle(n,r);return e.diff(i,o)}},{key:"diff",value:function(t,e){var n=null;return(n=t<e?e-t:t-e)>Math.PI&&(n=2*Math.PI-n),n}},{key:"toRadians",value:function(t){return t*Math.PI/180}},{key:"getTurn",value:function(t,n){var r=Math.sin(n-t);return r>0?e.COUNTERCLOCKWISE:r<0?e.CLOCKWISE:e.NONE}},{key:"angleBetweenOriented",value:function(t,n,r){var i=e.angle(n,t),o=e.angle(n,r)-i;return o<=-Math.PI?o+e.PI_TIMES_2:o>Math.PI?o-e.PI_TIMES_2:o}}]),e}();On.PI_TIMES_2=2*Math.PI,On.PI_OVER_2=Math.PI/2,On.PI_OVER_4=Math.PI/4,On.COUNTERCLOCKWISE=ft.COUNTERCLOCKWISE,On.CLOCKWISE=ft.CLOCKWISE,On.NONE=ft.COLLINEAR;var Rn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"addNextSegment",value:function(t,e){if(this._s0=this._s1,this._s1=this._s2,this._s2=t,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;var n=ft.index(this._s0,this._s1,this._s2),r=n===ft.CLOCKWISE&&this._side===tt.LEFT||n===ft.COUNTERCLOCKWISE&&this._side===tt.RIGHT;0===n?this.addCollinear(e):r?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)}},{key:"addLineEndCap",value:function(t,e){var n=new bn(t,e),r=new bn;this.computeOffsetSegment(n,tt.LEFT,this._distance,r);var i=new bn;this.computeOffsetSegment(n,tt.RIGHT,this._distance,i);var o=e.x-t.x,s=e.y-t.y,a=Math.atan2(s,o);switch(this._bufParams.getEndCapStyle()){case y.CAP_ROUND:this._segList.addPt(r.p1),this.addDirectedFillet(e,a+Math.PI/2,a-Math.PI/2,ft.CLOCKWISE,this._distance),this._segList.addPt(i.p1);break;case y.CAP_FLAT:this._segList.addPt(r.p1),this._segList.addPt(i.p1);break;case y.CAP_SQUARE:var u=new z;u.x=Math.abs(this._distance)*Math.cos(a),u.y=Math.abs(this._distance)*Math.sin(a);var l=new z(r.p1.x+u.x,r.p1.y+u.y),h=new z(i.p1.x+u.x,i.p1.y+u.y);this._segList.addPt(l),this._segList.addPt(h)}}},{key:"getCoordinates",value:function(){return this._segList.getCoordinates()}},{key:"addMitreJoin",value:function(t,e,n,r){var i=_t.intersection(e.p0,e.p1,n.p0,n.p1);if(null!==i&&(r<=0?1:i.distance(t)/Math.abs(r))<=this._bufParams.getMitreLimit())return this._segList.addPt(i),null;this.addLimitedMitreJoin(e,n,r,this._bufParams.getMitreLimit())}},{key:"addOutsideTurn",value:function(t,n){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*e.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===y.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===y.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(n&&this._segList.addPt(this._offset0.p1),this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,t,this._distance),this._segList.addPt(this._offset1.p0))}},{key:"createSquare",value:function(t){this._segList.addPt(new z(t.x+this._distance,t.y+this._distance)),this._segList.addPt(new z(t.x+this._distance,t.y-this._distance)),this._segList.addPt(new z(t.x-this._distance,t.y-this._distance)),this._segList.addPt(new z(t.x-this._distance,t.y+this._distance)),this._segList.closeRing()}},{key:"addSegments",value:function(t,e){this._segList.addPts(t,e)}},{key:"addFirstSegment",value:function(){this._segList.addPt(this._offset1.p0)}},{key:"addCornerFillet",value:function(t,e,n,r,i){var o=e.x-t.x,s=e.y-t.y,a=Math.atan2(s,o),u=n.x-t.x,l=n.y-t.y,h=Math.atan2(l,u);r===ft.CLOCKWISE?a<=h&&(a+=2*Math.PI):a>=h&&(a-=2*Math.PI),this._segList.addPt(e),this.addDirectedFillet(t,a,h,r,i),this._segList.addPt(n)}},{key:"addLastSegment",value:function(){this._segList.addPt(this._offset1.p1)}},{key:"initSideSegments",value:function(t,e,n){this._s1=t,this._s2=e,this._side=n,this._seg1.setCoordinates(t,e),this.computeOffsetSegment(this._seg1,n,this._distance,this._offset1)}},{key:"addLimitedMitreJoin",value:function(t,e,n,r){var i=this._seg0.p1,o=On.angle(i,this._seg0.p0),s=On.angleBetweenOriented(this._seg0.p0,i,this._seg1.p1)/2,a=On.normalize(o+s),u=On.normalize(a+Math.PI),l=r*n,h=n-l*Math.abs(Math.sin(s)),c=i.x+l*Math.cos(u),f=i.y+l*Math.sin(u),g=new z(c,f),p=new bn(i,g),v=p.pointAlongOffset(1,h),d=p.pointAlongOffset(1,-h);this._side===tt.LEFT?(this._segList.addPt(v),this._segList.addPt(d)):(this._segList.addPt(d),this._segList.addPt(v))}},{key:"addDirectedFillet",value:function(t,e,n,r,i){var o=r===ft.CLOCKWISE?-1:1,s=Math.abs(e-n),a=Math.trunc(s/this._filletAngleQuantum+.5);if(a<1)return null;for(var u=s/a,l=new z,h=0;h<a;h++){var c=e+o*h*u;l.x=t.x+i*Math.cos(c),l.y=t.y+i*Math.sin(c),this._segList.addPt(l)}}},{key:"computeOffsetSegment",value:function(t,e,n,r){var i=e===tt.LEFT?1:-1,o=t.p1.x-t.p0.x,s=t.p1.y-t.p0.y,a=Math.sqrt(o*o+s*s),u=i*n*o/a,l=i*n*s/a;r.p0.x=t.p0.x-l,r.p0.y=t.p0.y+u,r.p1.x=t.p1.x-l,r.p1.y=t.p1.y+u}},{key:"addInsideTurn",value:function(t,n){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*e.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){var r=new z((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(r);var i=new z((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(i)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}}},{key:"createCircle",value:function(t){var e=new z(t.x+this._distance,t.y);this._segList.addPt(e),this.addDirectedFillet(t,0,2*Math.PI,-1,this._distance),this._segList.closeRing()}},{key:"addBevelJoin",value:function(t,e){this._segList.addPt(t.p1),this._segList.addPt(e.p0)}},{key:"init",value:function(t){this._distance=t,this._maxCurveSegmentError=t*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new Tn,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(t*e.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)}},{key:"addCollinear",value:function(t){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2),this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===y.JOIN_BEVEL||this._bufParams.getJoinStyle()===y.JOIN_MITRE?(t&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,ft.CLOCKWISE,this._distance))}},{key:"closeRing",value:function(){this._segList.closeRing()}},{key:"hasNarrowConcaveAngle",value:function(){return this._hasNarrowConcaveAngle}}],[{key:"constructor_",value:function(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new bn,this._seg1=new bn,this._offset0=new bn,this._offset1=new bn,this._side=0,this._hasNarrowConcaveAngle=!1;var t=arguments[0],n=arguments[1],r=arguments[2];this._precisionModel=t,this._bufParams=n,this._li=new Ce,this._filletAngleQuantum=Math.PI/2/n.getQuadrantSegments(),n.getQuadrantSegments()>=8&&n.getJoinStyle()===y.JOIN_ROUND&&(this._closingSegLengthFactor=e.MAX_CLOSING_SEG_LEN_FACTOR),this.init(r)}}]),e}();Rn.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,Rn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,Rn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,Rn.MAX_CLOSING_SEG_LEN_FACTOR=80;var An=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getOffsetCurve",value:function(t,e){if(this._distance=e,0===e)return null;var n=e<0,r=Math.abs(e),i=this.getSegGen(r);t.length<=1?this.computePointCurve(t[0],i):this.computeOffsetCurve(t,n,i);var o=i.getCoordinates();return n&&Wt.reverse(o),o}},{key:"computeSingleSidedBufferCurve",value:function(t,e,n){var r=this.simplifyTolerance(this._distance);if(e){n.addSegments(t,!0);var i=Cn.simplify(t,-r),o=i.length-1;n.initSideSegments(i[o],i[o-1],tt.LEFT),n.addFirstSegment();for(var s=o-2;s>=0;s--)n.addNextSegment(i[s],!0)}else{n.addSegments(t,!1);var a=Cn.simplify(t,r),u=a.length-1;n.initSideSegments(a[0],a[1],tt.LEFT),n.addFirstSegment();for(var l=2;l<=u;l++)n.addNextSegment(a[l],!0)}n.addLastSegment(),n.closeRing()}},{key:"computeRingBufferCurve",value:function(t,e,n){var r=this.simplifyTolerance(this._distance);e===tt.RIGHT&&(r=-r);var i=Cn.simplify(t,r),o=i.length-1;n.initSideSegments(i[o-1],i[0],e);for(var s=1;s<=o;s++){var a=1!==s;n.addNextSegment(i[s],a)}n.closeRing()}},{key:"computeLineBufferCurve",value:function(t,e){var n=this.simplifyTolerance(this._distance),r=Cn.simplify(t,n),i=r.length-1;e.initSideSegments(r[0],r[1],tt.LEFT);for(var o=2;o<=i;o++)e.addNextSegment(r[o],!0);e.addLastSegment(),e.addLineEndCap(r[i-1],r[i]);var s=Cn.simplify(t,-n),a=s.length-1;e.initSideSegments(s[a],s[a-1],tt.LEFT);for(var u=a-2;u>=0;u--)e.addNextSegment(s[u],!0);e.addLastSegment(),e.addLineEndCap(s[1],s[0]),e.closeRing()}},{key:"computePointCurve",value:function(t,e){switch(this._bufParams.getEndCapStyle()){case y.CAP_ROUND:e.createCircle(t);break;case y.CAP_SQUARE:e.createSquare(t)}}},{key:"getLineCurve",value:function(t,e){if(this._distance=e,this.isLineOffsetEmpty(e))return null;var n=Math.abs(e),r=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],r);else if(this._bufParams.isSingleSided()){var i=e<0;this.computeSingleSidedBufferCurve(t,i,r)}else this.computeLineBufferCurve(t,r);return r.getCoordinates()}},{key:"getBufferParameters",value:function(){return this._bufParams}},{key:"simplifyTolerance",value:function(t){return t*this._bufParams.getSimplifyFactor()}},{key:"getRingCurve",value:function(t,n,r){if(this._distance=r,t.length<=2)return this.getLineCurve(t,r);if(0===r)return e.copyCoordinates(t);var i=this.getSegGen(r);return this.computeRingBufferCurve(t,n,i),i.getCoordinates()}},{key:"computeOffsetCurve",value:function(t,e,n){var r=this.simplifyTolerance(this._distance);if(e){var i=Cn.simplify(t,-r),o=i.length-1;n.initSideSegments(i[o],i[o-1],tt.LEFT),n.addFirstSegment();for(var s=o-2;s>=0;s--)n.addNextSegment(i[s],!0)}else{var a=Cn.simplify(t,r),u=a.length-1;n.initSideSegments(a[0],a[1],tt.LEFT),n.addFirstSegment();for(var l=2;l<=u;l++)n.addNextSegment(a[l],!0)}n.addLastSegment()}},{key:"isLineOffsetEmpty",value:function(t){return 0===t||t<0&&!this._bufParams.isSingleSided()}},{key:"getSegGen",value:function(t){return new Rn(this._precisionModel,this._bufParams,t)}}],[{key:"constructor_",value:function(){this._distance=0,this._precisionModel=null,this._bufParams=null;var t=arguments[0],e=arguments[1];this._precisionModel=t,this._bufParams=e}},{key:"copyCoordinates",value:function(t){for(var e=new Array(t.length).fill(null),n=0;n<e.length;n++)e[n]=new z(t[n]);return e}}]),e}(),Dn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"findStabbedSegments",value:function(){if(1===arguments.length){for(var t=arguments[0],e=new dt,n=this._subgraphs.iterator();n.hasNext();){var r=n.next(),i=r.getEnvelope();t.y<i.getMinY()||t.y>i.getMaxY()||this.findStabbedSegments(t,r.getDirectedEdges(),e)}return e}if(3===arguments.length)if(ot(arguments[2],rt)&&arguments[0]instanceof z&&arguments[1]instanceof Ke){for(var o=arguments[0],s=arguments[1],a=arguments[2],u=s.getEdge().getCoordinates(),l=0;l<u.length-1;l++)if(this._seg.p0=u[l],this._seg.p1=u[l+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse(),!(Math.max(this._seg.p0.x,this._seg.p1.x)<o.x||this._seg.isHorizontal()||o.y<this._seg.p0.y||o.y>this._seg.p1.y||ft.index(this._seg.p0,this._seg.p1,o)===ft.RIGHT)){var h=s.getDepth(tt.LEFT);this._seg.p0.equals(u[l])||(h=s.getDepth(tt.RIGHT));var c=new Fn(this._seg,h);a.add(c)}}else if(ot(arguments[2],rt)&&arguments[0]instanceof z&&ot(arguments[1],rt))for(var f=arguments[0],g=arguments[2],p=arguments[1].iterator();p.hasNext();){var v=p.next();v.isForward()&&this.findStabbedSegments(f,v,g)}}},{key:"getDepth",value:function(t){var e=this.findStabbedSegments(t);return 0===e.size()?0:an.min(e)._leftDepth}}],[{key:"constructor_",value:function(){this._subgraphs=null,this._seg=new bn;var t=arguments[0];this._subgraphs=t}}]),e}(),Fn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"compareTo",value:function(t){var e=t;if(this._upwardSeg.minX()>=e._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=e._upwardSeg.minX())return-1;var n=this._upwardSeg.orientationIndex(e._upwardSeg);return 0!==n||0!=(n=-1*e._upwardSeg.orientationIndex(this._upwardSeg))?n:this._upwardSeg.compareTo(e._upwardSeg)}},{key:"compareX",value:function(t,e){var n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)}},{key:"toString",value:function(){return this._upwardSeg.toString()}},{key:"interfaces_",get:function(){return[k]}}],[{key:"constructor_",value:function(){this._upwardSeg=null,this._leftDepth=null;var t=arguments[0],e=arguments[1];this._upwardSeg=new bn(t),this._leftDepth=e}}]),e}();Dn.DepthSegment=Fn;var qn=function(e){r(o,e);var i=c(o);function o(){var e;return t(this,o),e=i.call(this),o.constructor_.apply(l(e),arguments),e}return n(o,null,[{key:"constructor_",value:function(){_.constructor_.call(this,"Projective point not representable on the Cartesian plane.")}}]),o}(_),Vn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getY",value:function(){var t=this.y/this.w;if(A.isNaN(t)||A.isInfinite(t))throw new qn;return t}},{key:"getX",value:function(){var t=this.x/this.w;if(A.isNaN(t)||A.isInfinite(t))throw new qn;return t}},{key:"getCoordinate",value:function(){var t=new z;return t.x=this.getX(),t.y=this.getY(),t}}],[{key:"constructor_",value:function(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){var t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var n=arguments[0],r=arguments[1];this.x=n,this.y=r,this.w=1}else if(arguments[0]instanceof e&&arguments[1]instanceof e){var i=arguments[0],o=arguments[1];this.x=i.y*o.w-o.y*i.w,this.y=o.x*i.w-i.x*o.w,this.w=i.x*o.y-o.x*i.y}else if(arguments[0]instanceof z&&arguments[1]instanceof z){var s=arguments[0],a=arguments[1];this.x=s.y-a.y,this.y=a.x-s.x,this.w=s.x*a.y-a.x*s.y}}else if(3===arguments.length){var u=arguments[0],l=arguments[1],h=arguments[2];this.x=u,this.y=l,this.w=h}else if(4===arguments.length){var c=arguments[0],f=arguments[1],g=arguments[2],p=arguments[3],v=c.y-f.y,d=f.x-c.x,y=c.x*f.y-f.x*c.y,m=g.y-p.y,_=p.x-g.x,x=g.x*p.y-p.x*g.y;this.x=d*x-_*y,this.y=m*y-v*x,this.w=v*_-m*d}}}]),e}(),Gn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"area",value:function(){return e.area(this.p0,this.p1,this.p2)}},{key:"signedArea",value:function(){return e.signedArea(this.p0,this.p1,this.p2)}},{key:"interpolateZ",value:function(t){if(null===t)throw new x("Supplied point is null.");return e.interpolateZ(t,this.p0,this.p1,this.p2)}},{key:"longestSideLength",value:function(){return e.longestSideLength(this.p0,this.p1,this.p2)}},{key:"isAcute",value:function(){return e.isAcute(this.p0,this.p1,this.p2)}},{key:"circumcentre",value:function(){return e.circumcentre(this.p0,this.p1,this.p2)}},{key:"area3D",value:function(){return e.area3D(this.p0,this.p1,this.p2)}},{key:"centroid",value:function(){return e.centroid(this.p0,this.p1,this.p2)}},{key:"inCentre",value:function(){return e.inCentre(this.p0,this.p1,this.p2)}}],[{key:"constructor_",value:function(){this.p0=null,this.p1=null,this.p2=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n}},{key:"area",value:function(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)}},{key:"signedArea",value:function(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2}},{key:"det",value:function(t,e,n,r){return t*r-e*n}},{key:"interpolateZ",value:function(t,e,n,r){var i=e.x,o=e.y,s=n.x-i,a=r.x-i,u=n.y-o,l=r.y-o,h=s*l-a*u,c=t.x-i,f=t.y-o,g=(l*c-a*f)/h,p=(-u*c+s*f)/h;return e.getZ()+g*(n.getZ()-e.getZ())+p*(r.getZ()-e.getZ())}},{key:"longestSideLength",value:function(t,e,n){var r=t.distance(e),i=e.distance(n),o=n.distance(t),s=r;return i>s&&(s=i),o>s&&(s=o),s}},{key:"circumcentreDD",value:function(t,e,n){var r=lt.valueOf(t.x).subtract(n.x),i=lt.valueOf(t.y).subtract(n.y),o=lt.valueOf(e.x).subtract(n.x),s=lt.valueOf(e.y).subtract(n.y),a=lt.determinant(r,i,o,s).multiply(2),u=r.sqr().add(i.sqr()),l=o.sqr().add(s.sqr()),h=lt.determinant(i,u,s,l),c=lt.determinant(r,u,o,l),f=lt.valueOf(n.x).subtract(h.divide(a)).doubleValue(),g=lt.valueOf(n.y).add(c.divide(a)).doubleValue();return new z(f,g)}},{key:"isAcute",value:function(t,e,n){return!!On.isAcute(t,e,n)&&!!On.isAcute(e,n,t)&&!!On.isAcute(n,t,e)}},{key:"circumcentre",value:function(t,n,r){var i=r.x,o=r.y,s=t.x-i,a=t.y-o,u=n.x-i,l=n.y-o,h=2*e.det(s,a,u,l),c=e.det(a,s*s+a*a,l,u*u+l*l),f=e.det(s,s*s+a*a,u,u*u+l*l);return new z(i-c/h,o+f/h)}},{key:"perpendicularBisector",value:function(t,e){var n=e.x-t.x,r=e.y-t.y,i=new Vn(t.x+n/2,t.y+r/2,1),o=new Vn(t.x-r+n/2,t.y+n+r/2,1);return new Vn(i,o)}},{key:"angleBisector",value:function(t,e,n){var r=e.distance(t),i=r/(r+e.distance(n)),o=n.x-t.x,s=n.y-t.y;return new z(t.x+i*o,t.y+i*s)}},{key:"area3D",value:function(t,e,n){var r=e.x-t.x,i=e.y-t.y,o=e.getZ()-t.getZ(),s=n.x-t.x,a=n.y-t.y,u=n.getZ()-t.getZ(),l=i*u-o*a,h=o*s-r*u,c=r*a-i*s,f=l*l+h*h+c*c;return Math.sqrt(f)/2}},{key:"centroid",value:function(t,e,n){var r=(t.x+e.x+n.x)/3,i=(t.y+e.y+n.y)/3;return new z(r,i)}},{key:"inCentre",value:function(t,e,n){var r=e.distance(n),i=t.distance(n),o=t.distance(e),s=r+i+o,a=(r*t.x+i*e.x+o*n.x)/s,u=(r*t.y+i*e.y+o*n.y)/s;return new z(a,u)}}]),e}(),Bn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"addRingSide",value:function(t,e,n,r,i){if(0===e&&t.length<zt.MINIMUM_VALID_SIZE)return null;var o=r,s=i;t.length>=zt.MINIMUM_VALID_SIZE&&ft.isCCW(t)&&(o=i,s=r,n=tt.opposite(n));var a=this._curveBuilder.getRingCurve(t,n,e);this.addCurve(a,o,s)}},{key:"addRingBothSides",value:function(t,e){this.addRingSide(t,e,tt.LEFT,Z.EXTERIOR,Z.INTERIOR),this.addRingSide(t,e,tt.RIGHT,Z.INTERIOR,Z.EXTERIOR)}},{key:"addPoint",value:function(t){if(this._distance<=0)return null;var e=t.getCoordinates(),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,Z.EXTERIOR,Z.INTERIOR)}},{key:"addPolygon",value:function(t){var e=this._distance,n=tt.LEFT;this._distance<0&&(e=-this._distance,n=tt.RIGHT);var r=t.getExteriorRing(),i=Wt.removeRepeatedPoints(r.getCoordinates());if(this._distance<0&&this.isErodedCompletely(r,this._distance))return null;if(this._distance<=0&&i.length<3)return null;this.addRingSide(i,e,n,Z.EXTERIOR,Z.INTERIOR);for(var o=0;o<t.getNumInteriorRing();o++){var s=t.getInteriorRingN(o),a=Wt.removeRepeatedPoints(s.getCoordinates());this._distance>0&&this.isErodedCompletely(s,-this._distance)||this.addRingSide(a,e,tt.opposite(n),Z.INTERIOR,Z.EXTERIOR)}}},{key:"isTriangleErodedCompletely",value:function(t,e){var n=new Gn(t[0],t[1],t[2]),r=n.inCentre();return kt.pointToSegment(r,n.p0,n.p1)<Math.abs(e)}},{key:"addLineString",value:function(t){if(this._curveBuilder.isLineOffsetEmpty(this._distance))return null;var e=Wt.removeRepeatedPoints(t.getCoordinates());if(Wt.isRing(e)&&!this._curveBuilder.getBufferParameters().isSingleSided())this.addRingBothSides(e,this._distance);else{var n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,Z.EXTERIOR,Z.INTERIOR)}}},{key:"addCurve",value:function(t,e,n){if(null===t||t.length<2)return null;var r=new kn(t,new Ae(0,Z.BOUNDARY,e,n));this._curveList.add(r)}},{key:"getCurves",value:function(){return this.add(this._inputGeom),this._curveList}},{key:"add",value:function(t){if(t.isEmpty())return null;if(t instanceof Ft)this.addPolygon(t);else if(t instanceof Ct)this.addLineString(t);else if(t instanceof Ot)this.addPoint(t);else if(t instanceof Yt)this.addCollection(t);else if(t instanceof se)this.addCollection(t);else if(t instanceof ee)this.addCollection(t);else{if(!(t instanceof Bt))throw new J(t.getGeometryType());this.addCollection(t)}}},{key:"isErodedCompletely",value:function(t,e){var n=t.getCoordinates();if(n.length<4)return e<0;if(4===n.length)return this.isTriangleErodedCompletely(n,e);var r=t.getEnvelopeInternal(),i=Math.min(r.getHeight(),r.getWidth());return e<0&&2*Math.abs(e)>i}},{key:"addCollection",value:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}}}],[{key:"constructor_",value:function(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new dt;var t=arguments[0],e=arguments[1],n=arguments[2];this._inputGeom=t,this._distance=e,this._curveBuilder=n}}]),e}(),Yn=function(){function e(){t(this,e)}return n(e,[{key:"locate",value:function(t){}}]),e}(),zn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"next",value:function(){if(this._atStart)return this._atStart=!1,e.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new W;var t=this._parent.getGeometryN(this._index++);return t instanceof Bt?(this._subcollectionIterator=new e(t),this._subcollectionIterator.next()):t}},{key:"remove",value:function(){throw new J(this.getClass().getName())}},{key:"hasNext",value:function(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)}},{key:"interfaces_",get:function(){return[yn]}}],[{key:"constructor_",value:function(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;var t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()}},{key:"isAtomic",value:function(t){return!(t instanceof Bt)}}]),e}(),jn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"locate",value:function(t){return e.locate(t,this._geom)}},{key:"interfaces_",get:function(){return[Yn]}}],[{key:"constructor_",value:function(){this._geom=null;var t=arguments[0];this._geom=t}},{key:"locatePointInPolygon",value:function(t,n){if(n.isEmpty())return Z.EXTERIOR;var r=n.getExteriorRing(),i=e.locatePointInRing(t,r);if(i!==Z.INTERIOR)return i;for(var o=0;o<n.getNumInteriorRing();o++){var s=n.getInteriorRingN(o),a=e.locatePointInRing(t,s);if(a===Z.BOUNDARY)return Z.BOUNDARY;if(a===Z.INTERIOR)return Z.EXTERIOR}return Z.INTERIOR}},{key:"locatePointInRing",value:function(t,e){return e.getEnvelopeInternal().intersects(t)?Oe.locateInRing(t,e.getCoordinates()):Z.EXTERIOR}},{key:"containsPointInPolygon",value:function(t,n){return Z.EXTERIOR!==e.locatePointInPolygon(t,n)}},{key:"locateInGeometry",value:function(t,n){if(n instanceof Ft)return e.locatePointInPolygon(t,n);if(n instanceof Bt)for(var r=new zn(n);r.hasNext();){var i=r.next();if(i!==n){var o=e.locateInGeometry(t,i);if(o!==Z.EXTERIOR)return o}}return Z.EXTERIOR}},{key:"isContained",value:function(t,n){return Z.EXTERIOR!==e.locate(t,n)}},{key:"locate",value:function(t,n){return n.isEmpty()?Z.EXTERIOR:n.getEnvelopeInternal().intersects(t)?e.locateInGeometry(t,n):Z.EXTERIOR}}]),e}(),Xn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getNextCW",value:function(t){this.getEdges();var e=this._edgeList.indexOf(t),n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)}},{key:"propagateSideLabels",value:function(t){for(var e=Z.NONE,n=this.iterator();n.hasNext();){var r=n.next().getLabel();r.isArea(t)&&r.getLocation(t,tt.LEFT)!==Z.NONE&&(e=r.getLocation(t,tt.LEFT))}if(e===Z.NONE)return null;for(var i=e,o=this.iterator();o.hasNext();){var s=o.next(),a=s.getLabel();if(a.getLocation(t,tt.ON)===Z.NONE&&a.setLocation(t,tt.ON,i),a.isArea(t)){var u=a.getLocation(t,tt.LEFT),l=a.getLocation(t,tt.RIGHT);if(l!==Z.NONE){if(l!==i)throw new pt("side location conflict",s.getCoordinate());u===Z.NONE&&V.shouldNeverReachHere("found single null side (at "+s.getCoordinate()+")"),i=u}else V.isTrue(a.getLocation(t,tt.LEFT)===Z.NONE,"found single null side"),a.setLocation(t,tt.RIGHT,i),a.setLocation(t,tt.LEFT,i)}}}},{key:"getCoordinate",value:function(){var t=this.iterator();return t.hasNext()?t.next().getCoordinate():null}},{key:"print",value:function(t){xt.out.println("EdgeEndStar:   "+this.getCoordinate());for(var e=this.iterator();e.hasNext();)e.next().print(t)}},{key:"isAreaLabelsConsistent",value:function(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}},{key:"checkAreaLabelsConsistent",value:function(t){var e=this.getEdges();if(e.size()<=0)return!0;var n=e.size()-1,r=e.get(n).getLabel().getLocation(t,tt.LEFT);V.isTrue(r!==Z.NONE,"Found unlabelled area edge");for(var i=r,o=this.iterator();o.hasNext();){var s=o.next().getLabel();V.isTrue(s.isArea(t),"Found non-area edge");var a=s.getLocation(t,tt.LEFT),u=s.getLocation(t,tt.RIGHT);if(a===u)return!1;if(u!==i)return!1;i=a}return!0}},{key:"findIndex",value:function(t){this.iterator();for(var e=0;e<this._edgeList.size();e++)if(this._edgeList.get(e)===t)return e;return-1}},{key:"iterator",value:function(){return this.getEdges().iterator()}},{key:"getEdges",value:function(){return null===this._edgeList&&(this._edgeList=new dt(this._edgeMap.values())),this._edgeList}},{key:"getLocation",value:function(t,e,n){return this._ptInAreaLocation[t]===Z.NONE&&(this._ptInAreaLocation[t]=jn.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]}},{key:"toString",value:function(){var t=new st;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(var e=this.iterator();e.hasNext();){var n=e.next();t.append(n),t.append("\n")}return t.toString()}},{key:"computeEdgeEndLabels",value:function(t){for(var e=this.iterator();e.hasNext();)e.next().computeLabel(t)}},{key:"computeLabelling",value:function(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);for(var e=[!1,!1],n=this.iterator();n.hasNext();)for(var r=n.next().getLabel(),i=0;i<2;i++)r.isLine(i)&&r.getLocation(i)===Z.BOUNDARY&&(e[i]=!0);for(var o=this.iterator();o.hasNext();)for(var s=o.next(),a=s.getLabel(),u=0;u<2;u++)if(a.isAnyNull(u)){var l=Z.NONE;if(e[u])l=Z.EXTERIOR;else{var h=s.getCoordinate();l=this.getLocation(u,h,t)}a.setAllLocationsIfNull(u,l)}}},{key:"getDegree",value:function(){return this._edgeMap.size()}},{key:"insertEdgeEnd",value:function(t,e){this._edgeMap.put(t,e),this._edgeList=null}}],[{key:"constructor_",value:function(){this._edgeMap=new Ze,this._edgeList=null,this._ptInAreaLocation=[Z.NONE,Z.NONE]}}]),e}(),Un=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"linkResultDirectedEdges",value:function(){this.getResultAreaEdges();for(var t=null,e=null,n=this._SCANNING_FOR_INCOMING,r=0;r<this._resultAreaEdgeList.size();r++){var i=this._resultAreaEdgeList.get(r),o=i.getSym();if(i.getLabel().isArea())switch(null===t&&i.isInResult()&&(t=i),n){case this._SCANNING_FOR_INCOMING:if(!o.isInResult())continue;e=o,n=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!i.isInResult())continue;e.setNext(i),n=this._SCANNING_FOR_INCOMING}}if(n===this._LINKING_TO_OUTGOING){if(null===t)throw new pt("no outgoing dirEdge found",this.getCoordinate());V.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}}},{key:"insert",value:function(t){var e=t;this.insertEdgeEnd(e,e)}},{key:"getRightmostEdge",value:function(){var t=this.getEdges(),e=t.size();if(e<1)return null;var n=t.get(0);if(1===e)return n;var r=t.get(e-1),i=n.getQuadrant(),o=r.getQuadrant();return We.isNorthern(i)&&We.isNorthern(o)?n:We.isNorthern(i)||We.isNorthern(o)?0!==n.getDy()?n:0!==r.getDy()?r:(V.shouldNeverReachHere("found two horizontal edges incident on node"),null):r}},{key:"print",value:function(t){xt.out.println("DirectedEdgeStar: "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}}},{key:"getResultAreaEdges",value:function(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new dt;for(var t=this.iterator();t.hasNext();){var e=t.next();(e.isInResult()||e.getSym().isInResult())&&this._resultAreaEdgeList.add(e)}return this._resultAreaEdgeList}},{key:"updateLabelling",value:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next().getLabel();n.setAllLocationsIfNull(0,t.getLocation(0)),n.setAllLocationsIfNull(1,t.getLocation(1))}}},{key:"linkAllDirectedEdges",value:function(){this.getEdges();for(var t=null,e=null,n=this._edgeList.size()-1;n>=0;n--){var r=this._edgeList.get(n),i=r.getSym();null===e&&(e=i),null!==t&&i.setNext(t),t=r}e.setNext(t)}},{key:"computeDepths",value:function(){if(1===arguments.length){var t=arguments[0],e=this.findIndex(t),n=t.getDepth(tt.LEFT),r=t.getDepth(tt.RIGHT),i=this.computeDepths(e+1,this._edgeList.size(),n);if(this.computeDepths(0,e,i)!==r)throw new pt("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){for(var o=arguments[1],s=arguments[2],a=arguments[0];a<o;a++){var u=this._edgeList.get(a);u.setEdgeDepths(tt.RIGHT,s),s=u.getDepth(tt.LEFT)}return s}}},{key:"mergeSymLabels",value:function(){for(var t=this.iterator();t.hasNext();){var e=t.next();e.getLabel().merge(e.getSym().getLabel())}}},{key:"linkMinimalDirectedEdges",value:function(t){for(var e=null,n=null,r=this._SCANNING_FOR_INCOMING,i=this._resultAreaEdgeList.size()-1;i>=0;i--){var o=this._resultAreaEdgeList.get(i),s=o.getSym();switch(null===e&&o.getEdgeRing()===t&&(e=o),r){case this._SCANNING_FOR_INCOMING:if(s.getEdgeRing()!==t)continue;n=s,r=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(o.getEdgeRing()!==t)continue;n.setNextMin(o),r=this._SCANNING_FOR_INCOMING}}r===this._LINKING_TO_OUTGOING&&(V.isTrue(null!==e,"found null for first outgoing dirEdge"),V.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))}},{key:"getOutgoingDegree",value:function(){if(0===arguments.length){for(var t=0,e=this.iterator();e.hasNext();)e.next().isInResult()&&t++;return t}if(1===arguments.length){for(var n=arguments[0],r=0,i=this.iterator();i.hasNext();)i.next().getEdgeRing()===n&&r++;return r}}},{key:"getLabel",value:function(){return this._label}},{key:"findCoveredLineEdges",value:function(){for(var t=Z.NONE,e=this.iterator();e.hasNext();){var n=e.next(),r=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=Z.INTERIOR;break}if(r.isInResult()){t=Z.EXTERIOR;break}}}if(t===Z.NONE)return null;for(var i=t,o=this.iterator();o.hasNext();){var s=o.next(),a=s.getSym();s.isLineEdge()?s.getEdge().setCovered(i===Z.INTERIOR):(s.isInResult()&&(i=Z.EXTERIOR),a.isInResult()&&(i=Z.INTERIOR))}}},{key:"computeLabelling",value:function(t){f(i(s.prototype),"computeLabelling",this).call(this,t),this._label=new Ae(Z.NONE);for(var e=this.iterator();e.hasNext();)for(var n=e.next().getEdge().getLabel(),r=0;r<2;r++){var o=n.getLocation(r);o!==Z.INTERIOR&&o!==Z.BOUNDARY||this._label.setLocation(r,Z.INTERIOR)}}}],[{key:"constructor_",value:function(){this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2}}]),s}(Xn),Zn=function(e){r(o,e);var i=c(o);function o(){return t(this,o),i.call(this)}return n(o,[{key:"createNode",value:function(t){return new Ge(t,new Un)}}]),o}(Qe),Hn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"compareTo",value:function(t){var n=t;return e.compareOriented(this._pts,this._orientation,n._pts,n._orientation)}},{key:"interfaces_",get:function(){return[k]}}],[{key:"constructor_",value:function(){this._pts=null,this._orientation=null;var t=arguments[0];this._pts=t,this._orientation=e.orientation(t)}},{key:"orientation",value:function(t){return 1===Wt.increasingDirection(t)}},{key:"compareOriented",value:function(t,e,n,r){for(var i=e?1:-1,o=r?1:-1,s=e?t.length:-1,a=r?n.length:-1,u=e?0:t.length-1,l=r?0:n.length-1;;){var h=t[u].compareTo(n[l]);if(0!==h)return h;var c=(u+=i)===s,f=(l+=o)===a;if(c&&!f)return-1;if(!c&&f)return 1;if(c&&f)return 0}}}]),e}(),Wn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"print",value:function(t){t.print("MULTILINESTRING ( ");for(var e=0;e<this._edges.size();e++){var n=this._edges.get(e);e>0&&t.print(","),t.print("(");for(var r=n.getCoordinates(),i=0;i<r.length;i++)i>0&&t.print(","),t.print(r[i].x+" "+r[i].y);t.println(")")}t.print(")  ")}},{key:"addAll",value:function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next())}},{key:"findEdgeIndex",value:function(t){for(var e=0;e<this._edges.size();e++)if(this._edges.get(e).equals(t))return e;return-1}},{key:"iterator",value:function(){return this._edges.iterator()}},{key:"getEdges",value:function(){return this._edges}},{key:"get",value:function(t){return this._edges.get(t)}},{key:"findEqualEdge",value:function(t){var e=new Hn(t.getCoordinates());return this._ocaMap.get(e)}},{key:"add",value:function(t){this._edges.add(t);var e=new Hn(t.getCoordinates());this._ocaMap.put(e,t)}}],[{key:"constructor_",value:function(){this._edges=new dt,this._ocaMap=new Ze}}]),e}(),Jn=function(){function e(){t(this,e)}return n(e,[{key:"processIntersections",value:function(t,e,n,r){}},{key:"isDone",value:function(){}}]),e}(),Kn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"isTrivialIntersection",value:function(t,n,r,i){if(t===r&&1===this._li.getIntersectionNum()){if(e.isAdjacentSegments(n,i))return!0;if(t.isClosed()){var o=t.size()-1;if(0===n&&i===o||0===i&&n===o)return!0}}return!1}},{key:"getProperIntersectionPoint",value:function(){return this._properIntersectionPoint}},{key:"hasProperInteriorIntersection",value:function(){return this._hasProperInterior}},{key:"getLineIntersector",value:function(){return this._li}},{key:"hasProperIntersection",value:function(){return this._hasProper}},{key:"processIntersections",value:function(t,e,n,r){if(t===n&&e===r)return null;this.numTests++;var i=t.getCoordinates()[e],o=t.getCoordinates()[e+1],s=n.getCoordinates()[r],a=n.getCoordinates()[r+1];this._li.computeIntersection(i,o,s,a),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(t,e,n,r)||(this._hasIntersection=!0,t.addIntersections(this._li,e,0),n.addIntersections(this._li,r,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))}},{key:"hasIntersection",value:function(){return this._hasIntersection}},{key:"isDone",value:function(){return!1}},{key:"hasInteriorIntersection",value:function(){return this._hasInterior}},{key:"interfaces_",get:function(){return[Jn]}}],[{key:"constructor_",value:function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;var t=arguments[0];this._li=t}},{key:"isAdjacentSegments",value:function(t,e){return 1===Math.abs(t-e)}}]),e}(),Qn=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getSegmentIndex",value:function(){return this.segmentIndex}},{key:"getCoordinate",value:function(){return this.coord}},{key:"print",value:function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}},{key:"compareTo",value:function(t){var e=t;return this.compare(e.segmentIndex,e.dist)}},{key:"isEndPoint",value:function(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}},{key:"toString",value:function(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}},{key:"getDistance",value:function(){return this.dist}},{key:"compare",value:function(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0}},{key:"interfaces_",get:function(){return[k]}}],[{key:"constructor_",value:function(){this.coord=null,this.segmentIndex=null,this.dist=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new z(t),this.segmentIndex=e,this.dist=n}}]),e}(),$n=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"print",value:function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();)e.next().print(t)}},{key:"iterator",value:function(){return this._nodeMap.values().iterator()}},{key:"addSplitEdges",value:function(t){this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var r=e.next(),i=this.createSplitEdge(n,r);t.add(i),n=r}}},{key:"addEndpoints",value:function(){var t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}},{key:"createSplitEdge",value:function(t,e){var n=e.segmentIndex-t.segmentIndex+2,r=this.edge.pts[e.segmentIndex],i=e.dist>0||!e.coord.equals2D(r);i||n--;var o=new Array(n).fill(null),s=0;o[s++]=new z(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)o[s++]=this.edge.pts[a];return i&&(o[s]=e.coord),new or(o,new Ae(this.edge._label))}},{key:"add",value:function(t,e,n){var r=new Qn(t,e,n),i=this._nodeMap.get(r);return null!==i?i:(this._nodeMap.put(r,r),r)}},{key:"isIntersection",value:function(t){for(var e=this.iterator();e.hasNext();)if(e.next().coord.equals(t))return!0;return!1}}],[{key:"constructor_",value:function(){this._nodeMap=new Ze,this.edge=null;var t=arguments[0];this.edge=t}}]),e}(),tr=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"isIntersects",value:function(){return!this.isDisjoint()}},{key:"isCovers",value:function(){return(e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR])||e.isTrue(this._matrix[Z.INTERIOR][Z.BOUNDARY])||e.isTrue(this._matrix[Z.BOUNDARY][Z.INTERIOR])||e.isTrue(this._matrix[Z.BOUNDARY][Z.BOUNDARY]))&&this._matrix[Z.EXTERIOR][Z.INTERIOR]===Mt.FALSE&&this._matrix[Z.EXTERIOR][Z.BOUNDARY]===Mt.FALSE}},{key:"isCoveredBy",value:function(){return(e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR])||e.isTrue(this._matrix[Z.INTERIOR][Z.BOUNDARY])||e.isTrue(this._matrix[Z.BOUNDARY][Z.INTERIOR])||e.isTrue(this._matrix[Z.BOUNDARY][Z.BOUNDARY]))&&this._matrix[Z.INTERIOR][Z.EXTERIOR]===Mt.FALSE&&this._matrix[Z.BOUNDARY][Z.EXTERIOR]===Mt.FALSE}},{key:"set",value:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<t.length;e++){var n=Math.trunc(e/3),r=e%3;this._matrix[n][r]=Mt.toDimensionValue(t.charAt(e))}else if(3===arguments.length){var i=arguments[0],o=arguments[1],s=arguments[2];this._matrix[i][o]=s}}},{key:"isContains",value:function(){return e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR])&&this._matrix[Z.EXTERIOR][Z.INTERIOR]===Mt.FALSE&&this._matrix[Z.EXTERIOR][Z.BOUNDARY]===Mt.FALSE}},{key:"setAtLeast",value:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<t.length;e++){var n=Math.trunc(e/3),r=e%3;this.setAtLeast(n,r,Mt.toDimensionValue(t.charAt(e)))}else if(3===arguments.length){var i=arguments[0],o=arguments[1],s=arguments[2];this._matrix[i][o]<s&&(this._matrix[i][o]=s)}}},{key:"setAtLeastIfValid",value:function(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)}},{key:"isWithin",value:function(){return e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR])&&this._matrix[Z.INTERIOR][Z.EXTERIOR]===Mt.FALSE&&this._matrix[Z.BOUNDARY][Z.EXTERIOR]===Mt.FALSE}},{key:"isTouches",value:function(t,n){return t>n?this.isTouches(n,t):(t===Mt.A&&n===Mt.A||t===Mt.L&&n===Mt.L||t===Mt.L&&n===Mt.A||t===Mt.P&&n===Mt.A||t===Mt.P&&n===Mt.L)&&this._matrix[Z.INTERIOR][Z.INTERIOR]===Mt.FALSE&&(e.isTrue(this._matrix[Z.INTERIOR][Z.BOUNDARY])||e.isTrue(this._matrix[Z.BOUNDARY][Z.INTERIOR])||e.isTrue(this._matrix[Z.BOUNDARY][Z.BOUNDARY]))}},{key:"isOverlaps",value:function(t,n){return t===Mt.P&&n===Mt.P||t===Mt.A&&n===Mt.A?e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR])&&e.isTrue(this._matrix[Z.INTERIOR][Z.EXTERIOR])&&e.isTrue(this._matrix[Z.EXTERIOR][Z.INTERIOR]):t===Mt.L&&n===Mt.L&&1===this._matrix[Z.INTERIOR][Z.INTERIOR]&&e.isTrue(this._matrix[Z.INTERIOR][Z.EXTERIOR])&&e.isTrue(this._matrix[Z.EXTERIOR][Z.INTERIOR])}},{key:"isEquals",value:function(t,n){return t===n&&e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR])&&this._matrix[Z.INTERIOR][Z.EXTERIOR]===Mt.FALSE&&this._matrix[Z.BOUNDARY][Z.EXTERIOR]===Mt.FALSE&&this._matrix[Z.EXTERIOR][Z.INTERIOR]===Mt.FALSE&&this._matrix[Z.EXTERIOR][Z.BOUNDARY]===Mt.FALSE}},{key:"toString",value:function(){for(var t=new Qt("123456789"),e=0;e<3;e++)for(var n=0;n<3;n++)t.setCharAt(3*e+n,Mt.toDimensionSymbol(this._matrix[e][n]));return t.toString()}},{key:"setAll",value:function(t){for(var e=0;e<3;e++)for(var n=0;n<3;n++)this._matrix[e][n]=t}},{key:"get",value:function(t,e){return this._matrix[t][e]}},{key:"transpose",value:function(){var t=this._matrix[1][0];return this._matrix[1][0]=this._matrix[0][1],this._matrix[0][1]=t,t=this._matrix[2][0],this._matrix[2][0]=this._matrix[0][2],this._matrix[0][2]=t,t=this._matrix[2][1],this._matrix[2][1]=this._matrix[1][2],this._matrix[1][2]=t,this}},{key:"matches",value:function(t){if(9!==t.length)throw new x("Should be length 9: "+t);for(var n=0;n<3;n++)for(var r=0;r<3;r++)if(!e.matches(this._matrix[n][r],t.charAt(3*n+r)))return!1;return!0}},{key:"add",value:function(t){for(var e=0;e<3;e++)for(var n=0;n<3;n++)this.setAtLeast(e,n,t.get(e,n))}},{key:"isDisjoint",value:function(){return this._matrix[Z.INTERIOR][Z.INTERIOR]===Mt.FALSE&&this._matrix[Z.INTERIOR][Z.BOUNDARY]===Mt.FALSE&&this._matrix[Z.BOUNDARY][Z.INTERIOR]===Mt.FALSE&&this._matrix[Z.BOUNDARY][Z.BOUNDARY]===Mt.FALSE}},{key:"isCrosses",value:function(t,n){return t===Mt.P&&n===Mt.L||t===Mt.P&&n===Mt.A||t===Mt.L&&n===Mt.A?e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR])&&e.isTrue(this._matrix[Z.INTERIOR][Z.EXTERIOR]):t===Mt.L&&n===Mt.P||t===Mt.A&&n===Mt.P||t===Mt.A&&n===Mt.L?e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR])&&e.isTrue(this._matrix[Z.EXTERIOR][Z.INTERIOR]):t===Mt.L&&n===Mt.L&&0===this._matrix[Z.INTERIOR][Z.INTERIOR]}},{key:"interfaces_",get:function(){return[b]}}],[{key:"constructor_",value:function(){if(this._matrix=null,0===arguments.length)this._matrix=Array(3).fill().map((function(){return Array(3)})),this.setAll(Mt.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){var t=arguments[0];e.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof e){var n=arguments[0];e.constructor_.call(this),this._matrix[Z.INTERIOR][Z.INTERIOR]=n._matrix[Z.INTERIOR][Z.INTERIOR],this._matrix[Z.INTERIOR][Z.BOUNDARY]=n._matrix[Z.INTERIOR][Z.BOUNDARY],this._matrix[Z.INTERIOR][Z.EXTERIOR]=n._matrix[Z.INTERIOR][Z.EXTERIOR],this._matrix[Z.BOUNDARY][Z.INTERIOR]=n._matrix[Z.BOUNDARY][Z.INTERIOR],this._matrix[Z.BOUNDARY][Z.BOUNDARY]=n._matrix[Z.BOUNDARY][Z.BOUNDARY],this._matrix[Z.BOUNDARY][Z.EXTERIOR]=n._matrix[Z.BOUNDARY][Z.EXTERIOR],this._matrix[Z.EXTERIOR][Z.INTERIOR]=n._matrix[Z.EXTERIOR][Z.INTERIOR],this._matrix[Z.EXTERIOR][Z.BOUNDARY]=n._matrix[Z.EXTERIOR][Z.BOUNDARY],this._matrix[Z.EXTERIOR][Z.EXTERIOR]=n._matrix[Z.EXTERIOR][Z.EXTERIOR]}}},{key:"matches",value:function(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){var t=arguments[0],n=arguments[1];return n===Mt.SYM_DONTCARE||n===Mt.SYM_TRUE&&(t>=0||t===Mt.TRUE)||n===Mt.SYM_FALSE&&t===Mt.FALSE||n===Mt.SYM_P&&t===Mt.P||n===Mt.SYM_L&&t===Mt.L||n===Mt.SYM_A&&t===Mt.A}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){var r=arguments[1];return new e(arguments[0]).matches(r)}}},{key:"isTrue",value:function(t){return t>=0||t===Mt.TRUE}}]),e}(),er=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"size",value:function(){return this._size}},{key:"addAll",value:function(t){return null===t||0===t.length?null:(this.ensureCapacity(this._size+t.length),xt.arraycopy(t,0,this._data,this._size,t.length),void(this._size+=t.length))}},{key:"ensureCapacity",value:function(t){if(t<=this._data.length)return null;var e=Math.max(t,2*this._data.length);this._data=At.copyOf(this._data,e)}},{key:"toArray",value:function(){var t=new Array(this._size).fill(null);return xt.arraycopy(this._data,0,t,0,this._size),t}},{key:"add",value:function(t){this.ensureCapacity(this._size+1),this._data[this._size]=t,++this._size}}],[{key:"constructor_",value:function(){if(this._data=null,this._size=0,0===arguments.length)e.constructor_.call(this,10);else if(1===arguments.length){var t=arguments[0];this._data=new Array(t).fill(null)}}}]),e}(),nr=function(){function e(){t(this,e)}return n(e,[{key:"getChainStartIndices",value:function(t){var e=0,n=new er(Math.trunc(t.length/2));n.add(e);do{var r=this.findChainEnd(t,e);n.add(r),e=r}while(e<t.length-1);return n.toArray()}},{key:"findChainEnd",value:function(t,e){for(var n=We.quadrant(t[e],t[e+1]),r=e+1;r<t.length&&We.quadrant(t[r-1],t[r])===n;)r++;return r-1}},{key:"OLDgetChainStartIndices",value:function(t){var n=0,r=new dt;r.add(n);do{var i=this.findChainEnd(t,n);r.add(i),n=i}while(n<t.length-1);return e.toIntArray(r)}}],[{key:"toIntArray",value:function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}}]),e}(),rr=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getCoordinates",value:function(){return this.pts}},{key:"getMaxX",value:function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n}},{key:"getMinX",value:function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n}},{key:"computeIntersectsForChain",value:function(){if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],r=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],r)}else if(6===arguments.length){var i=arguments[0],o=arguments[1],s=arguments[2],a=arguments[3],u=arguments[4],l=arguments[5];if(o-i==1&&u-a==1)return l.addIntersections(this.e,i,s.e,a),null;if(!this.overlaps(i,o,s,a,u))return null;var h=Math.trunc((i+o)/2),c=Math.trunc((a+u)/2);i<h&&(a<c&&this.computeIntersectsForChain(i,h,s,a,c,l),c<u&&this.computeIntersectsForChain(i,h,s,c,u,l)),h<o&&(a<c&&this.computeIntersectsForChain(h,o,s,a,c,l),c<u&&this.computeIntersectsForChain(h,o,s,c,u,l))}}},{key:"overlaps",value:function(t,e,n,r,i){return X.intersects(this.pts[t],this.pts[e],n.pts[r],n.pts[i])}},{key:"getStartIndexes",value:function(){return this.startIndex}},{key:"computeIntersects",value:function(t,e){for(var n=0;n<this.startIndex.length-1;n++)for(var r=0;r<t.startIndex.length-1;r++)this.computeIntersectsForChain(n,t,r,e)}}],[{key:"constructor_",value:function(){this.e=null,this.pts=null,this.startIndex=null;var t=arguments[0];this.e=t,this.pts=t.getCoordinates();var e=new nr;this.startIndex=e.getChainStartIndices(this.pts)}}]),e}(),ir=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"getDepth",value:function(t,e){return this._depth[t][e]}},{key:"setDepth",value:function(t,e,n){this._depth[t][e]=n}},{key:"isNull",value:function(){if(0===arguments.length){for(var t=0;t<2;t++)for(var n=0;n<3;n++)if(this._depth[t][n]!==e.NULL_VALUE)return!1;return!0}if(1===arguments.length){var r=arguments[0];return this._depth[r][1]===e.NULL_VALUE}if(2===arguments.length){var i=arguments[0],o=arguments[1];return this._depth[i][o]===e.NULL_VALUE}}},{key:"normalize",value:function(){for(var t=0;t<2;t++)if(!this.isNull(t)){var e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(var n=1;n<3;n++){var r=0;this._depth[t][n]>e&&(r=1),this._depth[t][n]=r}}}},{key:"getDelta",value:function(t){return this._depth[t][tt.RIGHT]-this._depth[t][tt.LEFT]}},{key:"getLocation",value:function(t,e){return this._depth[t][e]<=0?Z.EXTERIOR:Z.INTERIOR}},{key:"toString",value:function(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]}},{key:"add",value:function(){if(1===arguments.length)for(var t=arguments[0],n=0;n<2;n++)for(var r=1;r<3;r++){var i=t.getLocation(n,r);i!==Z.EXTERIOR&&i!==Z.INTERIOR||(this.isNull(n,r)?this._depth[n][r]=e.depthAtLocation(i):this._depth[n][r]+=e.depthAtLocation(i))}else if(3===arguments.length){var o=arguments[0],s=arguments[1];arguments[2]===Z.INTERIOR&&this._depth[o][s]++}}}],[{key:"constructor_",value:function(){this._depth=Array(2).fill().map((function(){return Array(3)}));for(var t=0;t<2;t++)for(var n=0;n<3;n++)this._depth[t][n]=e.NULL_VALUE}},{key:"depthAtLocation",value:function(t){return t===Z.EXTERIOR?0:t===Z.INTERIOR?1:e.NULL_VALUE}}]),e}();ir.NULL_VALUE=-1;var or=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"getDepth",value:function(){return this._depth}},{key:"getCollapsedEdge",value:function(){var t=new Array(2).fill(null);return t[0]=this.pts[0],t[1]=this.pts[1],new s(t,Ae.toLineLabel(this._label))}},{key:"isIsolated",value:function(){return this._isIsolated}},{key:"getCoordinates",value:function(){return this.pts}},{key:"setIsolated",value:function(t){this._isIsolated=t}},{key:"setName",value:function(t){this._name=t}},{key:"equals",value:function(t){if(!(t instanceof s))return!1;var e=t;if(this.pts.length!==e.pts.length)return!1;for(var n=!0,r=!0,i=this.pts.length,o=0;o<this.pts.length;o++)if(this.pts[o].equals2D(e.pts[o])||(n=!1),this.pts[o].equals2D(e.pts[--i])||(r=!1),!n&&!r)return!1;return!0}},{key:"getCoordinate",value:function(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){var t=arguments[0];return this.pts[t]}}},{key:"print",value:function(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta)}},{key:"computeIM",value:function(t){s.updateIM(this._label,t)}},{key:"isCollapsed",value:function(){return!!this._label.isArea()&&3===this.pts.length&&!!this.pts[0].equals(this.pts[2])}},{key:"isClosed",value:function(){return this.pts[0].equals(this.pts[this.pts.length-1])}},{key:"getMaximumSegmentIndex",value:function(){return this.pts.length-1}},{key:"getDepthDelta",value:function(){return this._depthDelta}},{key:"getNumPoints",value:function(){return this.pts.length}},{key:"printReverse",value:function(t){t.print("edge "+this._name+": ");for(var e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")}},{key:"getMonotoneChainEdge",value:function(){return null===this._mce&&(this._mce=new rr(this)),this._mce}},{key:"getEnvelope",value:function(){if(null===this._env){this._env=new X;for(var t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env}},{key:"addIntersection",value:function(t,e,n,r){var i=new z(t.getIntersection(r)),o=e,s=t.getEdgeDistance(n,r),a=o+1;if(a<this.pts.length){var u=this.pts[a];i.equals2D(u)&&(o=a,s=0)}this.eiList.add(i,o,s)}},{key:"toString",value:function(){var t=new Qt;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()}},{key:"isPointwiseEqual",value:function(t){if(this.pts.length!==t.pts.length)return!1;for(var e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0}},{key:"setDepthDelta",value:function(t){this._depthDelta=t}},{key:"getEdgeIntersectionList",value:function(){return this.eiList}},{key:"addIntersections",value:function(t,e,n){for(var r=0;r<t.getIntersectionNum();r++)this.addIntersection(t,e,n,r)}}],[{key:"constructor_",value:function(){if(this.pts=null,this._env=null,this.eiList=new $n(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new ir,this._depthDelta=0,1===arguments.length){var t=arguments[0];s.constructor_.call(this,t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.pts=e,this._label=n}}},{key:"updateIM",value:function(){if(!(2===arguments.length&&arguments[1]instanceof tr&&arguments[0]instanceof Ae))return f(i(s),"updateIM",this).apply(this,arguments);var t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,tt.ON),t.getLocation(1,tt.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,tt.LEFT),t.getLocation(1,tt.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,tt.RIGHT),t.getLocation(1,tt.RIGHT),2))}}]),s}(Ve),sr=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"setWorkingPrecisionModel",value:function(t){this._workingPrecisionModel=t}},{key:"insertUniqueEdge",value:function(t){var n=this._edgeList.findEqualEdge(t);if(null!==n){var r=n.getLabel(),i=t.getLabel();n.isPointwiseEqual(t)||(i=new Ae(t.getLabel())).flip(),r.merge(i);var o=e.depthDelta(i),s=n.getDepthDelta()+o;n.setDepthDelta(s)}else this._edgeList.add(t),t.setDepthDelta(e.depthDelta(t.getLabel()))}},{key:"buildSubgraphs",value:function(t,e){for(var n=new dt,r=t.iterator();r.hasNext();){var i=r.next(),o=i.getRightmostCoordinate(),s=new Dn(n).getDepth(o);i.computeDepth(s),i.findResultEdges(),n.add(i),e.add(i.getDirectedEdges(),i.getNodes())}}},{key:"createSubgraphs",value:function(t){for(var e=new dt,n=t.getNodes().iterator();n.hasNext();){var r=n.next();if(!r.isVisited()){var i=new mt;i.create(r),e.add(i)}}return an.sort(e,an.reverseOrder()),e}},{key:"createEmptyResultGeometry",value:function(){return this._geomFact.createPolygon()}},{key:"getNoder",value:function(t){if(null!==this._workingNoder)return this._workingNoder;var e=new Ln,n=new Ce;return n.setPrecisionModel(t),e.setSegmentIntersector(new Kn(n)),e}},{key:"buffer",value:function(t,e){var n=this._workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this._geomFact=t.getFactory();var r=new An(n,this._bufParams),i=new Bn(t,e,r).getCurves();if(i.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(i,n),this._graph=new $e(new Zn),this._graph.addEdges(this._edgeList.getEdges());var o=this.createSubgraphs(this._graph),s=new tn(this._geomFact);this.buildSubgraphs(o,s);var a=s.getPolygons();return a.size()<=0?this.createEmptyResultGeometry():this._geomFact.buildGeometry(a)}},{key:"computeNodedEdges",value:function(t,e){var n=this.getNoder(e);n.computeNodes(t);for(var r=n.getNodedSubstrings().iterator();r.hasNext();){var i=r.next(),o=i.getCoordinates();if(2!==o.length||!o[0].equals2D(o[1])){var s=i.getData(),a=new or(i.getCoordinates(),new Ae(s));this.insertUniqueEdge(a)}}}},{key:"setNoder",value:function(t){this._workingNoder=t}}],[{key:"constructor_",value:function(){this._bufParams=null,this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new Wn;var t=arguments[0];this._bufParams=t}},{key:"depthDelta",value:function(t){var e=t.getLocation(0,tt.LEFT),n=t.getLocation(0,tt.RIGHT);return e===Z.INTERIOR&&n===Z.EXTERIOR?1:e===Z.EXTERIOR&&n===Z.INTERIOR?-1:0}},{key:"convertSegStrings",value:function(t){for(var e=new ae,n=new dt;t.hasNext();){var r=t.next(),i=e.createLineString(r.getCoordinates());n.add(i)}return e.buildGeometry(n)}}]),e}(),ar=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"rescale",value:function(){if(ot(arguments[0],H))for(var t=arguments[0].iterator();t.hasNext();){var e=t.next();this.rescale(e.getCoordinates())}else if(arguments[0]instanceof Array){for(var n=arguments[0],r=0;r<n.length;r++)n[r].x=n[r].x/this._scaleFactor+this._offsetX,n[r].y=n[r].y/this._scaleFactor+this._offsetY;2===n.length&&n[0].equals2D(n[1])&&xt.out.println(n)}}},{key:"scale",value:function(){if(ot(arguments[0],H)){for(var t=arguments[0],e=new dt(t.size()),n=t.iterator();n.hasNext();){var r=n.next();e.add(new kn(this.scale(r.getCoordinates()),r.getData()))}return e}if(arguments[0]instanceof Array){for(var i=arguments[0],o=new Array(i.length).fill(null),s=0;s<i.length;s++)o[s]=new z(Math.round((i[s].x-this._offsetX)*this._scaleFactor),Math.round((i[s].y-this._offsetY)*this._scaleFactor),i[s].getZ());return Wt.removeRepeatedPoints(o)}}},{key:"isIntegerPrecision",value:function(){return 1===this._scaleFactor}},{key:"getNodedSubstrings",value:function(){var t=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(t),t}},{key:"computeNodes",value:function(t){var e=t;this._isScaled&&(e=this.scale(t)),this._noder.computeNodes(e)}},{key:"interfaces_",get:function(){return[Sn]}}],[{key:"constructor_",value:function(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){var t=arguments[0],n=arguments[1];e.constructor_.call(this,t,n,0,0)}else if(4===arguments.length){var r=arguments[0],i=arguments[1];this._noder=r,this._scaleFactor=i,this._isScaled=!this.isIntegerPrecision()}}}]),e}(),ur=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"checkEndPtVertexIntersections",value:function(){if(0===arguments.length)for(var t=this._segStrings.iterator();t.hasNext();){var e=t.next().getCoordinates();this.checkEndPtVertexIntersections(e[0],this._segStrings),this.checkEndPtVertexIntersections(e[e.length-1],this._segStrings)}else if(2===arguments.length)for(var n=arguments[0],r=arguments[1].iterator();r.hasNext();)for(var i=r.next().getCoordinates(),o=1;o<i.length-1;o++)if(i[o].equals(n))throw new F("found endpt/interior pt intersection at index "+o+" :pt "+n)}},{key:"checkInteriorIntersections",value:function(){if(0===arguments.length)for(var t=this._segStrings.iterator();t.hasNext();)for(var e=t.next(),n=this._segStrings.iterator();n.hasNext();){var r=n.next();this.checkInteriorIntersections(e,r)}else if(2===arguments.length)for(var i=arguments[0],o=arguments[1],s=i.getCoordinates(),a=o.getCoordinates(),u=0;u<s.length-1;u++)for(var l=0;l<a.length-1;l++)this.checkInteriorIntersections(i,u,o,l);else if(4===arguments.length){var h=arguments[0],c=arguments[1],f=arguments[2],g=arguments[3];if(h===f&&c===g)return null;var p=h.getCoordinates()[c],v=h.getCoordinates()[c+1],d=f.getCoordinates()[g],y=f.getCoordinates()[g+1];if(this._li.computeIntersection(p,v,d,y),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,p,v)||this.hasInteriorIntersection(this._li,d,y)))throw new F("found non-noded intersection at "+p+"-"+v+" and "+d+"-"+y)}}},{key:"checkValid",value:function(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()}},{key:"checkCollapses",value:function(){if(0===arguments.length)for(var t=this._segStrings.iterator();t.hasNext();){var e=t.next();this.checkCollapses(e)}else if(1===arguments.length)for(var n=arguments[0].getCoordinates(),r=0;r<n.length-2;r++)this.checkCollapse(n[r],n[r+1],n[r+2])}},{key:"hasInteriorIntersection",value:function(t,e,n){for(var r=0;r<t.getIntersectionNum();r++){var i=t.getIntersection(r);if(!i.equals(e)&&!i.equals(n))return!0}return!1}},{key:"checkCollapse",value:function(t,n,r){if(t.equals(r))throw new F("found non-noded collapse at "+e.fact.createLineString([t,n,r]))}}],[{key:"constructor_",value:function(){this._li=new Ce,this._segStrings=null;var t=arguments[0];this._segStrings=t}}]),e}();ur.fact=new ae;var lr=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"intersectsScaled",value:function(t,e){var n=Math.min(t.x,e.x),r=Math.max(t.x,e.x),i=Math.min(t.y,e.y),o=Math.max(t.y,e.y),s=this._maxx<n||this._minx>r||this._maxy<i||this._miny>o;if(s)return!1;var a=this.intersectsToleranceSquare(t,e);return V.isTrue(!(s&&a),"Found bad envelope test"),a}},{key:"initCorners",value:function(t){var e=.5;this._minx=t.x-e,this._maxx=t.x+e,this._miny=t.y-e,this._maxy=t.y+e,this._corner[0]=new z(this._maxx,this._maxy),this._corner[1]=new z(this._minx,this._maxy),this._corner[2]=new z(this._minx,this._miny),this._corner[3]=new z(this._maxx,this._miny)}},{key:"intersects",value:function(t,e){return 1===this._scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this._p0Scaled),this.copyScaled(e,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))}},{key:"scale",value:function(t){return Math.round(t*this._scaleFactor)}},{key:"getCoordinate",value:function(){return this._originalPt}},{key:"copyScaled",value:function(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)}},{key:"getSafeEnvelope",value:function(){if(null===this._safeEnv){var t=e.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new X(this._originalPt.x-t,this._originalPt.x+t,this._originalPt.y-t,this._originalPt.y+t)}return this._safeEnv}},{key:"intersectsPixelClosure",value:function(t,e){return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!(this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),this._li.hasIntersection()))))}},{key:"intersectsToleranceSquare",value:function(t,e){var n=!1,r=!1;return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!(this._li.isProper()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),this._li.isProper()||(this._li.hasIntersection()&&(n=!0),this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),this._li.isProper()||(this._li.hasIntersection()&&(r=!0),this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),this._li.isProper()||n&&r||t.equals(this._pt)||e.equals(this._pt)))))}},{key:"addSnappedNode",value:function(t,e){var n=t.getCoordinate(e),r=t.getCoordinate(e+1);return!!this.intersects(n,r)&&(t.addIntersection(this.getCoordinate(),e),!0)}}],[{key:"constructor_",value:function(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(this._originalPt=t,this._pt=t,this._scaleFactor=e,this._li=n,e<=0)throw new x("Scale factor must be non-zero");1!==e&&(this._pt=new z(this.scale(t.x),this.scale(t.y)),this._p0Scaled=new z,this._p1Scaled=new z),this.initCorners(this._pt)}}]),e}();lr.SAFE_ENV_EXPANSION_FACTOR=.75;var hr=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"select",value:function(){if(1===arguments.length);else if(2===arguments.length){var t=arguments[1];arguments[0].getLineSegment(t,this.selectedSegment),this.select(this.selectedSegment)}}}],[{key:"constructor_",value:function(){this.selectedSegment=new bn}}]),e}(),cr=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"snap",value:function(){if(1===arguments.length){var e=arguments[0];return this.snap(e,null,-1)}if(3===arguments.length){var r=arguments[0],i=arguments[1],o=arguments[2],s=r.getSafeEnvelope(),a=new fr(r,i,o);return this._index.query(s,new(function(){function e(){t(this,e)}return n(e,[{key:"interfaces_",get:function(){return[hn]}},{key:"visitItem",value:function(t){t.select(s,a)}}]),e}())),a.isNodeAdded()}}}],[{key:"constructor_",value:function(){this._index=null;var t=arguments[0];this._index=t}}]),e}(),fr=function(e){r(s,e);var o=c(s);function s(){var e;return t(this,s),e=o.call(this),s.constructor_.apply(l(e),arguments),e}return n(s,[{key:"isNodeAdded",value:function(){return this._isNodeAdded}},{key:"select",value:function(){if(!(2===arguments.length&&Number.isInteger(arguments[1])&&arguments[0]instanceof In))return f(i(s.prototype),"select",this).apply(this,arguments);var t=arguments[1],e=arguments[0].getContext();if(this._parentEdge===e&&(t===this._hotPixelVertexIndex||t+1===this._hotPixelVertexIndex))return null;this._isNodeAdded|=this._hotPixel.addSnappedNode(e,t)}}],[{key:"constructor_",value:function(){this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this._hotPixel=t,this._parentEdge=e,this._hotPixelVertexIndex=n}}]),s}(hr);cr.HotPixelSnapAction=fr;var gr=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"processIntersections",value:function(t,e,n,r){if(t===n&&e===r)return null;var i=t.getCoordinates()[e],o=t.getCoordinates()[e+1],s=n.getCoordinates()[r],a=n.getCoordinates()[r+1];if(this._li.computeIntersection(i,o,s,a),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(var u=0;u<this._li.getIntersectionNum();u++)this._interiorIntersections.add(this._li.getIntersection(u));t.addIntersections(this._li,e,0),n.addIntersections(this._li,r,1)}}},{key:"isDone",value:function(){return!1}},{key:"getInteriorIntersections",value:function(){return this._interiorIntersections}},{key:"interfaces_",get:function(){return[Jn]}}],[{key:"constructor_",value:function(){this._li=null,this._interiorIntersections=null;var t=arguments[0];this._li=t,this._interiorIntersections=new dt}}]),e}(),pr=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"checkCorrectness",value:function(t){var e=kn.getNodedSubstrings(t),n=new ur(e);try{n.checkValid()}catch(t){if(!(t instanceof _))throw t;t.printStackTrace()}}},{key:"getNodedSubstrings",value:function(){return kn.getNodedSubstrings(this._nodedSegStrings)}},{key:"snapRound",value:function(t,e){var n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)}},{key:"findInteriorIntersections",value:function(t,e){var n=new gr(e);return this._noder.setSegmentIntersector(n),this._noder.computeNodes(t),n.getInteriorIntersections()}},{key:"computeVertexSnaps",value:function(){if(ot(arguments[0],H))for(var t=arguments[0].iterator();t.hasNext();){var e=t.next();this.computeVertexSnaps(e)}else if(arguments[0]instanceof kn)for(var n=arguments[0],r=n.getCoordinates(),i=0;i<r.length;i++){var o=new lr(r[i],this._scaleFactor,this._li);this._pointSnapper.snap(o,n,i)&&n.addIntersection(r[i],i)}}},{key:"computeNodes",value:function(t){this._nodedSegStrings=t,this._noder=new Ln,this._pointSnapper=new cr(this._noder.getIndex()),this.snapRound(t,this._li)}},{key:"computeIntersectionSnaps",value:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),r=new lr(n,this._scaleFactor,this._li);this._pointSnapper.snap(r)}}},{key:"interfaces_",get:function(){return[Sn]}}],[{key:"constructor_",value:function(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;var t=arguments[0];this._pm=t,this._li=new Ce,this._li.setPrecisionModel(t),this._scaleFactor=t.getScale()}}]),e}(),vr=function(){function e(){t(this,e),e.constructor_.apply(this,arguments)}return n(e,[{key:"bufferFixedPrecision",value:function(t){var e=new ar(new pr(new ie(1)),t.getScale()),n=new sr(this._bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this._resultGeometry=n.buffer(this._argGeom,this._distance)}},{key:"bufferReducedPrecision",value:function(){if(0===arguments.length){for(var t=e.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof pt))throw t;this._saveException=t}if(null!==this._resultGeometry)return null}throw this._saveException}if(1===arguments.length){var n=arguments[0],r=e.precisionScaleFactor(this._argGeom,this._distance,n),i=new ie(r);this.bufferFixedPrecision(i)}}},{key:"computeGeometry",value:function(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;var t=this._argGeom.getFactory().getPrecisionModel();t.getType()===ie.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()}},{key:"setQuadrantSegments",value:function(t){this._bufParams.setQuadrantSegments(t)}},{key:"bufferOriginalPrecision",value:function(){try{var t=new sr(this._bufParams);this._resultGeometry=t.buffer(this._argGeom,this._distance)}catch(t){if(!(t instanceof F))throw t;this._saveException=t}}},{key:"getResultGeometry",value:function(t){return this._distance=t,this.computeGeometry(),this._resultGeometry}},{key:"setEndCapStyle",value:function(t){this._bufParams.setEndCapStyle(t)}}],[{key:"constructor_",value:function(){if(this._argGeom=null,this._distance=null,this._bufParams=new y,this._resultGeometry=null,this._saveException=null,1===arguments.length){var t=arguments[0];this._argGeom=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this._argGeom=e,this._bufParams=n}}},{key:"bufferOp",value:function(){if(2===arguments.length){var t=arguments[1];return new e(arguments[0]).getResultGeometry(t)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof U&&"number"==typeof arguments[1]){var n=arguments[1],r=arguments[2],i=new e(arguments[0]);return i.setQuadrantSegments(r),i.getResultGeometry(n)}if(arguments[2]instanceof y&&arguments[0]instanceof U&&"number"==typeof arguments[1]){var o=arguments[1];return new e(arguments[0],arguments[2]).getResultGeometry(o)}}else if(4===arguments.length){var s=arguments[1],a=arguments[2],u=arguments[3],l=new e(arguments[0]);return l.setQuadrantSegments(a),l.setEndCapStyle(u),l.getResultGeometry(s)}}},{key:"precisionScaleFactor",value:function(t,e,n){var r=t.getEnvelopeInternal(),i=Et.max(Math.abs(r.getMaxX()),Math.abs(r.getMaxY()),Math.abs(r.getMinX()),Math.abs(r.getMinY()))+2*(e>0?e:0),o=n-Math.trunc(Math.log(i)/Math.log(10)+1);return Math.pow(10,o)}}]),e}();vr.CAP_ROUND=y.CAP_ROUND,vr.CAP_BUTT=y.CAP_FLAT,vr.CAP_FLAT=y.CAP_FLAT,vr.CAP_SQUARE=y.CAP_SQUARE,vr.MAX_PRECISION_DIGITS=12;var dr=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"],yr=function(){function e(n){t(this,e),this.geometryFactory=n||new ae}return n(e,[{key:"read",value:function(t){var e,n=(e="string"==typeof t?JSON.parse(t):t).type;if(!mr[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==dr.indexOf(n)?mr[n].call(this,e.coordinates):"GeometryCollection"===n?mr[n].call(this,e.geometries):mr[n].call(this,e)}},{key:"write",value:function(t){var e=t.getGeometryType();if(!_r[e])throw new Error("Geometry is not supported");return _r[e].call(this,t)}}]),e}(),mr={Feature:function(t){var e={};for(var n in t)e[n]=t[n];if(t.geometry){var r=t.geometry.type;if(!mr[r])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=mr.bbox.call(this,t.bbox)),e},FeatureCollection:function(t){var e={};if(t.features){e.features=[];for(var n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.call(this,t.bbox)),e},coordinates:function(t){for(var e=[],n=0;n<t.length;++n){var r=t[n];e.push(a(z,g(r)))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new z(t[0],t[1]),new z(t[2],t[1]),new z(t[2],t[3]),new z(t[0],t[3]),new z(t[0],t[1])])},Point:function(t){var e=a(z,g(t));return this.geometryFactory.createPoint(e)},MultiPoint:function(t){for(var e=[],n=0;n<t.length;++n)e.push(mr.Point.call(this,t[n]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){var e=mr.coordinates.call(this,t);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){for(var e=[],n=0;n<t.length;++n)e.push(mr.LineString.call(this,t[n]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){for(var e=mr.coordinates.call(this,t[0]),n=this.geometryFactory.createLinearRing(e),r=[],i=1;i<t.length;++i){var o=t[i],s=mr.coordinates.call(this,o),a=this.geometryFactory.createLinearRing(s);r.push(a)}return this.geometryFactory.createPolygon(n,r)},MultiPolygon:function(t){for(var e=[],n=0;n<t.length;++n){var r=t[n];e.push(mr.Polygon.call(this,r))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){for(var e=[],n=0;n<t.length;++n){var r=t[n];e.push(this.read(r))}return this.geometryFactory.createGeometryCollection(e)}},_r={coordinate:function(t){var e=[t.x,t.y];return t.z&&e.push(t.z),t.m&&e.push(t.m),e},Point:function(t){return{type:"Point",coordinates:_r.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){for(var e=[],n=0;n<t._geometries.length;++n){var r=t._geometries[n],i=_r.Point.call(this,r);e.push(i.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){for(var e=[],n=t.getCoordinates(),r=0;r<n.length;++r){var i=n[r];e.push(_r.coordinate.call(this,i))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){for(var e=[],n=0;n<t._geometries.length;++n){var r=t._geometries[n],i=_r.LineString.call(this,r);e.push(i.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){var e=[],n=_r.LineString.call(this,t._shell);e.push(n.coordinates);for(var r=0;r<t._holes.length;++r){var i=t._holes[r],o=_r.LineString.call(this,i);e.push(o.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){for(var e=[],n=0;n<t._geometries.length;++n){var r=t._geometries[n],i=_r.Polygon.call(this,r);e.push(i.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){for(var e=[],n=0;n<t._geometries.length;++n){var r=t._geometries[n],i=r.getGeometryType();e.push(_r[i].call(this,r))}return{type:"GeometryCollection",geometries:e}}};return{BufferOp:vr,GeoJSONReader:function(){function e(n){t(this,e),this.parser=new yr(n||new ae)}return n(e,[{key:"read",value:function(t){return this.parser.read(t)}}]),e}(),GeoJSONWriter:function(){function e(){t(this,e),this.parser=new yr(this.geometryFactory)}return n(e,[{key:"write",value:function(t){return this.parser.write(t)}}]),e}()}}()}(Fn)),Fn.exports),Vn=mn(qn);function Gn(){return new Bn}function Bn(){this.reset()}Bn.prototype={constructor:Bn,reset:function(){this.s=this.t=0},add:function(t){zn(Yn,t,this.t),zn(this,Yn.s,this.s),this.s?this.t+=Yn.t:this.s=Yn.t},valueOf:function(){return this.s}};var Yn=new Bn;function zn(t,e,n){var r=t.s=e+n,i=r-e,o=r-i;t.t=e-o+(n-i)}var jn=1e-6,Xn=Math.PI,Un=Xn/2,Zn=Xn/4,Hn=2*Xn,Wn=180/Xn,Jn=Xn/180,Kn=Math.abs,Qn=Math.atan,$n=Math.atan2,tr=Math.cos,er=Math.sin,nr=Math.sqrt;function rr(t){return t>1?0:t<-1?Xn:Math.acos(t)}function ir(t){return t>1?Un:t<-1?-Un:Math.asin(t)}function or(){}function sr(t,e){t&&ur.hasOwnProperty(t.type)&&ur[t.type](t,e)}var ar={Feature:function(t,e){sr(t.geometry,e)},FeatureCollection:function(t,e){for(var n=t.features,r=-1,i=n.length;++r<i;)sr(n[r].geometry,e)}},ur={Sphere:function(t,e){e.sphere()},Point:function(t,e){t=t.coordinates,e.point(t[0],t[1],t[2])},MultiPoint:function(t,e){for(var n=t.coordinates,r=-1,i=n.length;++r<i;)t=n[r],e.point(t[0],t[1],t[2])},LineString:function(t,e){lr(t.coordinates,e,0)},MultiLineString:function(t,e){for(var n=t.coordinates,r=-1,i=n.length;++r<i;)lr(n[r],e,0)},Polygon:function(t,e){hr(t.coordinates,e)},MultiPolygon:function(t,e){for(var n=t.coordinates,r=-1,i=n.length;++r<i;)hr(n[r],e)},GeometryCollection:function(t,e){for(var n=t.geometries,r=-1,i=n.length;++r<i;)sr(n[r],e)}};function lr(t,e,n){var r,i=-1,o=t.length-n;for(e.lineStart();++i<o;)r=t[i],e.point(r[0],r[1],r[2]);e.lineEnd()}function hr(t,e){var n=-1,r=t.length;for(e.polygonStart();++n<r;)lr(t[n],e,1);e.polygonEnd()}function cr(t){return[$n(t[1],t[0]),ir(t[2])]}function fr(t){var e=t[0],n=t[1],r=tr(n);return[r*tr(e),r*er(e),er(n)]}function gr(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function pr(t,e){return[t[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0]]}function vr(t,e){t[0]+=e[0],t[1]+=e[1],t[2]+=e[2]}function dr(t,e){return[t[0]*e,t[1]*e,t[2]*e]}function yr(t){var e=nr(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]/=e,t[1]/=e,t[2]/=e}function mr(t,e){function n(n,r){return n=t(n,r),e(n[0],n[1])}return t.invert&&e.invert&&(n.invert=function(n,r){return(n=e.invert(n,r))&&t.invert(n[0],n[1])}),n}function _r(t,e){return[t>Xn?t-Hn:t<-Xn?t+Hn:t,e]}function xr(t){return function(e,n){return[(e+=t)>Xn?e-Hn:e<-Xn?e+Hn:e,n]}}function Er(t){var e=xr(t);return e.invert=xr(-t),e}function kr(t,e){var n=tr(t),r=er(t),i=tr(e),o=er(e);function s(t,e){var s=tr(e),a=tr(t)*s,u=er(t)*s,l=er(e),h=l*n+a*r;return[$n(u*i-h*o,a*n-l*r),ir(h*i+u*o)]}return s.invert=function(t,e){var s=tr(e),a=tr(t)*s,u=er(t)*s,l=er(e),h=l*i-u*o;return[$n(u*i+l*o,a*n+h*r),ir(h*n-a*r)]},s}function br(t,e){(e=fr(e))[0]-=t,yr(e);var n=rr(-e[1]);return((-e[2]<0?-n:n)+Hn-jn)%Hn}function wr(){var t,e=[];return{point:function(e,n){t.push([e,n])},lineStart:function(){e.push(t=[])},lineEnd:or,rejoin:function(){e.length>1&&e.push(e.pop().concat(e.shift()))},result:function(){var n=e;return e=[],t=null,n}}}function Ir(t,e){return Kn(t[0]-e[0])<jn&&Kn(t[1]-e[1])<jn}function Nr(t,e,n,r){this.x=t,this.z=e,this.o=n,this.e=r,this.v=!1,this.n=this.p=null}function Sr(t,e,n,r,i){var o,s,a=[],u=[];if(t.forEach((function(t){if(!((e=t.length-1)<=0)){var e,n,r=t[0],s=t[e];if(Ir(r,s)){for(i.lineStart(),o=0;o<e;++o)i.point((r=t[o])[0],r[1]);i.lineEnd()}else a.push(n=new Nr(r,t,null,!0)),u.push(n.o=new Nr(r,null,n,!1)),a.push(n=new Nr(s,t,null,!1)),u.push(n.o=new Nr(s,null,n,!0))}})),a.length){for(u.sort(e),Mr(a),Mr(u),o=0,s=u.length;o<s;++o)u[o].e=n=!n;for(var l,h,c=a[0];;){for(var f=c,g=!0;f.v;)if((f=f.n)===c)return;l=f.z,i.lineStart();do{if(f.v=f.o.v=!0,f.e){if(g)for(o=0,s=l.length;o<s;++o)i.point((h=l[o])[0],h[1]);else r(f.x,f.n.x,1,i);f=f.n}else{if(g)for(l=f.p.z,o=l.length-1;o>=0;--o)i.point((h=l[o])[0],h[1]);else r(f.x,f.p.x,-1,i);f=f.p}l=(f=f.o).z,g=!g}while(!f.v);i.lineEnd()}}}function Mr(t){if(e=t.length){for(var e,n,r=0,i=t[0];++r<e;)i.n=n=t[r],n.p=i,i=n;i.n=n=t[0],n.p=i}}function Lr(t,e){return t<e?-1:t>e?1:t>=e?0:NaN}function Pr(t){for(var e,n,r,i=t.length,o=-1,s=0;++o<i;)s+=t[o].length;for(n=new Array(s);--i>=0;)for(e=(r=t[i]).length;--e>=0;)n[--s]=r[e];return n}Gn(),Gn(),Gn(),_r.invert=_r,function(t){var e;1===t.length&&(e=t,t=function(t,n){return Lr(e(t),n)})}(Lr);var Cr=1e9,Tr=-Cr;function Or(t,e,n,r){function i(i,o){return t<=i&&i<=n&&e<=o&&o<=r}function o(i,o,a,l){var h=0,c=0;if(null==i||(h=s(i,a))!==(c=s(o,a))||u(i,o)<0^a>0)do{l.point(0===h||3===h?t:n,h>1?r:e)}while((h=(h+a+4)%4)!==c);else l.point(o[0],o[1])}function s(r,i){return Kn(r[0]-t)<jn?i>0?0:3:Kn(r[0]-n)<jn?i>0?2:1:Kn(r[1]-e)<jn?i>0?1:0:i>0?3:2}function a(t,e){return u(t.x,e.x)}function u(t,e){var n=s(t,1),r=s(e,1);return n!==r?n-r:0===n?e[1]-t[1]:1===n?t[0]-e[0]:2===n?t[1]-e[1]:e[0]-t[0]}return function(s){var u,l,h,c,f,g,p,v,d,y,m,_=s,x=wr(),E={point:k,lineStart:function(){E.point=b,l&&l.push(h=[]);y=!0,d=!1,p=v=NaN},lineEnd:function(){u&&(b(c,f),g&&d&&x.rejoin(),u.push(x.result()));E.point=k,d&&_.lineEnd()},polygonStart:function(){_=x,u=[],l=[],m=!0},polygonEnd:function(){var e=function(){for(var e=0,n=0,i=l.length;n<i;++n)for(var o,s,a=l[n],u=1,h=a.length,c=a[0],f=c[0],g=c[1];u<h;++u)o=f,s=g,f=(c=a[u])[0],g=c[1],s<=r?g>r&&(f-o)*(r-s)>(g-s)*(t-o)&&++e:g<=r&&(f-o)*(r-s)<(g-s)*(t-o)&&--e;return e}(),n=m&&e,i=(u=Pr(u)).length;(n||i)&&(s.polygonStart(),n&&(s.lineStart(),o(null,null,1,s),s.lineEnd()),i&&Sr(u,a,e,o,s),s.polygonEnd());_=s,u=l=h=null}};function k(t,e){i(t,e)&&_.point(t,e)}function b(o,s){var a=i(o,s);if(l&&h.push([o,s]),y)c=o,f=s,g=a,y=!1,a&&(_.lineStart(),_.point(o,s));else if(a&&d)_.point(o,s);else{var u=[p=Math.max(Tr,Math.min(Cr,p)),v=Math.max(Tr,Math.min(Cr,v))],x=[o=Math.max(Tr,Math.min(Cr,o)),s=Math.max(Tr,Math.min(Cr,s))];!function(t,e,n,r,i,o){var s,a=t[0],u=t[1],l=0,h=1,c=e[0]-a,f=e[1]-u;if(s=n-a,c||!(s>0)){if(s/=c,c<0){if(s<l)return;s<h&&(h=s)}else if(c>0){if(s>h)return;s>l&&(l=s)}if(s=i-a,c||!(s<0)){if(s/=c,c<0){if(s>h)return;s>l&&(l=s)}else if(c>0){if(s<l)return;s<h&&(h=s)}if(s=r-u,f||!(s>0)){if(s/=f,f<0){if(s<l)return;s<h&&(h=s)}else if(f>0){if(s>h)return;s>l&&(l=s)}if(s=o-u,f||!(s<0)){if(s/=f,f<0){if(s>h)return;s>l&&(l=s)}else if(f>0){if(s<l)return;s<h&&(h=s)}return l>0&&(t[0]=a+l*c,t[1]=u+l*f),h<1&&(e[0]=a+h*c,e[1]=u+h*f),!0}}}}}(u,x,t,e,n,r)?a&&(_.lineStart(),_.point(o,s),m=!1):(d||(_.lineStart(),_.point(u[0],u[1])),_.point(x[0],x[1]),a||_.lineEnd(),m=!1)}p=o,v=s,d=a}return E}}var Rr=Gn();function Ar(t){return t}Gn(),Gn(),Gn();var Dr=1/0,Fr=Dr,qr=-Dr,Vr=qr,Gr={point:function(t,e){t<Dr&&(Dr=t);t>qr&&(qr=t);e<Fr&&(Fr=e);e>Vr&&(Vr=e)},lineStart:or,lineEnd:or,polygonStart:or,polygonEnd:or,result:function(){var t=[[Dr,Fr],[qr,Vr]];return qr=Vr=-(Fr=Dr=1/0),t}};function Br(t,e,n,r){return function(i,o){var s,a,u,l=e(o),h=i.invert(r[0],r[1]),c=wr(),f=e(c),g=!1,p={point:v,lineStart:y,lineEnd:m,polygonStart:function(){p.point=_,p.lineStart=x,p.lineEnd=E,a=[],s=[]},polygonEnd:function(){p.point=v,p.lineStart=y,p.lineEnd=m,a=Pr(a);var t=function(t,e){var n=e[0],r=e[1],i=[er(n),-tr(n),0],o=0,s=0;Rr.reset();for(var a=0,u=t.length;a<u;++a)if(h=(l=t[a]).length)for(var l,h,c=l[h-1],f=c[0],g=c[1]/2+Zn,p=er(g),v=tr(g),d=0;d<h;++d,f=m,p=x,v=E,c=y){var y=l[d],m=y[0],_=y[1]/2+Zn,x=er(_),E=tr(_),k=m-f,b=k>=0?1:-1,w=b*k,I=w>Xn,N=p*x;if(Rr.add($n(N*b*er(w),v*E+N*tr(w))),o+=I?k+b*Hn:k,I^f>=n^m>=n){var S=pr(fr(c),fr(y));yr(S);var M=pr(i,S);yr(M);var L=(I^k>=0?-1:1)*ir(M[2]);(r>L||r===L&&(S[0]||S[1]))&&(s+=I^k>=0?1:-1)}}return(o<-jn||o<jn&&Rr<-jn)^1&s}(s,h);a.length?(g||(o.polygonStart(),g=!0),Sr(a,zr,t,n,o)):t&&(g||(o.polygonStart(),g=!0),o.lineStart(),n(null,null,1,o),o.lineEnd()),g&&(o.polygonEnd(),g=!1),a=s=null},sphere:function(){o.polygonStart(),o.lineStart(),n(null,null,1,o),o.lineEnd(),o.polygonEnd()}};function v(e,n){var r=i(e,n);t(e=r[0],n=r[1])&&o.point(e,n)}function d(t,e){var n=i(t,e);l.point(n[0],n[1])}function y(){p.point=d,l.lineStart()}function m(){p.point=v,l.lineEnd()}function _(t,e){u.push([t,e]);var n=i(t,e);f.point(n[0],n[1])}function x(){f.lineStart(),u=[]}function E(){_(u[0][0],u[0][1]),f.lineEnd();var t,e,n,r,i=f.clean(),l=c.result(),h=l.length;if(u.pop(),s.push(u),u=null,h)if(1&i){if((e=(n=l[0]).length-1)>0){for(g||(o.polygonStart(),g=!0),o.lineStart(),t=0;t<e;++t)o.point((r=n[t])[0],r[1]);o.lineEnd()}}else h>1&&2&i&&l.push(l.pop().concat(l.shift())),a.push(l.filter(Yr))}return p}}function Yr(t){return t.length>1}function zr(t,e){return((t=t.x)[0]<0?t[1]-Un-jn:Un-t[1])-((e=e.x)[0]<0?e[1]-Un-jn:Un-e[1])}Gn();var jr=Br((function(){return!0}),(function(t){var e,n=NaN,r=NaN,i=NaN;return{lineStart:function(){t.lineStart(),e=1},point:function(o,s){var a=o>0?Xn:-Xn,u=Kn(o-n);Kn(u-Xn)<jn?(t.point(n,r=(r+s)/2>0?Un:-Un),t.point(i,r),t.lineEnd(),t.lineStart(),t.point(a,r),t.point(o,r),e=0):i!==a&&u>=Xn&&(Kn(n-i)<jn&&(n-=i*jn),Kn(o-a)<jn&&(o-=a*jn),r=function(t,e,n,r){var i,o,s=er(t-n);return Kn(s)>jn?Qn((er(e)*(o=tr(r))*er(n)-er(r)*(i=tr(e))*er(t))/(i*o*s)):(e+r)/2}(n,r,o,s),t.point(i,r),t.lineEnd(),t.lineStart(),t.point(a,r),e=0),t.point(n=o,r=s),i=a},lineEnd:function(){t.lineEnd(),n=r=NaN},clean:function(){return 2-e}}}),(function(t,e,n,r){var i;if(null==t)i=n*Un,r.point(-Xn,i),r.point(0,i),r.point(Xn,i),r.point(Xn,0),r.point(Xn,-i),r.point(0,-i),r.point(-Xn,-i),r.point(-Xn,0),r.point(-Xn,i);else if(Kn(t[0]-e[0])>jn){var o=t[0]<e[0]?Xn:-Xn;i=n*o/2,r.point(-o,i),r.point(0,i),r.point(o,i)}else r.point(e[0],e[1])}),[-Xn,-Un]);function Xr(t,e){var n=tr(t),r=n>0,i=Kn(n)>jn;function o(t,e){return tr(t)*tr(e)>n}function s(t,e,r){var i=[1,0,0],o=pr(fr(t),fr(e)),s=gr(o,o),a=o[0],u=s-a*a;if(!u)return!r&&t;var l=n*s/u,h=-n*a/u,c=pr(i,o),f=dr(i,l);vr(f,dr(o,h));var g=c,p=gr(f,g),v=gr(g,g),d=p*p-v*(gr(f,f)-1);if(!(d<0)){var y=nr(d),m=dr(g,(-p-y)/v);if(vr(m,f),m=cr(m),!r)return m;var _,x=t[0],E=e[0],k=t[1],b=e[1];E<x&&(_=x,x=E,E=_);var w=E-x,I=Kn(w-Xn)<jn;if(!I&&b<k&&(_=k,k=b,b=_),I||w<jn?I?k+b>0^m[1]<(Kn(m[0]-x)<jn?k:b):k<=m[1]&&m[1]<=b:w>Xn^(x<=m[0]&&m[0]<=E)){var N=dr(g,(-p+y)/v);return vr(N,f),[m,cr(N)]}}}function a(e,n){var i=r?t:Xn-t,o=0;return e<-i?o|=1:e>i&&(o|=2),n<-i?o|=4:n>i&&(o|=8),o}return Br(o,(function(t){var e,n,u,l,h;return{lineStart:function(){l=u=!1,h=1},point:function(c,f){var g,p=[c,f],v=o(c,f),d=r?v?0:a(c,f):v?a(c+(c<0?Xn:-Xn),f):0;if(!e&&(l=u=v)&&t.lineStart(),v!==u&&(!(g=s(e,p))||Ir(e,g)||Ir(p,g))&&(p[0]+=jn,p[1]+=jn,v=o(p[0],p[1])),v!==u)h=0,v?(t.lineStart(),g=s(p,e),t.point(g[0],g[1])):(g=s(e,p),t.point(g[0],g[1]),t.lineEnd()),e=g;else if(i&&e&&r^v){var y;d&n||!(y=s(p,e,!0))||(h=0,r?(t.lineStart(),t.point(y[0][0],y[0][1]),t.point(y[1][0],y[1][1]),t.lineEnd()):(t.point(y[1][0],y[1][1]),t.lineEnd(),t.lineStart(),t.point(y[0][0],y[0][1])))}!v||e&&Ir(e,p)||t.point(p[0],p[1]),e=p,u=v,n=d},lineEnd:function(){u&&t.lineEnd(),e=null},clean:function(){return h|(l&&u)<<1}}}),(function(n,r,i,o){!function(t,e,n,r,i,o){if(n){var s=tr(e),a=er(e),u=r*n;null==i?(i=e+r*Hn,o=e-u/2):(i=br(s,i),o=br(s,o),(r>0?i<o:i>o)&&(i+=r*Hn));for(var l,h=i;r>0?h>o:h<o;h-=u)l=cr([s,-a*tr(h),-a*er(h)]),t.point(l[0],l[1])}}(o,t,e,i,n,r)}),r?[0,-t]:[-Xn,t-Xn])}function Ur(t){return function(e){var n=new Zr;for(var r in t)n[r]=t[r];return n.stream=e,n}}function Zr(){}function Hr(t,e,n){var r=e[1][0]-e[0][0],i=e[1][1]-e[0][1],o=t.clipExtent&&t.clipExtent();t.scale(150).translate([0,0]),null!=o&&t.clipExtent(null),function(t,e){t&&ar.hasOwnProperty(t.type)?ar[t.type](t,e):sr(t,e)}(n,t.stream(Gr));var s=Gr.result(),a=Math.min(r/(s[1][0]-s[0][0]),i/(s[1][1]-s[0][1])),u=+e[0][0]+(r-a*(s[1][0]+s[0][0]))/2,l=+e[0][1]+(i-a*(s[1][1]+s[0][1]))/2;return null!=o&&t.clipExtent(o),t.scale(150*a).translate([u,l])}Zr.prototype={constructor:Zr,point:function(t,e){this.stream.point(t,e)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}};var Wr=16,Jr=tr(30*Jn);function Kr(t,e){return+e?function(t,e){function n(r,i,o,s,a,u,l,h,c,f,g,p,v,d){var y=l-r,m=h-i,_=y*y+m*m;if(_>4*e&&v--){var x=s+f,E=a+g,k=u+p,b=nr(x*x+E*E+k*k),w=ir(k/=b),I=Kn(Kn(k)-1)<jn||Kn(o-c)<jn?(o+c)/2:$n(E,x),N=t(I,w),S=N[0],M=N[1],L=S-r,P=M-i,C=m*L-y*P;(C*C/_>e||Kn((y*L+m*P)/_-.5)>.3||s*f+a*g+u*p<Jr)&&(n(r,i,o,s,a,u,S,M,I,x/=b,E/=b,k,v,d),d.point(S,M),n(S,M,I,x,E,k,l,h,c,f,g,p,v,d))}}return function(e){var r,i,o,s,a,u,l,h,c,f,g,p,v={point:d,lineStart:y,lineEnd:_,polygonStart:function(){e.polygonStart(),v.lineStart=x},polygonEnd:function(){e.polygonEnd(),v.lineStart=y}};function d(n,r){n=t(n,r),e.point(n[0],n[1])}function y(){h=NaN,v.point=m,e.lineStart()}function m(r,i){var o=fr([r,i]),s=t(r,i);n(h,c,l,f,g,p,h=s[0],c=s[1],l=r,f=o[0],g=o[1],p=o[2],Wr,e),e.point(h,c)}function _(){v.point=d,e.lineEnd()}function x(){y(),v.point=E,v.lineEnd=k}function E(t,e){m(r=t,e),i=h,o=c,s=f,a=g,u=p,v.point=m}function k(){n(h,c,l,f,g,p,i,o,r,s,a,u,Wr,e),v.lineEnd=_,_()}return v}}(t,e):function(t){return Ur({point:function(e,n){e=t(e,n),this.stream.point(e[0],e[1])}})}(t)}var Qr=Ur({point:function(t,e){this.stream.point(t*Jn,e*Jn)}});function $r(t){return function(t){var e,n,r,i,o,s,a,u,l,h,c=150,f=480,g=250,p=0,v=0,d=0,y=0,m=0,_=null,x=jr,E=null,k=Ar,b=.5,w=Kr(S,b);function I(t){return[(t=o(t[0]*Jn,t[1]*Jn))[0]*c+n,r-t[1]*c]}function N(t){return(t=o.invert((t[0]-n)/c,(r-t[1])/c))&&[t[0]*Wn,t[1]*Wn]}function S(t,i){return[(t=e(t,i))[0]*c+n,r-t[1]*c]}function M(){o=mr(i=function(t,e,n){return(t%=Hn)?e||n?mr(Er(t),kr(e,n)):Er(t):e||n?kr(e,n):_r}(d,y,m),e);var t=e(p,v);return n=f-t[0]*c,r=g+t[1]*c,L()}function L(){return l=h=null,I}return I.stream=function(t){return l&&h===t?l:l=Qr(x(i,w(k(h=t))))},I.clipAngle=function(t){return arguments.length?(x=+t?Xr(_=t*Jn,6*Jn):(_=null,jr),L()):_*Wn},I.clipExtent=function(t){return arguments.length?(k=null==t?(E=s=a=u=null,Ar):Or(E=+t[0][0],s=+t[0][1],a=+t[1][0],u=+t[1][1]),L()):null==E?null:[[E,s],[a,u]]},I.scale=function(t){return arguments.length?(c=+t,M()):c},I.translate=function(t){return arguments.length?(f=+t[0],g=+t[1],M()):[f,g]},I.center=function(t){return arguments.length?(p=t[0]%360*Jn,v=t[1]%360*Jn,M()):[p*Wn,v*Wn]},I.rotate=function(t){return arguments.length?(d=t[0]%360*Jn,y=t[1]%360*Jn,m=t.length>2?t[2]%360*Jn:0,M()):[d*Wn,y*Wn,m*Wn]},I.precision=function(t){return arguments.length?(w=Kr(S,b=t*t),L()):nr(b)},I.fitExtent=function(t,e){return Hr(I,t,e)},I.fitSize=function(t,e){return function(t,e,n){return Hr(t,[[0,0],e],n)}(I,t,e)},function(){return e=t.apply(this,arguments),I.invert=e.invert&&N,M()}}((function(){return t}))()}function ti(t){return function(e,n){var r=tr(e),i=tr(n),o=t(r*i);return[o*i*er(e),o*er(n)]}}function ei(t){return function(e,n){var r=nr(e*e+n*n),i=t(r),o=er(i),s=tr(i);return[$n(e*o,r*s),ir(r&&n*o/r)]}}ti((function(t){return nr(2/(1+t))})).invert=ei((function(t){return 2*ir(t/2)}));var ni=ti((function(t){return(t=rr(t))&&t/er(t)}));function ri(){return $r(ni).scale(79.4188).clipAngle(179.999)}function ii(t,e){return[t,e]}ni.invert=ei((function(t){return t})),ii.invert=ii;var oi=Vn.BufferOp,si=Vn.GeoJSONReader,ai=Vn.GeoJSONWriter;function ui(t,e,n,r){var i=t.properties||{},o="Feature"===t.type?t.geometry:t;if("GeometryCollection"===o.type){var s=[];return mt(t,(function(t){var i=ui(t,e,n,r);i&&s.push(i)})),C(s)}var a=function(t){var e=An(t).geometry.coordinates,n=[-e[0],-e[1]];return ri().rotate(n).scale(x)}(o),u={type:o.type,coordinates:hi(o.coordinates,a)},l=(new si).read(u),h=F(q(e,n),"meters"),c=oi.bufferOp(l,h,r);if(!li((c=(new ai).write(c)).coordinates))return b({type:c.type,coordinates:ci(c.coordinates,a)},i)}function li(t){return Array.isArray(t[0])?li(t[0]):isNaN(t[0])}function hi(t,e){return"object"!==m(t[0])?e(t):t.map((function(t){return hi(t,e)}))}function ci(t,e){return"object"!==m(t[0])?e.invert(t):t.map((function(t){return ci(t,e)}))}function fi(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=0,r=0,i=0;return mt(t,(function(t,o,s){var a=e.weight?null==s?void 0:s[e.weight]:void 0;if(!U(a=null==a?1:a))throw new Error("weight value must be a number for feature index "+o);(a=Number(a))>0&&ct(t,(function(t){n+=t[0]*a,r+=t[1]*a,i+=a}))})),I([n/i,r/i],e.properties,e)}function gi(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=0,r=0,i=0;return ct(t,(function(t){n+=t[0],r+=t[1],i++}),!0),I([n/i,r/i],e.properties)}function pi(t,e,n,r,i){var o=r.tolerance||.001,s=0,a=0,u=0,l=0;if(vt(n,(function(e){var n,r=null==(n=e.properties)?void 0:n.weight,i=null==r?1:r;if(!U(i=Number(i)))throw new Error("weight value must be a number");if(i>0){l+=1;var o=i*ut(e,t);0===o&&(o=1);var h=i/o;s+=e.geometry.coordinates[0]*h,a+=e.geometry.coordinates[1]*h,u+=h}})),l<1)throw new Error("no features to measure");var h=s/u,c=a/u;return 1===l||0===i||Math.abs(h-e[0])<o&&Math.abs(c-e[1])<o?I([h,c],{medianCandidates:r.medianCandidates}):(r.medianCandidates.push([h,c]),pi([h,c],t,n,r,i-1))}var vi={exports:{}},di=_n(Ke),yi=function(){return s((function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mi;if(i(this,t),this.data=e,this.length=this.data.length,this.compare=n,this.length>0)for(var r=(this.length>>1)-1;r>=0;r--)this._down(r)}),[{key:"push",value:function(t){this.data.push(t),this.length++,this._up(this.length-1)}},{key:"pop",value:function(){if(0!==this.length){var t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}}},{key:"peek",value:function(){return this.data[0]}},{key:"_up",value:function(t){for(var e=this.data,n=this.compare,r=e[t];t>0;){var i=t-1>>1,o=e[i];if(n(r,o)>=0)break;e[t]=o,t=i}e[t]=r}},{key:"_down",value:function(t){for(var e=this.data,n=this.compare,r=this.length>>1,i=e[t];t<r;){var o=1+(t<<1),s=e[o],a=o+1;if(a<this.length&&n(e[a],s)<0&&(o=a,s=e[a]),n(s,i)>=0)break;e[t]=s,t=o}e[t]=i}}])}();function mi(t,e){return t<e?-1:t>e?1:0}var _i,xi,Ei,ki,bi,wi=_n(Object.freeze({__proto__:null,default:yi})),Ii={exports:{}};function Ni(){if(bi)return Ii.exports;bi=1;var t=(xi||(xi=1,_i=function(t,e,n,r){var i=t[0],o=t[1],s=!1;void 0===n&&(n=0),void 0===r&&(r=e.length);for(var a=(r-n)/2,u=0,l=a-1;u<a;l=u++){var h=e[n+2*u+0],c=e[n+2*u+1],f=e[n+2*l+0],g=e[n+2*l+1];c>o!=g>o&&i<(f-h)*(o-c)/(g-c)+h&&(s=!s)}return s}),_i),e=(ki||(ki=1,Ei=function(t,e,n,r){var i=t[0],o=t[1],s=!1;void 0===n&&(n=0),void 0===r&&(r=e.length);for(var a=r-n,u=0,l=a-1;u<a;l=u++){var h=e[u+n][0],c=e[u+n][1],f=e[l+n][0],g=e[l+n][1];c>o!=g>o&&i<(f-h)*(o-c)/(g-c)+h&&(s=!s)}return s}),Ei);return Ii.exports=function(n,r,i,o){return r.length>0&&Array.isArray(r[0])?e(n,r,i,o):t(n,r,i,o)},Ii.exports.nested=e,Ii.exports.flat=t,Ii.exports}var Si,Mi,Li={exports:{}};Li.exports;function Pi(){return Si||(Si=1,function(t,e){!function(t){var e=134217729,n=33306690738754706e-32;function r(t,e,n,r,i){var o,s,a,u,l=e[0],h=r[0],c=0,f=0;h>l==h>-l?(o=l,l=e[++c]):(o=h,h=r[++f]);var g=0;if(c<t&&f<n)for(h>l==h>-l?(a=o-((s=l+o)-l),l=e[++c]):(a=o-((s=h+o)-h),h=r[++f]),o=s,0!==a&&(i[g++]=a);c<t&&f<n;)h>l==h>-l?(a=o-((s=o+l)-(u=s-o))+(l-u),l=e[++c]):(a=o-((s=o+h)-(u=s-o))+(h-u),h=r[++f]),o=s,0!==a&&(i[g++]=a);for(;c<t;)a=o-((s=o+l)-(u=s-o))+(l-u),l=e[++c],o=s,0!==a&&(i[g++]=a);for(;f<n;)a=o-((s=o+h)-(u=s-o))+(h-u),h=r[++f],o=s,0!==a&&(i[g++]=a);return 0===o&&0!==g||(i[g++]=o),g}function i(t){return new Float64Array(t)}var o=33306690738754716e-32,s=22204460492503146e-32,a=11093356479670487e-47,u=i(4),l=i(8),h=i(12),c=i(16),f=i(4);t.orient2d=function(t,i,g,p,v,d){var y=(i-d)*(g-v),m=(t-v)*(p-d),_=y-m;if(0===y||0===m||y>0!=m>0)return _;var x=Math.abs(y+m);return Math.abs(_)>=o*x?_:-function(t,i,o,g,p,v,d){var y,m,_,x,E,k,b,w,I,N,S,M,L,P,C,T,O,R,A=t-p,D=o-p,F=i-v,q=g-v;E=(C=(w=A-(b=(k=e*A)-(k-A)))*(N=q-(I=(k=e*q)-(k-q)))-((P=A*q)-b*I-w*I-b*N))-(S=C-(O=(w=F-(b=(k=e*F)-(k-F)))*(N=D-(I=(k=e*D)-(k-D)))-((T=F*D)-b*I-w*I-b*N))),u[0]=C-(S+E)+(E-O),E=(L=P-((M=P+S)-(E=M-P))+(S-E))-(S=L-T),u[1]=L-(S+E)+(E-T),E=(R=M+S)-M,u[2]=M-(R-E)+(S-E),u[3]=R;var V=function(t,e){for(var n=e[0],r=1;r<t;r++)n+=e[r];return n}(4,u),G=s*d;if(V>=G||-V>=G)return V;if(y=t-(A+(E=t-A))+(E-p),_=o-(D+(E=o-D))+(E-p),m=i-(F+(E=i-F))+(E-v),x=g-(q+(E=g-q))+(E-v),0===y&&0===m&&0===_&&0===x)return V;if(G=a*d+n*Math.abs(V),(V+=A*x+q*y-(F*_+D*m))>=G||-V>=G)return V;E=(C=(w=y-(b=(k=e*y)-(k-y)))*(N=q-(I=(k=e*q)-(k-q)))-((P=y*q)-b*I-w*I-b*N))-(S=C-(O=(w=m-(b=(k=e*m)-(k-m)))*(N=D-(I=(k=e*D)-(k-D)))-((T=m*D)-b*I-w*I-b*N))),f[0]=C-(S+E)+(E-O),E=(L=P-((M=P+S)-(E=M-P))+(S-E))-(S=L-T),f[1]=L-(S+E)+(E-T),E=(R=M+S)-M,f[2]=M-(R-E)+(S-E),f[3]=R;var B=r(4,u,4,f,l);E=(C=(w=A-(b=(k=e*A)-(k-A)))*(N=x-(I=(k=e*x)-(k-x)))-((P=A*x)-b*I-w*I-b*N))-(S=C-(O=(w=F-(b=(k=e*F)-(k-F)))*(N=_-(I=(k=e*_)-(k-_)))-((T=F*_)-b*I-w*I-b*N))),f[0]=C-(S+E)+(E-O),E=(L=P-((M=P+S)-(E=M-P))+(S-E))-(S=L-T),f[1]=L-(S+E)+(E-T),E=(R=M+S)-M,f[2]=M-(R-E)+(S-E),f[3]=R;var Y=r(B,l,4,f,h);E=(C=(w=y-(b=(k=e*y)-(k-y)))*(N=x-(I=(k=e*x)-(k-x)))-((P=y*x)-b*I-w*I-b*N))-(S=C-(O=(w=m-(b=(k=e*m)-(k-m)))*(N=_-(I=(k=e*_)-(k-_)))-((T=m*_)-b*I-w*I-b*N))),f[0]=C-(S+E)+(E-O),E=(L=P-((M=P+S)-(E=M-P))+(S-E))-(S=L-T),f[1]=L-(S+E)+(E-T),E=(R=M+S)-M,f[2]=M-(R-E)+(S-E),f[3]=R;var z=r(Y,h,4,f,c);return c[z-1]}(t,i,g,p,v,d,x)},t.orient2dfast=function(t,e,n,r,i,o){return(e-o)*(n-i)-(t-i)*(r-o)},Object.defineProperty(t,"__esModule",{value:!0})}(e)}(0,Li.exports)),Li.exports}var Ci=function(){if(Mi)return vi.exports;Mi=1;var t=di,e=wi,n=Ni(),r=Pi().orient2d;function i(e,r,i){r=Math.max(0,void 0===r?2:r),i=i||0;var s=function(t){for(var e=t[0],r=t[0],i=t[0],o=t[0],s=0;s<t.length;s++){var a=t[s];a[0]<e[0]&&(e=a),a[0]>i[0]&&(i=a),a[1]<r[1]&&(r=a),a[1]>o[1]&&(o=a)}var u=[e,r,i,o],l=u.slice();for(s=0;s<t.length;s++)n(t[s],u)||l.push(t[s]);return function(t){t.sort(d);for(var e=[],n=0;n<t.length;n++){for(;e.length>=2&&h(e[e.length-2],e[e.length-1],t[n])<=0;)e.pop();e.push(t[n])}for(var r=[],i=t.length-1;i>=0;i--){for(;r.length>=2&&h(r[r.length-2],r[r.length-1],t[i])<=0;)r.pop();r.push(t[i])}return r.pop(),e.pop(),e.concat(r)}(l)}(e),a=new t(16);a.toBBox=function(t){return{minX:t[0],minY:t[1],maxX:t[0],maxY:t[1]}},a.compareMinX=function(t,e){return t[0]-e[0]},a.compareMinY=function(t,e){return t[1]-e[1]},a.load(e);for(var u,l=[],p=0;p<s.length;p++){var v=s[p];a.remove(v),u=f(v,u),l.push(u)}var y=new t(16);for(p=0;p<l.length;p++)y.insert(c(l[p]));for(var m=r*r,_=i*i;l.length;){var x=l.shift(),E=x.p,k=x.next.p,b=g(E,k);if(!(b<_)){var w=b/m;(v=o(a,x.prev.p,E,k,x.next.next.p,w,y))&&Math.min(g(v,E),g(v,k))<=w&&(l.push(x),l.push(f(v,x)),a.remove(v),y.remove(x),y.insert(c(x)),y.insert(c(x.next)))}}x=u;var I=[];do{I.push(x.p),x=x.next}while(x!==u);return I.push(x.p),I}function o(t,n,r,i,o,u,h){for(var c=new e([],s),f=t.data;f;){for(var g=0;g<f.children.length;g++){var v=f.children[g],d=f.leaf?p(v,r,i):a(r,i,v);d>u||c.push({node:v,dist:d})}for(;c.length&&!c.peek().node.children;){var y=c.pop(),m=y.node,_=p(m,n,r),x=p(m,i,o);if(y.dist<_&&y.dist<x&&l(r,m,h)&&l(i,m,h))return m}(f=c.pop())&&(f=f.node)}return null}function s(t,e){return t.dist-e.dist}function a(t,e,n){if(u(t,n)||u(e,n))return 0;var r=v(t[0],t[1],e[0],e[1],n.minX,n.minY,n.maxX,n.minY);if(0===r)return 0;var i=v(t[0],t[1],e[0],e[1],n.minX,n.minY,n.minX,n.maxY);if(0===i)return 0;var o=v(t[0],t[1],e[0],e[1],n.maxX,n.minY,n.maxX,n.maxY);if(0===o)return 0;var s=v(t[0],t[1],e[0],e[1],n.minX,n.maxY,n.maxX,n.maxY);return 0===s?0:Math.min(r,i,o,s)}function u(t,e){return t[0]>=e.minX&&t[0]<=e.maxX&&t[1]>=e.minY&&t[1]<=e.maxY}function l(t,e,n){for(var r,i,o,s,a=Math.min(t[0],e[0]),u=Math.min(t[1],e[1]),l=Math.max(t[0],e[0]),c=Math.max(t[1],e[1]),f=n.search({minX:a,minY:u,maxX:l,maxY:c}),g=0;g<f.length;g++)if(r=f[g].p,i=f[g].next.p,o=t,r!==(s=e)&&i!==o&&h(r,i,o)>0!=h(r,i,s)>0&&h(o,s,r)>0!=h(o,s,i)>0)return!1;return!0}function h(t,e,n){return r(t[0],t[1],e[0],e[1],n[0],n[1])}function c(t){var e=t.p,n=t.next.p;return t.minX=Math.min(e[0],n[0]),t.minY=Math.min(e[1],n[1]),t.maxX=Math.max(e[0],n[0]),t.maxY=Math.max(e[1],n[1]),t}function f(t,e){var n={p:t,prev:null,next:null,minX:0,minY:0,maxX:0,maxY:0};return e?(n.next=e.next,n.prev=e,e.next.prev=n,e.next=n):(n.prev=n,n.next=n),n}function g(t,e){var n=t[0]-e[0],r=t[1]-e[1];return n*n+r*r}function p(t,e,n){var r=e[0],i=e[1],o=n[0]-r,s=n[1]-i;if(0!==o||0!==s){var a=((t[0]-r)*o+(t[1]-i)*s)/(o*o+s*s);a>1?(r=n[0],i=n[1]):a>0&&(r+=o*a,i+=s*a)}return(o=t[0]-r)*o+(s=t[1]-i)*s}function v(t,e,n,r,i,o,s,a){var u,l,h,c,f=n-t,g=r-e,p=s-i,v=a-o,d=t-i,y=e-o,m=f*f+g*g,_=f*p+g*v,x=p*p+v*v,E=f*d+g*y,k=p*d+v*y,b=m*x-_*_,w=b,I=b;0===b?(l=0,w=1,c=k,I=x):(c=m*k-_*E,(l=_*k-x*E)<0?(l=0,c=k,I=x):l>w&&(l=w,c=k+_,I=x)),c<0?(c=0,-E<0?l=0:-E>m?l=w:(l=-E,w=m)):c>I&&(c=I,-E+_<0?l=0:-E+_>m?l=w:(l=-E+_,w=m));var N=(1-(h=0===c?0:c/I))*i+h*s-((1-(u=0===l?0:l/w))*t+u*n),S=(1-h)*o+h*a-((1-u)*e+u*r);return N*N+S*S}function d(t,e){return t[0]===e[0]?t[1]-e[1]:t[0]-e[0]}return e.default&&(e=e.default),vi.exports=i,vi.exports.default=i,vi.exports}(),Ti=mn(Ci);function Oi(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e.concavity=e.concavity||1/0;var n=[];if(ct(t,(function(t){n.push([t[0],t[1]])})),!n.length)return null;var r=Ti(n,e.concavity);return r.length>3?S([r]):null}function Ri(t,e){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=n.steps||64,i=n.properties?n.properties:!Array.isArray(t)&&"Feature"===t.type&&t.properties?t.properties:{},o=[],s=0;s<r;s++)o.push(at(t,e,-360*s/r,n).geometry.coordinates);return o.push(o[0]),S([o],i)}function Ai(t){if(!t)throw new Error("geojson is required");switch(t.type){case"Feature":return Di(t);case"FeatureCollection":return function(t){var e={type:"FeatureCollection"};return Object.keys(t).forEach((function(n){switch(n){case"type":case"features":return;default:e[n]=t[n]}})),e.features=t.features.map((function(t){return Di(t)})),e}(t);case"Point":case"LineString":case"Polygon":case"MultiPoint":case"MultiLineString":case"MultiPolygon":case"GeometryCollection":return qi(t);default:throw new Error("unknown GeoJSON type")}}function Di(t){var e={type:"Feature"};return Object.keys(t).forEach((function(n){switch(n){case"type":case"properties":case"geometry":return;default:e[n]=t[n]}})),e.properties=Fi(t.properties),null==t.geometry?e.geometry=null:e.geometry=qi(t.geometry),e}function Fi(t){var e={};return t?(Object.keys(t).forEach((function(n){var r=t[n];"object"===m(r)?null===r?e[n]=null:Array.isArray(r)?e[n]=r.map((function(t){return t})):e[n]=Fi(r):e[n]=r})),e):e}function qi(t){var e={type:t.type};return t.bbox&&(e.bbox=t.bbox),"GeometryCollection"===t.type?(e.geometries=t.geometries.map((function(t){return qi(t)})),e):(e.coordinates=Vi(t.coordinates),e)}function Vi(t){var e=t;return"object"!==m(e[0])?e.slice():e.map((function(t){return Vi(t)}))}function Gi(t,e){if(!t)throw new Error("geojson is required");if("FeatureCollection"!==t.type)throw new Error("geojson must be a FeatureCollection");if(null==e)throw new Error("filter is required");var n=[];return vt(t,(function(t){ji(t.properties,e)&&n.push(t)})),C(n)}function Bi(t,e,n){if(!t)throw new Error("geojson is required");if("FeatureCollection"!==t.type)throw new Error("geojson must be a FeatureCollection");if(null==e)throw new Error("property is required");for(var r=zi(t,e),i=Object.keys(r),o=0;o<i.length;o++){for(var s=i[o],a=r[s],u=[],l=0;l<a.length;l++)u.push(t.features[a[l]]);n(C(u),s,o)}}function Yi(t,e,n,r){var i=r;return Bi(t,e,(function(t,e,o){i=0===o&&void 0===r?t:n(i,t,e,o)})),i}function zi(t,e){var n={};return vt(t,(function(t,r){var i=t.properties||{};if(Object.prototype.hasOwnProperty.call(i,String(e))){var o=i[e];Object.prototype.hasOwnProperty.call(n,o)?n[o].push(r):n[o]=[r]}})),n}function ji(t,e){if(void 0===t)return!1;var n=m(e);if("number"===n||"string"===n)return Object.prototype.hasOwnProperty.call(t,e);if(Array.isArray(e)){for(var r=0;r<e.length;r++)if(!ji(t,e[r]))return!1;return!0}return Xi(t,e)}function Xi(t,e){for(var n=Object.keys(e),r=0;r<n.length;r++){var i=n[r];if(t[i]!==e[i])return!1}return!0}function Ui(t,e){if(!e)return{};if(!e.length)return{};for(var n={},r=0;r<e.length;r++){var i=e[r];Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n}var Zi,Hi,Wi,Ji,Ki,Qi,$i=Object.freeze({__proto__:null,applyFilter:ji,clusterEach:Bi,clusterReduce:Yi,createBins:zi,filterProperties:Ui,getCluster:Gi,propertiesContainsFilter:Xi}),to=qe;function eo(){return Hi||(Hi=1,Zi={eudist:function(t,e,n){for(var r=t.length,i=0,o=0;o<r;o++){var s=(t[o]||0)-(e[o]||0);i+=s*s}return n?Math.sqrt(i):i},mandist:function(t,e,n){for(var r=t.length,i=0,o=0;o<r;o++)i+=Math.abs((t[o]||0)-(e[o]||0));return n?Math.sqrt(i):i},dist:function(t,e,n){var r=Math.abs(t-e);return n?r:r*r}}),Zi}var no=function(){if(Qi)return Ki;Qi=1;var t=eo(),e=function(){if(Ji)return Wi;Ji=1;var t=eo(),e=t.eudist,n=t.dist;return Wi={kmrand:function(t,e){for(var n={},r=[],i=e<<2,o=t.length,s=t[0].length>0;r.length<e&&i-- >0;){var a=t[Math.floor(Math.random()*o)],u=s?a.join("_"):""+a;n[u]||(n[u]=!0,r.push(a))}if(r.length<e)throw new Error("Error initializating clusters");return r},kmpp:function(t,r){var i=t[0].length?e:n,o=[],s=t.length,a=t[0].length>0,u=t[Math.floor(Math.random()*s)];for(a&&u.join("_"),o.push(u);o.length<r;){for(var l=[],h=o.length,c=0,f=[],g=0;g<s;g++){for(var p=1/0,v=0;v<h;v++){var d=i(t[g],o[v]);d<=p&&(p=d)}l[g]=p}for(var y=0;y<s;y++)c+=l[y];for(var m=0;m<s;m++)f[m]={i:m,v:t[m],pr:l[m]/c,cs:0};f.sort((function(t,e){return t.pr-e.pr})),f[0].cs=f[0].pr;for(var _=1;_<s;_++)f[_].cs=f[_-1].cs+f[_].pr;for(var x=Math.random(),E=0;E<s-1&&f[E++].cs<x;);o.push(f[E-1].v)}return o}},Wi}(),n=t.eudist;t.mandist,t.dist;var r=e.kmrand,i=e.kmpp;function o(t,e,n){n=n||[];for(var r=0;r<t;r++)n[r]=e;return n}return Ki=function(t,e,s,a){var u=[],l=[],h=[],c=[],f=!1,g=a||1e4,p=t.length,v=t[0].length,d=v>0,y=[];if(s)u="kmrand"==s?r(t,e):"kmpp"==s?i(t,e):s;else for(var m={};u.length<e;){var _=Math.floor(Math.random()*p);m[_]||(m[_]=!0,u.push(t[_]))}do{o(e,0,y);for(var x=0;x<p;x++){for(var E=1/0,k=0,b=0;b<e;b++){(c=d?n(t[x],u[b]):Math.abs(t[x]-u[b]))<=E&&(E=c,k=b)}h[x]=k,y[k]++}for(var w=[],I=(l=[],0);I<e;I++)w[I]=d?o(v,0,w[I]):0,l[I]=u[I];if(d){for(var N=0;N<e;N++)u[N]=[];for(var S=0;S<p;S++)for(var M=w[h[S]],L=t[S],P=0;P<v;P++)M[P]+=L[P];f=!0;for(var C=0;C<e;C++){for(var T=u[C],O=w[C],R=l[C],A=y[C],D=0;D<v;D++)T[D]=O[D]/A||0;if(f)for(var F=0;F<v;F++)if(R[F]!=T[F]){f=!1;break}}}else{for(var q=0;q<p;q++){w[h[q]]+=t[q]}for(var V=0;V<e;V++)u[V]=w[V]/y[V]||0;f=!0;for(var G=0;G<e;G++)if(l[G]!=u[G]){f=!1;break}}f=f||--g<=0}while(!f);return{it:1e4-g,k:e,idxs:h,centroids:u}},Ki}(),ro=mn(no);var io=qe;function oo(t,e){var n=!1;return C(function(t){if(t.length<3)return[];t.sort(ao);var e,n,r,i,o,s,a=t.length-1,u=t[a].x,l=t[0].x,h=t[a].y,c=h,f=1e-12;for(;a--;)t[a].y<h&&(h=t[a].y),t[a].y>c&&(c=t[a].y);var g,p=l-u,v=c-h,d=p>v?p:v,y=.5*(l+u),m=.5*(c+h),_=[new so({__sentinel:!0,x:y-20*d,y:m-d},{__sentinel:!0,x:y,y:m+20*d},{__sentinel:!0,x:y+20*d,y:m-d})],x=[],E=[];a=t.length;for(;a--;){for(E.length=0,g=_.length;g--;)(p=t[a].x-_[g].x)>0&&p*p>_[g].r?(x.push(_[g]),_.splice(g,1)):p*p+(v=t[a].y-_[g].y)*v>_[g].r||(E.push(_[g].a,_[g].b,_[g].b,_[g].c,_[g].c,_[g].a),_.splice(g,1));for(uo(E),g=E.length;g;)n=E[--g],e=E[--g],r=t[a],i=n.x-e.x,o=n.y-e.y,s=2*(i*(r.y-n.y)-o*(r.x-n.x)),Math.abs(s)>f&&_.push(new so(e,n,r))}Array.prototype.push.apply(x,_),a=x.length;for(;a--;)(x[a].a.__sentinel||x[a].b.__sentinel||x[a].c.__sentinel)&&x.splice(a,1);return x}(t.features.map((function(t){var r={x:t.geometry.coordinates[0],y:t.geometry.coordinates[1]};return e?r.z=t.properties[e]:3===t.geometry.coordinates.length&&(n=!0,r.z=t.geometry.coordinates[2]),r}))).map((function(t){var e=[t.a.x,t.a.y],r=[t.b.x,t.b.y],i=[t.c.x,t.c.y],o={};return n?(e.push(t.a.z),r.push(t.b.z),i.push(t.c.z)):o={a:t.a.z,b:t.b.z,c:t.c.z},S([[e,r,i,e]],o)})))}var so=s((function t(e,n,r){i(this,t),this.a=e,this.b=n,this.c=r;var o,s,a=n.x-e.x,u=n.y-e.y,l=r.x-e.x,h=r.y-e.y,c=a*(e.x+n.x)+u*(e.y+n.y),f=l*(e.x+r.x)+h*(e.y+r.y),g=2*(a*(r.y-n.y)-u*(r.x-n.x));this.x=(h*c-u*f)/g,this.y=(a*f-l*c)/g,o=this.x-e.x,s=this.y-e.y,this.r=o*o+s*s}));function ao(t,e){return e.x-t.x}function uo(t){var e,n,r,i,o,s=t.length;t:for(;s;)for(n=t[--s],e=t[--s],r=s;r;)if(o=t[--r],e===(i=t[--r])&&n===o||e===o&&n===i){t.splice(s,2),t.splice(r,2),s-=2;continue t}}function lo(t){return t}function ho(t,e){var n=function(t){if(null==t)return lo;var e,n,r=t.scale[0],i=t.scale[1],o=t.translate[0],s=t.translate[1];return function(t,a){a||(e=n=0);var u=2,l=t.length,h=new Array(l);for(h[0]=(e+=t[0])*r+o,h[1]=(n+=t[1])*i+s;u<l;)h[u]=t[u],++u;return h}}(t.transform),r=t.arcs;function i(t,e){e.length&&e.pop();for(var i=r[t<0?~t:t],o=0,s=i.length;o<s;++o)e.push(n(i[o],o));t<0&&function(t,e){for(var n,r=t.length,i=r-e;i<--r;)n=t[i],t[i++]=t[r],t[r]=n}(e,s)}function o(t){return n(t)}function s(t){for(var e=[],n=0,r=t.length;n<r;++n)i(t[n],e);return e.length<2&&e.push(e[0]),e}function a(t){for(var e=s(t);e.length<4;)e.push(e[0]);return e}function u(t){return t.map(a)}return function t(e){var n,r=e.type;switch(r){case"GeometryCollection":return{type:r,geometries:e.geometries.map(t)};case"Point":n=o(e.coordinates);break;case"MultiPoint":n=e.coordinates.map(o);break;case"LineString":n=s(e.arcs);break;case"MultiLineString":n=e.arcs.map(s);break;case"Polygon":n=u(e.arcs);break;case"MultiPolygon":n=e.arcs.map(u);break;default:return null}return{type:r,coordinates:n}}(e)}function co(t,e){var n={},r={},i={},o=[],s=-1;function a(t,e){for(var r in t){var i=t[r];delete e[i.start],delete i.start,delete i.end,i.forEach((function(t){n[t<0?~t:t]=1})),o.push(i)}}return e.forEach((function(n,r){var i,o=t.arcs[n<0?~n:n];o.length<3&&!o[1][0]&&!o[1][1]&&(i=e[++s],e[s]=n,e[r]=i)})),e.forEach((function(e){var n,o,s=function(e){var n,r=t.arcs[e<0?~e:e],i=r[0];t.transform?(n=[0,0],r.forEach((function(t){n[0]+=t[0],n[1]+=t[1]}))):n=r[r.length-1];return e<0?[n,i]:[i,n]}(e),a=s[0],u=s[1];if(n=i[a])if(delete i[n.end],n.push(e),n.end=u,o=r[u]){delete r[o.start];var l=o===n?n:n.concat(o);r[l.start=n.start]=i[l.end=o.end]=l}else r[n.start]=i[n.end]=n;else if(n=r[u])if(delete r[n.start],n.unshift(e),n.start=a,o=i[a]){delete i[o.end];var h=o===n?n:o.concat(n);r[h.start=o.start]=i[h.end=n.end]=h}else r[n.start]=i[n.end]=n;else r[(n=[e]).start=a]=i[n.end=u]=n})),a(i,r),a(r,i),e.forEach((function(t){n[t<0?~t:t]||o.push([t])})),o}function fo(t){return ho(t,go.apply(this,arguments))}function go(t,e){var n={},r=[],i=[];function o(t){t.forEach((function(e){e.forEach((function(e){(n[e=e<0?~e:e]||(n[e]=[])).push(t)}))})),r.push(t)}function s(e){return function(t){for(var e,n=-1,r=t.length,i=t[r-1],o=0;++n<r;)e=i,i=t[n],o+=e[0]*i[1]-e[1]*i[0];return Math.abs(o)}(ho(t,{type:"Polygon",arcs:[e]}).coordinates[0])}return e.forEach((function t(e){switch(e.type){case"GeometryCollection":e.geometries.forEach(t);break;case"Polygon":o(e.arcs);break;case"MultiPolygon":e.arcs.forEach(o)}})),r.forEach((function(t){if(!t._){var e=[],r=[t];for(t._=1,i.push(e);t=r.pop();)e.push(t),t.forEach((function(t){t.forEach((function(t){n[t<0?~t:t].forEach((function(t){t._||(t._=1,r.push(t))}))}))}))}})),r.forEach((function(t){delete t._})),{type:"MultiPolygon",arcs:i.map((function(e){var r,i=[];if(e.forEach((function(t){t.forEach((function(t){t.forEach((function(t){n[t<0?~t:t].length<2&&i.push(t)}))}))})),(r=(i=co(t,i)).length)>1)for(var o,a,u=1,l=s(i[0]);u<r;++u)(o=s(i[u]))>l&&(a=i[0],i[0]=i[u],i[u]=a,l=o);return i})).filter((function(t){return t.length>0}))}}var po=Object.prototype.hasOwnProperty;function vo(t,e,n,r,i,o){3===arguments.length&&(r=o=Array,i=null);for(var s=new r(t=1<<Math.max(4,Math.ceil(Math.log(t)/Math.LN2))),a=new o(t),u=t-1,l=0;l<t;++l)s[l]=i;return{set:function(r,o){for(var l=e(r)&u,h=s[l],c=0;h!=i;){if(n(h,r))return a[l]=o;if(++c>=t)throw new Error("full hashmap");h=s[l=l+1&u]}return s[l]=r,a[l]=o,o},maybeSet:function(r,o){for(var l=e(r)&u,h=s[l],c=0;h!=i;){if(n(h,r))return a[l];if(++c>=t)throw new Error("full hashmap");h=s[l=l+1&u]}return s[l]=r,a[l]=o,o},get:function(r,o){for(var l=e(r)&u,h=s[l],c=0;h!=i;){if(n(h,r))return a[l];if(++c>=t)break;h=s[l=l+1&u]}return o},keys:function(){for(var t=[],e=0,n=s.length;e<n;++e){var r=s[e];r!=i&&t.push(r)}return t}}}function yo(t,e){return t[0]===e[0]&&t[1]===e[1]}var mo=new ArrayBuffer(16),_o=new Float64Array(mo),xo=new Uint32Array(mo);function Eo(t){_o[0]=t[0],_o[1]=t[1];var e=xo[0]^xo[1];return 2147483647&(e=e<<5^e>>7^xo[2]^xo[3])}function ko(t){var e,n,r,i,o=t.coordinates,s=t.lines,a=t.rings,u=function(){for(var t=vo(1.4*o.length,E,k,Int32Array,-1,Int32Array),e=new Int32Array(o.length),n=0,r=o.length;n<r;++n)e[n]=t.maybeSet(n,n);return e}(),l=new Int32Array(o.length),h=new Int32Array(o.length),c=new Int32Array(o.length),f=new Int8Array(o.length),g=0;for(e=0,n=o.length;e<n;++e)l[e]=h[e]=c[e]=-1;for(e=0,n=s.length;e<n;++e){var p=s[e],v=p[0],d=p[1];for(r=u[v],i=u[++v],++g,f[r]=1;++v<=d;)x(e,r,r=i,i=u[v]);++g,f[i]=1}for(e=0,n=o.length;e<n;++e)l[e]=-1;for(e=0,n=a.length;e<n;++e){var y=a[e],m=y[0]+1,_=y[1];for(x(e,u[_-1],r=u[m-1],i=u[m]);++m<=_;)x(e,r,r=i,i=u[m])}function x(t,e,n,r){if(l[n]!==t){l[n]=t;var i=h[n];if(i>=0){var o=c[n];i===e&&o===r||i===r&&o===e||(++g,f[n]=1)}else h[n]=e,c[n]=r}}function E(t){return Eo(o[t])}function k(t,e){return yo(o[t],o[e])}l=h=c=null;var b,w=function(t,e,n,r,i){3===arguments.length&&(r=Array,i=null);for(var o=new r(t=1<<Math.max(4,Math.ceil(Math.log(t)/Math.LN2))),s=t-1,a=0;a<t;++a)o[a]=i;return{add:function(r){for(var a=e(r)&s,u=o[a],l=0;u!=i;){if(n(u,r))return!0;if(++l>=t)throw new Error("full hashset");u=o[a=a+1&s]}return o[a]=r,!0},has:function(r){for(var a=e(r)&s,u=o[a],l=0;u!=i;){if(n(u,r))return!0;if(++l>=t)break;u=o[a=a+1&s]}return!1},values:function(){for(var t=[],e=0,n=o.length;e<n;++e){var r=o[e];r!=i&&t.push(r)}return t}}}(1.4*g,Eo,yo);for(e=0,n=o.length;e<n;++e)f[b=u[e]]&&w.add(o[b]);return w}function bo(t,e,n,r){wo(t,e,n),wo(t,e,e+r),wo(t,e+r,n)}function wo(t,e,n){for(var r,i=e+(n---e>>1);e<i;++e,--n)r=t[e],t[e]=t[n],t[n]=r}function Io(t){var e,n,r={};for(e in t)r[e]=null==(n=t[e])?{type:null}:("FeatureCollection"===n.type?No:"Feature"===n.type?So:Mo)(n);return r}function No(t){var e={type:"GeometryCollection",geometries:t.features.map(So)};return null!=t.bbox&&(e.bbox=t.bbox),e}function So(t){var e,n=Mo(t.geometry);for(e in null!=t.id&&(n.id=t.id),null!=t.bbox&&(n.bbox=t.bbox),t.properties){n.properties=t.properties;break}return n}function Mo(t){if(null==t)return{type:null};var e="GeometryCollection"===t.type?{type:"GeometryCollection",geometries:t.geometries.map(Mo)}:"Point"===t.type||"MultiPoint"===t.type?{type:t.type,coordinates:t.coordinates}:{type:t.type,arcs:t.coordinates};return null!=t.bbox&&(e.bbox=t.bbox),e}function Lo(t,e){var n=function(t){var e=1/0,n=1/0,r=-1/0,i=-1/0;function o(t){null!=t&&po.call(s,t.type)&&s[t.type](t)}var s={GeometryCollection:function(t){t.geometries.forEach(o)},Point:function(t){a(t.coordinates)},MultiPoint:function(t){t.coordinates.forEach(a)},LineString:function(t){u(t.arcs)},MultiLineString:function(t){t.arcs.forEach(u)},Polygon:function(t){t.arcs.forEach(u)},MultiPolygon:function(t){t.arcs.forEach(l)}};function a(t){var o=t[0],s=t[1];o<e&&(e=o),o>r&&(r=o),s<n&&(n=s),s>i&&(i=s)}function u(t){t.forEach(a)}function l(t){t.forEach(u)}for(var h in t)o(t[h]);return r>=e&&i>=n?[e,n,r,i]:void 0}(t=Io(t)),r=function(t){var e,n,r,i,o=t.coordinates,s=t.lines,a=t.rings,u=s.length+a.length;for(delete t.lines,delete t.rings,r=0,i=s.length;r<i;++r)for(e=s[r];e=e.next;)++u;for(r=0,i=a.length;r<i;++r)for(n=a[r];n=n.next;)++u;var l=vo(2*u*1.4,Eo,yo),h=t.arcs=[];for(r=0,i=s.length;r<i;++r){e=s[r];do{c(e)}while(e=e.next)}for(r=0,i=a.length;r<i;++r)if((n=a[r]).next)do{c(n)}while(n=n.next);else f(n);function c(t){var e,n,r,i,s,a,u,c;if(r=l.get(e=o[t[0]]))for(u=0,c=r.length;u<c;++u)if(g(i=r[u],t))return t[0]=i[0],void(t[1]=i[1]);if(s=l.get(n=o[t[1]]))for(u=0,c=s.length;u<c;++u)if(p(a=s[u],t))return t[1]=a[0],void(t[0]=a[1]);r?r.push(t):l.set(e,[t]),s?s.push(t):l.set(n,[t]),h.push(t)}function f(t){var e,n,r,i,s;if(n=l.get(o[t[0]]))for(i=0,s=n.length;i<s;++i){if(v(r=n[i],t))return t[0]=r[0],void(t[1]=r[1]);if(d(r,t))return t[0]=r[1],void(t[1]=r[0])}if(n=l.get(e=o[t[0]+y(t)]))for(i=0,s=n.length;i<s;++i){if(v(r=n[i],t))return t[0]=r[0],void(t[1]=r[1]);if(d(r,t))return t[0]=r[1],void(t[1]=r[0])}n?n.push(t):l.set(e,[t]),h.push(t)}function g(t,e){var n=t[0],r=e[0],i=t[1];if(n-i!=r-e[1])return!1;for(;n<=i;++n,++r)if(!yo(o[n],o[r]))return!1;return!0}function p(t,e){var n=t[0],r=e[0],i=t[1],s=e[1];if(n-i!=r-s)return!1;for(;n<=i;++n,--s)if(!yo(o[n],o[s]))return!1;return!0}function v(t,e){var n=t[0],r=e[0],i=t[1]-n;if(i!==e[1]-r)return!1;for(var s=y(t),a=y(e),u=0;u<i;++u)if(!yo(o[n+(u+s)%i],o[r+(u+a)%i]))return!1;return!0}function d(t,e){var n=t[0],r=e[0],i=t[1],s=e[1],a=i-n;if(a!==s-r)return!1;for(var u=y(t),l=a-y(e),h=0;h<a;++h)if(!yo(o[n+(h+u)%a],o[s-(h+l)%a]))return!1;return!0}function y(t){for(var e=t[0],n=t[1],r=e,i=r,s=o[r];++r<n;){var a=o[r];(a[0]<s[0]||a[0]===s[0]&&a[1]<s[1])&&(i=r,s=a)}return i-e}return t}(function(t){var e,n,r,i=ko(t),o=t.coordinates,s=t.lines,a=t.rings;for(n=0,r=s.length;n<r;++n)for(var u=s[n],l=u[0],h=u[1];++l<h;)i.has(o[l])&&(e={0:l,1:u[1]},u[1]=l,u=u.next=e);for(n=0,r=a.length;n<r;++n)for(var c=a[n],f=c[0],g=f,p=c[1],v=i.has(o[f]);++g<p;)i.has(o[g])&&(v?(e={0:g,1:c[1]},c[1]=g,c=c.next=e):(bo(o,f,p,p-g),o[p]=o[f],v=!0,g=f));return t}(function(t){var e=-1,n=[],r=[],i=[];function o(t){t&&po.call(s,t.type)&&s[t.type](t)}var s={GeometryCollection:function(t){t.geometries.forEach(o)},LineString:function(t){t.arcs=a(t.arcs)},MultiLineString:function(t){t.arcs=t.arcs.map(a)},Polygon:function(t){t.arcs=t.arcs.map(u)},MultiPolygon:function(t){t.arcs=t.arcs.map(l)}};function a(t){for(var r=0,o=t.length;r<o;++r)i[++e]=t[r];var s={0:e-o+1,1:e};return n.push(s),s}function u(t){for(var n=0,o=t.length;n<o;++n)i[++e]=t[n];var s={0:e-o+1,1:e};return r.push(s),s}function l(t){return t.map(u)}for(var h in t)o(t[h]);return{type:"Topology",coordinates:i,lines:n,rings:r,objects:t}}(t))),i=r.coordinates,o=vo(1.4*r.arcs.length,Po,Co);function s(t){t&&po.call(a,t.type)&&a[t.type](t)}t=r.objects,r.bbox=n,r.arcs=r.arcs.map((function(t,e){return o.set(t,e),i.slice(t[0],t[1]+1)})),delete r.coordinates,i=null;var a={GeometryCollection:function(t){t.geometries.forEach(s)},LineString:function(t){t.arcs=u(t.arcs)},MultiLineString:function(t){t.arcs=t.arcs.map(u)},Polygon:function(t){t.arcs=t.arcs.map(u)},MultiPolygon:function(t){t.arcs=t.arcs.map(l)}};function u(t){var e=[];do{var n=o.get(t);e.push(t[0]<t[1]?n:~n)}while(t=t.next);return e}function l(t){return t.map(u)}for(var h in t)s(t[h]);return r}function Po(t){var e,n=t[0],r=t[1];return r<n&&(e=n,n=r,r=e),n+31*r}function Co(t,e){var n,r=t[0],i=t[1],o=e[0],s=e[1];return i<r&&(n=r,r=i,i=n),s<o&&(n=o,o=s,s=n),r===o&&i===s}function To(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!Z(e=e||{}))throw new Error("options is invalid");var n=e.mutate;if("FeatureCollection"!==it(t))throw new Error("geojson must be a FeatureCollection");if(!t.features.length)throw new Error("geojson is empty");!1!==n&&void 0!==n||(t=Ai(t));var r=[],i=It(t,(function(t,e){var n=function(t,e){var n,r=t.geometry.coordinates,i=e.geometry.coordinates,o=Oo(r[0]),s=Oo(r[r.length-1]),a=Oo(i[0]),u=Oo(i[i.length-1]);if(o===u)n=i.concat(r.slice(1));else if(a===s)n=r.concat(i.slice(1));else if(o===a)n=r.slice(1).reverse().concat(i);else{if(s!==u)return null;n=r.concat(i.reverse().slice(1))}return L(n)}(t,e);return n||(r.push(t),e)}));return i&&r.push(i),r.length?1===r.length?r[0]:T(r.map((function(t){return t.coordinates}))):null}function Oo(t){return t[0].toString()+","+t[1].toString()}function Ro(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!Z(e=e||{}))throw new Error("options is invalid");var n=e.mutate;if("FeatureCollection"!==it(t))throw new Error("geojson must be a FeatureCollection");if(!t.features.length)throw new Error("geojson is empty");!1!==n&&void 0!==n||(t=Ai(t));var r=function(t){var e={};xt(t,(function(t){e[t.geometry.type]=!0}));var n=Object.keys(e);if(1===n.length)return n[0];return null}(t);if(!r)throw new Error("geojson must be homogenous");var i=t;switch(r){case"LineString":return To(i,e);case"Polygon":return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("FeatureCollection"!==it(t))throw new Error("geojson must be a FeatureCollection");if(!t.features.length)throw new Error("geojson is empty");!1!==e.mutate&&void 0!==e.mutate||(t=Ai(t));var n=[];xt(t,(function(t){n.push(t.geometry)}));var r=Lo({geoms:A(n).geometry});return fo(r,r.objects.geoms.geometries)}(i,e);default:throw new Error(r+" is not supported")}}var Ao=/^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,Do=Math.ceil,Fo=Math.floor,qo="[BigNumber Error] ",Vo=qo+"Number primitive has more than 15 significant digits: ",Go=1e14,Bo=14,Yo=9007199254740991,zo=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],jo=1e7,Xo=1e9;function Uo(t){var e=0|t;return t>0||t===e?e:e-1}function Zo(t){for(var e,n,r=1,i=t.length,o=t[0]+"";r<i;){for(e=t[r++]+"",n=Bo-e.length;n--;e="0"+e);o+=e}for(i=o.length;48===o.charCodeAt(--i););return o.slice(0,i+1||1)}function Ho(t,e){var n,r,i=t.c,o=e.c,s=t.s,a=e.s,u=t.e,l=e.e;if(!s||!a)return null;if(n=i&&!i[0],r=o&&!o[0],n||r)return n?r?0:-a:s;if(s!=a)return s;if(n=s<0,r=u==l,!i||!o)return r?0:!i^n?1:-1;if(!r)return u>l^n?1:-1;for(a=(u=i.length)<(l=o.length)?u:l,s=0;s<a;s++)if(i[s]!=o[s])return i[s]>o[s]^n?1:-1;return u==l?0:u>l^n?1:-1}function Wo(t,e,n,r){if(t<e||t>n||t!==Fo(t))throw Error(qo+(r||"Argument")+("number"==typeof t?t<e||t>n?" out of range: ":" not an integer: ":" not a primitive number: ")+String(t))}function Jo(t){var e=t.c.length-1;return Uo(t.e/Bo)==e&&t.c[e]%2!=0}function Ko(t,e){return(t.length>1?t.charAt(0)+"."+t.slice(1):t)+(e<0?"e":"e+")+e}function Qo(t,e,n){var r,i;if(e<0){for(i=n+".";++e;i+=n);t=i+t}else if(++e>(r=t.length)){for(i=n,e-=r;--e;i+=n);t+=i}else e<r&&(t=t.slice(0,e)+"."+t.slice(e));return t}var $o=function t(e){var n,r,i,o,s,a,u,l,h,c,f=S.prototype={constructor:S,toString:null,valueOf:null},g=new S(1),p=20,v=4,d=-7,y=21,_=-1e7,x=1e7,E=!1,k=1,b=0,w={prefix:"",groupSize:3,secondaryGroupSize:0,groupSeparator:",",decimalSeparator:".",fractionGroupSize:0,fractionGroupSeparator:" ",suffix:""},I="0123456789abcdefghijklmnopqrstuvwxyz",N=!0;function S(t,e){var n,o,s,a,u,l,h,c,f=this;if(!(f instanceof S))return new S(t,e);if(null==e){if(t&&!0===t._isBigNumber)return f.s=t.s,void(!t.c||t.e>x?f.c=f.e=null:t.e<_?f.c=[f.e=0]:(f.e=t.e,f.c=t.c.slice()));if((l="number"==typeof t)&&0*t==0){if(f.s=1/t<0?(t=-t,-1):1,t===~~t){for(a=0,u=t;u>=10;u/=10,a++);return void(a>x?f.c=f.e=null:(f.e=a,f.c=[t]))}c=String(t)}else{if(!Ao.test(c=String(t)))return i(f,c,l);f.s=45==c.charCodeAt(0)?(c=c.slice(1),-1):1}(a=c.indexOf("."))>-1&&(c=c.replace(".","")),(u=c.search(/e/i))>0?(a<0&&(a=u),a+=+c.slice(u+1),c=c.substring(0,u)):a<0&&(a=c.length)}else{if(Wo(e,2,I.length,"Base"),10==e&&N)return C(f=new S(t),p+f.e+1,v);if(c=String(t),l="number"==typeof t){if(0*t!=0)return i(f,c,l,e);if(f.s=1/t<0?(c=c.slice(1),-1):1,S.DEBUG&&c.replace(/^0\.0*|\./,"").length>15)throw Error(Vo+t)}else f.s=45===c.charCodeAt(0)?(c=c.slice(1),-1):1;for(n=I.slice(0,e),a=u=0,h=c.length;u<h;u++)if(n.indexOf(o=c.charAt(u))<0){if("."==o){if(u>a){a=h;continue}}else if(!s&&(c==c.toUpperCase()&&(c=c.toLowerCase())||c==c.toLowerCase()&&(c=c.toUpperCase()))){s=!0,u=-1,a=0;continue}return i(f,String(t),l,e)}l=!1,(a=(c=r(c,e,10,f.s)).indexOf("."))>-1?c=c.replace(".",""):a=c.length}for(u=0;48===c.charCodeAt(u);u++);for(h=c.length;48===c.charCodeAt(--h););if(c=c.slice(u,++h)){if(h-=u,l&&S.DEBUG&&h>15&&(t>Yo||t!==Fo(t)))throw Error(Vo+f.s*t);if((a=a-u-1)>x)f.c=f.e=null;else if(a<_)f.c=[f.e=0];else{if(f.e=a,f.c=[],u=(a+1)%Bo,a<0&&(u+=Bo),u<h){for(u&&f.c.push(+c.slice(0,u)),h-=Bo;u<h;)f.c.push(+c.slice(u,u+=Bo));u=Bo-(c=c.slice(u)).length}else u-=h;for(;u--;c+="0");f.c.push(+c)}}else f.c=[f.e=0]}function M(t,e,n,r){var i,o,s,a,u;if(null==n?n=v:Wo(n,0,8),!t.c)return t.toString();if(i=t.c[0],s=t.e,null==e)u=Zo(t.c),u=1==r||2==r&&(s<=d||s>=y)?Ko(u,s):Qo(u,s,"0");else if(o=(t=C(new S(t),e,n)).e,a=(u=Zo(t.c)).length,1==r||2==r&&(e<=o||o<=d)){for(;a<e;u+="0",a++);u=Ko(u,o)}else if(e-=s,u=Qo(u,o,"0"),o+1>a){if(--e>0)for(u+=".";e--;u+="0");}else if((e+=o-a)>0)for(o+1==a&&(u+=".");e--;u+="0");return t.s<0&&i?"-"+u:u}function L(t,e){for(var n,r,i=1,o=new S(t[0]);i<t.length;i++)(!(r=new S(t[i])).s||(n=Ho(o,r))===e||0===n&&o.s===e)&&(o=r);return o}function P(t,e,n){for(var r=1,i=e.length;!e[--i];e.pop());for(i=e[0];i>=10;i/=10,r++);return(n=r+n*Bo-1)>x?t.c=t.e=null:n<_?t.c=[t.e=0]:(t.e=n,t.c=e),t}function C(t,e,n,r){var i,o,s,a,u,l,h,c=t.c,f=zo;if(c){t:{for(i=1,a=c[0];a>=10;a/=10,i++);if((o=e-i)<0)o+=Bo,s=e,u=c[l=0],h=Fo(u/f[i-s-1]%10);else if((l=Do((o+1)/Bo))>=c.length){if(!r)break t;for(;c.length<=l;c.push(0));u=h=0,i=1,s=(o%=Bo)-Bo+1}else{for(u=a=c[l],i=1;a>=10;a/=10,i++);h=(s=(o%=Bo)-Bo+i)<0?0:Fo(u/f[i-s-1]%10)}if(r=r||e<0||null!=c[l+1]||(s<0?u:u%f[i-s-1]),r=n<4?(h||r)&&(0==n||n==(t.s<0?3:2)):h>5||5==h&&(4==n||r||6==n&&(o>0?s>0?u/f[i-s]:0:c[l-1])%10&1||n==(t.s<0?8:7)),e<1||!c[0])return c.length=0,r?(e-=t.e+1,c[0]=f[(Bo-e%Bo)%Bo],t.e=-e||0):c[0]=t.e=0,t;if(0==o?(c.length=l,a=1,l--):(c.length=l+1,a=f[Bo-o],c[l]=s>0?Fo(u/f[i-s]%f[s])*a:0),r)for(;;){if(0==l){for(o=1,s=c[0];s>=10;s/=10,o++);for(s=c[0]+=a,a=1;s>=10;s/=10,a++);o!=a&&(t.e++,c[0]==Go&&(c[0]=1));break}if(c[l]+=a,c[l]!=Go)break;c[l--]=0,a=1}for(o=c.length;0===c[--o];c.pop());}t.e>x?t.c=t.e=null:t.e<_&&(t.c=[t.e=0])}return t}function T(t){var e,n=t.e;return null===n?t.toString():(e=Zo(t.c),e=n<=d||n>=y?Ko(e,n):Qo(e,n,"0"),t.s<0?"-"+e:e)}return S.clone=t,S.ROUND_UP=0,S.ROUND_DOWN=1,S.ROUND_CEIL=2,S.ROUND_FLOOR=3,S.ROUND_HALF_UP=4,S.ROUND_HALF_DOWN=5,S.ROUND_HALF_EVEN=6,S.ROUND_HALF_CEIL=7,S.ROUND_HALF_FLOOR=8,S.EUCLID=9,S.config=S.set=function(t){var e,n;if(null!=t){if("object"!=m(t))throw Error(qo+"Object expected: "+t);if(t.hasOwnProperty(e="DECIMAL_PLACES")&&(Wo(n=t[e],0,Xo,e),p=n),t.hasOwnProperty(e="ROUNDING_MODE")&&(Wo(n=t[e],0,8,e),v=n),t.hasOwnProperty(e="EXPONENTIAL_AT")&&((n=t[e])&&n.pop?(Wo(n[0],-Xo,0,e),Wo(n[1],0,Xo,e),d=n[0],y=n[1]):(Wo(n,-Xo,Xo,e),d=-(y=n<0?-n:n))),t.hasOwnProperty(e="RANGE"))if((n=t[e])&&n.pop)Wo(n[0],-Xo,-1,e),Wo(n[1],1,Xo,e),_=n[0],x=n[1];else{if(Wo(n,-Xo,Xo,e),!n)throw Error(qo+e+" cannot be zero: "+n);_=-(x=n<0?-n:n)}if(t.hasOwnProperty(e="CRYPTO")){if((n=t[e])!==!!n)throw Error(qo+e+" not true or false: "+n);if(n){if("undefined"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw E=!n,Error(qo+"crypto unavailable");E=n}else E=n}if(t.hasOwnProperty(e="MODULO_MODE")&&(Wo(n=t[e],0,9,e),k=n),t.hasOwnProperty(e="POW_PRECISION")&&(Wo(n=t[e],0,Xo,e),b=n),t.hasOwnProperty(e="FORMAT")){if("object"!=m(n=t[e]))throw Error(qo+e+" not an object: "+n);w=n}if(t.hasOwnProperty(e="ALPHABET")){if("string"!=typeof(n=t[e])||/^.?$|[+\-.\s]|(.).*\1/.test(n))throw Error(qo+e+" invalid: "+n);N="0123456789"==n.slice(0,10),I=n}}return{DECIMAL_PLACES:p,ROUNDING_MODE:v,EXPONENTIAL_AT:[d,y],RANGE:[_,x],CRYPTO:E,MODULO_MODE:k,POW_PRECISION:b,FORMAT:w,ALPHABET:I}},S.isBigNumber=function(t){if(!t||!0!==t._isBigNumber)return!1;if(!S.DEBUG)return!0;var e,n,r=t.c,i=t.e,o=t.s;t:if("[object Array]"=={}.toString.call(r)){if((1===o||-1===o)&&i>=-Xo&&i<=Xo&&i===Fo(i)){if(0===r[0]){if(0===i&&1===r.length)return!0;break t}if((e=(i+1)%Bo)<1&&(e+=Bo),String(r[0]).length==e){for(e=0;e<r.length;e++)if((n=r[e])<0||n>=Go||n!==Fo(n))break t;if(0!==n)return!0}}}else if(null===r&&null===i&&(null===o||1===o||-1===o))return!0;throw Error(qo+"Invalid BigNumber: "+t)},S.maximum=S.max=function(){return L(arguments,-1)},S.minimum=S.min=function(){return L(arguments,1)},S.random=(o=9007199254740992,s=Math.random()*o&2097151?function(){return Fo(Math.random()*o)}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)},function(t){var e,n,r,i,o,a=0,u=[],l=new S(g);if(null==t?t=p:Wo(t,0,Xo),i=Do(t/Bo),E)if(crypto.getRandomValues){for(e=crypto.getRandomValues(new Uint32Array(i*=2));a<i;)(o=131072*e[a]+(e[a+1]>>>11))>=9e15?(n=crypto.getRandomValues(new Uint32Array(2)),e[a]=n[0],e[a+1]=n[1]):(u.push(o%1e14),a+=2);a=i/2}else{if(!crypto.randomBytes)throw E=!1,Error(qo+"crypto unavailable");for(e=crypto.randomBytes(i*=7);a<i;)(o=281474976710656*(31&e[a])+1099511627776*e[a+1]+4294967296*e[a+2]+16777216*e[a+3]+(e[a+4]<<16)+(e[a+5]<<8)+e[a+6])>=9e15?crypto.randomBytes(7).copy(e,a):(u.push(o%1e14),a+=7);a=i/7}if(!E)for(;a<i;)(o=s())<9e15&&(u[a++]=o%1e14);for(i=u[--a],t%=Bo,i&&t&&(o=zo[Bo-t],u[a]=Fo(i/o)*o);0===u[a];u.pop(),a--);if(a<0)u=[r=0];else{for(r=-1;0===u[0];u.splice(0,1),r-=Bo);for(a=1,o=u[0];o>=10;o/=10,a++);a<Bo&&(r-=Bo-a)}return l.e=r,l.c=u,l}),S.sum=function(){for(var t=1,e=arguments,n=new S(e[0]);t<e.length;)n=n.plus(e[t++]);return n},r=function(){var t="0123456789";function e(t,e,n,r){for(var i,o,s=[0],a=0,u=t.length;a<u;){for(o=s.length;o--;s[o]*=e);for(s[0]+=r.indexOf(t.charAt(a++)),i=0;i<s.length;i++)s[i]>n-1&&(null==s[i+1]&&(s[i+1]=0),s[i+1]+=s[i]/n|0,s[i]%=n)}return s.reverse()}return function(r,i,o,s,a){var u,l,h,c,f,g,d,y,m=r.indexOf("."),_=p,x=v;for(m>=0&&(c=b,b=0,r=r.replace(".",""),g=(y=new S(i)).pow(r.length-m),b=c,y.c=e(Qo(Zo(g.c),g.e,"0"),10,o,t),y.e=y.c.length),h=c=(d=e(r,i,o,a?(u=I,t):(u=t,I))).length;0==d[--c];d.pop());if(!d[0])return u.charAt(0);if(m<0?--h:(g.c=d,g.e=h,g.s=s,d=(g=n(g,y,_,x,o)).c,f=g.r,h=g.e),m=d[l=h+_+1],c=o/2,f=f||l<0||null!=d[l+1],f=x<4?(null!=m||f)&&(0==x||x==(g.s<0?3:2)):m>c||m==c&&(4==x||f||6==x&&1&d[l-1]||x==(g.s<0?8:7)),l<1||!d[0])r=f?Qo(u.charAt(1),-_,u.charAt(0)):u.charAt(0);else{if(d.length=l,f)for(--o;++d[--l]>o;)d[l]=0,l||(++h,d=[1].concat(d));for(c=d.length;!d[--c];);for(m=0,r="";m<=c;r+=u.charAt(d[m++]));r=Qo(r,h,u.charAt(0))}return r}}(),n=function(){function t(t,e,n){var r,i,o,s,a=0,u=t.length,l=e%jo,h=e/jo|0;for(t=t.slice();u--;)a=((i=l*(o=t[u]%jo)+(r=h*o+(s=t[u]/jo|0)*l)%jo*jo+a)/n|0)+(r/jo|0)+h*s,t[u]=i%n;return a&&(t=[a].concat(t)),t}function e(t,e,n,r){var i,o;if(n!=r)o=n>r?1:-1;else for(i=o=0;i<n;i++)if(t[i]!=e[i]){o=t[i]>e[i]?1:-1;break}return o}function n(t,e,n,r){for(var i=0;n--;)t[n]-=i,i=t[n]<e[n]?1:0,t[n]=i*r+t[n]-e[n];for(;!t[0]&&t.length>1;t.splice(0,1));}return function(r,i,o,s,a){var u,l,h,c,f,g,p,v,d,y,m,_,x,E,k,b,w,I=r.s==i.s?1:-1,N=r.c,M=i.c;if(!(N&&N[0]&&M&&M[0]))return new S(r.s&&i.s&&(N?!M||N[0]!=M[0]:M)?N&&0==N[0]||!M?0*I:I/0:NaN);for(d=(v=new S(I)).c=[],I=o+(l=r.e-i.e)+1,a||(a=Go,l=Uo(r.e/Bo)-Uo(i.e/Bo),I=I/Bo|0),h=0;M[h]==(N[h]||0);h++);if(M[h]>(N[h]||0)&&l--,I<0)d.push(1),c=!0;else{for(E=N.length,b=M.length,h=0,I+=2,(f=Fo(a/(M[0]+1)))>1&&(M=t(M,f,a),N=t(N,f,a),b=M.length,E=N.length),x=b,m=(y=N.slice(0,b)).length;m<b;y[m++]=0);w=M.slice(),w=[0].concat(w),k=M[0],M[1]>=a/2&&k++;do{if(f=0,(u=e(M,y,b,m))<0){if(_=y[0],b!=m&&(_=_*a+(y[1]||0)),(f=Fo(_/k))>1)for(f>=a&&(f=a-1),p=(g=t(M,f,a)).length,m=y.length;1==e(g,y,p,m);)f--,n(g,b<p?w:M,p,a),p=g.length,u=1;else 0==f&&(u=f=1),p=(g=M.slice()).length;if(p<m&&(g=[0].concat(g)),n(y,g,m,a),m=y.length,-1==u)for(;e(M,y,b,m)<1;)f++,n(y,b<m?w:M,m,a),m=y.length}else 0===u&&(f++,y=[0]);d[h++]=f,y[0]?y[m++]=N[x]||0:(y=[N[x]],m=1)}while((x++<E||null!=y[0])&&I--);c=null!=y[0],d[0]||d.splice(0,1)}if(a==Go){for(h=1,I=d[0];I>=10;I/=10,h++);C(v,o+(v.e=h+l*Bo-1)+1,s,c)}else v.e=l,v.r=+c;return v}}(),a=/^(-?)0([xbo])(?=\w[\w.]*$)/i,u=/^([^.]+)\.$/,l=/^\.([^.]+)$/,h=/^-?(Infinity|NaN)$/,c=/^\s*\+(?=[\w.])|^\s+|\s+$/g,i=function(t,e,n,r){var i,o=n?e:e.replace(c,"");if(h.test(o))t.s=isNaN(o)?null:o<0?-1:1;else{if(!n&&(o=o.replace(a,(function(t,e,n){return i="x"==(n=n.toLowerCase())?16:"b"==n?2:8,r&&r!=i?t:e})),r&&(i=r,o=o.replace(u,"$1").replace(l,"0.$1")),e!=o))return new S(o,i);if(S.DEBUG)throw Error(qo+"Not a"+(r?" base "+r:"")+" number: "+e);t.s=null}t.c=t.e=null},f.absoluteValue=f.abs=function(){var t=new S(this);return t.s<0&&(t.s=1),t},f.comparedTo=function(t,e){return Ho(this,new S(t,e))},f.decimalPlaces=f.dp=function(t,e){var n,r,i,o=this;if(null!=t)return Wo(t,0,Xo),null==e?e=v:Wo(e,0,8),C(new S(o),t+o.e+1,e);if(!(n=o.c))return null;if(r=((i=n.length-1)-Uo(this.e/Bo))*Bo,i=n[i])for(;i%10==0;i/=10,r--);return r<0&&(r=0),r},f.dividedBy=f.div=function(t,e){return n(this,new S(t,e),p,v)},f.dividedToIntegerBy=f.idiv=function(t,e){return n(this,new S(t,e),0,1)},f.exponentiatedBy=f.pow=function(t,e){var n,r,i,o,s,a,u,l,h=this;if((t=new S(t)).c&&!t.isInteger())throw Error(qo+"Exponent not an integer: "+T(t));if(null!=e&&(e=new S(e)),s=t.e>14,!h.c||!h.c[0]||1==h.c[0]&&!h.e&&1==h.c.length||!t.c||!t.c[0])return l=new S(Math.pow(+T(h),s?t.s*(2-Jo(t)):+T(t))),e?l.mod(e):l;if(a=t.s<0,e){if(e.c?!e.c[0]:!e.s)return new S(NaN);(r=!a&&h.isInteger()&&e.isInteger())&&(h=h.mod(e))}else{if(t.e>9&&(h.e>0||h.e<-1||(0==h.e?h.c[0]>1||s&&h.c[1]>=24e7:h.c[0]<8e13||s&&h.c[0]<=9999975e7)))return o=h.s<0&&Jo(t)?-0:0,h.e>-1&&(o=1/o),new S(a?1/o:o);b&&(o=Do(b/Bo+2))}for(s?(n=new S(.5),a&&(t.s=1),u=Jo(t)):u=(i=Math.abs(+T(t)))%2,l=new S(g);;){if(u){if(!(l=l.times(h)).c)break;o?l.c.length>o&&(l.c.length=o):r&&(l=l.mod(e))}if(i){if(0===(i=Fo(i/2)))break;u=i%2}else if(C(t=t.times(n),t.e+1,1),t.e>14)u=Jo(t);else{if(0===(i=+T(t)))break;u=i%2}h=h.times(h),o?h.c&&h.c.length>o&&(h.c.length=o):r&&(h=h.mod(e))}return r?l:(a&&(l=g.div(l)),e?l.mod(e):o?C(l,b,v,undefined):l)},f.integerValue=function(t){var e=new S(this);return null==t?t=v:Wo(t,0,8),C(e,e.e+1,t)},f.isEqualTo=f.eq=function(t,e){return 0===Ho(this,new S(t,e))},f.isFinite=function(){return!!this.c},f.isGreaterThan=f.gt=function(t,e){return Ho(this,new S(t,e))>0},f.isGreaterThanOrEqualTo=f.gte=function(t,e){return 1===(e=Ho(this,new S(t,e)))||0===e},f.isInteger=function(){return!!this.c&&Uo(this.e/Bo)>this.c.length-2},f.isLessThan=f.lt=function(t,e){return Ho(this,new S(t,e))<0},f.isLessThanOrEqualTo=f.lte=function(t,e){return-1===(e=Ho(this,new S(t,e)))||0===e},f.isNaN=function(){return!this.s},f.isNegative=function(){return this.s<0},f.isPositive=function(){return this.s>0},f.isZero=function(){return!!this.c&&0==this.c[0]},f.minus=function(t,e){var n,r,i,o,s=this,a=s.s;if(e=(t=new S(t,e)).s,!a||!e)return new S(NaN);if(a!=e)return t.s=-e,s.plus(t);var u=s.e/Bo,l=t.e/Bo,h=s.c,c=t.c;if(!u||!l){if(!h||!c)return h?(t.s=-e,t):new S(c?s:NaN);if(!h[0]||!c[0])return c[0]?(t.s=-e,t):new S(h[0]?s:3==v?-0:0)}if(u=Uo(u),l=Uo(l),h=h.slice(),a=u-l){for((o=a<0)?(a=-a,i=h):(l=u,i=c),i.reverse(),e=a;e--;i.push(0));i.reverse()}else for(r=(o=(a=h.length)<(e=c.length))?a:e,a=e=0;e<r;e++)if(h[e]!=c[e]){o=h[e]<c[e];break}if(o&&(i=h,h=c,c=i,t.s=-t.s),(e=(r=c.length)-(n=h.length))>0)for(;e--;h[n++]=0);for(e=Go-1;r>a;){if(h[--r]<c[r]){for(n=r;n&&!h[--n];h[n]=e);--h[n],h[r]+=Go}h[r]-=c[r]}for(;0==h[0];h.splice(0,1),--l);return h[0]?P(t,h,l):(t.s=3==v?-1:1,t.c=[t.e=0],t)},f.modulo=f.mod=function(t,e){var r,i,o=this;return t=new S(t,e),!o.c||!t.s||t.c&&!t.c[0]?new S(NaN):!t.c||o.c&&!o.c[0]?new S(o):(9==k?(i=t.s,t.s=1,r=n(o,t,0,3),t.s=i,r.s*=i):r=n(o,t,0,k),(t=o.minus(r.times(t))).c[0]||1!=k||(t.s=o.s),t)},f.multipliedBy=f.times=function(t,e){var n,r,i,o,s,a,u,l,h,c,f,g,p,v,d,y=this,m=y.c,_=(t=new S(t,e)).c;if(!(m&&_&&m[0]&&_[0]))return!y.s||!t.s||m&&!m[0]&&!_||_&&!_[0]&&!m?t.c=t.e=t.s=null:(t.s*=y.s,m&&_?(t.c=[0],t.e=0):t.c=t.e=null),t;for(r=Uo(y.e/Bo)+Uo(t.e/Bo),t.s*=y.s,(u=m.length)<(c=_.length)&&(p=m,m=_,_=p,i=u,u=c,c=i),i=u+c,p=[];i--;p.push(0));for(v=Go,d=jo,i=c;--i>=0;){for(n=0,f=_[i]%d,g=_[i]/d|0,o=i+(s=u);o>i;)n=((l=f*(l=m[--s]%d)+(a=g*l+(h=m[s]/d|0)*f)%d*d+p[o]+n)/v|0)+(a/d|0)+g*h,p[o--]=l%v;p[o]=n}return n?++r:p.splice(0,1),P(t,p,r)},f.negated=function(){var t=new S(this);return t.s=-t.s||null,t},f.plus=function(t,e){var n,r=this,i=r.s;if(e=(t=new S(t,e)).s,!i||!e)return new S(NaN);if(i!=e)return t.s=-e,r.minus(t);var o=r.e/Bo,s=t.e/Bo,a=r.c,u=t.c;if(!o||!s){if(!a||!u)return new S(i/0);if(!a[0]||!u[0])return u[0]?t:new S(a[0]?r:0*i)}if(o=Uo(o),s=Uo(s),a=a.slice(),i=o-s){for(i>0?(s=o,n=u):(i=-i,n=a),n.reverse();i--;n.push(0));n.reverse()}for((i=a.length)-(e=u.length)<0&&(n=u,u=a,a=n,e=i),i=0;e;)i=(a[--e]=a[e]+u[e]+i)/Go|0,a[e]=Go===a[e]?0:a[e]%Go;return i&&(a=[i].concat(a),++s),P(t,a,s)},f.precision=f.sd=function(t,e){var n,r,i,o=this;if(null!=t&&t!==!!t)return Wo(t,1,Xo),null==e?e=v:Wo(e,0,8),C(new S(o),t,e);if(!(n=o.c))return null;if(r=(i=n.length-1)*Bo+1,i=n[i]){for(;i%10==0;i/=10,r--);for(i=n[0];i>=10;i/=10,r++);}return t&&o.e+1>r&&(r=o.e+1),r},f.shiftedBy=function(t){return Wo(t,-9007199254740991,Yo),this.times("1e"+t)},f.squareRoot=f.sqrt=function(){var t,e,r,i,o,s=this,a=s.c,u=s.s,l=s.e,h=p+4,c=new S("0.5");if(1!==u||!a||!a[0])return new S(!u||u<0&&(!a||a[0])?NaN:a?s:1/0);if(0==(u=Math.sqrt(+T(s)))||u==1/0?(((e=Zo(a)).length+l)%2==0&&(e+="0"),u=Math.sqrt(+e),l=Uo((l+1)/2)-(l<0||l%2),r=new S(e=u==1/0?"5e"+l:(e=u.toExponential()).slice(0,e.indexOf("e")+1)+l)):r=new S(u+""),r.c[0])for((u=(l=r.e)+h)<3&&(u=0);;)if(o=r,r=c.times(o.plus(n(s,o,h,1))),Zo(o.c).slice(0,u)===(e=Zo(r.c)).slice(0,u)){if(r.e<l&&--u,"9999"!=(e=e.slice(u-3,u+1))&&(i||"4999"!=e)){+e&&(+e.slice(1)||"5"!=e.charAt(0))||(C(r,r.e+p+2,1),t=!r.times(r).eq(s));break}if(!i&&(C(o,o.e+p+2,0),o.times(o).eq(s))){r=o;break}h+=4,u+=4,i=1}return C(r,r.e+p+1,v,t)},f.toExponential=function(t,e){return null!=t&&(Wo(t,0,Xo),t++),M(this,t,e,1)},f.toFixed=function(t,e){return null!=t&&(Wo(t,0,Xo),t=t+this.e+1),M(this,t,e)},f.toFormat=function(t,e,n){var r,i=this;if(null==n)null!=t&&e&&"object"==m(e)?(n=e,e=null):t&&"object"==m(t)?(n=t,t=e=null):n=w;else if("object"!=m(n))throw Error(qo+"Argument not an object: "+n);if(r=i.toFixed(t,e),i.c){var o,s=r.split("."),a=+n.groupSize,u=+n.secondaryGroupSize,l=n.groupSeparator||"",h=s[0],c=s[1],f=i.s<0,g=f?h.slice(1):h,p=g.length;if(u&&(o=a,a=u,u=o,p-=o),a>0&&p>0){for(o=p%a||a,h=g.substr(0,o);o<p;o+=a)h+=l+g.substr(o,a);u>0&&(h+=l+g.slice(o)),f&&(h="-"+h)}r=c?h+(n.decimalSeparator||"")+((u=+n.fractionGroupSize)?c.replace(new RegExp("\\d{"+u+"}\\B","g"),"$&"+(n.fractionGroupSeparator||"")):c):h}return(n.prefix||"")+r+(n.suffix||"")},f.toFraction=function(t){var e,r,i,o,s,a,u,l,h,c,f,p,d=this,y=d.c;if(null!=t&&(!(u=new S(t)).isInteger()&&(u.c||1!==u.s)||u.lt(g)))throw Error(qo+"Argument "+(u.isInteger()?"out of range: ":"not an integer: ")+T(u));if(!y)return new S(d);for(e=new S(g),h=r=new S(g),i=l=new S(g),p=Zo(y),s=e.e=p.length-d.e-1,e.c[0]=zo[(a=s%Bo)<0?Bo+a:a],t=!t||u.comparedTo(e)>0?s>0?e:h:u,a=x,x=1/0,u=new S(p),l.c[0]=0;c=n(u,e,0,1),1!=(o=r.plus(c.times(i))).comparedTo(t);)r=i,i=o,h=l.plus(c.times(o=h)),l=o,e=u.minus(c.times(o=e)),u=o;return o=n(t.minus(r),i,0,1),l=l.plus(o.times(h)),r=r.plus(o.times(i)),l.s=h.s=d.s,f=n(h,i,s*=2,v).minus(d).abs().comparedTo(n(l,r,s,v).minus(d).abs())<1?[h,i]:[l,r],x=a,f},f.toNumber=function(){return+T(this)},f.toPrecision=function(t,e){return null!=t&&Wo(t,1,Xo),M(this,t,e,2)},f.toString=function(t){var e,n=this,i=n.s,o=n.e;return null===o?i?(e="Infinity",i<0&&(e="-"+e)):e="NaN":(null==t?e=o<=d||o>=y?Ko(Zo(n.c),o):Qo(Zo(n.c),o,"0"):10===t&&N?e=Qo(Zo((n=C(new S(n),p+o+1,v)).c),n.e,"0"):(Wo(t,2,I.length,"Base"),e=r(Qo(Zo(n.c),o,"0"),10,t,i,!0)),i<0&&n.c[0]&&(e="-"+e)),e},f.valueOf=f.toJSON=function(){return T(this)},f._isBigNumber=!0,f[Symbol.toStringTag]="BigNumber",f[Symbol.for("nodejs.util.inspect.custom")]=f.valueOf,null!=e&&S.set(e),S}(),ts=function(t){function e(t){return i(this,e),r(this,e,[t])}return h(e,t),s(e)}(s((function t(e){i(this,t),u(this,"key",void 0),u(this,"left",null),u(this,"right",null),this.key=e}))),es=function(){return s((function t(){i(this,t),u(this,"size",0),u(this,"modificationCount",0),u(this,"splayCount",0)}),[{key:"splay",value:function(t){var e=this.root;if(null==e)return this.compare(t,t),-1;for(var n,r=null,i=null,o=null,s=null,a=e,u=this.compare;;)if((n=u(a.key,t))>0){var l=a.left;if(null==l)break;if((n=u(l.key,t))>0&&(a.left=l.right,l.right=a,null==(l=(a=l).left)))break;null==r?i=a:r.left=a,r=a,a=l}else{if(!(n<0))break;var h=a.right;if(null==h)break;if((n=u(h.key,t))<0&&(a.right=h.left,h.left=a,null==(h=(a=h).right)))break;null==o?s=a:o.right=a,o=a,a=h}return null!=o&&(o.right=a.left,a.left=s),null!=r&&(r.left=a.right,a.right=i),this.root!==a&&(this.root=a,this.splayCount++),n}},{key:"splayMin",value:function(t){for(var e=t,n=e.left;null!=n;){var r=n;e.left=r.right,r.right=e,n=(e=r).left}return e}},{key:"splayMax",value:function(t){for(var e=t,n=e.right;null!=n;){var r=n;e.right=r.left,r.left=e,n=(e=r).right}return e}},{key:"_delete",value:function(t){if(null==this.root)return null;if(0!=this.splay(t))return null;var e=this.root,n=e,r=e.left;if(this.size--,null==r)this.root=e.right;else{var i=e.right;(e=this.splayMax(r)).right=i,this.root=e}return this.modificationCount++,n}},{key:"addNewRoot",value:function(t,e){this.size++,this.modificationCount++;var n=this.root;null!=n?(e<0?(t.left=n,t.right=n.right,n.right=null):(t.right=n,t.left=n.left,n.left=null),this.root=t):this.root=t}},{key:"_first",value:function(){var t=this.root;return null==t?null:(this.root=this.splayMin(t),this.root)}},{key:"_last",value:function(){var t=this.root;return null==t?null:(this.root=this.splayMax(t),this.root)}},{key:"clear",value:function(){this.root=null,this.size=0,this.modificationCount++}},{key:"has",value:function(t){return this.validKey(t)&&0==this.splay(t)}},{key:"defaultCompare",value:function(){return function(t,e){return t<e?-1:t>e?1:0}}},{key:"wrap",value:function(){var t=this;return{getRoot:function(){return t.root},setRoot:function(e){t.root=e},getSize:function(){return t.size},getModificationCount:function(){return t.modificationCount},getSplayCount:function(){return t.splayCount},setSplayCount:function(e){t.splayCount=e},splay:function(e){return t.splay(e)},has:function(e){return t.has(e)}}}}])}(),ns=function(t){function e(t,n){var o;return i(this,e),u(o=r(this,e),"root",null),u(o,"compare",void 0),u(o,"validKey",void 0),u(o,Symbol.toStringTag,"[object Set]"),o.compare=null!=t?t:o.defaultCompare(),o.validKey=null!=n?n:function(t){return null!=t&&null!=t},o}return h(e,t),s(e,[{key:"delete",value:function(t){return!!this.validKey(t)&&null!=this._delete(t)}},{key:"deleteAll",value:function(t){var e,n=a(t);try{for(n.s();!(e=n.n()).done;){var r=e.value;this.delete(r)}}catch(t){n.e(t)}finally{n.f()}}},{key:"forEach",value:function(t){for(var e,n=this[Symbol.iterator]();!(e=n.next()).done;)t(e.value,e.value,this)}},{key:"add",value:function(t){var e=this.splay(t);return 0!=e&&this.addNewRoot(new ts(t),e),this}},{key:"addAndReturn",value:function(t){var e=this.splay(t);return 0!=e&&this.addNewRoot(new ts(t),e),this.root.key}},{key:"addAll",value:function(t){var e,n=a(t);try{for(n.s();!(e=n.n()).done;){var r=e.value;this.add(r)}}catch(t){n.e(t)}finally{n.f()}}},{key:"isEmpty",value:function(){return null==this.root}},{key:"isNotEmpty",value:function(){return null!=this.root}},{key:"single",value:function(){if(0==this.size)throw"Bad state: No element";if(this.size>1)throw"Bad state: Too many element";return this.root.key}},{key:"first",value:function(){if(0==this.size)throw"Bad state: No element";return this._first().key}},{key:"last",value:function(){if(0==this.size)throw"Bad state: No element";return this._last().key}},{key:"lastBefore",value:function(t){if(null==t)throw"Invalid arguments(s)";if(null==this.root)return null;if(this.splay(t)<0)return this.root.key;var e=this.root.left;if(null==e)return null;for(var n=e.right;null!=n;)n=(e=n).right;return e.key}},{key:"firstAfter",value:function(t){if(null==t)throw"Invalid arguments(s)";if(null==this.root)return null;if(this.splay(t)>0)return this.root.key;var e=this.root.right;if(null==e)return null;for(var n=e.left;null!=n;)n=(e=n).left;return e.key}},{key:"retainAll",value:function(t){var n,r=new e(this.compare,this.validKey),i=this.modificationCount,o=a(t);try{for(o.s();!(n=o.n()).done;){var s=n.value;if(i!=this.modificationCount)throw"Concurrent modification during iteration.";this.validKey(s)&&0==this.splay(s)&&r.add(this.root.key)}}catch(t){o.e(t)}finally{o.f()}r.size!=this.size&&(this.root=r.root,this.size=r.size,this.modificationCount++)}},{key:"lookup",value:function(t){return this.validKey(t)?0!=this.splay(t)?null:this.root.key:null}},{key:"intersection",value:function(t){var n,r=new e(this.compare,this.validKey),i=a(this);try{for(i.s();!(n=i.n()).done;){var o=n.value;t.has(o)&&r.add(o)}}catch(t){i.e(t)}finally{i.f()}return r}},{key:"difference",value:function(t){var n,r=new e(this.compare,this.validKey),i=a(this);try{for(i.s();!(n=i.n()).done;){var o=n.value;t.has(o)||r.add(o)}}catch(t){i.e(t)}finally{i.f()}return r}},{key:"union",value:function(t){var e=this.clone();return e.addAll(t),e}},{key:"clone",value:function(){var t=new e(this.compare,this.validKey);return t.size=this.size,t.root=this.copyNode(this.root),t}},{key:"copyNode",value:function(t){if(null==t)return null;var e=new ts(t.key);return function t(e,n){var r,i;do{if(r=e.left,i=e.right,null!=r){var o=new ts(r.key);n.left=o,t(r,o)}if(null!=i){var s=new ts(i.key);n.right=s,e=i,n=s}}while(null!=i)}(t,e),e}},{key:"toSet",value:function(){return this.clone()}},{key:"entries",value:function(){return new os(this.wrap())}},{key:"keys",value:function(){return this[Symbol.iterator]()}},{key:"values",value:function(){return this[Symbol.iterator]()}},{key:Symbol.iterator,value:function(){return new is(this.wrap())}}])}(es),rs=function(){return s((function t(e){i(this,t),u(this,"tree",void 0),u(this,"path",new Array),u(this,"modificationCount",null),u(this,"splayCount",void 0),this.tree=e,this.splayCount=e.getSplayCount()}),[{key:Symbol.iterator,value:function(){return this}},{key:"next",value:function(){return this.moveNext()?{done:!1,value:this.current()}:{done:!0,value:null}}},{key:"current",value:function(){if(!this.path.length)return null;var t=this.path[this.path.length-1];return this.getValue(t)}},{key:"rebuildPath",value:function(t){this.path.splice(0,this.path.length),this.tree.splay(t),this.path.push(this.tree.getRoot()),this.splayCount=this.tree.getSplayCount()}},{key:"findLeftMostDescendent",value:function(t){for(;null!=t;)this.path.push(t),t=t.left}},{key:"moveNext",value:function(){if(this.modificationCount!=this.tree.getModificationCount()){if(null==this.modificationCount){this.modificationCount=this.tree.getModificationCount();for(var t=this.tree.getRoot();null!=t;)this.path.push(t),t=t.left;return this.path.length>0}throw"Concurrent modification during iteration."}if(!this.path.length)return!1;this.splayCount!=this.tree.getSplayCount()&&this.rebuildPath(this.path[this.path.length-1].key);var e=this.path[this.path.length-1],n=e.right;if(null!=n){for(;null!=n;)this.path.push(n),n=n.left;return!0}for(this.path.pop();this.path.length&&this.path[this.path.length-1].right===e;)e=this.path.pop();return this.path.length>0}}])}(),is=function(t){function e(){return i(this,e),r(this,e,arguments)}return h(e,t),s(e,[{key:"getValue",value:function(t){return t.key}}])}(rs),os=function(t){function e(){return i(this,e),r(this,e,arguments)}return h(e,t),s(e,[{key:"getValue",value:function(t){return[t.key,t.key]}}])}(rs),ss=function(t){return function(){return t}},as=function(t){var e=t?function(e,n){return n.minus(e).abs().isLessThanOrEqualTo(t)}:ss(!1);return function(t,n){return e(t,n)?0:t.comparedTo(n)}};function us(t){var e=t?function(e,n,r,i,o){return e.exponentiatedBy(2).isLessThanOrEqualTo(i.minus(n).exponentiatedBy(2).plus(o.minus(r).exponentiatedBy(2)).times(t))}:ss(!1);return function(t,n,r){var i=t.x,o=t.y,s=r.x,a=r.y,u=o.minus(a).times(n.x.minus(s)).minus(i.minus(s).times(n.y.minus(a)));return e(u,i,o,s,a)?0:u.comparedTo(0)}}var ls=function(t){return t},hs=function(t){if(t){var e=new ns(as(t)),n=new ns(as(t)),r=function(t,e){return e.addAndReturn(t)},i=function(t){return{x:r(t.x,e),y:r(t.y,n)}};return i({x:new $o(0),y:new $o(0)}),i}return ls},cs=function(t){return{set:function(t){fs=cs(t)},reset:function(){return cs(t)},compare:as(t),snap:hs(t),orient:us(t)}},fs=cs(),gs=function(t,e){return t.ll.x.isLessThanOrEqualTo(e.x)&&e.x.isLessThanOrEqualTo(t.ur.x)&&t.ll.y.isLessThanOrEqualTo(e.y)&&e.y.isLessThanOrEqualTo(t.ur.y)},ps=function(t,e){if(e.ur.x.isLessThan(t.ll.x)||t.ur.x.isLessThan(e.ll.x)||e.ur.y.isLessThan(t.ll.y)||t.ur.y.isLessThan(e.ll.y))return null;var n=t.ll.x.isLessThan(e.ll.x)?e.ll.x:t.ll.x,r=t.ur.x.isLessThan(e.ur.x)?t.ur.x:e.ur.x;return{ll:{x:n,y:t.ll.y.isLessThan(e.ll.y)?e.ll.y:t.ll.y},ur:{x:r,y:t.ur.y.isLessThan(e.ur.y)?t.ur.y:e.ur.y}}},vs=function(t,e){return t.x.times(e.y).minus(t.y.times(e.x))},ds=function(t,e){return t.x.times(e.x).plus(t.y.times(e.y))},ys=function(t){return ds(t,t).sqrt()},ms=function(t,e,n){var r={x:e.x.minus(t.x),y:e.y.minus(t.y)},i={x:n.x.minus(t.x),y:n.y.minus(t.y)};return ds(i,r).div(ys(i)).div(ys(r))},_s=function(t,e,n){return e.y.isZero()?null:{x:t.x.plus(e.x.div(e.y).times(n.minus(t.y))),y:n}},xs=function(t,e,n){return e.x.isZero()?null:{x:n,y:t.y.plus(e.y.div(e.x).times(n.minus(t.x)))}},Es=function(){function t(e,n){i(this,t),u(this,"point",void 0),u(this,"isLeft",void 0),u(this,"segment",void 0),u(this,"otherSE",void 0),u(this,"consumedBy",void 0),void 0===e.events?e.events=[this]:e.events.push(this),this.point=e,this.isLeft=n}return s(t,[{key:"link",value:function(t){if(t.point===this.point)throw new Error("Tried to link already linked events");for(var e=t.point.events,n=0,r=e.length;n<r;n++){var i=e[n];this.point.events.push(i),i.point=this.point}this.checkForConsuming()}},{key:"checkForConsuming",value:function(){for(var t=this.point.events.length,e=0;e<t;e++){var n=this.point.events[e];if(void 0===n.segment.consumedBy)for(var r=e+1;r<t;r++){var i=this.point.events[r];void 0===i.consumedBy&&(n.otherSE.point.events===i.otherSE.point.events&&n.segment.consume(i.segment))}}}},{key:"getAvailableLinkedEvents",value:function(){for(var t=[],e=0,n=this.point.events.length;e<n;e++){var r=this.point.events[e];r!==this&&!r.segment.ringOut&&r.segment.isInResult()&&t.push(r)}return t}},{key:"getLeftmostComparator",value:function(t){var e=this,n=new Map,r=function(r){var i,o,s,a,u,l=r.otherSE;n.set(r,{sine:(i=e.point,o=t.point,s=l.point,a={x:o.x.minus(i.x),y:o.y.minus(i.y)},u={x:s.x.minus(i.x),y:s.y.minus(i.y)},vs(u,a).div(ys(u)).div(ys(a))),cosine:ms(e.point,t.point,l.point)})};return function(t,e){n.has(t)||r(t),n.has(e)||r(e);var i=n.get(t),o=i.sine,s=i.cosine,a=n.get(e),u=a.sine,l=a.cosine;return o.isGreaterThanOrEqualTo(0)&&u.isGreaterThanOrEqualTo(0)?s.isLessThan(l)?1:s.isGreaterThan(l)?-1:0:o.isLessThan(0)&&u.isLessThan(0)?s.isLessThan(l)?-1:s.isGreaterThan(l)?1:0:u.isLessThan(o)?-1:u.isGreaterThan(o)?1:0}}}],[{key:"compare",value:function(e,n){var r=t.comparePoints(e.point,n.point);return 0!==r?r:(e.point!==n.point&&e.link(n),e.isLeft!==n.isLeft?e.isLeft?1:-1:Ls.compare(e.segment,n.segment))}},{key:"comparePoints",value:function(t,e){return t.x.isLessThan(e.x)?-1:t.x.isGreaterThan(e.x)?1:t.y.isLessThan(e.y)?-1:t.y.isGreaterThan(e.y)?1:0}}])}(),ks=function(){function t(e){i(this,t),u(this,"events",void 0),u(this,"poly",void 0),u(this,"_isExteriorRing",void 0),u(this,"_enclosingRing",void 0),this.events=e;for(var n=0,r=e.length;n<r;n++)e[n].segment.ringOut=this;this.poly=null}return s(t,[{key:"getGeom",value:function(){for(var t=this.events[0].point,e=[t],n=1,r=this.events.length-1;n<r;n++){var i=this.events[n].point,o=this.events[n+1].point;0!==fs.orient(i,t,o)&&(e.push(i),t=i)}if(1===e.length)return null;var s=e[0],a=e[1];0===fs.orient(s,t,a)&&e.shift(),e.push(e[0]);for(var u=this.isExteriorRing()?1:-1,l=this.isExteriorRing()?0:e.length-1,h=this.isExteriorRing()?e.length:-1,c=[],f=l;f!=h;f+=u)c.push([e[f].x.toNumber(),e[f].y.toNumber()]);return c}},{key:"isExteriorRing",value:function(){if(void 0===this._isExteriorRing){var t=this.enclosingRing();this._isExteriorRing=!t||!t.isExteriorRing()}return this._isExteriorRing}},{key:"enclosingRing",value:function(){return void 0===this._enclosingRing&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}},{key:"_calcEnclosingRing",value:function(){for(var t=this.events[0],e=1,n=this.events.length;e<n;e++){var r=this.events[e];Es.compare(t,r)>0&&(t=r)}for(var i=t.segment.prevInResult(),o=i?i.prevInResult():null;;){if(!i)return null;if(!o)return i.ringOut;var s,a;if(o.ringOut!==i.ringOut)return(null===(s=o.ringOut)||void 0===s?void 0:s.enclosingRing())!==i.ringOut?i.ringOut:null===(a=i.ringOut)||void 0===a?void 0:a.enclosingRing();i=o.prevInResult(),o=i?i.prevInResult():null}}}],[{key:"factory",value:function(e){for(var n=[],r=0,i=e.length;r<i;r++){var o=e[r];if(o.isInResult()&&!o.ringOut){for(var s=null,a=o.leftSE,u=o.rightSE,l=[a],h=a.point,c=[];s=a,a=u,l.push(a),a.point!==h;)for(;;){var f=a.getAvailableLinkedEvents();if(0===f.length){var g=l[0].point,p=l[l.length-1].point;throw new Error("Unable to complete output ring starting at [".concat(g.x,", ").concat(g.y,"]. Last matching segment found ends at [").concat(p.x,", ").concat(p.y,"]."))}if(1===f.length){u=f[0].otherSE;break}for(var v=null,d=0,y=c.length;d<y;d++)if(c[d].point===a.point){v=d;break}if(null===v){c.push({index:l.length,point:a.point});var m=a.getLeftmostComparator(s);u=f.sort(m)[0].otherSE;break}var _=c.splice(v)[0],x=l.splice(_.index);x.unshift(x[0].otherSE),n.push(new t(x.reverse()))}n.push(new t(l))}}return n}}])}(),bs=function(){return s((function t(e){i(this,t),u(this,"exteriorRing",void 0),u(this,"interiorRings",void 0),this.exteriorRing=e,e.poly=this,this.interiorRings=[]}),[{key:"addInterior",value:function(t){this.interiorRings.push(t),t.poly=this}},{key:"getGeom",value:function(){var t=this.exteriorRing.getGeom();if(null===t)return null;for(var e=[t],n=0,r=this.interiorRings.length;n<r;n++){var i=this.interiorRings[n].getGeom();null!==i&&e.push(i)}return e}}])}(),ws=function(){return s((function t(e){i(this,t),u(this,"rings",void 0),u(this,"polys",void 0),this.rings=e,this.polys=this._composePolys(e)}),[{key:"getGeom",value:function(){for(var t=[],e=0,n=this.polys.length;e<n;e++){var r=this.polys[e].getGeom();null!==r&&t.push(r)}return t}},{key:"_composePolys",value:function(t){for(var e=[],n=0,r=t.length;n<r;n++){var i=t[n];if(!i.poly)if(i.isExteriorRing())e.push(new bs(i));else{var o,s=i.enclosingRing();null!=s&&s.poly||e.push(new bs(s)),null==s||null===(o=s.poly)||void 0===o||o.addInterior(i)}}return e}}])}(),Is=function(){return s((function t(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Ls.compare;i(this,t),u(this,"queue",void 0),u(this,"tree",void 0),u(this,"segments",void 0),this.queue=e,this.tree=new ns(n),this.segments=[]}),[{key:"process",value:function(t){var e=t.segment,n=[];if(t.consumedBy)return t.isLeft?this.queue.delete(t.otherSE):this.tree.delete(e),n;t.isLeft&&this.tree.add(e);var r=e,i=e;do{r=this.tree.lastBefore(r)}while(null!=r&&null!=r.consumedBy);do{i=this.tree.firstAfter(i)}while(null!=i&&null!=i.consumedBy);if(t.isLeft){var o=null;if(r){var s=r.getIntersection(e);if(null!==s&&(e.isAnEndpoint(s)||(o=s),!r.isAnEndpoint(s)))for(var a=this._splitSafely(r,s),u=0,l=a.length;u<l;u++)n.push(a[u])}var h=null;if(i){var c=i.getIntersection(e);if(null!==c&&(e.isAnEndpoint(c)||(h=c),!i.isAnEndpoint(c)))for(var f=this._splitSafely(i,c),g=0,p=f.length;g<p;g++)n.push(f[g])}if(null!==o||null!==h){var v=null;if(null===o)v=h;else if(null===h)v=o;else{v=Es.comparePoints(o,h)<=0?o:h}this.queue.delete(e.rightSE),n.push(e.rightSE);for(var d=e.split(v),y=0,m=d.length;y<m;y++)n.push(d[y])}n.length>0?(this.tree.delete(e),n.push(t)):(this.segments.push(e),e.prev=r)}else{if(r&&i){var _=r.getIntersection(i);if(null!==_){if(!r.isAnEndpoint(_))for(var x=this._splitSafely(r,_),E=0,k=x.length;E<k;E++)n.push(x[E]);if(!i.isAnEndpoint(_))for(var b=this._splitSafely(i,_),w=0,I=b.length;w<I;w++)n.push(b[w])}}this.tree.delete(e)}return n}},{key:"_splitSafely",value:function(t,e){this.tree.delete(t);var n=t.rightSE;this.queue.delete(n);var r=t.split(e);return r.push(n),void 0===t.consumedBy&&this.tree.add(t),r}}])}(),Ns=new(function(){return s((function t(){i(this,t),u(this,"type",void 0),u(this,"numMultiPolys",void 0)}),[{key:"run",value:function(t,e,n){Ns.type=t;for(var r=[new Ts(e,!0)],i=0,o=n.length;i<o;i++)r.push(new Ts(n[i],!1));if(Ns.numMultiPolys=r.length,"difference"===Ns.type)for(var s=r[0],a=1;a<r.length;)null!==ps(r[a].bbox,s.bbox)?a++:r.splice(a,1);if("intersection"===Ns.type)for(var u=0,l=r.length;u<l;u++)for(var h=r[u],c=u+1,f=r.length;c<f;c++)if(null===ps(h.bbox,r[c].bbox))return[];for(var g=new ns(Es.compare),p=0,v=r.length;p<v;p++)for(var d=r[p].getSweepEvents(),y=0,m=d.length;y<m;y++)g.add(d[y]);var _=new Is(g),x=null;for(0!=g.size&&(x=g.first(),g.delete(x));x;){for(var E=_.process(x),k=0,b=E.length;k<b;k++){var w=E[k];void 0===w.consumedBy&&g.add(w)}0!=g.size?(x=g.first(),g.delete(x)):x=null}fs.reset();var I=ks.factory(_.segments);return new ws(I).getGeom()}}])}()),Ss=Ns,Ms=0,Ls=function(){function t(e,n,r,o){i(this,t),u(this,"id",void 0),u(this,"leftSE",void 0),u(this,"rightSE",void 0),u(this,"rings",void 0),u(this,"windings",void 0),u(this,"ringOut",void 0),u(this,"consumedBy",void 0),u(this,"prev",void 0),u(this,"_prevInResult",void 0),u(this,"_beforeState",void 0),u(this,"_afterState",void 0),u(this,"_isInResult",void 0),this.id=++Ms,this.leftSE=e,e.segment=this,e.otherSE=n,this.rightSE=n,n.segment=this,n.otherSE=e,this.rings=r,this.windings=o}return s(t,[{key:"replaceRightSE",value:function(t){this.rightSE=t,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}},{key:"bbox",value:function(){var t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t.isLessThan(e)?t:e},ur:{x:this.rightSE.point.x,y:t.isGreaterThan(e)?t:e}}}},{key:"vector",value:function(){return{x:this.rightSE.point.x.minus(this.leftSE.point.x),y:this.rightSE.point.y.minus(this.leftSE.point.y)}}},{key:"isAnEndpoint",value:function(t){return t.x.eq(this.leftSE.point.x)&&t.y.eq(this.leftSE.point.y)||t.x.eq(this.rightSE.point.x)&&t.y.eq(this.rightSE.point.y)}},{key:"comparePoint",value:function(t){return fs.orient(this.leftSE.point,t,this.rightSE.point)}},{key:"getIntersection",value:function(t){var e=this.bbox(),n=t.bbox(),r=ps(e,n);if(null===r)return null;var i=this.leftSE.point,o=this.rightSE.point,s=t.leftSE.point,a=t.rightSE.point,u=gs(e,s)&&0===this.comparePoint(s),l=gs(n,i)&&0===t.comparePoint(i),h=gs(e,a)&&0===this.comparePoint(a),c=gs(n,o)&&0===t.comparePoint(o);if(l&&u)return c&&!h?o:!c&&h?a:null;if(l)return h&&i.x.eq(a.x)&&i.y.eq(a.y)?null:i;if(u)return c&&o.x.eq(s.x)&&o.y.eq(s.y)?null:s;if(c&&h)return null;if(c)return o;if(h)return a;var f=function(t,e,n,r){if(e.x.isZero())return xs(n,r,t.x);if(r.x.isZero())return xs(t,e,n.x);if(e.y.isZero())return _s(n,r,t.y);if(r.y.isZero())return _s(t,e,n.y);var i=vs(e,r);if(i.isZero())return null;var o={x:n.x.minus(t.x),y:n.y.minus(t.y)},s=vs(o,e).div(i),a=vs(o,r).div(i),u=t.x.plus(a.times(e.x)),l=n.x.plus(s.times(r.x)),h=t.y.plus(a.times(e.y)),c=n.y.plus(s.times(r.y));return{x:u.plus(l).div(2),y:h.plus(c).div(2)}}(i,this.vector(),s,t.vector());return null===f?null:gs(r,f)?fs.snap(f):null}},{key:"split",value:function(e){var n=[],r=void 0!==e.events,i=new Es(e,!0),o=new Es(e,!1),s=this.rightSE;this.replaceRightSE(o),n.push(o),n.push(i);var a=new t(i,s,this.rings.slice(),this.windings.slice());return Es.comparePoints(a.leftSE.point,a.rightSE.point)>0&&a.swapEvents(),Es.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),r&&(i.checkForConsuming(),o.checkForConsuming()),n}},{key:"swapEvents",value:function(){var t=this.rightSE;this.rightSE=this.leftSE,this.leftSE=t,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(var e=0,n=this.windings.length;e<n;e++)this.windings[e]*=-1}},{key:"consume",value:function(e){for(var n=this,r=e;n.consumedBy;)n=n.consumedBy;for(;r.consumedBy;)r=r.consumedBy;var i=t.compare(n,r);if(0!==i){if(i>0){var o=n;n=r,r=o}if(n.prev===r){var s=n;n=r,r=s}for(var a=0,u=r.rings.length;a<u;a++){var l=r.rings[a],h=r.windings[a],c=n.rings.indexOf(l);-1===c?(n.rings.push(l),n.windings.push(h)):n.windings[c]+=h}r.rings=null,r.windings=null,r.consumedBy=n,r.leftSE.consumedBy=n.leftSE,r.rightSE.consumedBy=n.rightSE}}},{key:"prevInResult",value:function(){return void 0!==this._prevInResult||(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null),this._prevInResult}},{key:"beforeState",value:function(){if(void 0!==this._beforeState)return this._beforeState;if(this.prev){var t=this.prev.consumedBy||this.prev;this._beforeState=t.afterState()}else this._beforeState={rings:[],windings:[],multiPolys:[]};return this._beforeState}},{key:"afterState",value:function(){if(void 0!==this._afterState)return this._afterState;var t=this.beforeState();this._afterState={rings:t.rings.slice(0),windings:t.windings.slice(0),multiPolys:[]};for(var e=this._afterState.rings,n=this._afterState.windings,r=this._afterState.multiPolys,i=0,o=this.rings.length;i<o;i++){var s=this.rings[i],a=this.windings[i],u=e.indexOf(s);-1===u?(e.push(s),n.push(a)):n[u]+=a}for(var l=[],h=[],c=0,f=e.length;c<f;c++)if(0!==n[c]){var g=e[c],p=g.poly;if(-1===h.indexOf(p))if(g.isExterior)l.push(p);else{-1===h.indexOf(p)&&h.push(p);var v=l.indexOf(g.poly);-1!==v&&l.splice(v,1)}}for(var d=0,y=l.length;d<y;d++){var m=l[d].multiPoly;-1===r.indexOf(m)&&r.push(m)}return this._afterState}},{key:"isInResult",value:function(){if(this.consumedBy)return!1;if(void 0!==this._isInResult)return this._isInResult;var t=this.beforeState().multiPolys,e=this.afterState().multiPolys;switch(Ss.type){case"union":var n=0===t.length,r=0===e.length;this._isInResult=n!==r;break;case"intersection":var i,o;t.length<e.length?(i=t.length,o=e.length):(i=e.length,o=t.length),this._isInResult=o===Ss.numMultiPolys&&i<o;break;case"xor":var s=Math.abs(t.length-e.length);this._isInResult=s%2==1;break;case"difference":var a=function(t){return 1===t.length&&t[0].isSubject};this._isInResult=a(t)!==a(e)}return this._isInResult}}],[{key:"compare",value:function(t,e){var n=t.leftSE.point.x,r=e.leftSE.point.x,i=t.rightSE.point.x,o=e.rightSE.point.x;if(o.isLessThan(n))return 1;if(i.isLessThan(r))return-1;var s=t.leftSE.point.y,a=e.leftSE.point.y,u=t.rightSE.point.y,l=e.rightSE.point.y;if(n.isLessThan(r)){if(a.isLessThan(s)&&a.isLessThan(u))return 1;if(a.isGreaterThan(s)&&a.isGreaterThan(u))return-1;var h=t.comparePoint(e.leftSE.point);if(h<0)return 1;if(h>0)return-1;var c=e.comparePoint(t.rightSE.point);return 0!==c?c:-1}if(n.isGreaterThan(r)){if(s.isLessThan(a)&&s.isLessThan(l))return-1;if(s.isGreaterThan(a)&&s.isGreaterThan(l))return 1;var f=e.comparePoint(t.leftSE.point);if(0!==f)return f;var g=t.comparePoint(e.rightSE.point);return g<0?1:g>0?-1:1}if(s.isLessThan(a))return-1;if(s.isGreaterThan(a))return 1;if(i.isLessThan(o)){var p=e.comparePoint(t.rightSE.point);if(0!==p)return p}if(i.isGreaterThan(o)){var v=t.comparePoint(e.rightSE.point);if(v<0)return 1;if(v>0)return-1}if(!i.eq(o)){var d=u.minus(s),y=i.minus(n),m=l.minus(a),_=o.minus(r);if(d.isGreaterThan(y)&&m.isLessThan(_))return 1;if(d.isLessThan(y)&&m.isGreaterThan(_))return-1}return i.isGreaterThan(o)?1:i.isLessThan(o)||u.isLessThan(l)?-1:u.isGreaterThan(l)?1:t.id<e.id?-1:t.id>e.id?1:0}},{key:"fromRing",value:function(e,n,r){var i,o,s,a=Es.comparePoints(e,n);if(a<0)i=e,o=n,s=1;else{if(!(a>0))throw new Error("Tried to create degenerate segment at [".concat(e.x,", ").concat(e.y,"]"));i=n,o=e,s=-1}return new t(new Es(i,!0),new Es(o,!1),[r],[s])}}])}(),Ps=function(){return s((function t(e,n,r){if(i(this,t),u(this,"poly",void 0),u(this,"isExterior",void 0),u(this,"segments",void 0),u(this,"bbox",void 0),!Array.isArray(e)||0===e.length)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=n,this.isExterior=r,this.segments=[],"number"!=typeof e[0][0]||"number"!=typeof e[0][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");var o=fs.snap({x:new $o(e[0][0]),y:new $o(e[0][1])});this.bbox={ll:{x:o.x,y:o.y},ur:{x:o.x,y:o.y}};for(var s=o,a=1,l=e.length;a<l;a++){if("number"!=typeof e[a][0]||"number"!=typeof e[a][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");var h=fs.snap({x:new $o(e[a][0]),y:new $o(e[a][1])});h.x.eq(s.x)&&h.y.eq(s.y)||(this.segments.push(Ls.fromRing(s,h,this)),h.x.isLessThan(this.bbox.ll.x)&&(this.bbox.ll.x=h.x),h.y.isLessThan(this.bbox.ll.y)&&(this.bbox.ll.y=h.y),h.x.isGreaterThan(this.bbox.ur.x)&&(this.bbox.ur.x=h.x),h.y.isGreaterThan(this.bbox.ur.y)&&(this.bbox.ur.y=h.y),s=h)}o.x.eq(s.x)&&o.y.eq(s.y)||this.segments.push(Ls.fromRing(s,o,this))}),[{key:"getSweepEvents",value:function(){for(var t=[],e=0,n=this.segments.length;e<n;e++){var r=this.segments[e];t.push(r.leftSE),t.push(r.rightSE)}return t}}])}(),Cs=function(){return s((function t(e,n){if(i(this,t),u(this,"multiPoly",void 0),u(this,"exteriorRing",void 0),u(this,"interiorRings",void 0),u(this,"bbox",void 0),!Array.isArray(e))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new Ps(e[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(var r=1,o=e.length;r<o;r++){var s=new Ps(e[r],this,!1);s.bbox.ll.x.isLessThan(this.bbox.ll.x)&&(this.bbox.ll.x=s.bbox.ll.x),s.bbox.ll.y.isLessThan(this.bbox.ll.y)&&(this.bbox.ll.y=s.bbox.ll.y),s.bbox.ur.x.isGreaterThan(this.bbox.ur.x)&&(this.bbox.ur.x=s.bbox.ur.x),s.bbox.ur.y.isGreaterThan(this.bbox.ur.y)&&(this.bbox.ur.y=s.bbox.ur.y),this.interiorRings.push(s)}this.multiPoly=n}),[{key:"getSweepEvents",value:function(){for(var t=this.exteriorRing.getSweepEvents(),e=0,n=this.interiorRings.length;e<n;e++)for(var r=this.interiorRings[e].getSweepEvents(),i=0,o=r.length;i<o;i++)t.push(r[i]);return t}}])}(),Ts=function(){return s((function t(e,n){if(i(this,t),u(this,"isSubject",void 0),u(this,"polys",void 0),u(this,"bbox",void 0),!Array.isArray(e))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{"number"==typeof e[0][0][0]&&(e=[e])}catch(t){}this.polys=[],this.bbox={ll:{x:new $o(Number.POSITIVE_INFINITY),y:new $o(Number.POSITIVE_INFINITY)},ur:{x:new $o(Number.NEGATIVE_INFINITY),y:new $o(Number.NEGATIVE_INFINITY)}};for(var r=0,o=e.length;r<o;r++){var s=new Cs(e[r],this);s.bbox.ll.x.isLessThan(this.bbox.ll.x)&&(this.bbox.ll.x=s.bbox.ll.x),s.bbox.ll.y.isLessThan(this.bbox.ll.y)&&(this.bbox.ll.y=s.bbox.ll.y),s.bbox.ur.x.isGreaterThan(this.bbox.ur.x)&&(this.bbox.ur.x=s.bbox.ur.x),s.bbox.ur.y.isGreaterThan(this.bbox.ur.y)&&(this.bbox.ur.y=s.bbox.ur.y),this.polys.push(s)}this.isSubject=n}),[{key:"getSweepEvents",value:function(){for(var t=[],e=0,n=this.polys.length;e<n;e++)for(var r=this.polys[e].getSweepEvents(),i=0,o=r.length;i<o;i++)t.push(r[i]);return t}}])}(),Os=function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];return Ss.run("union",t,n)},Rs=function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];return Ss.run("intersection",t,n)},As=function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];return Ss.run("difference",t,n)},Ds=fs.set,Fs=Object.freeze({__proto__:null,difference:As,intersection:Rs,setPrecision:Ds,union:Os,xor:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];return Ss.run("xor",t,n)}});function qs(t){if(!t)throw new Error("geojson is required");var e=[];return xt(t,(function(t){e.push(t)})),C(e)}function Vs(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2,r=K(t),i=K(e),o=r[0]-i[0],s=r[1]-i[1];return 1===n?Math.abs(o)+Math.abs(s):Math.pow(Math.pow(o,n)+Math.pow(s,n),1/n)}function Gs(t,e){var n,r,i=(e=e||{}).threshold||1e4,o=e.p||2,s=null!=(n=e.binary)&&n,a=e.alpha||-1,u=null!=(r=e.standardization)&&r,l=[];vt(t,(function(t){l.push(gi(t))}));for(var h=[],c=0;c<l.length;c++)h[c]=[];for(var f=0;f<l.length;f++)for(var g=f;g<l.length;g++){f===g&&(h[f][g]=0);var p=Vs(l[f],l[g],o);h[f][g]=p,h[g][f]=p}for(var v=0;v<l.length;v++)for(var d=0;d<l.length;d++){var y=h[v][d];0!==y&&(h[v][d]=s?y<=i?1:0:y<=i?Math.pow(y,a):0)}if(u)for(var m=0;m<l.length;m++)for(var _=h[m].reduce((function(t,e){return t+e}),0),x=0;x<l.length;x++)h[m][x]=h[m][x]/_;return h}function Bs(t,e,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=e<0,o=j(Math.abs(e),r.units,"meters");i&&(o=-Math.abs(o));var s=K(t),a=function(t,e,n,r){r=void 0===r?x:Number(r);var i=e/r,o=t[0]*Math.PI/180,s=z(t[1]),a=z(n),u=i*Math.cos(a),l=s+u;Math.abs(l)>Math.PI/2&&(l=l>0?Math.PI-l:-Math.PI-l);var h=Math.log(Math.tan(l/2+Math.PI/4)/Math.tan(s/2+Math.PI/4)),c=Math.abs(h)>1e-11?u/h:Math.cos(s),f=i*Math.sin(a)/c;return[(180*(o+f)/Math.PI+540)%360-180,180*l/Math.PI]}(s,o,n);return a[0]+=a[0]-s[0]>180?-360:s[0]-a[0]>180?360:0,I(a,r.properties)}function Ys(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=K(t),i=K(e);i[0]+=i[0]-r[0]>180?-360:r[0]-i[0]>180?360:0;var o=function(t,e,n){var r=n=void 0===n?x:Number(n),i=t[1]*Math.PI/180,o=e[1]*Math.PI/180,s=o-i,a=Math.abs(e[0]-t[0])*Math.PI/180;a>Math.PI&&(a-=2*Math.PI);var u=Math.log(Math.tan(o/2+Math.PI/4)/Math.tan(i/2+Math.PI/4)),l=Math.abs(u)>1e-11?s/u:Math.cos(i);return Math.sqrt(s*s+l*l*a*a)*r}(r,i);return j(o,"meters",n.units)}function zs(t,e,n){if(!Z(n=n||{}))throw new Error("options is invalid");var r=n.pivot,i=n.mutate;if(!t)throw new Error("geojson is required");if(null==e||isNaN(e))throw new Error("angle is required");if(0===e)return t;var o=null!=r?r:gi(t);return!1!==i&&void 0!==i||(t=Ai(t)),ct(t,(function(t){var n=lt(o,t)+e,r=Ys(o,t),i=Q(Bs(o,r,n));t[0]=i[0],t[1]=i[1]})),t}function js(t,e,n,r){var i=(r=r||{}).steps||64,o=r.units||"kilometers",s=r.angle||0,a=r.pivot||t,u=r.properties||{};if(!t)throw new Error("center is required");if(!e)throw new Error("xSemiAxis is required");if(!n)throw new Error("ySemiAxis is required");if(!Z(r))throw new Error("options must be an object");if(!U(i))throw new Error("steps must be a number");if(!U(s))throw new Error("angle must be a number");var l=K(t);if("degrees"!==o){var h=Bs(t,e,90,{units:o}),c=Bs(t,n,0,{units:o});e=K(h)[0]-l[0],n=K(c)[1]-l[1]}for(var f=[],g=0;g<i;g+=1){var p=-360*g/i,v=e*n/Math.sqrt(Math.pow(n,2)+Math.pow(e,2)*Math.pow(Xs(p),2)),d=e*n/Math.sqrt(Math.pow(e,2)+Math.pow(n,2)/Math.pow(Xs(p),2));if(p<-90&&p>=-270&&(v=-v),p<-180&&p>=-360&&(d=-d),"degrees"===o){var y=z(s),m=v*Math.cos(y)+d*Math.sin(y),_=d*Math.cos(y)-v*Math.sin(y);v=m,d=_}f.push([v+l[0],d+l[1]])}return f.push(f[0]),"degrees"===o?S([f],u):zs(S([f],u),s,{pivot:a})}function Xs(t){var e=t*Math.PI/180;return Math.tan(e)}function Us(t){return Vt(Rt(t))}function Zs(t){var e=[];return"FeatureCollection"===t.type?vt(t,(function(t){ct(t,(function(n){e.push(I(n,t.properties))}))})):"Feature"===t.type?ct(t,(function(n){e.push(I(n,t.properties))})):ct(t,(function(t){e.push(I(t))})),C(e)}var Hs=Math.PI/180,Ws=180/Math.PI,Js=function(t,e){this.lon=t,this.lat=e,this.x=Hs*t,this.y=Hs*e};Js.prototype.view=function(){return String(this.lon).slice(0,4)+","+String(this.lat).slice(0,4)},Js.prototype.antipode=function(){var t=-1*this.lat,e=this.lon<0?180+this.lon:-1*(180-this.lon);return new Js(e,t)};var Ks=function(){this.coords=[],this.length=0};Ks.prototype.move_to=function(t){this.length++,this.coords.push(t)};var Qs=function(t){this.properties=t||{},this.geometries=[]};Qs.prototype.json=function(){if(this.geometries.length<=0)return{geometry:{type:"LineString",coordinates:null},type:"Feature",properties:this.properties};if(1===this.geometries.length)return{geometry:{type:"LineString",coordinates:this.geometries[0].coords},type:"Feature",properties:this.properties};for(var t=[],e=0;e<this.geometries.length;e++)t.push(this.geometries[e].coords);return{geometry:{type:"MultiLineString",coordinates:t},type:"Feature",properties:this.properties}},Qs.prototype.wkt=function(){for(var t="",e="LINESTRING(",n=function(t){e+=t[0]+" "+t[1]+","},r=0;r<this.geometries.length;r++){if(0===this.geometries[r].coords.length)return"LINESTRING(empty)";this.geometries[r].coords.forEach(n),t+=e.substring(0,e.length-1)+")"}return t};var $s=function(t,e,n){if(!t||void 0===t.x||void 0===t.y)throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");if(!e||void 0===e.x||void 0===e.y)throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");this.start=new Js(t.x,t.y),this.end=new Js(e.x,e.y),this.properties=n||{};var r=this.start.x-this.end.x,i=this.start.y-this.end.y,o=Math.pow(Math.sin(i/2),2)+Math.cos(this.start.y)*Math.cos(this.end.y)*Math.pow(Math.sin(r/2),2);if(this.g=2*Math.asin(Math.sqrt(o)),this.g===Math.PI)throw new Error("it appears "+t.view()+" and "+e.view()+" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");if(isNaN(this.g))throw new Error("could not calculate great circle between "+t+" and "+e)};
        /*!
        * Copyright (c) 2019, Dane Springmeyer
        *
        * Redistribution and use in source and binary forms, with or without
        * modification, are permitted provided that the following conditions are
        * met:
        *
        *     * Redistributions of source code must retain the above copyright
        *       notice, this list of conditions and the following disclaimer.
        *     * Redistributions in binary form must reproduce the above copyright
        *       notice, this list of conditions and the following disclaimer in
        *       the documentation and/or other materials provided with the
        *       distribution.
        *
        * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
        * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
        * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
        * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
        * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
        * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
        * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
        * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
        * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        */
        function ta(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=[];if(mt(t,(function(t){n.push(t.coordinates)})),n.length<2)throw new Error("Must specify at least 2 geometries");var r=Rs.apply(Fs,[n[0]].concat(d(n.slice(1))));return 0===r.length?null:1===r.length?S(r[0],e.properties):R(r,e.properties)}function ea(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=JSON.stringify(n.properties||{}),i=v(t,4),o=i[0],s=i[1],a=i[2],u=i[3],l=(s+u)/2,h=(o+a)/2,c=2*e/ut([o,l],[a,l],n)*(a-o),f=2*e/ut([h,s],[h,u],n)*(u-s),g=c/2,p=2*g,d=Math.sqrt(3)/2*f,y=a-o,m=u-s,_=3/4*p,x=d,E=(y-p)/(p-g/2),k=Math.floor(E),b=(k*_-g/2-y)/2-g/2+_/2,w=Math.floor((m-d)/d),I=(m-w*d)/2,N=w*d-m>d/2;N&&(I-=d/4);for(var S=[],M=[],L=0;L<6;L++){var P=2*Math.PI/6*L;S.push(Math.cos(P)),M.push(Math.sin(P))}for(var T=[],O=0;O<=k;O++)for(var R=0;R<=w;R++){var A=O%2==1;if((0!==R||!A)&&(0!==R||!N)){var D=O*_+o-b,F=R*x+s+I;if(A&&(F-=d/2),!0===n.triangles)ra([D,F],c/2,f/2,JSON.parse(r),S,M).forEach((function(t){n.mask?ta(C([n.mask,t]))&&T.push(t):T.push(t)}));else{var q=na([D,F],c/2,f/2,JSON.parse(r),S,M);n.mask?ta(C([n.mask,q]))&&T.push(q):T.push(q)}}}return C(T)}function na(t,e,n,r,i,o){for(var s=[],a=0;a<6;a++){var u=t[0]+e*i[a],l=t[1]+n*o[a];s.push([u,l])}return s.push(s[0].slice()),S([s],r)}function ra(t,e,n,r,i,o){for(var s=[],a=0;a<6;a++){var u=[];u.push(t),u.push([t[0]+e*i[a],t[1]+n*o[a]]),u.push([t[0]+e*i[(a+1)%6],t[1]+n*o[(a+1)%6]]),u.push(t),s.push(S([u],r))}return s}function ia(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};n.mask&&!n.units&&(n.units="kilometers");for(var r=[],i=t[0],o=t[1],s=t[2],a=t[3],u=e/ut([i,o],[s,o],n)*(s-i),l=e/ut([i,o],[i,a],n)*(a-o),h=s-i,c=a-o,f=Math.floor(h/u),g=(c-Math.floor(c/l)*l)/2,p=i+(h-f*u)/2;p<=s;){for(var v=o+g;v<=a;){var d=I([p,v],n.properties);n.mask?Cn(d,n.mask)&&r.push(d):r.push(d),v+=l}p+=u}return C(r)}function oa(t,e,n){for(var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=[],o=t[0],s=t[1],a=t[2],u=t[3],l=a-o,h=j(e,r.units,"degrees"),c=u-s,f=j(n,r.units,"degrees"),g=Math.floor(Math.abs(l)/h),p=Math.floor(Math.abs(c)/f),v=(c-p*f)/2,d=o+(l-g*h)/2,y=0;y<g;y++){for(var m=s+v,_=0;_<p;_++){var x=S([[[d,m],[d,m+f],[d+h,m+f],[d+h,m],[d,m]]],r.properties);r.mask?Oe(r.mask,x)&&i.push(x):i.push(x),m+=f}d+=h}return C(i)}function sa(t,e){return oa(t,e,e,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}function aa(t,e){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=[],i=e/ut([t[0],t[1]],[t[2],t[1]],n)*(t[2]-t[0]),o=e/ut([t[0],t[1]],[t[0],t[3]],n)*(t[3]-t[1]),s=0,a=t[0];a<=t[2];){for(var u=0,l=t[1];l<=t[3];){var h=null,c=null;s%2==0&&u%2==0?(h=S([[[a,l],[a,l+o],[a+i,l],[a,l]]],n.properties),c=S([[[a,l+o],[a+i,l+o],[a+i,l],[a,l+o]]],n.properties)):s%2==0&&u%2==1?(h=S([[[a,l],[a+i,l+o],[a+i,l],[a,l]]],n.properties),c=S([[[a,l],[a,l+o],[a+i,l+o],[a,l]]],n.properties)):u%2==0&&s%2==1?(h=S([[[a,l],[a,l+o],[a+i,l+o],[a,l]]],n.properties),c=S([[[a,l],[a+i,l+o],[a+i,l],[a,l]]],n.properties)):u%2==1&&s%2==1&&(h=S([[[a,l],[a,l+o],[a+i,l],[a,l]]],n.properties),c=S([[[a,l+o],[a+i,l+o],[a+i,l],[a,l+o]]],n.properties)),n.mask?(ta(C([n.mask,h]))&&r.push(h),ta(C([n.mask,c]))&&r.push(c)):(r.push(h),r.push(c)),l+=o,u++}s++,a+=i}return C(r)}
        /*!
        * MarchingSquaresJS
        * version 1.3.3
        * https://github.com/RaumZeit/MarchingSquares.js
        *
        * @license GNU Affero General Public License.
        * Copyright (c) 2015-2019 Ronny Lorenz <ronny@tbi.univie.ac.at>
        */
        function ua(t,e,n){return t<e?(n-t)/(e-t):(t-n)/(t-e)}function la(t,e,n,r){var i;return n>r&&(i=n,n=r,r=i),t<e?t<n?(n-t)/(e-t):(r-t)/(e-t):t>r?(t-r)/(t-e):(t-n)/(t-e)}function ha(t,e,n,r){return t<e?(n-t)/(e-t):(t-r)/(t-e)}function ca(t,e,n,r){return t<e?(r-t)/(e-t):(t-n)/(t-e)}function fa(){this.successCallback=null,this.verbose=!1,this.polygons=!1,this.polygons_full=!1,this.linearRing=!0,this.noQuadTree=!1,this.noFrame=!1}function ga(t,e,n,r){var i=[];return t.polygons.forEach((function(t){t.forEach((function(t){t[0]+=e,t[1]+=n})),r.linearRing&&t.push(t[0]),i.push(t)})),i}function pa(t,e,n,r){return 0===n?(t+=1,e+=r[0][1]):1===n?t+=r[0][0]:2===n?e+=r[0][1]:3===n&&(t+=r[0][0],e+=1),[t,e]}function va(t,e,n){return 0===n?t++:1===n||(2===n?e++:3===n&&(t++,e++)),[t,e]}function da(t,e,n,r,i){var o=r,s=i,a=0,u=0;if(this.x=e,this.y=n,this.lowerBound=null,this.upperBound=null,this.childA=null,this.childB=null,this.childC=null,this.childD=null,1===r&&1===i)this.lowerBound=Math.min(t[n][e],t[n][e+1],t[n+1][e+1],t[n+1][e]),this.upperBound=Math.max(t[n][e],t[n][e+1],t[n+1][e+1],t[n+1][e]);else{if(r>1){for(;0!==o;)o>>=1,a++;r===1<<a-1&&a--,o=1<<a-1}if(i>1){for(;0!==s;)s>>=1,u++;i===1<<u-1&&u--,s=1<<u-1}this.childA=new da(t,e,n,o,s),this.lowerBound=this.childA.lowerBound,this.upperBound=this.childA.upperBound,r-o>0&&(this.childB=new da(t,e+o,n,r-o,s),this.lowerBound=Math.min(this.lowerBound,this.childB.lowerBound),this.upperBound=Math.max(this.upperBound,this.childB.upperBound),i-s>0&&(this.childC=new da(t,e+o,n+s,r-o,i-s),this.lowerBound=Math.min(this.lowerBound,this.childC.lowerBound),this.upperBound=Math.max(this.upperBound,this.childC.upperBound))),i-s>0&&(this.childD=new da(t,e,n+s,o,i-s),this.lowerBound=Math.min(this.lowerBound,this.childD.lowerBound),this.upperBound=Math.max(this.upperBound,this.childD.upperBound))}}function ya(t){var e,n;if(!t)throw new Error("data is required");if(!Array.isArray(t)||!Array.isArray(t[0]))throw new Error("data must be scalar field, i.e. array of arrays");if(t.length<2)throw new Error("data must contain at least two rows");if((n=t[0].length)<2)throw new Error("data must contain at least two columns");for(e=1;e<t.length;e++){if(!Array.isArray(t[e]))throw new Error("Row "+e+" is not an array");if(t[e].length!=n)throw new Error("unequal row lengths detected, please provide a regular grid")}this.data=t,this.root=new da(t,0,0,t[0].length-1,t.length-1)}function ma(t,e,n){var r,i,o,s=!1,a=!1,u=null,l=null,h=null,c=null,f=null,g=[];if(!t)throw new Error("data is required");if(null==e)throw new Error("threshold is required");if(n&&"object"!==m(n))throw new Error("options must be an object");if(r=function(t){var e,n,r,i,o;for(i=new fa,t=t||{},o=Object.keys(i),e=0;e<o.length;e++)null!=(r=t[n=o[e]])&&(i[n]=r);return i.polygons_full=!i.polygons,i.interpolate=ua,i}(n),t instanceof ya)u=t,l=t.root,h=t.data,r.noQuadTree||(s=!0);else{if(!Array.isArray(t)||!Array.isArray(t[0]))throw new Error("input is neither array of arrays nor object retrieved from 'QuadTree()'");h=t}if(Array.isArray(e)){for(a=!0,r.noQuadTree||(s=!0),i=0;i<e.length;i++)if(isNaN(+e[i]))throw new Error("threshold["+i+"] is not a number")}else{if(isNaN(+e))throw new Error("threshold must be a number or array of numbers");e=[e]}return s&&!l&&(u=new ya(h),l=u.root,h=u.data),r.verbose&&(r.polygons?console.log("MarchingSquaresJS-isoLines: returning single lines (polygons) for each grid cell"):console.log("MarchingSquaresJS-isoLines: returning line paths (polygons) for entire data grid"),a&&console.log("MarchingSquaresJS-isoLines: multiple lines requested, returning array of line paths instead of lines for a single threshold")),e.forEach((function(t,e){if(f=[],r.threshold=t,r.verbose&&console.log("MarchingSquaresJS-isoLines: computing iso lines for threshold "+t),r.polygons)if(s)l.cellsBelowThreshold(r.threshold,!0).forEach((function(t){f=f.concat(ga(_a(h,t.x,t.y,r),t.x,t.y,r))}));else for(o=0;o<h.length-1;++o)for(e=0;e<h[0].length-1;++e)f=f.concat(ga(_a(h,e,o,r),e,o,r));else{for(c=[],e=0;e<h[0].length-1;++e)c[e]=[];if(s)l.cellsBelowThreshold(r.threshold,!1).forEach((function(t){c[t.x][t.y]=_a(h,t.x,t.y,r)}));else for(e=0;e<h[0].length-1;++e)for(o=0;o<h.length-1;++o)c[e][o]=_a(h,e,o,r);f=function(t,e,n){var r,i,o,s,a,u,l,h,c,f,g,p,v,d,y,_=[],x=t.length-1,E=t[0].length-1,k=["right","bottom","left","top"],b=[0,-1,0,1],w=[-1,0,1,0],I={bottom:1,left:2,top:3,right:0};return n.noFrame||function(t,e){var n,r,i,o,s;for(n=!0,r=t[0].length,i=t.length,s=0;s<i;s++)if(t[s][0]>=e||t[s][r-1]>=e){n=!1;break}if(n&&(t[i-1][0]>=e||t[i-1][r-1]>=e)&&(n=!1),n)for(o=0;o<r-1;o++)if(t[0][o]>=e||t[i-1][o]>e){n=!1;break}return n}(t,n.threshold)&&(n.linearRing?_.push([[0,0],[0,x],[E,x],[E,0],[0,0]]):_.push([[0,0],[0,x],[E,x],[E,0]])),e.forEach((function(t,N){t.forEach((function(t,S){for(r=null,i=0;i<4;i++)if(r=k[i],"object"===m(t.edges[r])){for(a=[],o=t.edges[r],u=r,l=N,h=S,c=!1,f=[N+o.path[0][0],S+o.path[0][1]],a.push(f);!c&&"object"===m((s=e[l][h]).edges[u]);)if(o=s.edges[u],delete s.edges[u],(g=o.path[1])[0]+=l,g[1]+=h,a.push(g),u=o.move.enter,l+=o.move.x,h+=o.move.y,void 0===e[l]||void 0===e[l][h]){if(!n.linearRing)break;if(p=0,v=0,l===E?(l--,p=0):l<0?(l++,p=2):h===x?(h--,p=3):h<0&&(h++,p=1),l===N&&h===S&&p===I[r]){c=!0,u=r;break}for(;;){if(d=!1,v>4)throw new Error("Direction change counter overflow! This should never happen!");if(void 0!==e[l]&&void 0!==e[l][h]&&(s=e[l][h],y=k[p],"object"===m(s.edges[y]))){o=s.edges[y],a.push(pa(l,h,p,o.path)),u=y,d=!0;break}if(d)break;if(a.push(va(l,h,p)),h+=w[p],void 0!==e[l+=b[p]]&&void 0!==e[l][h]||(0===p&&h<0||1===p&&l<0||2===p&&h===x||3===p&&l===E)&&(l-=b[p],h-=w[p],p=(p+1)%4,v++),l===N&&h===S&&p===I[r]){c=!0,u=r;break}}}!n.linearRing||a[a.length-1][0]===f[0]&&a[a.length-1][1]===f[1]||a.push(f),_.push(a)}}))})),_}(h,c,r)}a?g.push(f):g=f,"function"==typeof r.successCallback&&r.successCallback(g,t)})),g}function _a(t,e,n,r){var i,o,s,a,u,l,h=0,c=t[n+1][e],f=t[n+1][e+1],g=t[n][e+1],p=t[n][e],v=r.threshold;if(!(isNaN(p)||isNaN(g)||isNaN(f)||isNaN(c))){switch(h|=c>=v?8:0,h|=f>=v?4:0,h|=g>=v?2:0,l={cval:h=+(h|=p>=v?1:0),polygons:[],edges:{},x0:p,x1:g,x2:f,x3:c},h){case 0:r.polygons&&l.polygons.push([[0,0],[0,1],[1,1],[1,0]]);break;case 15:break;case 14:i=r.interpolate(p,c,v),a=r.interpolate(p,g,v),r.polygons_full&&(l.edges.left={path:[[0,i],[a,0]],move:{x:0,y:-1,enter:"top"}}),r.polygons&&l.polygons.push([[0,0],[0,i],[a,0]]);break;case 13:a=r.interpolate(p,g,v),o=r.interpolate(g,f,v),r.polygons_full&&(l.edges.bottom={path:[[a,0],[1,o]],move:{x:1,y:0,enter:"left"}}),r.polygons&&l.polygons.push([[a,0],[1,o],[1,0]]);break;case 11:o=r.interpolate(g,f,v),s=r.interpolate(c,f,v),r.polygons_full&&(l.edges.right={path:[[1,o],[s,1]],move:{x:0,y:1,enter:"bottom"}}),r.polygons&&l.polygons.push([[1,o],[s,1],[1,1]]);break;case 7:i=r.interpolate(p,c,v),s=r.interpolate(c,f,v),r.polygons_full&&(l.edges.top={path:[[s,1],[0,i]],move:{x:-1,y:0,enter:"right"}}),r.polygons&&l.polygons.push([[s,1],[0,i],[0,1]]);break;case 1:i=r.interpolate(p,c,v),a=r.interpolate(p,g,v),r.polygons_full&&(l.edges.bottom={path:[[a,0],[0,i]],move:{x:-1,y:0,enter:"right"}}),r.polygons&&l.polygons.push([[a,0],[0,i],[0,1],[1,1],[1,0]]);break;case 2:a=r.interpolate(p,g,v),o=r.interpolate(g,f,v),r.polygons_full&&(l.edges.right={path:[[1,o],[a,0]],move:{x:0,y:-1,enter:"top"}}),r.polygons&&l.polygons.push([[0,0],[0,1],[1,1],[1,o],[a,0]]);break;case 4:o=r.interpolate(g,f,v),s=r.interpolate(c,f,v),r.polygons_full&&(l.edges.top={path:[[s,1],[1,o]],move:{x:1,y:0,enter:"left"}}),r.polygons&&l.polygons.push([[0,0],[0,1],[s,1],[1,o],[1,0]]);break;case 8:i=r.interpolate(p,c,v),s=r.interpolate(c,f,v),r.polygons_full&&(l.edges.left={path:[[0,i],[s,1]],move:{x:0,y:1,enter:"bottom"}}),r.polygons&&l.polygons.push([[0,0],[0,i],[s,1],[1,1],[1,0]]);break;case 12:i=r.interpolate(p,c,v),o=r.interpolate(g,f,v),r.polygons_full&&(l.edges.left={path:[[0,i],[1,o]],move:{x:1,y:0,enter:"left"}}),r.polygons&&l.polygons.push([[0,0],[0,i],[1,o],[1,0]]);break;case 9:a=r.interpolate(p,g,v),s=r.interpolate(c,f,v),r.polygons_full&&(l.edges.bottom={path:[[a,0],[s,1]],move:{x:0,y:1,enter:"bottom"}}),r.polygons&&l.polygons.push([[a,0],[s,1],[1,1],[1,0]]);break;case 3:i=r.interpolate(p,c,v),o=r.interpolate(g,f,v),r.polygons_full&&(l.edges.right={path:[[1,o],[0,i]],move:{x:-1,y:0,enter:"right"}}),r.polygons&&l.polygons.push([[0,i],[0,1],[1,1],[1,o]]);break;case 6:a=r.interpolate(p,g,v),s=r.interpolate(c,f,v),r.polygons_full&&(l.edges.top={path:[[s,1],[a,0]],move:{x:0,y:-1,enter:"top"}}),r.polygons&&l.polygons.push([[0,0],[0,1],[s,1],[a,0]]);break;case 10:i=r.interpolate(p,c,v),o=r.interpolate(g,f,v),a=r.interpolate(p,g,v),s=r.interpolate(c,f,v),u=(p+g+f+c)/4,r.polygons_full&&(u<v?(l.edges.left={path:[[0,i],[s,1]],move:{x:0,y:1,enter:"bottom"}},l.edges.right={path:[[1,o],[a,0]],move:{x:0,y:-1,enter:"top"}}):(l.edges.right={path:[[1,o],[s,1]],move:{x:0,y:1,enter:"bottom"}},l.edges.left={path:[[0,i],[a,0]],move:{x:0,y:-1,enter:"top"}})),r.polygons&&(u<v?l.polygons.push([[0,0],[0,i],[s,1],[1,1],[1,o],[a,0]]):(l.polygons.push([[0,0],[0,i],[a,0]]),l.polygons.push([[s,1],[1,1],[1,o]])));break;case 5:i=r.interpolate(p,c,v),o=r.interpolate(g,f,v),a=r.interpolate(p,g,v),s=r.interpolate(c,f,v),u=(p+g+f+c)/4,r.polygons_full&&(u<v?(l.edges.bottom={path:[[a,0],[0,i]],move:{x:-1,y:0,enter:"right"}},l.edges.top={path:[[s,1],[1,o]],move:{x:1,y:0,enter:"left"}}):(l.edges.top={path:[[s,1],[0,i]],move:{x:-1,y:0,enter:"right"}},l.edges.bottom={path:[[a,0],[1,o]],move:{x:1,y:0,enter:"left"}})),r.polygons&&(u<v?l.polygons.push([[0,i],[0,1],[s,1],[1,o],[1,0],[a,0]]):(l.polygons.push([[0,i],[0,1],[s,1]]),l.polygons.push([[a,0],[1,o],[1,0]])))}return l}}$s.prototype.interpolate=function(t){var e=Math.sin((1-t)*this.g)/Math.sin(this.g),n=Math.sin(t*this.g)/Math.sin(this.g),r=e*Math.cos(this.start.y)*Math.cos(this.start.x)+n*Math.cos(this.end.y)*Math.cos(this.end.x),i=e*Math.cos(this.start.y)*Math.sin(this.start.x)+n*Math.cos(this.end.y)*Math.sin(this.end.x),o=e*Math.sin(this.start.y)+n*Math.sin(this.end.y),s=Ws*Math.atan2(o,Math.sqrt(Math.pow(r,2)+Math.pow(i,2)));return[Ws*Math.atan2(i,r),s]},$s.prototype.Arc=function(t,e){var n=[];if(!t||t<=2)n.push([this.start.lon,this.start.lat]),n.push([this.end.lon,this.end.lat]);else for(var r=1/(t-1),i=0;i<t;++i){var o=r*i,s=this.interpolate(o);n.push(s)}for(var a=!1,u=0,l=e&&e.offset?e.offset:10,h=180-l,c=-180+l,f=360-l,g=1;g<n.length;++g){var p=n[g-1][0],v=n[g][0],d=Math.abs(v-p);d>f&&(v>h&&p<c||p>h&&v<c)?a=!0:d>u&&(u=d)}var y=[];if(a&&u<l){var m=[];y.push(m);for(var _=0;_<n.length;++_){var x=parseFloat(n[_][0]);if(_>0&&Math.abs(x-n[_-1][0])>f){var E=parseFloat(n[_-1][0]),k=parseFloat(n[_-1][1]),b=parseFloat(n[_][0]),w=parseFloat(n[_][1]);if(E>-180&&E<c&&180===b&&_+1<n.length&&n[_-1][0]>-180&&n[_-1][0]<c){m.push([-180,n[_][1]]),_++,m.push([n[_][0],n[_][1]]);continue}if(E>h&&E<180&&-180===b&&_+1<n.length&&n[_-1][0]>h&&n[_-1][0]<180){m.push([180,n[_][1]]),_++,m.push([n[_][0],n[_][1]]);continue}if(E<c&&b>h){var I=E;E=b,b=I;var N=k;k=w,w=N}if(E>h&&b<c&&(b+=360),E<=180&&b>=180&&E<b){var S=(180-E)/(b-E),M=S*w+(1-S)*k;m.push([n[_-1][0]>h?180:-180,M]),(m=[]).push([n[_-1][0]>h?-180:180,M]),y.push(m)}else m=[],y.push(m);m.push([x,n[_][1]])}else m.push([n[_][0],n[_][1]])}}else{var L=[];y.push(L);for(var P=0;P<n.length;++P)L.push([n[P][0],n[P][1]])}for(var C=new Qs(this.properties),T=0;T<y.length;++T){var O=new Ks;C.geometries.push(O);for(var R=y[T],A=0;A<R.length;++A)O.move_to(R[A])}return C},da.prototype.cellsInBand=function(t,e,n){var r=[];return n=void 0===n||n,this.lowerBound>e||this.upperBound<t||(this.childA||this.childB||this.childC||this.childD?(this.childA&&(r=r.concat(this.childA.cellsInBand(t,e,n))),this.childB&&(r=r.concat(this.childB.cellsInBand(t,e,n))),this.childD&&(r=r.concat(this.childD.cellsInBand(t,e,n))),this.childC&&(r=r.concat(this.childC.cellsInBand(t,e,n)))):(n||this.lowerBound<=t||this.upperBound>=e)&&r.push({x:this.x,y:this.y})),r},da.prototype.cellsBelowThreshold=function(t,e){var n=[];return e=void 0===e||e,this.lowerBound>t||(this.childA||this.childB||this.childC||this.childD?(this.childA&&(n=n.concat(this.childA.cellsBelowThreshold(t,e))),this.childB&&(n=n.concat(this.childB.cellsBelowThreshold(t,e))),this.childD&&(n=n.concat(this.childD.cellsBelowThreshold(t,e))),this.childC&&(n=n.concat(this.childC.cellsBelowThreshold(t,e)))):(e||this.upperBound>=t)&&n.push({x:this.x,y:this.y})),n};var xa={square:function(t,e,n,r,i,o){o.polygons&&t.polygons.push([[0,0],[0,1],[1,1],[1,0]])},triangle_bl:function(t,e,n,r,i,o){var s=o.interpolate(e,n,o.minV,o.maxV),a=o.interpolate(e,i,o.minV,o.maxV);o.polygons_full&&(t.edges.lb={path:[[0,a],[s,0]],move:{x:0,y:-1,enter:"tl"}}),o.polygons&&t.polygons.push([[0,a],[s,0],[0,0]])},triangle_br:function(t,e,n,r,i,o){var s=o.interpolate(e,n,o.minV,o.maxV),a=o.interpolate(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.br={path:[[s,0],[1,a]],move:{x:1,y:0,enter:"lb"}}),o.polygons&&t.polygons.push([[s,0],[1,a],[1,0]])},triangle_tr:function(t,e,n,r,i,o){var s=o.interpolate(n,r,o.minV,o.maxV),a=o.interpolate(i,r,o.minV,o.maxV);o.polygons_full&&(t.edges.rt={path:[[1,s],[a,1]],move:{x:0,y:1,enter:"br"}}),o.polygons&&t.polygons.push([[1,s],[a,1],[1,1]])},triangle_tl:function(t,e,n,r,i,o){var s=o.interpolate(i,r,o.minV,o.maxV),a=o.interpolate(e,i,o.minV,o.maxV);o.polygons_full&&(t.edges.tl={path:[[s,1],[0,a]],move:{x:-1,y:0,enter:"rt"}}),o.polygons&&t.polygons.push([[0,a],[0,1],[s,1]])},tetragon_t:function(t,e,n,r,i,o){var s=o.interpolate(n,r,o.minV,o.maxV),a=o.interpolate(e,i,o.minV,o.maxV);o.polygons_full&&(t.edges.rt={path:[[1,s],[0,a]],move:{x:-1,y:0,enter:"rt"}}),o.polygons&&t.polygons.push([[0,a],[0,1],[1,1],[1,s]])},tetragon_r:function(t,e,n,r,i,o){var s=o.interpolate(e,n,o.minV,o.maxV),a=o.interpolate(i,r,o.minV,o.maxV);o.polygons_full&&(t.edges.br={path:[[s,0],[a,1]],move:{x:0,y:1,enter:"br"}}),o.polygons&&t.polygons.push([[s,0],[a,1],[1,1],[1,0]])},tetragon_b:function(t,e,n,r,i,o){var s=o.interpolate(e,i,o.minV,o.maxV),a=o.interpolate(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.lb={path:[[0,s],[1,a]],move:{x:1,y:0,enter:"lb"}}),o.polygons&&t.polygons.push([[0,0],[0,s],[1,a],[1,0]])},tetragon_l:function(t,e,n,r,i,o){var s=o.interpolate(i,r,o.minV,o.maxV),a=o.interpolate(e,n,o.minV,o.maxV);o.polygons_full&&(t.edges.tl={path:[[s,1],[a,0]],move:{x:0,y:-1,enter:"tl"}}),o.polygons&&t.polygons.push([[0,0],[0,1],[s,1],[a,0]])},tetragon_bl:function(t,e,n,r,i,o){var s=o.interpolate_a(e,n,o.minV,o.maxV),a=o.interpolate_b(e,n,o.minV,o.maxV),u=o.interpolate_a(e,i,o.minV,o.maxV),l=o.interpolate_b(e,i,o.minV,o.maxV);o.polygons_full&&(t.edges.bl={path:[[s,0],[0,u]],move:{x:-1,y:0,enter:"rb"}},t.edges.lt={path:[[0,l],[a,0]],move:{x:0,y:-1,enter:"tr"}}),o.polygons&&t.polygons.push([[s,0],[0,u],[0,l],[a,0]])},tetragon_br:function(t,e,n,r,i,o){var s=o.interpolate_a(e,n,o.minV,o.maxV),a=o.interpolate_b(e,n,o.minV,o.maxV),u=o.interpolate_a(n,r,o.minV,o.maxV),l=o.interpolate_b(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.bl={path:[[s,0],[1,l]],move:{x:1,y:0,enter:"lt"}},t.edges.rb={path:[[1,u],[a,0]],move:{x:0,y:-1,enter:"tr"}}),o.polygons&&t.polygons.push([[s,0],[1,l],[1,u],[a,0]])},tetragon_tr:function(t,e,n,r,i,o){var s=o.interpolate_a(i,r,o.minV,o.maxV),a=o.interpolate_b(i,r,o.minV,o.maxV),u=o.interpolate_b(n,r,o.minV,o.maxV),l=o.interpolate_a(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.rb={path:[[1,l],[s,1]],move:{x:0,y:1,enter:"bl"}},t.edges.tr={path:[[a,1],[1,u]],move:{x:1,y:0,enter:"lt"}}),o.polygons&&t.polygons.push([[1,l],[s,1],[a,1],[1,u]])},tetragon_tl:function(t,e,n,r,i,o){var s=o.interpolate_a(i,r,o.minV,o.maxV),a=o.interpolate_b(i,r,o.minV,o.maxV),u=o.interpolate_b(e,i,o.minV,o.maxV),l=o.interpolate_a(e,i,o.minV,o.maxV);o.polygons_full&&(t.edges.tr={path:[[a,1],[0,l]],move:{x:-1,y:0,enter:"rb"}},t.edges.lt={path:[[0,u],[s,1]],move:{x:0,y:1,enter:"bl"}}),o.polygons&&t.polygons.push([[a,1],[0,l],[0,u],[s,1]])},tetragon_lr:function(t,e,n,r,i,o){var s=o.interpolate_a(e,i,o.minV,o.maxV),a=o.interpolate_b(e,i,o.minV,o.maxV),u=o.interpolate_b(n,r,o.minV,o.maxV),l=o.interpolate_a(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.lt={path:[[0,a],[1,u]],move:{x:1,y:0,enter:"lt"}},t.edges.rb={path:[[1,l],[0,s]],move:{x:-1,y:0,enter:"rb"}}),o.polygons&&t.polygons.push([[0,s],[0,a],[1,u],[1,l]])},tetragon_tb:function(t,e,n,r,i,o){var s=o.interpolate_a(i,r,o.minV,o.maxV),a=o.interpolate_b(i,r,o.minV,o.maxV),u=o.interpolate_b(e,n,o.minV,o.maxV),l=o.interpolate_a(e,n,o.minV,o.maxV);o.polygons_full&&(t.edges.tr={path:[[a,1],[u,0]],move:{x:0,y:-1,enter:"tr"}},t.edges.bl={path:[[l,0],[s,1]],move:{x:0,y:1,enter:"bl"}}),o.polygons&&t.polygons.push([[l,0],[s,1],[a,1],[u,0]])},pentagon_tr:function(t,e,n,r,i,o){var s=o.interpolate(i,r,o.minV,o.maxV),a=o.interpolate(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.tl={path:[[s,1],[1,a]],move:{x:1,y:0,enter:"lb"}}),o.polygons&&t.polygons.push([[0,0],[0,1],[s,1],[1,a],[1,0]])},pentagon_tl:function(t,e,n,r,i,o){var s=o.interpolate(e,i,o.minV,o.maxV),a=o.interpolate(i,r,o.minV,o.maxV);o.polygons_full&&(t.edges.lb={path:[[0,s],[a,1]],move:{x:0,y:1,enter:"br"}}),o.polygons&&t.polygons.push([[0,0],[0,s],[a,1],[1,1],[1,0]])},pentagon_br:function(t,e,n,r,i,o){var s=o.interpolate(e,n,o.minV,o.maxV),a=o.interpolate(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.rt={path:[[1,a],[s,0]],move:{x:0,y:-1,enter:"tl"}}),o.polygons&&t.polygons.push([[0,0],[0,1],[1,1],[1,a],[s,0]])},pentagon_bl:function(t,e,n,r,i,o){var s=o.interpolate(e,i,o.minV,o.maxV),a=o.interpolate(e,n,o.minV,o.maxV);o.polygons_full&&(t.edges.br={path:[[a,0],[0,s]],move:{x:-1,y:0,enter:"rt"}}),o.polygons&&t.polygons.push([[0,s],[0,1],[1,1],[1,0],[a,0]])},pentagon_tr_rl:function(t,e,n,r,i,o){var s=o.interpolate(e,i,o.minV,o.maxV),a=o.interpolate(i,r,o.minV,o.maxV),u=o.interpolate_b(n,r,o.minV,o.maxV),l=o.interpolate_a(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.tl={path:[[a,1],[1,u]],move:{x:1,y:0,enter:"lt"}},t.edges.rb={path:[[1,l],[0,s]],move:{x:-1,y:0,enter:"rt"}}),o.polygons&&t.polygons.push([[0,s],[0,1],[a,1],[1,u],[1,l]])},pentagon_rb_bt:function(t,e,n,r,i,o){var s=o.interpolate(n,r,o.minV,o.maxV),a=o.interpolate_b(e,n,o.minV,o.maxV),u=o.interpolate_a(e,n,o.minV,o.maxV),l=o.interpolate(i,r,o.minV,o.maxV);o.polygons_full&&(t.edges.rt={path:[[1,s],[a,0]],move:{x:0,y:-1,enter:"tr"}},t.edges.bl={path:[[u,0],[l,1]],move:{x:0,y:1,enter:"br"}}),o.polygons&&t.polygons.push([[l,1],[1,1],[1,s],[a,0],[u,0]])},pentagon_bl_lr:function(t,e,n,r,i,o){var s=o.interpolate(e,n,o.minV,o.maxV),a=o.interpolate_a(e,i,o.minV,o.maxV),u=o.interpolate_b(e,i,o.minV,o.maxV),l=o.interpolate(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.br={path:[[s,0],[0,a]],move:{x:-1,y:0,enter:"rb"}},t.edges.lt={path:[[0,u],[1,l]],move:{x:1,y:0,enter:"lb"}}),o.polygons&&t.polygons.push([[s,0],[0,a],[0,u],[1,l],[1,0]])},pentagon_lt_tb:function(t,e,n,r,i,o){var s=o.interpolate(e,i,o.minV,o.maxV),a=o.interpolate_a(i,r,o.minV,o.maxV),u=o.interpolate_b(i,r,o.minV,o.maxV),l=o.interpolate(e,n,o.minV,o.maxV);o.polygons_full&&(t.edges.lb={path:[[0,s],[a,1]],move:{x:0,y:1,enter:"bl"}},t.edges.tr={path:[[u,1],[l,0]],move:{x:0,y:-1,enter:"tl"}}),o.polygons&&t.polygons.push([[0,0],[0,s],[a,1],[u,1],[l,0]])},pentagon_bl_tb:function(t,e,n,r,i,o){var s=o.interpolate(e,i,o.minV,o.maxV),a=o.interpolate(i,r,o.minV,o.maxV),u=o.interpolate_b(e,n,o.minV,o.maxV),l=o.interpolate_a(e,n,o.minV,o.maxV);o.polygons_full&&(t.edges.bl={path:[[l,0],[0,s]],move:{x:-1,y:0,enter:"rt"}},t.edges.tl={path:[[a,1],[u,0]],move:{x:0,y:-1,enter:"tr"}}),o.polygons&&t.polygons.push([[0,s],[0,1],[a,1],[u,0],[l,0]])},pentagon_lt_rl:function(t,e,n,r,i,o){var s=o.interpolate_a(e,i,o.minV,o.maxV),a=o.interpolate_b(e,i,o.minV,o.maxV),u=o.interpolate(i,r,o.minV,o.maxV),l=o.interpolate(n,i,o.minV,o.maxV);o.polygons_full&&(t.edges.lt={path:[[0,a],[u,1]],move:{x:0,y:1,enter:"br"}},t.edges.rt={path:[[1,l],[0,s]],move:{x:-1,y:0,enter:"rb"}}),o.polygons&&t.polygons.push([[0,s],[0,a],[u,1],[1,1],[1,l]])},pentagon_tr_bt:function(t,e,n,r,i,o){var s=o.interpolate_a(i,r,o.minV,o.maxV),a=o.interpolate_b(i,r,o.minV,o.maxV),u=o.interpolate(n,r,o.minV,o.maxV),l=o.interpolate(e,n,o.minV,o.maxV);o.polygons_full&&(t.edges.br={path:[[l,0],[s,1]],move:{x:0,y:1,enter:"bl"}},t.edges.tr={path:[[a,1],[1,u]],move:{x:1,y:0,enter:"lb"}}),o.polygons&&t.polygons.push([[s,1],[a,1],[1,u],[1,0],[l,0]])},pentagon_rb_lr:function(t,e,n,r,i,o){var s=o.interpolate(e,i,o.minV,o.maxV),a=o.interpolate_b(n,r,o.minV,o.maxV),u=o.interpolate_a(n,r,o.minV,o.maxV),l=o.interpolate(e,n,o.minV,o.maxV);o.polygons_full&&(t.edges.lb={path:[[0,s],[1,a]],move:{x:1,y:0,enter:"lt"}},t.edges.rb={path:[[1,u],[l,0]],move:{x:0,y:-1,enter:"tl"}}),o.polygons&&t.polygons.push([[0,0],[0,s],[1,a],[1,u],[l,0]])},hexagon_lt_tr:function(t,e,n,r,i,o){var s=o.interpolate(e,i,o.minV,o.maxV),a=o.interpolate_a(i,r,o.minV,o.maxV),u=o.interpolate_b(i,r,o.minV,o.maxV),l=o.interpolate(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.lb={path:[[0,s],[a,1]],move:{x:0,y:1,enter:"bl"}},t.edges.tr={path:[[u,1],[1,l]],move:{x:1,y:0,enter:"lb"}}),o.polygons&&t.polygons.push([[0,0],[0,s],[a,1],[u,1],[1,l],[1,0]])},hexagon_bl_lt:function(t,e,n,r,i,o){var s=o.interpolate(e,n,o.minV,o.maxV),a=o.interpolate_a(e,i,o.minV,o.maxV),u=o.interpolate_b(e,i,o.minV,o.maxV),l=o.interpolate(i,r,o.minV,o.maxV);o.polygons_full&&(t.edges.br={path:[[s,0],[0,a]],move:{x:-1,y:0,enter:"rb"}},t.edges.lt={path:[[0,u],[l,1]],move:{x:0,y:1,enter:"br"}}),o.polygons&&t.polygons.push([[s,0],[0,a],[0,u],[l,1],[1,1],[1,0]])},hexagon_bl_rb:function(t,e,n,r,i,o){var s=o.interpolate_a(e,n,o.minV,o.maxV),a=o.interpolate_b(e,n,o.minV,o.maxV),u=o.interpolate(e,i,o.minV,o.maxV),l=o.interpolate(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.bl={path:[[s,0],[0,u]],move:{x:-1,y:0,enter:"rt"}},t.edges.rt={path:[[1,l],[a,0]],move:{x:0,y:-1,enter:"tr"}}),o.polygons&&t.polygons.push([[s,0],[0,u],[0,1],[1,1],[1,l],[a,0]])},hexagon_tr_rb:function(t,e,n,r,i,o){var s=o.interpolate(e,n,o.minV,o.maxV),a=o.interpolate(i,r,o.minV,o.maxV),u=o.interpolate_b(n,r,o.minV,o.maxV),l=o.interpolate_a(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.tl={path:[[a,1],[1,u]],move:{x:1,y:0,enter:"lt"}},t.edges.rb={path:[[1,l],[s,0]],move:{x:0,y:-1,enter:"tl"}}),o.polygons&&t.polygons.push([[0,0],[0,1],[a,1],[1,u],[1,l],[s,0]])},hexagon_lt_rb:function(t,e,n,r,i,o){var s=o.interpolate(e,i,o.minV,o.maxV),a=o.interpolate(i,r,o.minV,o.maxV),u=o.interpolate(n,r,o.minV,o.maxV),l=o.interpolate(e,n,o.minV,o.maxV);o.polygons_full&&(t.edges.lb={path:[[0,s],[a,1]],move:{x:0,y:1,enter:"br"}},t.edges.rt={path:[[1,u],[l,0]],move:{x:0,y:-1,enter:"tl"}}),o.polygons&&t.polygons.push([[0,0],[0,s],[a,1],[1,1],[1,u],[l,0]])},hexagon_bl_tr:function(t,e,n,r,i,o){var s=o.interpolate(e,n,o.minV,o.maxV),a=o.interpolate(e,i,o.minV,o.maxV),u=o.interpolate(i,r,o.minV,o.maxV),l=o.interpolate(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.br={path:[[s,0],[0,a]],move:{x:-1,y:0,enter:"rt"}},t.edges.tl={path:[[u,1],[1,l]],move:{x:1,y:0,enter:"lb"}}),o.polygons&&t.polygons.push([[s,0],[0,a],[0,1],[u,1],[1,l],[1,0]])},heptagon_tr:function(t,e,n,r,i,o){var s=o.interpolate_a(e,n,o.minV,o.maxV),a=o.interpolate_b(e,n,o.minV,o.maxV),u=o.interpolate_a(e,i,o.minV,o.maxV),l=o.interpolate_b(e,i,o.minV,o.maxV),h=o.interpolate(i,r,o.minV,o.maxV),c=o.interpolate(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.bl={path:[[s,0],[0,u]],move:{x:-1,y:0,enter:"rb"}},t.edges.lt={path:[[0,l],[h,1]],move:{x:0,y:1,enter:"br"}},t.edges.rt={path:[[1,c],[a,0]],move:{x:0,y:-1,enter:"tr"}}),o.polygons&&t.polygons.push([[s,0],[0,u],[0,l],[h,1],[1,1],[1,c],[a,0]])},heptagon_bl:function(t,e,n,r,i,o){var s=o.interpolate(e,n,o.minV,o.maxV),a=o.interpolate(e,i,o.minV,o.maxV),u=o.interpolate_a(i,r,o.minV,o.maxV),l=o.interpolate_b(i,r,o.minV,o.maxV),h=o.interpolate_b(n,r,o.minV,o.maxV),c=o.interpolate_a(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.lb={path:[[0,a],[u,1]],move:{x:0,y:1,enter:"bl"}},t.edges.tr={path:[[l,1],[1,h]],move:{x:1,y:0,enter:"lt"}},t.edges.rb={path:[[1,c],[s,0]],move:{x:0,y:-1,enter:"tl"}}),o.polygons&&t.polygons.push([[0,0],[0,a],[u,1],[l,1],[1,h],[1,c],[s,0]])},heptagon_tl:function(t,e,n,r,i,o){var s=o.interpolate_a(e,n,o.minV,o.maxV),a=o.interpolate_b(e,n,o.minV,o.maxV),u=o.interpolate(e,i,o.minV,o.maxV),l=o.interpolate(i,r,o.minV,o.maxV),h=o.interpolate_b(n,r,o.minV,o.maxV),c=o.interpolate_a(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.bl={path:[[s,0],[0,u]],move:{x:-1,y:0,enter:"rt"}},t.edges.tl={path:[[l,1],[1,h]],move:{x:1,y:0,enter:"lt"}},t.edges.rb={path:[[1,c],[a,0]],move:{x:0,y:-1,enter:"tr"}}),o.polygons&&t.polygons.push([[s,0],[0,u],[0,1],[l,1],[1,h],[1,c],[a,0]])},heptagon_br:function(t,e,n,r,i,o){var s=o.interpolate(e,n,o.minV,o.maxV),a=o.interpolate_a(e,i,o.minV,o.maxV),u=o.interpolate_b(e,i,o.minV,o.maxV),l=o.interpolate_a(i,r,o.minV,o.maxV),h=o.interpolate_b(i,r,o.minV,o.maxV),c=o.interpolate(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.br={path:[[s,0],[0,a]],move:{x:-1,y:0,enter:"rb"}},t.edges.lt={path:[[0,u],[l,1]],move:{x:0,y:1,enter:"bl"}},t.edges.tr={path:[[h,1],[1,c]],move:{x:1,y:0,enter:"lb"}}),o.polygons&&t.polygons.push([[s,0],[0,a],[0,u],[l,1],[h,1],[1,c],[1,0]])},octagon:function(t,e,n,r,i,o){var s=o.interpolate_a(e,n,o.minV,o.maxV),a=o.interpolate_b(e,n,o.minV,o.maxV),u=o.interpolate_a(e,i,o.minV,o.maxV),l=o.interpolate_b(e,i,o.minV,o.maxV),h=o.interpolate_a(i,r,o.minV,o.maxV),c=o.interpolate_b(i,r,o.minV,o.maxV),f=o.interpolate_b(n,r,o.minV,o.maxV),g=o.interpolate_a(n,r,o.minV,o.maxV);o.polygons_full&&(t.edges.bl={path:[[s,0],[0,u]],move:{x:-1,y:0,enter:"rb"}},t.edges.lt={path:[[0,l],[h,1]],move:{x:0,y:1,enter:"bl"}},t.edges.tr={path:[[c,1],[1,f]],move:{x:1,y:0,enter:"lt"}},t.edges.rb={path:[[1,g],[a,0]],move:{x:0,y:-1,enter:"tr"}}),o.polygons&&t.polygons.push([[s,0],[0,u],[0,l],[h,1],[c,1],[1,f],[1,g],[a,0]])}};function Ea(t,e,n,r){var i,o,s,a=!1,u=null,l=null,h=null,c=null,f=!1,g=[],p=[],v=[];if(!t)throw new Error("data is required");if(null==e)throw new Error("lowerBound is required");if(null==n)throw new Error("bandWidth is required");if(s=function(t){var e,n,r,i,o;for(i=new fa,t=t||{},o=Object.keys(i),e=0;e<o.length;e++)null!=(r=t[n=o[e]])&&(i[n]=r);return i.polygons_full=!i.polygons,i.interpolate=la,i.interpolate_a=ha,i.interpolate_b=ca,i}(r),t instanceof ya)u=t,l=t.root,h=t.data,s.noQuadTree||(a=!0);else{if(!Array.isArray(t)||!Array.isArray(t[0]))throw new Error("input is neither array of arrays nor object retrieved from 'QuadTree()'");h=t}if(Array.isArray(e)){for(f=!0,s.noQuadTree||(a=!0),i=0;i<e.length;i++)if(isNaN(+e[i]))throw new Error("lowerBound["+i+"] is not a number");if(Array.isArray(n)){if(e.length!==n.length)throw new Error("lowerBound and bandWidth have unequal lengths");for(i=0;i<n.length;i++)if(isNaN(+n[i]))throw new Error("bandWidth["+i+"] is not a number")}else{if(isNaN(+n))throw new Error("bandWidth must be a number");for(g=[],i=0;i<e.length;i++)g.push(n);n=g}}else{if(isNaN(+e))throw new Error("lowerBound must be a number");if(e=[e],isNaN(+n))throw new Error("bandWidth must be a number");n=[n]}return a&&!l&&(u=new ya(h),l=u.root,h=u.data),s.verbose&&(s.polygons?console.log("MarchingSquaresJS-isoBands: returning single polygons for each grid cell"):console.log("MarchingSquaresJS-isoBands: returning polygon paths for entire data grid"),f&&console.log("MarchingSquaresJS-isoBands: multiple bands requested, returning array of band polygons instead of polygons for a single band")),e.forEach((function(t,e){if(p=[],s.minV=t,s.maxV=t+n[e],s.verbose&&console.log("MarchingSquaresJS-isoBands: computing isobands for ["+t+":"+(t+n[e])+"]"),s.polygons)if(a)l.cellsInBand(s.minV,s.maxV,!0).forEach((function(t){p=p.concat(ga(ba(h,t.x,t.y,s),t.x,t.y,s))}));else for(o=0;o<h.length-1;++o)for(i=0;i<h[0].length-1;++i)p=p.concat(ga(ba(h,i,o,s),i,o,s));else{for(c=[],i=0;i<h[0].length-1;++i)c[i]=[];if(a)l.cellsInBand(s.minV,s.maxV,!1).forEach((function(t){c[t.x][t.y]=ba(h,t.x,t.y,s)}));else for(i=0;i<h[0].length-1;++i)for(o=0;o<h.length-1;++o)c[i][o]=ba(h,i,o,s);p=function(t,e,n){var r,i,o,s,a,u,l,h,c,f,g,p,v,d,y,_,x=[],E=t.length-1,k=t[0].length-1,b=[["rt","rb"],["br","bl"],["lb","lt"],["tl","tr"]],w=[0,-1,0,1],I=[-1,0,1,0],N=["bl","lb","lt","tl","tr","rt","rb","br"],S={bl:1,br:1,lb:2,lt:2,tl:3,tr:3,rt:0,rb:0};return function(t,e,n){var r,i,o,s,a;for(r=!0,i=t[0].length,o=t.length,a=0;a<o;a++)if(t[a][0]<e||t[a][0]>n||t[a][i-1]<e||t[a][i-1]>n){r=!1;break}if(r&&(t[o-1][0]<e||t[o-1][0]>n||t[o-1][i-1]<e||t[o-1][i-1]>n)&&(r=!1),r)for(s=0;s<i-1;s++)if(t[0][s]<e||t[0][s]>n||t[o-1][s]<e||t[o-1][s]>n){r=!1;break}return r}(t,n.minV,n.maxV)&&(n.linearRing?x.push([[0,0],[0,E],[k,E],[k,0],[0,0]]):x.push([[0,0],[0,E],[k,E],[k,0]])),e.forEach((function(t,M){t.forEach((function(t,L){for(r=null,o=0;o<8;o++)if(r=N[o],"object"===m(t.edges[r])){for(i=[],s=t.edges[r],l=r,h=M,c=L,f=!1,g=[M+s.path[0][0],L+s.path[0][1]],i.push(g);!f&&"object"===m((p=e[h][c]).edges[l]);)if(s=p.edges[l],delete p.edges[l],(y=s.path[1])[0]+=h,y[1]+=c,i.push(y),l=s.move.enter,h+=s.move.x,c+=s.move.y,void 0===e[h]||void 0===e[h][c]){if(v=0,d=0,h===k)h--,v=0;else if(h<0)h++,v=2;else if(c===E)c--,v=3;else{if(!(c<0))throw new Error("Left the grid somewhere in the interior!");c++,v=1}if(h===M&&c===L&&v===S[r]){f=!0,l=r;break}for(;;){if(_=!1,d>4)throw new Error("Direction change counter overflow! This should never happen!");if(void 0!==e[h]&&void 0!==e[h][c])for(p=e[h][c],a=0;a<b[v].length;a++)if(u=b[v][a],"object"===m(p.edges[u])){s=p.edges[u],i.push(pa(h,c,v,s.path)),l=u,_=!0;break}if(_)break;if(i.push(va(h,c,v)),c+=I[v],void 0!==e[h+=w[v]]&&void 0!==e[h][c]||(0===v&&c<0||1===v&&h<0||2===v&&c===E||3===v&&h===k)&&(h-=w[v],c-=I[v],v=(v+1)%4,d++),h===M&&c===L&&v===S[r]){f=!0,l=r;break}}}!n.linearRing||i[i.length-1][0]===g[0]&&i[i.length-1][1]===g[1]||i.push(g),x.push(i)}}))})),x}(h,c,s)}f?v.push(p):v=p,"function"==typeof s.successCallback&&s.successCallback(v,t,n[e])})),v}function ka(t,e,n,r,i,o){var s=(r+n+e+t)/4;return s>o?2:s<i?0:1}function ba(t,e,n,r){var i,o,s=0,a=t[n+1][e],u=t[n+1][e+1],l=t[n][e+1],h=t[n][e],c=r.minV,f=r.maxV;if(!(isNaN(h)||isNaN(l)||isNaN(u)||isNaN(a))){switch(s|=a<c?0:a>f?128:64,s|=u<c?0:u>f?32:16,s|=l<c?0:l>f?8:4,o=0,i={cval:s=+(s|=h<c?0:h>f?2:1),polygons:[],edges:{},x0:h,x1:l,x2:u,x3:a,x:e,y:n},s){case 85:xa.square(i,h,l,u,a,r);case 0:case 170:break;case 169:xa.triangle_bl(i,h,l,u,a,r);break;case 166:xa.triangle_br(i,h,l,u,a,r);break;case 154:xa.triangle_tr(i,h,l,u,a,r);break;case 106:xa.triangle_tl(i,h,l,u,a,r);break;case 1:xa.triangle_bl(i,h,l,u,a,r);break;case 4:xa.triangle_br(i,h,l,u,a,r);break;case 16:xa.triangle_tr(i,h,l,u,a,r);break;case 64:xa.triangle_tl(i,h,l,u,a,r);break;case 168:xa.tetragon_bl(i,h,l,u,a,r);break;case 162:xa.tetragon_br(i,h,l,u,a,r);break;case 138:xa.tetragon_tr(i,h,l,u,a,r);break;case 42:xa.tetragon_tl(i,h,l,u,a,r);break;case 2:xa.tetragon_bl(i,h,l,u,a,r);break;case 8:xa.tetragon_br(i,h,l,u,a,r);break;case 32:xa.tetragon_tr(i,h,l,u,a,r);break;case 128:xa.tetragon_tl(i,h,l,u,a,r);break;case 5:xa.tetragon_b(i,h,l,u,a,r);break;case 20:xa.tetragon_r(i,h,l,u,a,r);break;case 80:xa.tetragon_t(i,h,l,u,a,r);break;case 65:xa.tetragon_l(i,h,l,u,a,r);break;case 165:xa.tetragon_b(i,h,l,u,a,r);break;case 150:xa.tetragon_r(i,h,l,u,a,r);break;case 90:xa.tetragon_t(i,h,l,u,a,r);break;case 105:xa.tetragon_l(i,h,l,u,a,r);break;case 160:xa.tetragon_lr(i,h,l,u,a,r);break;case 130:xa.tetragon_tb(i,h,l,u,a,r);break;case 10:xa.tetragon_lr(i,h,l,u,a,r);break;case 40:xa.tetragon_tb(i,h,l,u,a,r);break;case 101:xa.pentagon_tr(i,h,l,u,a,r);break;case 149:xa.pentagon_tl(i,h,l,u,a,r);break;case 86:xa.pentagon_bl(i,h,l,u,a,r);break;case 89:xa.pentagon_br(i,h,l,u,a,r);break;case 69:xa.pentagon_tr(i,h,l,u,a,r);break;case 21:xa.pentagon_tl(i,h,l,u,a,r);break;case 84:xa.pentagon_bl(i,h,l,u,a,r);break;case 81:xa.pentagon_br(i,h,l,u,a,r);break;case 96:xa.pentagon_tr_rl(i,h,l,u,a,r);break;case 24:xa.pentagon_rb_bt(i,h,l,u,a,r);break;case 6:xa.pentagon_bl_lr(i,h,l,u,a,r);break;case 129:xa.pentagon_lt_tb(i,h,l,u,a,r);break;case 74:xa.pentagon_tr_rl(i,h,l,u,a,r);break;case 146:xa.pentagon_rb_bt(i,h,l,u,a,r);break;case 164:xa.pentagon_bl_lr(i,h,l,u,a,r);break;case 41:xa.pentagon_lt_tb(i,h,l,u,a,r);break;case 66:xa.pentagon_bl_tb(i,h,l,u,a,r);break;case 144:xa.pentagon_lt_rl(i,h,l,u,a,r);break;case 36:xa.pentagon_tr_bt(i,h,l,u,a,r);break;case 9:xa.pentagon_rb_lr(i,h,l,u,a,r);break;case 104:xa.pentagon_bl_tb(i,h,l,u,a,r);break;case 26:xa.pentagon_lt_rl(i,h,l,u,a,r);break;case 134:xa.pentagon_tr_bt(i,h,l,u,a,r);break;case 161:xa.pentagon_rb_lr(i,h,l,u,a,r);break;case 37:xa.hexagon_lt_tr(i,h,l,u,a,r);break;case 148:xa.hexagon_bl_lt(i,h,l,u,a,r);break;case 82:xa.hexagon_bl_rb(i,h,l,u,a,r);break;case 73:xa.hexagon_tr_rb(i,h,l,u,a,r);break;case 133:xa.hexagon_lt_tr(i,h,l,u,a,r);break;case 22:xa.hexagon_bl_lt(i,h,l,u,a,r);break;case 88:xa.hexagon_bl_rb(i,h,l,u,a,r);break;case 97:xa.hexagon_tr_rb(i,h,l,u,a,r);break;case 145:case 25:xa.hexagon_lt_rb(i,h,l,u,a,r);break;case 70:case 100:xa.hexagon_bl_tr(i,h,l,u,a,r);break;case 17:0===(o=ka(h,l,u,a,c,f))?(xa.triangle_bl(i,h,l,u,a,r),xa.triangle_tr(i,h,l,u,a,r)):xa.hexagon_lt_rb(i,h,l,u,a,r);break;case 68:0===(o=ka(h,l,u,a,c,f))?(xa.triangle_tl(i,h,l,u,a,r),xa.triangle_br(i,h,l,u,a,r)):xa.hexagon_bl_tr(i,h,l,u,a,r);break;case 153:2===(o=ka(h,l,u,a,c,f))?(xa.triangle_bl(i,h,l,u,a,r),xa.triangle_tr(i,h,l,u,a,r)):xa.hexagon_lt_rb(i,h,l,u,a,r);break;case 102:2===(o=ka(h,l,u,a,c,f))?(xa.triangle_tl(i,h,l,u,a,r),xa.triangle_br(i,h,l,u,a,r)):xa.hexagon_bl_tr(i,h,l,u,a,r);break;case 152:2===(o=ka(h,l,u,a,c,f))?(xa.triangle_tr(i,h,l,u,a,r),xa.tetragon_bl(i,h,l,u,a,r)):xa.heptagon_tr(i,h,l,u,a,r);break;case 137:2===(o=ka(h,l,u,a,c,f))?(xa.triangle_bl(i,h,l,u,a,r),xa.tetragon_tr(i,h,l,u,a,r)):xa.heptagon_bl(i,h,l,u,a,r);break;case 98:2===(o=ka(h,l,u,a,c,f))?(xa.triangle_tl(i,h,l,u,a,r),xa.tetragon_br(i,h,l,u,a,r)):xa.heptagon_tl(i,h,l,u,a,r);break;case 38:2===(o=ka(h,l,u,a,c,f))?(xa.triangle_br(i,h,l,u,a,r),xa.tetragon_tl(i,h,l,u,a,r)):xa.heptagon_br(i,h,l,u,a,r);break;case 18:0===(o=ka(h,l,u,a,c,f))?(xa.triangle_tr(i,h,l,u,a,r),xa.tetragon_bl(i,h,l,u,a,r)):xa.heptagon_tr(i,h,l,u,a,r);break;case 33:0===(o=ka(h,l,u,a,c,f))?(xa.triangle_bl(i,h,l,u,a,r),xa.tetragon_tr(i,h,l,u,a,r)):xa.heptagon_bl(i,h,l,u,a,r);break;case 72:0===(o=ka(h,l,u,a,c,f))?(xa.triangle_tl(i,h,l,u,a,r),xa.tetragon_br(i,h,l,u,a,r)):xa.heptagon_tl(i,h,l,u,a,r);break;case 132:0===(o=ka(h,l,u,a,c,f))?(xa.triangle_br(i,h,l,u,a,r),xa.tetragon_tl(i,h,l,u,a,r)):xa.heptagon_br(i,h,l,u,a,r);break;case 136:0===(o=ka(h,l,u,a,c,f))?(xa.tetragon_tl(i,h,l,u,a,r),xa.tetragon_br(i,h,l,u,a,r)):1===o?xa.octagon(i,h,l,u,a,r):(xa.tetragon_bl(i,h,l,u,a,r),xa.tetragon_tr(i,h,l,u,a,r));break;case 34:0===(o=ka(h,l,u,a,c,f))?(xa.tetragon_bl(i,h,l,u,a,r),xa.tetragon_tr(i,h,l,u,a,r)):1===o?xa.octagon(i,h,l,u,a,r):(xa.tetragon_tl(i,h,l,u,a,r),xa.tetragon_br(i,h,l,u,a,r))}return i}}var wa=Object.defineProperty,Ia=Object.getOwnPropertySymbols,Na=Object.prototype.hasOwnProperty,Sa=Object.prototype.propertyIsEnumerable,Ma=function(t,e,n){return e in t?wa(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n},La=function(t,e){for(var n in e||(e={}))Na.call(e,n)&&Ma(t,n,e[n]);if(Ia){var r,i=a(Ia(e));try{for(i.s();!(r=i.n()).done;){n=r.value;Sa.call(e,n)&&Ma(t,n,e[n])}}catch(t){i.e(t)}finally{i.f()}}return t};function Pa(t,e){if(!Z(e=e||{}))throw new Error("options is invalid");var n=e.zProperty||"elevation",r=e.flip,i=e.flags;nt(t,"Point","input must contain Points");for(var o=function(t,e){var n={};vt(t,(function(t){var e=Q(t)[1];n[e]||(n[e]=[]),n[e].push(t)}));var r=Object.keys(n).map((function(t){return n[t].sort((function(t,e){return Q(t)[0]-Q(e)[0]}))})),i=r.sort((function(t,n){return e?Q(t[0])[1]-Q(n[0])[1]:Q(n[0])[1]-Q(t[0])[1]}));return i}(t,r),s=[],a=0;a<o.length;a++){for(var u=o[a],l=[],h=0;h<u.length;h++){var c=u[h];c.properties[n]?l.push(c.properties[n]):l.push(0),!0===i&&(c.properties.matrixPosition=[a,h])}s.push(l)}return s}function Ca(t){var e=t.map((function(t){return{ring:t,area:Lt(S([t]))}}));return e.sort((function(t,e){return e.area-t.area})),e.map((function(t){return t.ring}))}function Ta(t){for(var e=t.map((function(t){return{lrCoordinates:t,grouped:!1}})),n=[];!Ra(e);)for(var r=0;r<e.length;r++)if(!e[r].grouped){var i=[];i.push(e[r].lrCoordinates),e[r].grouped=!0;for(var o=S([e[r].lrCoordinates]),s=r+1;s<e.length;s++){if(!e[s].grouped)Oa(S([e[s].lrCoordinates]),o)&&(i.push(e[s].lrCoordinates),e[s].grouped=!0)}n.push(i)}return n}function Oa(t,e){for(var n=Zs(t),r=0;r<n.features.length;r++)if(!zt(n.features[r],e))return!1;return!0}function Ra(t){for(var e=0;e<t.length;e++)if(!1===t[e].grouped)return!1;return!0}var Aa=Object.defineProperty,Da=Object.getOwnPropertySymbols,Fa=Object.prototype.hasOwnProperty,qa=Object.prototype.propertyIsEnumerable,Va=function(t,e,n){return e in t?Aa(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n},Ga=function(t,e){for(var n in e||(e={}))Fa.call(e,n)&&Va(t,n,e[n]);if(Da){var r,i=a(Da(e));try{for(i.s();!(r=i.n()).done;){n=r.value;qa.call(e,n)&&Va(t,n,e[n])}}catch(t){i.e(t)}finally{i.f()}}return t};function Ba(t,e){if(!Z(e=e||{}))throw new Error("options is invalid");var n=e.zProperty||"elevation",r=e.flip,i=e.flags;nt(t,"Point","input must contain Points");for(var o=function(t,e){var n={};vt(t,(function(t){var e=Q(t)[1];n[e]||(n[e]=[]),n[e].push(t)}));var r=Object.keys(n).map((function(t){return n[t].sort((function(t,e){return Q(t)[0]-Q(e)[0]}))})),i=r.sort((function(t,n){return e?Q(t[0])[1]-Q(n[0])[1]:Q(n[0])[1]-Q(t[0])[1]}));return i}(t,r),s=[],a=0;a<o.length;a++){for(var u=o[a],l=[],h=0;h<u.length;h++){var c=u[h];c.properties[n]?l.push(c.properties[n]):l.push(0),!0===i&&(c.properties.matrixPosition=[a,h])}s.push(l)}return s}function Ya(t,e,n,r,i,o,s,a){var u,l,h,c,f={x:null,y:null,onLine1:!1,onLine2:!1};return 0===(u=(a-o)*(n-t)-(s-i)*(r-e))?null!==f.x&&null!==f.y&&f:(c=(n-t)*(l=e-o)-(r-e)*(h=t-i),l=((s-i)*l-(a-o)*h)/u,h=c/u,f.x=t+l*(n-t),f.y=e+l*(r-e),l>=0&&l<=1&&(f.onLine1=!0),h>=0&&h<=1&&(f.onLine2=!0),!(!f.onLine1||!f.onLine2)&&[f.x,f.y])}function za(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return bt(t,(function(t,n){var r=n.geometry.coordinates;return t+ut(r[0],r[1],e)}),0)}function ja(t,e,n,r){var i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},o=i.steps||64,s=Xa(n),a=Xa(r),u=Array.isArray(t)||"Feature"!==t.type?{}:t.properties;if(s===a)return L(Ri(t,e,i).geometry.coordinates[0],u);for(var l=s,h=s<a?a:a+360,c=l,f=[],g=0,p=(h-l)/o;c<=h;)f.push(at(t,e,c,i).geometry.coordinates),c=l+ ++g*p;return L(f,u)}function Xa(t){var e=t%360;return e<0&&(e+=360),e}function Ua(t,e,n,r){if(!Z(r=r||{}))throw new Error("options is invalid");var i,o=[];if("Feature"===t.type)i=t.geometry.coordinates;else{if("LineString"!==t.type)throw new Error("input must be a LineString Feature or Geometry");i=t.coordinates}for(var s,a,u,l=i.length,h=0,c=0;c<i.length&&!(e>=h&&c===i.length-1);c++){if(h>e&&0===o.length){if(!(s=e-h))return o.push(i[c]),L(o);a=st(i[c],i[c-1])-180,u=at(i[c],s,a,r),o.push(u.geometry.coordinates)}if(h>=n)return(s=n-h)?(a=st(i[c],i[c-1])-180,u=at(i[c],s,a,r),o.push(u.geometry.coordinates),L(o)):(o.push(i[c]),L(o));if(h>=e&&o.push(i[c]),c===i.length-1)return L(o);h+=ut(i[c],i[c+1],r)}if(h<e&&i.length===l)throw new Error("Start position is beyond line");var f=i[i.length-1];return L([f,f])}function Za(t){var e=t[0],n=t[1];return[n[0]-e[0],n[1]-e[1]]}function Ha(t,e){return t[0]*e[1]-e[0]*t[1]}function Wa(t,e){return!function(t,e){return 0===Ha(Za(t),Za(e))}(t,e)&&function(t,e){var n,r,i=t[0],o=Za(t),s=e[0],a=Za(e),u=Ha(o,a),l=function(t,e){return[t[0]+e[0],t[1]+e[1]]}(i,function(t,e){return[t*e[0],t*e[1]]}(Ha((r=i,[(n=s)[0]-r[0],n[1]-r[1]]),a)/u,o));return l}(t,e)}function Ja(t,e,n){var r=[],i=V(e,n),o=Q(t),s=[];return o.forEach((function(t,e){if(e!==o.length-1){var n=(l=t,h=o[e+1],c=i,f=Math.sqrt((l[0]-h[0])*(l[0]-h[0])+(l[1]-h[1])*(l[1]-h[1])),g=l[0]+c*(h[1]-l[1])/f,p=h[0]+c*(h[1]-l[1])/f,v=l[1]+c*(l[0]-h[0])/f,d=h[1]+c*(l[0]-h[0])/f,[[g,v],[p,d]]);if(r.push(n),e>0){var a=r[e-1],u=Wa(n,a);!1!==u&&(a[1]=u,n[0]=u),s.push(a[0]),e===o.length-2&&(s.push(n[0]),s.push(n[1]))}2===o.length&&(s.push(n[0]),s.push(n[1]))}var l,h,c,f,g,p,v,d})),L(s,t.properties)}function Ka(t){var e=t[0],n=t[1],r=t[2],i=t[3];if(ut(t.slice(0,2),[r,n])>=ut(t.slice(0,2),[e,i])){var o=(n+i)/2;return[e,o-(r-e)/2,r,o+(r-e)/2]}var s=(e+r)/2;return[s-(i-n)/2,n,s+(i-n)/2,i]}function Qa(t,e){if(!Z(e=null!=e?e:{}))throw new Error("options is invalid");var n=e.precision,r=e.coordinates,i=e.mutate;if(n=null==n||isNaN(n)?6:n,r=null==r||isNaN(r)?3:r,!t)throw new Error("<geojson> is required");if("number"!=typeof n)throw new Error("<precision> must be a number");if("number"!=typeof r)throw new Error("<coordinates> must be a number");!1!==i&&void 0!==i||(t=JSON.parse(JSON.stringify(t)));var o=Math.pow(10,n);return ct(t,(function(t){!function(t,e,n){t.length>n&&t.splice(n,t.length);for(var r=0;r<t.length;r++)t[r]=Math.round(t[r]*e)/e}(t,o,r)})),t}function $a(t,e){var n=[],r=Qe();return xt(e,(function(e){if(n.forEach((function(t,e){t.id=e})),n.length){var i=r.search(e);if(i.features.length){var o=eu(e,i);n=n.filter((function(t){return t.id!==o.id})),r.remove(o),vt(tu(o,e),(function(t){n.push(t),r.insert(t)}))}}else(n=tu(t,e).features).forEach((function(t){t.bbox||(t.bbox=Ka(Rt(t)))})),r.load(C(n))})),C(n)}function tu(t,e){var n=[],r=Q(t)[0],i=Q(t)[t.geometry.coordinates.length-1];if(nu(r,K(e))||nu(i,K(e)))return C([t]);var o=Qe(),s=$e(t);o.load(s);var a=o.search(e);if(!a.features.length)return C([t]);var u=eu(e,a),l=dt(s,(function(t,r,i){var o=Q(r)[1],s=K(e);return i===u.id?(t.push(s),n.push(L(t)),nu(s,o)?[s]:[s,o]):(t.push(o),t)}),[r]);return l.length>1&&n.push(L(l)),C(n)}function eu(t,e){if(!e.features.length)throw new Error("lines must contain features");if(1===e.features.length)return e.features[0];var n,r=1/0;return vt(e,(function(e){var i=fn(e,t).properties.dist;i<r&&(n=e,r=i)})),n}function nu(t,e){return t[0]===e[0]&&t[1]===e[1]}function ru(t,e,n,r){e=e||("Feature"===t.type?t.properties:{});var i=rt(t),o=i.coordinates,s=i.type;if(!o.length)throw new Error("line must contain coordinates");switch(s){case"LineString":return n&&(o=iu(o)),S([o],e);case"MultiLineString":var a=[],u=0;return o.forEach((function(t){if(n&&(t=iu(t)),r){var e=function(t){var e=t[0],n=t[1],r=t[2],i=t[3];return Math.abs(e-r)*Math.abs(n-i)}(Rt(L(t)));e>u?(a.unshift(t),u=e):a.push(t)}else a.push(t)})),S(a,e);default:throw new Error("geometry type "+s+" is not supported")}}function iu(t){var e=t[0],n=e[0],r=e[1],i=t[t.length-1],o=i[0],s=i[1];return n===o&&r===s||t.push(e),t}function ou(t){return R(t)}function su(t){var e=[[[180,90],[-180,90],[-180,-90],[180,-90],[180,90]]];return t&&(e="Feature"===t.type?t.geometry.coordinates:t.coordinates),S(e)}function au(t){var e,n=0,r=a(t);try{for(r.s();!(e=r.n()).done;){n+=e.value}}catch(t){r.e(t)}finally{r.f()}return n/t.length}var uu=Object.defineProperty,lu=Object.defineProperties,hu=Object.getOwnPropertyDescriptors,cu=Object.getOwnPropertySymbols,fu=Object.prototype.hasOwnProperty,gu=Object.prototype.propertyIsEnumerable,pu=function(t,e,n){return e in t?uu(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n},vu=function(t,e){for(var n in e||(e={}))fu.call(e,n)&&pu(t,n,e[n]);if(cu){var r,i=a(cu(e));try{for(i.s();!(r=i.n()).done;){n=r.value;gu.call(e,n)&&pu(t,n,e[n])}}catch(t){i.e(t)}finally{i.f()}}return t},du=function(t,e){return lu(t,hu(e))};function yu(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!t)throw new Error("targetPoint is required");if(!e)throw new Error("points is required");var r=1/0,i=0;vt(e,(function(e,o){var s=ut(t,e,n);s<r&&(i=o,r=s)}));var o=Ai(e.features[i]);return du(vu({},o),{properties:du(vu({},o.properties),{featureIndex:i,distanceToPoint:r})})}function mu(t,e){var n,r,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=null!=(n=i.method)?n:"geodesic",s=null!=(r=i.units)?r:"kilometers";if(!t)throw new Error("pt is required");if(Array.isArray(t)?t=I(t):"Point"===t.type?t=b(t):et(t,"Point","point"),!e)throw new Error("line is required");Array.isArray(e)?e=L(e):"LineString"===e.type?e=b(e):et(e,"LineString","line");var a=1/0,u=t.geometry.coordinates;return kt(e,(function(t){if(t){var e=t.geometry.coordinates[0],n=t.geometry.coordinates[1],r=function(t,e,n,r){if("geodesic"===r.method){return fn(L([e,n]).geometry,t,{units:"degrees"}).properties.dist}var i=[n[0]-e[0],n[1]-e[1]],o=[t[0]-e[0],t[1]-e[1]],s=_u(o,i);if(s<=0)return Ys(t,e,{units:"degrees"});var a=_u(i,i);if(a<=s)return Ys(t,n,{units:"degrees"});var u=s/a,l=[e[0]+u*i[0],e[1]+u*i[1]];return Ys(t,l,{units:"degrees"})}(u,e,n,{method:o});r<a&&(a=r)}})),j(a,"degrees",s)}function _u(t,e){return t[0]*e[0]+t[1]*e[1]}var xu=Object.defineProperty,Eu=Object.getOwnPropertySymbols,ku=Object.prototype.hasOwnProperty,bu=Object.prototype.propertyIsEnumerable,wu=function(t,e,n){return e in t?xu(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n},Iu=function(t,e){for(var n in e||(e={}))ku.call(e,n)&&wu(t,n,e[n]);if(Eu){var r,i=a(Eu(e));try{for(i.s();!(r=i.n()).done;){n=r.value;bu.call(e,n)&&wu(t,n,e[n])}}catch(t){i.e(t)}finally{i.f()}}return t};function Nu(t,e,n,r,i,o){return Math.sqrt((i-n)*(i-n)+(o-r)*(o-r))===Math.sqrt((t-n)*(t-n)+(e-r)*(e-r))+Math.sqrt((i-t)*(i-t)+(o-e)*(o-e))}function Su(t,e){var n=[];return vt(t,(function(t){var r=!1;if("Point"===t.geometry.type)mt(e,(function(e){zt(t,e)&&(r=!0)})),r&&n.push(t);else{if("MultiPoint"!==t.geometry.type)throw new Error("Input geometry must be a Point or MultiPoint");var i=[];mt(e,(function(e){ct(t,(function(t){zt(t,e)&&(r=!0,i.push(t))}))})),r&&n.push(O(i,t.properties))}})),C(n)}function Mu(t,e,n){var r=e[0]-t[0],i=e[1]-t[1],o=n[0]-e[0];return function(t){return(t>0)-(t<0)||+t}(r*(n[1]-e[1])-o*i)}function Lu(t,e){return e.geometry.coordinates[0].every((function(e){return zt(I(e),t)}))}var Pu=function(){return s((function t(e){i(this,t),this.id=t.buildId(e),this.coordinates=e,this.innerEdges=[],this.outerEdges=[],this.outerEdgesSorted=!1}),[{key:"removeInnerEdge",value:function(t){this.innerEdges=this.innerEdges.filter((function(e){return e.from.id!==t.from.id}))}},{key:"removeOuterEdge",value:function(t){this.outerEdges=this.outerEdges.filter((function(e){return e.to.id!==t.to.id}))}},{key:"addOuterEdge",value:function(t){this.outerEdges.push(t),this.outerEdgesSorted=!1}},{key:"sortOuterEdges",value:function(){var t=this;this.outerEdgesSorted||(this.outerEdges.sort((function(e,n){var r=e.to,i=n.to;if(r.coordinates[0]-t.coordinates[0]>=0&&i.coordinates[0]-t.coordinates[0]<0)return 1;if(r.coordinates[0]-t.coordinates[0]<0&&i.coordinates[0]-t.coordinates[0]>=0)return-1;if(r.coordinates[0]-t.coordinates[0]==0&&i.coordinates[0]-t.coordinates[0]==0)return r.coordinates[1]-t.coordinates[1]>=0||i.coordinates[1]-t.coordinates[1]>=0?r.coordinates[1]-i.coordinates[1]:i.coordinates[1]-r.coordinates[1];var o=Mu(t.coordinates,r.coordinates,i.coordinates);return o<0?1:o>0?-1:Math.pow(r.coordinates[0]-t.coordinates[0],2)+Math.pow(r.coordinates[1]-t.coordinates[1],2)-(Math.pow(i.coordinates[0]-t.coordinates[0],2)+Math.pow(i.coordinates[1]-t.coordinates[1],2))})),this.outerEdgesSorted=!0)}},{key:"getOuterEdges",value:function(){return this.sortOuterEdges(),this.outerEdges}},{key:"getOuterEdge",value:function(t){return this.sortOuterEdges(),this.outerEdges[t]}},{key:"addInnerEdge",value:function(t){this.innerEdges.push(t)}}],[{key:"buildId",value:function(t){return t.join(",")}}])}(),Cu=function(){function t(e,n){i(this,t),this.from=e,this.to=n,this.next=void 0,this.label=void 0,this.symetric=void 0,this.ring=void 0,this.from.addOuterEdge(this),this.to.addInnerEdge(this)}return s(t,[{key:"getSymetric",value:function(){return this.symetric||(this.symetric=new t(this.to,this.from),this.symetric.symetric=this),this.symetric}},{key:"deleteEdge",value:function(){this.from.removeOuterEdge(this),this.to.removeInnerEdge(this)}},{key:"isEqual",value:function(t){return this.from.id===t.from.id&&this.to.id===t.to.id}},{key:"toString",value:function(){return"Edge { ".concat(this.from.id," -> ").concat(this.to.id," }")}},{key:"toLineString",value:function(){return L([this.from.coordinates,this.to.coordinates])}},{key:"compareTo",value:function(t){return Mu(t.from.coordinates,t.to.coordinates,this.to.coordinates)}}])}(),Tu=function(){return s((function t(){i(this,t),this.edges=[],this.polygon=void 0,this.envelope=void 0}),[{key:"push",value:function(t){this.edges.push(t),this.polygon=this.envelope=void 0}},{key:"get",value:function(t){return this.edges[t]}},{key:"length",get:function(){return this.edges.length}},{key:"forEach",value:function(t){this.edges.forEach(t)}},{key:"map",value:function(t){return this.edges.map(t)}},{key:"some",value:function(t){return this.edges.some(t)}},{key:"isValid",value:function(){return!0}},{key:"isHole",value:function(){var t=this,e=this.edges.reduce((function(e,n,r){return n.from.coordinates[1]>t.edges[e].from.coordinates[1]&&(e=r),e}),0),n=(0===e?this.length:e)-1,r=(e+1)%this.length,i=Mu(this.edges[n].from.coordinates,this.edges[e].from.coordinates,this.edges[r].from.coordinates);return 0===i?this.edges[n].from.coordinates[0]>this.edges[r].from.coordinates[0]:i>0}},{key:"toMultiPoint",value:function(){return O(this.edges.map((function(t){return t.from.coordinates})))}},{key:"toPolygon",value:function(){if(this.polygon)return this.polygon;var t=this.edges.map((function(t){return t.from.coordinates}));return t.push(this.edges[0].from.coordinates),this.polygon=S([t])}},{key:"getEnvelope",value:function(){return this.envelope?this.envelope:this.envelope=Us(this.toPolygon())}},{key:"inside",value:function(t){return zt(t,this.toPolygon())}}],[{key:"findEdgeRingContaining",value:function(t,e){var n,r,i=t.getEnvelope();return e.forEach((function(e){var o,s,u,l,h,c,f=e.getEnvelope();if((r&&(n=r.getEnvelope()),s=i,u=(o=f).geometry.coordinates[0].map((function(t){return t[0]})),l=o.geometry.coordinates[0].map((function(t){return t[1]})),h=s.geometry.coordinates[0].map((function(t){return t[0]})),c=s.geometry.coordinates[0].map((function(t){return t[1]})),Math.max.apply(null,u)!==Math.max.apply(null,h)||Math.max.apply(null,l)!==Math.max.apply(null,c)||Math.min.apply(null,u)!==Math.min.apply(null,h)||Math.min.apply(null,l)!==Math.min.apply(null,c))&&Lu(f,i)){var g,p,v=a(t.map((function(t){return t.from.coordinates})));try{var d=function(){var t=p.value;e.some((function(e){return n=t,r=e.from.coordinates,n[0]===r[0]&&n[1]===r[1];var n,r}))||(g=t)};for(v.s();!(p=v.n()).done;)d()}catch(t){v.e(t)}finally{v.f()}g&&e.inside(I(g))&&(r&&!Lu(n,f)||(r=e))}})),r}}])}();var Ou=function(){function t(){i(this,t),this.edges=[],this.nodes={}}return s(t,[{key:"getNode",value:function(t){var e=Pu.buildId(t),n=this.nodes[e];return n||(n=this.nodes[e]=new Pu(t)),n}},{key:"addEdge",value:function(t,e){var n=new Cu(t,e),r=n.getSymetric();this.edges.push(n),this.edges.push(r)}},{key:"deleteDangles",value:function(){var t=this;Object.keys(this.nodes).map((function(e){return t.nodes[e]})).forEach((function(e){return t._removeIfDangle(e)}))}},{key:"_removeIfDangle",value:function(t){var e=this;if(t.innerEdges.length<=1){var n=t.getOuterEdges().map((function(t){return t.to}));this.removeNode(t),n.forEach((function(t){return e._removeIfDangle(t)}))}}},{key:"deleteCutEdges",value:function(){var t=this;this._computeNextCWEdges(),this._findLabeledEdgeRings(),this.edges.forEach((function(e){e.label===e.symetric.label&&(t.removeEdge(e.symetric),t.removeEdge(e))}))}},{key:"_computeNextCWEdges",value:function(t){var e=this;void 0===t?Object.keys(this.nodes).forEach((function(t){return e._computeNextCWEdges(e.nodes[t])})):t.getOuterEdges().forEach((function(e,n){t.getOuterEdge((0===n?t.getOuterEdges().length:n)-1).symetric.next=e}))}},{key:"_computeNextCCWEdges",value:function(t,e){for(var n,r,i=t.getOuterEdges(),o=i.length-1;o>=0;--o){var s=i[o],a=s.symetric,u=void 0,l=void 0;s.label===e&&(u=s),a.label===e&&(l=a),u&&l&&(l&&(r=l),u&&(r&&(r.next=u,r=void 0),n||(n=u)))}r&&(r.next=n)}},{key:"_findLabeledEdgeRings",value:function(){var t=[],e=0;return this.edges.forEach((function(n){if(!(n.label>=0)){t.push(n);var r=n;do{r.label=e,r=r.next}while(!n.isEqual(r));e++}})),t}},{key:"getEdgeRings",value:function(){var t=this;this._computeNextCWEdges(),this.edges.forEach((function(t){t.label=void 0})),this._findLabeledEdgeRings().forEach((function(e){t._findIntersectionNodes(e).forEach((function(n){t._computeNextCCWEdges(n,e.label)}))}));var e=[];return this.edges.forEach((function(n){n.ring||e.push(t._findEdgeRing(n))})),e}},{key:"_findIntersectionNodes",value:function(t){var e=[],n=t,r=function(){var r=0;n.from.getOuterEdges().forEach((function(e){e.label===t.label&&++r})),r>1&&e.push(n.from),n=n.next};do{r()}while(!t.isEqual(n));return e}},{key:"_findEdgeRing",value:function(t){var e=t,n=new Tu;do{n.push(e),e.ring=n,e=e.next}while(!t.isEqual(e));return n}},{key:"removeNode",value:function(t){var e=this;t.getOuterEdges().forEach((function(t){return e.removeEdge(t)})),t.innerEdges.forEach((function(t){return e.removeEdge(t)})),delete this.nodes[t.id]}},{key:"removeEdge",value:function(t){this.edges=this.edges.filter((function(e){return!e.isEqual(t)})),t.deleteEdge()}}],[{key:"fromGeoJson",value:function(e){!function(t){if(!t)throw new Error("No geojson passed");if("FeatureCollection"!==t.type&&"GeometryCollection"!==t.type&&"MultiLineString"!==t.type&&"LineString"!==t.type&&"Feature"!==t.type)throw new Error("Invalid input type '".concat(t.type,"'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature"))}(e);var n=new t;return xt(e,(function(t){et(t,"LineString","Graph::fromGeoJson"),ft(t,(function(t,e){if(t){var r=n.getNode(t),i=n.getNode(e);n.addEdge(r,i)}return e}))})),n}}])}();function Ru(t,e){var n,r;ct(t,(function(t,i,o,s,a){if(r!==a)e.push([]);else{var u=n[0],l=n[1],h=t[0],c=t[1];e[a].push([.75*u+.25*h,.75*l+.25*c]),e[a].push([.25*u+.75*h,.25*l+.75*c])}n=t,r=a}),!1),e.forEach((function(t){t.push(t[0])}))}function Au(t,e){var n,r,i;ct(t,(function(t,o,s,a,u){if(r!==a)e.push([[]]);else if(i!==u)e[a].push([]);else{var l=n[0],h=n[1],c=t[0],f=t[1];e[a][u].push([.75*l+.25*c,.75*h+.25*f]),e[a][u].push([.25*l+.75*c,.25*h+.75*f])}n=t,r=a,i=u}),!1),e.forEach((function(t){t.forEach((function(t){t.push(t[0])}))}))}function Du(t,e,n,r,i){for(var o=0;o<t.length;o++){var s=t[o],a=t[o+1];o===t.length-1&&(a=t[0]);var u=qu(s,a,e);n<=0&&u>0?qu(e,s,r)<0||(r=s):n>0&&u<=0&&(Fu(e,s,i)||(i=s)),n=u}return[r,i]}function Fu(t,e,n){return qu(t,e,n)>0}function qu(t,e,n){return(e[0]-t[0])*(n[1]-t[1])-(n[0]-t[0])*(e[1]-t[1])}function Vu(t){return Bu(t,"mercator",arguments.length>1&&void 0!==arguments[1]?arguments[1]:{})}function Gu(t){return Bu(t,"wgs84",arguments.length>1&&void 0!==arguments[1]?arguments[1]:{})}function Bu(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=(n=n||{}).mutate;if(!t)throw new Error("geojson is required");return Array.isArray(t)&&U(t[0])?t="mercator"===e?Yu(t):zu(t):(!0!==r&&(t=Ai(t)),ct(t,(function(t){var n="mercator"===e?Yu(t):zu(t);t[0]=n[0],t[1]=n[1]}))),t}function Yu(t){var e=Math.PI/180,n=6378137,r=20037508.342789244,i=Math.abs(t[0])<=180?t[0]:t[0]-360*function(t){return t<0?-1:t>0?1:0}(t[0]),o=[n*i*e,n*Math.log(Math.tan(.25*Math.PI+.5*t[1]*e))];return o[0]>r&&(o[0]=r),o[0]<-r&&(o[0]=-r),o[1]>r&&(o[1]=r),o[1]<-r&&(o[1]=-r),o}function zu(t){var e=180/Math.PI,n=6378137;return[t[0]*e/n,(.5*Math.PI-2*Math.atan(Math.exp(-t[1]/n)))*e]}var ju=Object.freeze({__proto__:null,toMercator:Vu,toWgs84:Gu});var Xu={20:1.07275,15:1.13795,10:1.22385,5:1.3581,2:1.51743,1:1.62762};function Uu(t,e){return e[0]<=t[0]&&e[1]<=t[1]&&e[2]>=t[0]&&e[3]>=t[1]}function Zu(t){var e=[];return function t(n){return 0===n||1===n?1:e[n]>0?e[n]:e[n]=t(n-1)*n}(t)}function Hu(t){return Ju(t),Wu(t)}function Wu(t){return Array.isArray(t)?el(t):t&&t.bbox?el(t.bbox):[360*tl(),180*tl()]}function Ju(t){null!=t&&(Array.isArray(t)?H(t):null!=t.bbox&&H(t.bbox))}function Ku(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Ju(e.bbox),null==t&&(t=1);for(var n=[],r=0;r<t;r++)n.push(I(Wu(e.bbox)));return C(n)}function Qu(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Ju(e.bbox),null==t&&(t=1),void 0!==e.bbox&&null!==e.bbox||(e.bbox=[-180,-90,180,90]),U(e.num_vertices)&&void 0!==e.num_vertices||(e.num_vertices=10),U(e.max_radial_length)&&void 0!==e.max_radial_length||(e.max_radial_length=10);var n=Math.abs(e.bbox[0]-e.bbox[2]),r=Math.abs(e.bbox[1]-e.bbox[3]),i=Math.min(n/2,r/2);if(e.max_radial_length>i)throw new Error("max_radial_length is greater than the radius of the bbox");for(var o=[e.bbox[0]+e.max_radial_length,e.bbox[1]+e.max_radial_length,e.bbox[2]-e.max_radial_length,e.bbox[3]-e.max_radial_length],s=[],a=function(){var t,n=[],r=d(Array(e.num_vertices+1)).map(Math.random);r.forEach((function(t,e,n){n[e]=e>0?t+n[e-1]:t})),r.forEach((function(t){t=2*t*Math.PI/r[r.length-1];var i=Math.random();n.push([i*(e.max_radial_length||10)*Math.sin(t),i*(e.max_radial_length||10)*Math.cos(t)])})),n[n.length-1]=n[0],n=n.reverse().map((t=Wu(o),function(e){return[e[0]+t[0],e[1]+t[1]]})),s.push(S([n]))},u=0;u<t;u++)a();return C(s)}function $u(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!Z(e=e||{}))throw new Error("options is invalid");var n=e.bbox;Ju(n);var r=e.num_vertices,i=e.max_length,o=e.max_rotation;null==t&&(t=1),(!U(r)||void 0===r||r<2)&&(r=10),U(i)&&void 0!==i||(i=1e-4),U(o)&&void 0!==o||(o=Math.PI/8);for(var s=[],a=0;a<t;a++){for(var u=[Wu(n)],l=0;l<r-1;l++){var h=(0===l?2*Math.random()*Math.PI:Math.tan((u[l][1]-u[l-1][1])/(u[l][0]-u[l-1][0])))+(Math.random()-.5)*o*2,c=Math.random()*i;u.push([u[l][0]+c*Math.cos(h),u[l][1]+c*Math.sin(h)])}s.push(L(u))}return C(s)}function tl(){return Math.random()-.5}function el(t){return[Math.random()*(t[2]-t[0])+t[0],Math.random()*(t[3]-t[1])+t[1]]}var nl=Object.freeze({__proto__:null,randomLineString:$u,randomPoint:Ku,randomPolygon:Qu,randomPosition:Hu});function rl(t,e){switch("Feature"===t.type?t.geometry.type:t.type){case"GeometryCollection":return mt(t,(function(t){rl(t,e)})),t;case"LineString":return il(Q(t),e),t;case"Polygon":return ol(Q(t),e),t;case"MultiLineString":return Q(t).forEach((function(t){il(t,e)})),t;case"MultiPolygon":return Q(t).forEach((function(t){ol(t,e)})),t;case"Point":case"MultiPoint":return t}}function il(t,e){Bt(t)===e&&t.reverse()}function ol(t,e){Bt(t[0])!==e&&t[0].reverse();for(var n=1;n<t.length;n++)Bt(t[n])===e&&t[n].reverse()}function sl(t){var e=t%360;return e<0&&(e+=360),e}function al(t,e,n){if(!Z(n=n||{}))throw new Error("options is invalid");var r=n.origin||"centroid",i=n.mutate||!1;if(!t)throw new Error("geojson required");if("number"!=typeof e||e<=0)throw new Error("invalid factor");var o=Array.isArray(r)||"object"===m(r);return!0!==i&&(t=Ai(t)),"FeatureCollection"!==t.type||o?ul(t,e,r):(vt(t,(function(n,i){t.features[i]=ul(n,e,r)})),t)}function ul(t,e,n){var r="Point"===it(t),i=function(t,e){null==e&&(e="centroid");if(Array.isArray(e)||"object"===m(e))return K(e);var n=t.bbox?t.bbox:Rt(t,{recompute:!0}),r=n[0],i=n[1],o=n[2],s=n[3];switch(e){case"sw":case"southwest":case"westsouth":case"bottomleft":return I([r,i]);case"se":case"southeast":case"eastsouth":case"bottomright":return I([o,i]);case"nw":case"northwest":case"westnorth":case"topleft":return I([r,s]);case"ne":case"northeast":case"eastnorth":case"topright":return I([o,s]);case"center":return An(t);case void 0:case null:case"centroid":return gi(t);default:throw new Error("invalid origin")}}(t,n);return 1===e||r||(ct(t,(function(t){var n=Ys(i,t),r=lt(i,t),o=Q(Bs(i,n*e,r));t[0]=o[0],t[1]=o[1],3===t.length&&(t[2]*=e)})),delete t.bbox),t}function ll(t){for(var e=t,n=[];e.parent;)n.unshift(e),e=e.parent;return n}var hl={search:function(t,e,n,r){var i;t.cleanDirty();var o=(r=r||{}).heuristic||hl.heuristics.manhattan,s=null!=(i=r.closest)&&i,a=new gl((function(t){return t.f})),u=e;for(e.h=o(e,n),a.push(e);a.size()>0;){var l=a.pop();if(l===n)return ll(l);l.closed=!0;for(var h=t.neighbors(l),c=0,f=h.length;c<f;++c){var g=h[c];if(!g.closed&&!g.isWall()){var p=l.g+g.getCost(l),v=g.visited;(!v||p<g.g)&&(g.visited=!0,g.parent=l,g.h=g.h||o(g,n),g.g=p,g.f=g.g+g.h,t.markDirty(g),s&&(g.h<u.h||g.h===u.h&&g.g<u.g)&&(u=g),v?a.rescoreElement(g):a.push(g))}}}return s?ll(u):[]},heuristics:{manhattan:function(t,e){return Math.abs(e.x-t.x)+Math.abs(e.y-t.y)},diagonal:function(t,e){var n=Math.sqrt(2),r=Math.abs(e.x-t.x),i=Math.abs(e.y-t.y);return 1*(r+i)+(n-2)*Math.min(r,i)}},cleanNode:function(t){t.f=0,t.g=0,t.h=0,t.visited=!1,t.closed=!1,t.parent=null}};function cl(t,e){e=e||{},this.nodes=[],this.diagonal=!!e.diagonal,this.grid=[];for(var n=0;n<t.length;n++){this.grid[n]=[];for(var r=0,i=t[n];r<i.length;r++){var o=new fl(n,r,i[r]);this.grid[n][r]=o,this.nodes.push(o)}}this.init()}function fl(t,e,n){this.x=t,this.y=e,this.weight=n}function gl(t){this.content=[],this.scoreFunction=t}function pl(t,e){for(var n=0;n<e.features.length;n++)if(zt(t,e.features[n]))return!0;return!1}function vl(t,e,n){var r=e[0],i=e[1],o=n[0]-r,s=n[1]-i;if(0!==o||0!==s){var a=((t[0]-r)*o+(t[1]-i)*s)/(o*o+s*s);a>1?(r=n[0],i=n[1]):a>0&&(r+=o*a,i+=s*a)}return(o=t[0]-r)*o+(s=t[1]-i)*s}function dl(t,e,n,r,i){for(var o,s=r,a=e+1;a<n;a++){var u=vl(t[a],t[e],t[n]);u>s&&(o=a,s=u)}s>r&&(o-e>1&&dl(t,e,o,r,i),i.push(t[o]),n-o>1&&dl(t,o,n,r,i))}function yl(t,e){var n=t.length-1,r=[t[0]];return dl(t,0,n,e,r),r.push(t[n]),r}function ml(t,e,n){if(t.length<=2)return t;var r=void 0!==e?e*e:1;return t=n?t:function(t,e){for(var n,r,i,o,s,a=t[0],u=[a],l=1,h=t.length;l<h;l++)n=t[l],i=a,o=void 0,s=void 0,o=(r=n)[0]-i[0],s=r[1]-i[1],o*o+s*s>e&&(u.push(n),a=n);return a!==n&&u.push(n),u}(t,r),t=yl(t,r)}function _l(t,e,n){return t.map((function(t){if(t.length<4)throw new Error("invalid polygon");for(var r=e,i=ml(t,r,n);!xl(i);)i=ml(t,r-=.01*r,n);return i[i.length-1][0]===i[0][0]&&i[i.length-1][1]===i[0][1]||i.push(i[0]),i}))}function xl(t){return!(t.length<3)&&!(3===t.length&&t[2][0]===t[0][0]&&t[2][1]===t[0][1])}function El(t,e){return{x:t[0]-e[0],y:t[1]-e[1]}}cl.prototype.init=function(){this.dirtyNodes=[];for(var t=0;t<this.nodes.length;t++)hl.cleanNode(this.nodes[t])},cl.prototype.cleanDirty=function(){for(var t=0;t<this.dirtyNodes.length;t++)hl.cleanNode(this.dirtyNodes[t]);this.dirtyNodes=[]},cl.prototype.markDirty=function(t){this.dirtyNodes.push(t)},cl.prototype.neighbors=function(t){var e=[],n=t.x,r=t.y,i=this.grid;return i[n-1]&&i[n-1][r]&&e.push(i[n-1][r]),i[n+1]&&i[n+1][r]&&e.push(i[n+1][r]),i[n]&&i[n][r-1]&&e.push(i[n][r-1]),i[n]&&i[n][r+1]&&e.push(i[n][r+1]),this.diagonal&&(i[n-1]&&i[n-1][r-1]&&e.push(i[n-1][r-1]),i[n+1]&&i[n+1][r-1]&&e.push(i[n+1][r-1]),i[n-1]&&i[n-1][r+1]&&e.push(i[n-1][r+1]),i[n+1]&&i[n+1][r+1]&&e.push(i[n+1][r+1])),e},cl.prototype.toString=function(){for(var t,e,n,r,i=[],o=this.grid,s=0,a=o.length;s<a;s++){for(t=[],n=0,r=(e=o[s]).length;n<r;n++)t.push(e[n].weight);i.push(t.join(" "))}return i.join("\n")},fl.prototype.toString=function(){return"["+this.x+" "+this.y+"]"},fl.prototype.getCost=function(t){return t&&t.x!==this.x&&t.y!==this.y?1.41421*this.weight:this.weight},fl.prototype.isWall=function(){return 0===this.weight},gl.prototype={push:function(t){this.content.push(t),this.sinkDown(this.content.length-1)},pop:function(){var t=this.content[0],e=this.content.pop();return this.content.length>0&&(this.content[0]=e,this.bubbleUp(0)),t},remove:function(t){var e=this.content.indexOf(t),n=this.content.pop();e!==this.content.length-1&&(this.content[e]=n,this.scoreFunction(n)<this.scoreFunction(t)?this.sinkDown(e):this.bubbleUp(e))},size:function(){return this.content.length},rescoreElement:function(t){this.sinkDown(this.content.indexOf(t))},sinkDown:function(t){for(var e=this.content[t];t>0;){var n=(t+1>>1)-1,r=this.content[n];if(!(this.scoreFunction(e)<this.scoreFunction(r)))break;this.content[n]=e,this.content[t]=r,t=n}},bubbleUp:function(t){for(var e=this.content.length,n=this.content[t],r=this.scoreFunction(n);;){var i,o=t+1<<1,s=o-1,a=null;if(s<e){var u=this.content[s];(i=this.scoreFunction(u))<r&&(a=s)}if(o<e){var l=this.content[o];this.scoreFunction(l)<(null===a?r:i)&&(a=o)}if(null===a)break;this.content[t]=this.content[a],this.content[a]=n,t=a}}};var kl,bl={exports:{}};var wl=function(){if(kl)return bl.exports;function t(t,n,i){i=i||2;var o,s,a,h,c,g,p,v=n&&n.length,d=v?n[0]*i:t.length,y=e(t,0,d,i,!0),m=[];if(!y||y.next===y.prev)return m;if(v&&(y=function(t,n,r,i){var o,s,a,h=[];for(o=0,s=n.length;o<s;o++)(a=e(t,n[o]*i,o<s-1?n[o+1]*i:t.length,i,!1))===a.next&&(a.steiner=!0),h.push(f(a));for(h.sort(u),o=0;o<h.length;o++)r=l(h[o],r);return r}(t,n,y,i)),t.length>80*i){o=a=t[0],s=h=t[1];for(var _=i;_<d;_+=i)(c=t[_])<o&&(o=c),(g=t[_+1])<s&&(s=g),c>a&&(a=c),g>h&&(h=g);p=0!==(p=Math.max(a-o,h-s))?32767/p:0}return r(y,m,i,o,s,p,0),m}function e(t,e,n,r,i){var o,s;if(i===I(t,e,n,r)>0)for(o=e;o<n;o+=r)s=k(o,t[o],t[o+1],s);else for(o=n-r;o>=e;o-=r)s=k(o,t[o],t[o+1],s);return s&&d(s,s.next)&&(b(s),s=s.next),s}function n(t,e){if(!t)return t;e||(e=t);var n,r=t;do{if(n=!1,r.steiner||!d(r,r.next)&&0!==v(r.prev,r,r.next))r=r.next;else{if(b(r),(r=e=r.prev)===r.next)break;n=!0}}while(n||r!==e);return e}function r(t,e,u,l,h,f,g){if(t){!g&&f&&function(t,e,n,r){var i=t;do{0===i.z&&(i.z=c(i.x,i.y,e,n,r)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next}while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,function(t){var e,n,r,i,o,s,a,u,l=1;do{for(n=t,t=null,o=null,s=0;n;){for(s++,r=n,a=0,e=0;e<l&&(a++,r=r.nextZ);e++);for(u=l;a>0||u>0&&r;)0!==a&&(0===u||!r||n.z<=r.z)?(i=n,n=n.nextZ,a--):(i=r,r=r.nextZ,u--),o?o.nextZ=i:t=i,i.prevZ=o,o=i;n=r}o.nextZ=null,l*=2}while(s>1)}(i)}(t,l,h,f);for(var p,v,d=t;t.prev!==t.next;)if(p=t.prev,v=t.next,f?o(t,l,h,f):i(t))e.push(p.i/u|0),e.push(t.i/u|0),e.push(v.i/u|0),b(t),t=v.next,d=v.next;else if((t=v)===d){g?1===g?r(t=s(n(t),e,u),e,u,l,h,f,2):2===g&&a(t,e,u,l,h,f):r(n(t),e,u,l,h,f,1);break}}}function i(t){var e=t.prev,n=t,r=t.next;if(v(e,n,r)>=0)return!1;for(var i=e.x,o=n.x,s=r.x,a=e.y,u=n.y,l=r.y,h=i<o?i<s?i:s:o<s?o:s,c=a<u?a<l?a:l:u<l?u:l,f=i>o?i>s?i:s:o>s?o:s,p=a>u?a>l?a:l:u>l?u:l,d=r.next;d!==e;){if(d.x>=h&&d.x<=f&&d.y>=c&&d.y<=p&&g(i,a,o,u,s,l,d.x,d.y)&&v(d.prev,d,d.next)>=0)return!1;d=d.next}return!0}function o(t,e,n,r){var i=t.prev,o=t,s=t.next;if(v(i,o,s)>=0)return!1;for(var a=i.x,u=o.x,l=s.x,h=i.y,f=o.y,p=s.y,d=a<u?a<l?a:l:u<l?u:l,y=h<f?h<p?h:p:f<p?f:p,m=a>u?a>l?a:l:u>l?u:l,_=h>f?h>p?h:p:f>p?f:p,x=c(d,y,e,n,r),E=c(m,_,e,n,r),k=t.prevZ,b=t.nextZ;k&&k.z>=x&&b&&b.z<=E;){if(k.x>=d&&k.x<=m&&k.y>=y&&k.y<=_&&k!==i&&k!==s&&g(a,h,u,f,l,p,k.x,k.y)&&v(k.prev,k,k.next)>=0)return!1;if(k=k.prevZ,b.x>=d&&b.x<=m&&b.y>=y&&b.y<=_&&b!==i&&b!==s&&g(a,h,u,f,l,p,b.x,b.y)&&v(b.prev,b,b.next)>=0)return!1;b=b.nextZ}for(;k&&k.z>=x;){if(k.x>=d&&k.x<=m&&k.y>=y&&k.y<=_&&k!==i&&k!==s&&g(a,h,u,f,l,p,k.x,k.y)&&v(k.prev,k,k.next)>=0)return!1;k=k.prevZ}for(;b&&b.z<=E;){if(b.x>=d&&b.x<=m&&b.y>=y&&b.y<=_&&b!==i&&b!==s&&g(a,h,u,f,l,p,b.x,b.y)&&v(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function s(t,e,r){var i=t;do{var o=i.prev,s=i.next.next;!d(o,s)&&y(o,i,i.next,s)&&x(o,s)&&x(s,o)&&(e.push(o.i/r|0),e.push(i.i/r|0),e.push(s.i/r|0),b(i),b(i.next),i=t=s),i=i.next}while(i!==t);return n(i)}function a(t,e,i,o,s,a){var u=t;do{for(var l=u.next.next;l!==u.prev;){if(u.i!==l.i&&p(u,l)){var h=E(u,l);return u=n(u,u.next),h=n(h,h.next),r(u,e,i,o,s,a,0),void r(h,e,i,o,s,a,0)}l=l.next}u=u.next}while(u!==t)}function u(t,e){return t.x-e.x}function l(t,e){var r=function(t,e){var n,r=e,i=t.x,o=t.y,s=-1/0;do{if(o<=r.y&&o>=r.next.y&&r.next.y!==r.y){var a=r.x+(o-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(a<=i&&a>s&&(s=a,n=r.x<r.next.x?r:r.next,a===i))return n}r=r.next}while(r!==e);if(!n)return null;var u,l=n,c=n.x,f=n.y,p=1/0;r=n;do{i>=r.x&&r.x>=c&&i!==r.x&&g(o<f?i:s,o,c,f,o<f?s:i,o,r.x,r.y)&&(u=Math.abs(o-r.y)/(i-r.x),x(r,t)&&(u<p||u===p&&(r.x>n.x||r.x===n.x&&h(n,r)))&&(n=r,p=u)),r=r.next}while(r!==l);return n}(t,e);if(!r)return e;var i=E(r,t);return n(i,i.next),n(r,r.next)}function h(t,e){return v(t.prev,t,e.prev)<0&&v(e.next,t,t.next)<0}function c(t,e,n,r,i){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-n)*i|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-r)*i|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function f(t){var e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function g(t,e,n,r,i,o,s,a){return(i-s)*(e-a)>=(t-s)*(o-a)&&(t-s)*(r-a)>=(n-s)*(e-a)&&(n-s)*(o-a)>=(i-s)*(r-a)}function p(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){var n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&y(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(x(t,e)&&x(e,t)&&function(t,e){var n=t,r=!1,i=(t.x+e.x)/2,o=(t.y+e.y)/2;do{n.y>o!=n.next.y>o&&n.next.y!==n.y&&i<(n.next.x-n.x)*(o-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==t);return r}(t,e)&&(v(t.prev,t,e.prev)||v(t,e.prev,e))||d(t,e)&&v(t.prev,t,t.next)>0&&v(e.prev,e,e.next)>0)}function v(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function d(t,e){return t.x===e.x&&t.y===e.y}function y(t,e,n,r){var i=_(v(t,e,n)),o=_(v(t,e,r)),s=_(v(n,r,t)),a=_(v(n,r,e));return i!==o&&s!==a||(!(0!==i||!m(t,n,e))||(!(0!==o||!m(t,r,e))||(!(0!==s||!m(n,t,r))||!(0!==a||!m(n,e,r)))))}function m(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function _(t){return t>0?1:t<0?-1:0}function x(t,e){return v(t.prev,t,t.next)<0?v(t,e,t.next)>=0&&v(t,t.prev,e)>=0:v(t,e,t.prev)<0||v(t,t.next,e)<0}function E(t,e){var n=new w(t.i,t.x,t.y),r=new w(e.i,e.x,e.y),i=t.next,o=e.prev;return t.next=e,e.prev=t,n.next=i,i.prev=n,r.next=n,n.prev=r,o.next=r,r.prev=o,r}function k(t,e,n,r){var i=new w(t,e,n);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function b(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function w(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function I(t,e,n,r){for(var i=0,o=e,s=n-r;o<n;o+=r)i+=(t[s]-t[o])*(t[o+1]+t[s+1]),s=o;return i}return kl=1,bl.exports=t,bl.exports.default=t,t.deviation=function(t,e,n,r){var i=e&&e.length,o=i?e[0]*n:t.length,s=Math.abs(I(t,0,o,n));if(i)for(var a=0,u=e.length;a<u;a++){var l=e[a]*n,h=a<u-1?e[a+1]*n:t.length;s-=Math.abs(I(t,l,h,n))}var c=0;for(a=0;a<r.length;a+=3){var f=r[a]*n,g=r[a+1]*n,p=r[a+2]*n;c+=Math.abs((t[f]-t[p])*(t[g+1]-t[f+1])-(t[f]-t[g])*(t[p+1]-t[f+1]))}return 0===s&&0===c?0:Math.abs((c-s)/s)},t.flatten=function(t){for(var e=t[0][0].length,n={vertices:[],holes:[],dimensions:e},r=0,i=0;i<t.length;i++){for(var o=0;o<t[i].length;o++)for(var s=0;s<e;s++)n.vertices.push(t[i][o][s]);i>0&&(r+=t[i-1].length,n.holes.push(r))}return n},bl.exports}(),Il=mn(wl);function Nl(t){var e=function(t){for(var e=t[0][0].length,n={vertices:[],holes:[],dimensions:e},r=0,i=0;i<t.length;i++){for(var o=0;o<t[i].length;o++)for(var s=0;s<e;s++)n.vertices.push(t[i][o][s]);i>0&&(r+=t[i-1].length,n.holes.push(r))}return n}(t),n=Il(e.vertices,e.holes,2),r=[],i=[];n.forEach((function(t,r){var o=n[r];i.push([e.vertices[2*o],e.vertices[2*o+1]])}));for(var o=0;o<i.length;o+=3){var s=i.slice(o,o+3);s.push(i[o]),r.push(S([s]))}return r}function Sl(t,e,n){if("Polygon"!==t.geometry.type)throw new Error("The input feature must be a Polygon");void 0===n&&(n=1);var r=t.geometry.coordinates,i=[],o={};if(n){for(var s=[],a=0;a<r.length;a++)for(var u=0;u<r[a].length-1;u++)s.push(v(a,u));var l=new qe;l.load(s)}for(var h=0;h<r.length;h++)for(var c=0;c<r[h].length-1;c++){if(n)l.search(v(h,c)).forEach((function(t){var e=t.ring,n=t.edge;p(h,c,e,n)}));else for(var f=0;f<r.length;f++)for(var g=0;g<r[f].length-1;g++)p(h,c,f,g)}return e||(i={type:"Feature",geometry:{type:"MultiPoint",coordinates:i}}),i;function p(t,n,s,a){var u,l,h=r[t][n],c=r[t][n+1],f=r[s][a],g=r[s][a+1],p=function(t,e,n,r){if(Ml(t,n)||Ml(t,r)||Ml(e,n)||Ml(r,n))return null;var i=t[0],o=t[1],s=e[0],a=e[1],u=n[0],l=n[1],h=r[0],c=r[1],f=(i-s)*(l-c)-(o-a)*(u-h);if(0===f)return null;var g=((i*a-o*s)*(u-h)-(i-s)*(u*c-l*h))/f,p=((i*a-o*s)*(l-c)-(o-a)*(u*c-l*h))/f;return[g,p]}(h,c,f,g);if(null!==p&&(u=c[0]!==h[0]?(p[0]-h[0])/(c[0]-h[0]):(p[1]-h[1])/(c[1]-h[1]),l=g[0]!==f[0]?(p[0]-f[0])/(g[0]-f[0]):(p[1]-f[1])/(g[1]-f[1]),!(u>=1||u<=0||l>=1||l<=0))){var v=p,d=!o[v];d&&(o[v]=!0),e?i.push(e(p,t,n,h,c,u,s,a,f,g,l,d)):i.push(p)}}function v(t,e){var n,i,o,s,a=r[t][e],u=r[t][e+1];return a[0]<u[0]?(n=a[0],i=u[0]):(n=u[0],i=a[0]),a[1]<u[1]?(o=a[1],s=u[1]):(o=u[1],s=a[1]),{minX:n,minY:o,maxX:i,maxY:s,ring:t,edge:e}}}function Ml(t,e){if(!t||!e)return!1;if(t.length!==e.length)return!1;for(var n=0,r=t.length;n<r;n++)if(t[n]instanceof Array&&e[n]instanceof Array){if(!Ml(t[n],e[n]))return!1}else if(t[n]!==e[n])return!1;return!0}function Ll(t){if("Feature"!=t.type)throw new Error("The input must a geojson object of type Feature");if(void 0===t.geometry||null==t.geometry)throw new Error("The input must a geojson object with a non-empty geometry");if("Polygon"!=t.geometry.type)throw new Error("The input must be a geojson Polygon");for(var e=t.geometry.coordinates.length,n=[],r=0;r<e;r++){var i=t.geometry.coordinates[r];Rl(i[0],i[i.length-1])||i.push(i[0]);for(var o=0;o<i.length-1;o++)n.push(i[o])}if(!function(t){for(var e={},n=1,r=0,i=t.length;r<i;++r){if(Object.prototype.hasOwnProperty.call(e,t[r])){n=0;break}e[t[r]]=1}return n}(n))throw new Error("The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)");var s=n.length,a=Sl(t,(function(t,e,n,r,i,o,s,a,u,l,h,c){return[t,e,n,r,i,o,s,a,u,l,h,c]})),u=a.length;if(0==u){var l=[];for(r=0;r<e;r++)l.push(S([t.geometry.coordinates[r]],{parent:-1,winding:Ol(t.geometry.coordinates[r])}));var h=C(l);return q(),V(),h}var c=[],f=[];for(r=0;r<e;r++){c.push([]);for(o=0;o<t.geometry.coordinates[r].length-1;o++)c[r].push([new Pl(t.geometry.coordinates[r][Al(o+1,t.geometry.coordinates[r].length-1)],1,[r,o],[r,Al(o+1,t.geometry.coordinates[r].length-1)],void 0)]),f.push(new Cl(t.geometry.coordinates[r][o],[r,Al(o-1,t.geometry.coordinates[r].length-1)],[r,o],void 0,void 0,!1,!0))}for(r=0;r<u;r++)c[a[r][1]][a[r][2]].push(new Pl(a[r][0],a[r][5],[a[r][1],a[r][2]],[a[r][6],a[r][7]],void 0)),a[r][11]&&f.push(new Cl(a[r][0],[a[r][1],a[r][2]],[a[r][6],a[r][7]],void 0,void 0,!0,!0));var g=f.length;for(r=0;r<c.length;r++)for(o=0;o<c[r].length;o++)c[r][o].sort((function(t,e){return t.param<e.param?-1:1}));var p=[];for(r=0;r<g;r++)p.push({minX:f[r].coord[0],minY:f[r].coord[1],maxX:f[r].coord[0],maxY:f[r].coord[1],index:r});var v=new qe;v.load(p);for(r=0;r<c.length;r++)for(o=0;o<c[r].length;o++)for(var d=0;d<c[r][o].length;d++){m=d==c[r][o].length-1?c[r][Al(o+1,t.geometry.coordinates[r].length-1)][0].coord:c[r][o][d+1].coord;var y=v.search({minX:m[0],minY:m[1],maxX:m[0],maxY:m[1]})[0];c[r][o][d].nxtIsectAlongEdgeIn=y.index}for(r=0;r<c.length;r++)for(o=0;o<c[r].length;o++)for(d=0;d<c[r][o].length;d++){var m=c[r][o][d].coord,_=(y=v.search({minX:m[0],minY:m[1],maxX:m[0],maxY:m[1]})[0]).index;_<s?f[_].nxtIsectAlongRingAndEdge2=c[r][o][d].nxtIsectAlongEdgeIn:Rl(f[_].ringAndEdge1,c[r][o][d].ringAndEdgeIn)?f[_].nxtIsectAlongRingAndEdge1=c[r][o][d].nxtIsectAlongEdgeIn:f[_].nxtIsectAlongRingAndEdge2=c[r][o][d].nxtIsectAlongEdgeIn}var x=[];for(r=0,o=0;o<e;o++){var E=r;for(d=0;d<t.geometry.coordinates[o].length-1;d++)f[r].coord[0]<f[E].coord[0]&&(E=r),r++;var k=f[E].nxtIsectAlongRingAndEdge2;for(d=0;d<f.length;d++)if(f[d].nxtIsectAlongRingAndEdge1==E||f[d].nxtIsectAlongRingAndEdge2==E){var b=d;break}var w=Tl([f[b].coord,f[E].coord,f[k].coord],!0)?1:-1;x.push({isect:E,parent:-1,winding:w})}x.sort((function(t,e){return f[t.isect].coord>f[e.isect].coord?-1:1}));for(l=[];x.length>0;){var I=x.pop(),N=I.isect,M=I.parent,L=I.winding,P=l.length,T=[f[N].coord],O=N;if(f[N].ringAndEdge1Walkable)var R=f[N].ringAndEdge1,A=f[N].nxtIsectAlongRingAndEdge1;else R=f[N].ringAndEdge2,A=f[N].nxtIsectAlongRingAndEdge2;for(;!Rl(f[N].coord,f[A].coord);){T.push(f[A].coord);var D=void 0;for(r=0;r<x.length;r++)if(x[r].isect==A){D=r;break}if(null!=D&&x.splice(D,1),Rl(R,f[A].ringAndEdge1)){if(R=f[A].ringAndEdge2,f[A].ringAndEdge2Walkable=!1,f[A].ringAndEdge1Walkable){var F={isect:A};Tl([f[O].coord,f[A].coord,f[f[A].nxtIsectAlongRingAndEdge2].coord],1==L)?(F.parent=M,F.winding=-L):(F.parent=P,F.winding=L),x.push(F)}O=A,A=f[A].nxtIsectAlongRingAndEdge2}else{if(R=f[A].ringAndEdge1,f[A].ringAndEdge1Walkable=!1,f[A].ringAndEdge2Walkable){F={isect:A};Tl([f[O].coord,f[A].coord,f[f[A].nxtIsectAlongRingAndEdge1].coord],1==L)?(F.parent=M,F.winding=-L):(F.parent=P,F.winding=L),x.push(F)}O=A,A=f[A].nxtIsectAlongRingAndEdge1}}T.push(f[A].coord),l.push(S([T],{index:P,parent:M,winding:L,netWinding:void 0}))}h=C(l);function q(){for(var t=[],e=0;e<h.features.length;e++)-1==h.features[e].properties.parent&&t.push(e);if(t.length>1)for(e=0;e<t.length;e++){for(var n=-1,r=0;r<h.features.length;r++)t[e]!=r&&zt(h.features[t[e]].geometry.coordinates[0][0],h.features[r],{ignoreBoundary:!0})&&Lt(h.features[r])<Infinity&&(n=r);h.features[t[e]].properties.parent=n}}function V(){for(var t=0;t<h.features.length;t++)if(-1==h.features[t].properties.parent){var e=h.features[t].properties.winding;h.features[t].properties.netWinding=e,G(t,e)}}function G(t,e){for(var n=0;n<h.features.length;n++)if(h.features[n].properties.parent==t){var r=e+h.features[n].properties.winding;h.features[n].properties.netWinding=r,G(n,r)}}return q(),V(),h}var Pl=function(t,e,n,r,i){this.coord=t,this.param=e,this.ringAndEdgeIn=n,this.ringAndEdgeOut=r,this.nxtIsectAlongEdgeIn=i},Cl=function(t,e,n,r,i,o,s){this.coord=t,this.ringAndEdge1=e,this.ringAndEdge2=n,this.nxtIsectAlongRingAndEdge1=r,this.nxtIsectAlongRingAndEdge2=i,this.ringAndEdge1Walkable=o,this.ringAndEdge2Walkable=s};function Tl(t,e){if(void 0===e&&(e=!0),3!=t.length)throw new Error("This function requires an array of three points [x,y]");return(t[1][0]-t[0][0])*(t[2][1]-t[0][1])-(t[1][1]-t[0][1])*(t[2][0]-t[0][0])>=0==e}function Ol(t){for(var e=0,n=0;n<t.length-1;n++)t[n][0]<t[e][0]&&(e=n);if(Tl([t[Al(e-1,t.length-1)],t[e],t[Al(e+1,t.length-1)]],!0))var r=1;else r=-1;return r}function Rl(t,e){if(!t||!e)return!1;if(t.length!=e.length)return!1;for(var n=0,r=t.length;n<r;n++)if(t[n]instanceof Array&&e[n]instanceof Array){if(!Rl(t[n],e[n]))return!1}else if(t[n]!=e[n])return!1;return!0}function Al(t,e){return(t%e+e)%e}function Dl(t){return function(){return t}}function Fl(t){return t[0]}function ql(t){return t[1]}function Vl(){this._=null}function Gl(t){t.U=t.C=t.L=t.R=t.P=t.N=null}function Bl(t,e){var n=e,r=e.R,i=n.U;i?i.L===n?i.L=r:i.R=r:t._=r,r.U=i,n.U=r,n.R=r.L,n.R&&(n.R.U=n),r.L=n}function Yl(t,e){var n=e,r=e.L,i=n.U;i?i.L===n?i.L=r:i.R=r:t._=r,r.U=i,n.U=r,n.L=r.R,n.L&&(n.L.U=n),r.R=n}function zl(t){for(;t.L;)t=t.L;return t}function jl(t,e,n,r){var i=[null,null],o=ph.push(i)-1;return i.left=t,i.right=e,n&&Ul(i,t,e,n),r&&Ul(i,e,t,r),fh[t.index].halfedges.push(o),fh[e.index].halfedges.push(o),i}function Xl(t,e,n){var r=[e,n];return r.left=t,r}function Ul(t,e,n,r){t[0]||t[1]?t.left===n?t[1]=r:t[0]=r:(t[0]=r,t.left=e,t.right=n)}function Zl(t,e,n,r,i){var o,s=t[0],a=t[1],u=s[0],l=s[1],h=0,c=1,f=a[0]-u,g=a[1]-l;if(o=e-u,f||!(o>0)){if(o/=f,f<0){if(o<h)return;o<c&&(c=o)}else if(f>0){if(o>c)return;o>h&&(h=o)}if(o=r-u,f||!(o<0)){if(o/=f,f<0){if(o>c)return;o>h&&(h=o)}else if(f>0){if(o<h)return;o<c&&(c=o)}if(o=n-l,g||!(o>0)){if(o/=g,g<0){if(o<h)return;o<c&&(c=o)}else if(g>0){if(o>c)return;o>h&&(h=o)}if(o=i-l,g||!(o<0)){if(o/=g,g<0){if(o>c)return;o>h&&(h=o)}else if(g>0){if(o<h)return;o<c&&(c=o)}return!(h>0||c<1)||(h>0&&(t[0]=[u+h*f,l+h*g]),c<1&&(t[1]=[u+c*f,l+c*g]),!0)}}}}}function Hl(t,e,n,r,i){var o=t[1];if(o)return!0;var s,a,u=t[0],l=t.left,h=t.right,c=l[0],f=l[1],g=h[0],p=h[1],v=(c+g)/2,d=(f+p)/2;if(p===f){if(v<e||v>=r)return;if(c>g){if(u){if(u[1]>=i)return}else u=[v,n];o=[v,i]}else{if(u){if(u[1]<n)return}else u=[v,i];o=[v,n]}}else if(a=d-(s=(c-g)/(p-f))*v,s<-1||s>1)if(c>g){if(u){if(u[1]>=i)return}else u=[(n-a)/s,n];o=[(i-a)/s,i]}else{if(u){if(u[1]<n)return}else u=[(i-a)/s,i];o=[(n-a)/s,n]}else if(f<p){if(u){if(u[0]>=r)return}else u=[e,s*e+a];o=[r,s*r+a]}else{if(u){if(u[0]<e)return}else u=[r,s*r+a];o=[e,s*e+a]}return t[0]=u,t[1]=o,!0}function Wl(t,e){var n=t.site,r=e.left,i=e.right;return n===i&&(i=r,r=n),i?Math.atan2(i[1]-r[1],i[0]-r[0]):(n===r?(r=e[1],i=e[0]):(r=e[0],i=e[1]),Math.atan2(r[0]-i[0],i[1]-r[1]))}function Jl(t,e){return e[+(e.left!==t.site)]}function Kl(t,e){return e[+(e.left===t.site)]}Vl.prototype={constructor:Vl,insert:function(t,e){var n,r,i;if(t){if(e.P=t,e.N=t.N,t.N&&(t.N.P=e),t.N=e,t.R){for(t=t.R;t.L;)t=t.L;t.L=e}else t.R=e;n=t}else this._?(t=zl(this._),e.P=null,e.N=t,t.P=t.L=e,n=t):(e.P=e.N=null,this._=e,n=null);for(e.L=e.R=null,e.U=n,e.C=!0,t=e;n&&n.C;)n===(r=n.U).L?(i=r.R)&&i.C?(n.C=i.C=!1,r.C=!0,t=r):(t===n.R&&(Bl(this,n),n=(t=n).U),n.C=!1,r.C=!0,Yl(this,r)):(i=r.L)&&i.C?(n.C=i.C=!1,r.C=!0,t=r):(t===n.L&&(Yl(this,n),n=(t=n).U),n.C=!1,r.C=!0,Bl(this,r)),n=t.U;this._.C=!1},remove:function(t){t.N&&(t.N.P=t.P),t.P&&(t.P.N=t.N),t.N=t.P=null;var e,n,r,i=t.U,o=t.L,s=t.R;if(n=o?s?zl(s):o:s,i?i.L===t?i.L=n:i.R=n:this._=n,o&&s?(r=n.C,n.C=t.C,n.L=o,o.U=n,n!==s?(i=n.U,n.U=t.U,t=n.R,i.L=t,n.R=s,s.U=n):(n.U=i,i=n,t=n.R)):(r=t.C,t=n),t&&(t.U=i),!r)if(t&&t.C)t.C=!1;else{do{if(t===this._)break;if(t===i.L){if((e=i.R).C&&(e.C=!1,i.C=!0,Bl(this,i),e=i.R),e.L&&e.L.C||e.R&&e.R.C){e.R&&e.R.C||(e.L.C=!1,e.C=!0,Yl(this,e),e=i.R),e.C=i.C,i.C=e.R.C=!1,Bl(this,i),t=this._;break}}else if((e=i.L).C&&(e.C=!1,i.C=!0,Yl(this,i),e=i.L),e.L&&e.L.C||e.R&&e.R.C){e.L&&e.L.C||(e.R.C=!1,e.C=!0,Bl(this,e),e=i.L),e.C=i.C,i.C=e.L.C=!1,Yl(this,i),t=this._;break}e.C=!0,t=i,i=i.U}while(!t.C);t&&(t.C=!1)}}};var Ql,$l=[];function th(){Gl(this),this.x=this.y=this.arc=this.site=this.cy=null}function eh(t){var e=t.P,n=t.N;if(e&&n){var r=e.site,i=t.site,o=n.site;if(r!==o){var s=i[0],a=i[1],u=r[0]-s,l=r[1]-a,h=o[0]-s,c=o[1]-a,f=2*(u*c-l*h);if(!(f>=-dh)){var g=u*u+l*l,p=h*h+c*c,v=(c*g-l*p)/f,d=(u*p-h*g)/f,y=$l.pop()||new th;y.arc=t,y.site=i,y.x=v+s,y.y=(y.cy=d+a)+Math.sqrt(v*v+d*d),t.circle=y;for(var m=null,_=gh._;_;)if(y.y<_.y||y.y===_.y&&y.x<=_.x){if(!_.L){m=_.P;break}_=_.L}else{if(!_.R){m=_;break}_=_.R}gh.insert(m,y),m||(Ql=y)}}}}function nh(t){var e=t.circle;e&&(e.P||(Ql=e.N),gh.remove(e),$l.push(e),Gl(e),t.circle=null)}var rh=[];function ih(){Gl(this),this.edge=this.site=this.circle=null}function oh(t){var e=rh.pop()||new ih;return e.site=t,e}function sh(t){nh(t),ch.remove(t),rh.push(t),Gl(t)}function ah(t){var e=t.circle,n=e.x,r=e.cy,i=[n,r],o=t.P,s=t.N,a=[t];sh(t);for(var u=o;u.circle&&Math.abs(n-u.circle.x)<vh&&Math.abs(r-u.circle.cy)<vh;)o=u.P,a.unshift(u),sh(u),u=o;a.unshift(u),nh(u);for(var l=s;l.circle&&Math.abs(n-l.circle.x)<vh&&Math.abs(r-l.circle.cy)<vh;)s=l.N,a.push(l),sh(l),l=s;a.push(l),nh(l);var h,c=a.length;for(h=1;h<c;++h)l=a[h],u=a[h-1],Ul(l.edge,u.site,l.site,i);u=a[0],(l=a[c-1]).edge=jl(u.site,l.site,null,i),eh(u),eh(l)}function uh(t){for(var e,n,r,i,o=t[0],s=t[1],a=ch._;a;)if((r=lh(a,s)-o)>vh)a=a.L;else{if(!((i=o-hh(a,s))>vh)){r>-vh?(e=a.P,n=a):i>-vh?(e=a,n=a.N):e=n=a;break}if(!a.R){e=a;break}a=a.R}!function(t){fh[t.index]={site:t,halfedges:[]}}(t);var u=oh(t);if(ch.insert(e,u),e||n){if(e===n)return nh(e),n=oh(e.site),ch.insert(u,n),u.edge=n.edge=jl(e.site,u.site),eh(e),void eh(n);if(n){nh(e),nh(n);var l=e.site,h=l[0],c=l[1],f=t[0]-h,g=t[1]-c,p=n.site,v=p[0]-h,d=p[1]-c,y=2*(f*d-g*v),m=f*f+g*g,_=v*v+d*d,x=[(d*m-g*_)/y+h,(f*_-v*m)/y+c];Ul(n.edge,l,p,x),u.edge=jl(l,t,null,x),n.edge=jl(t,p,null,x),eh(e),eh(n)}else u.edge=jl(e.site,u.site)}}function lh(t,e){var n=t.site,r=n[0],i=n[1],o=i-e;if(!o)return r;var s=t.P;if(!s)return-1/0;var a=(n=s.site)[0],u=n[1],l=u-e;if(!l)return a;var h=a-r,c=1/o-1/l,f=h/l;return c?(-f+Math.sqrt(f*f-2*c*(h*h/(-2*l)-u+l/2+i-o/2)))/c+r:(r+a)/2}function hh(t,e){var n=t.N;if(n)return lh(n,e);var r=t.site;return r[1]===e?r[0]:1/0}var ch,fh,gh,ph,vh=1e-6,dh=1e-12;function yh(t,e){return e[1]-t[1]||e[0]-t[0]}function mh(t,e){var n,r,i,o=t.sort(yh).pop();for(ph=[],fh=new Array(t.length),ch=new Vl,gh=new Vl;;)if(i=Ql,o&&(!i||o[1]<i.y||o[1]===i.y&&o[0]<i.x))o[0]===n&&o[1]===r||(uh(o),n=o[0],r=o[1]),o=t.pop();else{if(!i)break;ah(i.arc)}if(function(){for(var t,e,n,r,i=0,o=fh.length;i<o;++i)if((t=fh[i])&&(r=(e=t.halfedges).length)){var s=new Array(r),a=new Array(r);for(n=0;n<r;++n)s[n]=n,a[n]=Wl(t,ph[e[n]]);for(s.sort((function(t,e){return a[e]-a[t]})),n=0;n<r;++n)a[n]=e[s[n]];for(n=0;n<r;++n)e[n]=a[n]}}(),e){var s=+e[0][0],a=+e[0][1],u=+e[1][0],l=+e[1][1];!function(t,e,n,r){for(var i,o=ph.length;o--;)Hl(i=ph[o],t,e,n,r)&&Zl(i,t,e,n,r)&&(Math.abs(i[0][0]-i[1][0])>vh||Math.abs(i[0][1]-i[1][1])>vh)||delete ph[o]}(s,a,u,l),function(t,e,n,r){var i,o,s,a,u,l,h,c,f,g,p,v,d=fh.length,y=!0;for(i=0;i<d;++i)if(o=fh[i]){for(s=o.site,a=(u=o.halfedges).length;a--;)ph[u[a]]||u.splice(a,1);for(a=0,l=u.length;a<l;)p=(g=Kl(o,ph[u[a]]))[0],v=g[1],c=(h=Jl(o,ph[u[++a%l]]))[0],f=h[1],(Math.abs(p-c)>vh||Math.abs(v-f)>vh)&&(u.splice(a,0,ph.push(Xl(s,g,Math.abs(p-t)<vh&&r-v>vh?[t,Math.abs(c-t)<vh?f:r]:Math.abs(v-r)<vh&&n-p>vh?[Math.abs(f-r)<vh?c:n,r]:Math.abs(p-n)<vh&&v-e>vh?[n,Math.abs(c-n)<vh?f:e]:Math.abs(v-e)<vh&&p-t>vh?[Math.abs(f-e)<vh?c:t,e]:null))-1),++l);l&&(y=!1)}if(y){var m,_,x,E=1/0;for(i=0,y=null;i<d;++i)(o=fh[i])&&(x=(m=(s=o.site)[0]-t)*m+(_=s[1]-e)*_)<E&&(E=x,y=o);if(y){var k=[t,e],b=[t,r],w=[n,r],I=[n,e];y.halfedges.push(ph.push(Xl(s=y.site,k,b))-1,ph.push(Xl(s,b,w))-1,ph.push(Xl(s,w,I))-1,ph.push(Xl(s,I,k))-1)}}for(i=0;i<d;++i)(o=fh[i])&&(o.halfedges.length||delete fh[i])}(s,a,u,l)}this.edges=ph,this.cells=fh,ch=gh=ph=fh=null}mh.prototype={constructor:mh,polygons:function(){var t=this.edges;return this.cells.map((function(e){var n=e.halfedges.map((function(n){return Jl(e,t[n])}));return n.data=e.site.data,n}))},triangles:function(){var t=[],e=this.edges;return this.cells.forEach((function(n,r){if(o=(i=n.halfedges).length)for(var i,o,s,a,u,l,h=n.site,c=-1,f=e[i[o-1]],g=f.left===h?f.right:f.left;++c<o;)s=g,g=(f=e[i[c]]).left===h?f.right:f.left,s&&g&&r<s.index&&r<g.index&&(u=s,l=g,((a=h)[0]-l[0])*(u[1]-a[1])-(a[0]-u[0])*(l[1]-a[1])<0)&&t.push([h.data,s.data,g.data])})),t},links:function(){return this.edges.filter((function(t){return t.right})).map((function(t){return{source:t.left.data,target:t.right.data}}))},find:function(t,e,n){for(var r,i,o=this,s=o._found||0,a=o.cells.length;!(i=o.cells[s]);)if(++s>=a)return null;var u=t-i.site[0],l=e-i.site[1],h=u*u+l*l;do{i=o.cells[r=s],s=null,i.halfedges.forEach((function(n){var r=o.edges[n],a=r.left;if(a!==i.site&&a||(a=r.right)){var u=t-a[0],l=e-a[1],c=u*u+l*l;c<h&&(h=c,s=a.index)}}))}while(null!==s);return o._found=r,null==n||h<=n*n?i.site:null}},t.along=function(t,e){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=rt(t).coordinates,i=0,o=0;o<r.length&&!(e>=i&&o===r.length-1);o++){if(i>=e){var s=e-i;if(s){var a=st(r[o],r[o-1])-180;return at(r[o],s,a,n)}return I(r[o])}i+=ut(r[o],r[o+1],n)}return I(r[r.length-1])},t.angle=function(t,e,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(!Z(r))throw new Error("options is invalid");if(!t)throw new Error("startPoint is required");if(!e)throw new Error("midPoint is required");if(!n)throw new Error("endPoint is required");var i=t,o=e,s=n,a=G(!0!==r.mercator?st(o,i):lt(o,i)),u=G(!0!==r.mercator?st(o,s):lt(o,s));u<a&&(u+=360);var l=u-a;return!0===r.explementary?360-l:l},t.applyFilter=ji,t.area=Lt,t.areaFactors=k,t.azimuthToBearing=B,t.bbox=Rt,t.bboxClip=function(t,e){var n=rt(t),r=n.type,i="Feature"===t.type?t.properties:{},o=n.coordinates;switch(r){case"LineString":case"MultiLineString":var s=[];return"LineString"===r&&(o=[o]),o.forEach((function(t){!function(t,e,n){var r,i,o,s,a,u=t.length,l=Ft(t[0],e),h=[];for(n||(n=[]),r=1;r<u;r++){for(s=t[r-1],i=o=Ft(a=t[r],e);;){if(!(l|i)){h.push(s),i!==o?(h.push(a),r<u-1&&(n.push(h),h=[])):r===u-1&&h.push(a);break}if(l&i)break;l?l=Ft(s=Dt(s,a,l,e),e):i=Ft(a=Dt(s,a,i,e),e)}l=o}h.length&&n.push(h)}(t,e,s)})),1===s.length?L(s[0],i):T(s,i);case"Polygon":return S(qt(o,e),i);case"MultiPolygon":return R(o.map((function(t){return qt(t,e)})),i);default:throw new Error("geometry "+r+" not supported")}},t.bboxPolygon=Vt,t.bearing=st,t.bearingToAzimuth=G,t.bezierSpline=function(t){for(var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e.resolution||1e4,r=e.sharpness||.85,i=[],o=rt(t).coordinates.map((function(t){return{x:t[0],y:t[1]}})),s=new Gt({duration:n,points:o,sharpness:r}),a=function(t){var e=s.pos(t);Math.floor(t/100)%2==0&&i.push([e.x,e.y])},u=0;u<s.duration;u+=10)a(u);return a(s.duration),L(i,e.properties)},t.booleanClockwise=Bt,t.booleanConcave=function(t){var e=rt(t).coordinates;if(e[0].length<=4)return!1;for(var n=!1,r=e[0].length-1,i=0;i<r;i++){var o=e[0][(i+2)%r][0]-e[0][(i+1)%r][0],s=e[0][(i+2)%r][1]-e[0][(i+1)%r][1],a=e[0][i][0]-e[0][(i+1)%r][0],u=o*(e[0][i][1]-e[0][(i+1)%r][1])-s*a;if(0===i)n=u>0;else if(n!==u>0)return!0}return!1},t.booleanContains=function(t,e){var n=rt(t),r=rt(e),i=n.type,o=r.type,s=n.coordinates,u=r.coordinates;switch(i){case"Point":if("Point"===o)return Ht(s,u);throw new Error("feature2 "+o+" geometry not supported");case"MultiPoint":switch(o){case"Point":return function(t,e){var n,r=!1;for(n=0;n<t.coordinates.length;n++)if(Ht(t.coordinates[n],e.coordinates)){r=!0;break}return r}(n,r);case"MultiPoint":return function(t,e){var n,r=a(e.coordinates);try{for(r.s();!(n=r.n()).done;){var i,o=n.value,s=!1,u=a(t.coordinates);try{for(u.s();!(i=u.n()).done;){if(Ht(o,i.value)){s=!0;break}}}catch(t){u.e(t)}finally{u.f()}if(!s)return!1}}catch(t){r.e(t)}finally{r.f()}return!0}(n,r);default:throw new Error("feature2 "+o+" geometry not supported")}case"LineString":switch(o){case"Point":return jt(r,n,{ignoreEndVertices:!0});case"LineString":return function(t,e){var n,r=!1,i=a(e.coordinates);try{for(i.s();!(n=i.n()).done;){var o=n.value;if(jt({type:"Point",coordinates:o},t,{ignoreEndVertices:!0})&&(r=!0),!jt({type:"Point",coordinates:o},t,{ignoreEndVertices:!1}))return!1}}catch(t){i.e(t)}finally{i.f()}return r}(n,r);case"MultiPoint":return function(t,e){var n,r=!1,i=a(e.coordinates);try{for(i.s();!(n=i.n()).done;){var o=n.value;if(jt(o,t,{ignoreEndVertices:!0})&&(r=!0),!jt(o,t))return!1}}catch(t){i.e(t)}finally{i.f()}if(r)return!0;return!1}(n,r);default:throw new Error("feature2 "+o+" geometry not supported")}case"Polygon":switch(o){case"Point":return zt(r,n,{ignoreBoundary:!0});case"LineString":return function(t,e){var n=!1,r=0,i=Rt(t),o=Rt(e);if(!Zt(i,o))return!1;for(;r<e.coordinates.length-1;r++){if(zt({type:"Point",coordinates:Wt(e.coordinates[r],e.coordinates[r+1])},t,{ignoreBoundary:!0})){n=!0;break}}return n}(n,r);case"Polygon":return Ut(n,r);case"MultiPoint":return function(t,e){var n,r=a(e.coordinates);try{for(r.s();!(n=r.n()).done;){if(!zt(n.value,t,{ignoreBoundary:!0}))return!1}}catch(t){r.e(t)}finally{r.f()}return!0}(n,r);default:throw new Error("feature2 "+o+" geometry not supported")}case"MultiPolygon":if("Polygon"===o)return function(t,e){return t.coordinates.some((function(t){return Ut({type:"Polygon",coordinates:t},e)}))}(n,r);throw new Error("feature2 "+o+" geometry not supported");default:throw new Error("feature1 "+i+" geometry not supported")}},t.booleanCrosses=ce,t.booleanDisjoint=de,t.booleanEqual=function(t,e){var n=(arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}).precision;if("number"!=typeof(n=null==n||isNaN(n)?6:n)||!(n>=0))throw new Error("precision must be a positive number");return rt(t).type===rt(e).type&&Ne(Le(t),Le(e),{precision:n})},t.booleanIntersects=Oe,t.booleanOverlap=function(t,e){var n=rt(t),r=rt(e),i=n.type,o=r.type;if("MultiPoint"===i&&"MultiPoint"!==o||("LineString"===i||"MultiLineString"===i)&&"LineString"!==o&&"MultiLineString"!==o||("Polygon"===i||"MultiPolygon"===i)&&"Polygon"!==o&&"MultiPolygon"!==o)throw new Error("features must be of the same type");if("Point"===i)throw new Error("Point geometry not supported");if(Ne(t,e,{precision:6}))return!1;var s=0;switch(i){case"MultiPoint":for(var a=0;a<n.coordinates.length;a++)for(var u=0;u<r.coordinates.length;u++){var l=n.coordinates[a],h=r.coordinates[u];if(l[0]===h[0]&&l[1]===h[1])return!0}return!1;case"LineString":case"MultiLineString":kt(t,(function(t){kt(e,(function(e){kn(t,e).features.length&&s++}))}));break;case"Polygon":case"MultiPolygon":kt(t,(function(t){kt(e,(function(e){ue(t,e).features.length&&s++}))}))}return s>0},t.booleanParallel=function(t,e){if(!t)throw new Error("line1 is required");if(!e)throw new Error("line2 is required");if("LineString"!==In(t,"line1"))throw new Error("line1 must be a LineString");if("LineString"!==In(e,"line2"))throw new Error("line2 must be a LineString");for(var n=$e(Le(t)).features,r=$e(Le(e)).features,i=0;i<n.length;i++){var o=n[i].geometry.coordinates;if(!r[i])break;if(!wn(o,r[i].geometry.coordinates))return!1}return!0},t.booleanPointInPolygon=zt,t.booleanPointOnLine=jt,t.booleanTouches=function(t,e){var n=rt(t),r=rt(e),i=n.type,o=r.type;switch(i){case"Point":switch(o){case"LineString":return Nn(n,r);case"MultiLineString":for(var s=!1,a=0;a<r.coordinates.length;a++)Nn(n,{type:"LineString",coordinates:r.coordinates[a]})&&(s=!0);return s;case"Polygon":for(var u=0;u<r.coordinates.length;u++)if(jt(n,{type:"LineString",coordinates:r.coordinates[u]}))return!0;return!1;case"MultiPolygon":for(u=0;u<r.coordinates.length;u++)for(a=0;a<r.coordinates[u].length;a++)if(jt(n,{type:"LineString",coordinates:r.coordinates[u][a]}))return!0;return!1;default:throw new Error("feature2 "+o+" geometry not supported")}case"MultiPoint":switch(o){case"LineString":for(s=!1,u=0;u<n.coordinates.length;u++)if(s||Nn({type:"Point",coordinates:n.coordinates[u]},r)&&(s=!0),jt({type:"Point",coordinates:n.coordinates[u]},r,{ignoreEndVertices:!0}))return!1;return s;case"MultiLineString":for(s=!1,u=0;u<n.coordinates.length;u++)for(a=0;a<r.coordinates.length;a++)if(s||Nn({type:"Point",coordinates:n.coordinates[u]},{type:"LineString",coordinates:r.coordinates[a]})&&(s=!0),jt({type:"Point",coordinates:n.coordinates[u]},{type:"LineString",coordinates:r.coordinates[a]},{ignoreEndVertices:!0}))return!1;return s;case"Polygon":for(s=!1,u=0;u<n.coordinates.length;u++)if(s||jt({type:"Point",coordinates:n.coordinates[u]},{type:"LineString",coordinates:r.coordinates[0]})&&(s=!0),zt({type:"Point",coordinates:n.coordinates[u]},r,{ignoreBoundary:!0}))return!1;return s;case"MultiPolygon":for(s=!1,u=0;u<n.coordinates.length;u++)for(a=0;a<r.coordinates.length;a++)if(s||jt({type:"Point",coordinates:n.coordinates[u]},{type:"LineString",coordinates:r.coordinates[a][0]})&&(s=!0),zt({type:"Point",coordinates:n.coordinates[u]},{type:"Polygon",coordinates:r.coordinates[a]},{ignoreBoundary:!0}))return!1;return s;default:throw new Error("feature2 "+o+" geometry not supported")}case"LineString":switch(o){case"Point":return Nn(r,n);case"MultiPoint":for(s=!1,u=0;u<r.coordinates.length;u++)if(s||Nn({type:"Point",coordinates:r.coordinates[u]},n)&&(s=!0),jt({type:"Point",coordinates:r.coordinates[u]},n,{ignoreEndVertices:!0}))return!1;return s;case"LineString":var l=!1;if(Nn({type:"Point",coordinates:n.coordinates[0]},r)&&(l=!0),Nn({type:"Point",coordinates:n.coordinates[n.coordinates.length-1]},r)&&(l=!0),!1===l)return!1;for(u=0;u<n.coordinates.length;u++)if(jt({type:"Point",coordinates:n.coordinates[u]},r,{ignoreEndVertices:!0}))return!1;return l;case"MultiLineString":for(l=!1,u=0;u<r.coordinates.length;u++){Nn({type:"Point",coordinates:n.coordinates[0]},{type:"LineString",coordinates:r.coordinates[u]})&&(l=!0),Nn({type:"Point",coordinates:n.coordinates[n.coordinates.length-1]},{type:"LineString",coordinates:r.coordinates[u]})&&(l=!0);for(a=0;a<n.coordinates[u].length;a++)if(jt({type:"Point",coordinates:n.coordinates[a]},{type:"LineString",coordinates:r.coordinates[u]},{ignoreEndVertices:!0}))return!1}return l;case"Polygon":for(s=!1,u=0;u<n.coordinates.length;u++)if(s||jt({type:"Point",coordinates:n.coordinates[u]},{type:"LineString",coordinates:r.coordinates[0]})&&(s=!0),zt({type:"Point",coordinates:n.coordinates[u]},r,{ignoreBoundary:!0}))return!1;return s;case"MultiPolygon":for(s=!1,u=0;u<n.coordinates.length;u++){for(a=0;a<r.coordinates.length;a++)s||jt({type:"Point",coordinates:n.coordinates[u]},{type:"LineString",coordinates:r.coordinates[a][0]})&&(s=!0);if(zt({type:"Point",coordinates:n.coordinates[u]},r,{ignoreBoundary:!0}))return!1}return s;default:throw new Error("feature2 "+o+" geometry not supported")}case"MultiLineString":switch(o){case"Point":for(u=0;u<n.coordinates.length;u++)if(Nn(r,{type:"LineString",coordinates:n.coordinates[u]}))return!0;return!1;case"MultiPoint":for(s=!1,u=0;u<n.coordinates.length;u++)for(a=0;a<r.coordinates.length;a++)if(s||Nn({type:"Point",coordinates:r.coordinates[a]},{type:"LineString",coordinates:n.coordinates[a]})&&(s=!0),jt({type:"Point",coordinates:r.coordinates[a]},{type:"LineString",coordinates:n.coordinates[a]},{ignoreEndVertices:!0}))return!1;return s;case"LineString":for(l=!1,u=0;u<n.coordinates.length;u++){Nn({type:"Point",coordinates:n.coordinates[u][0]},r)&&(l=!0),Nn({type:"Point",coordinates:n.coordinates[u][n.coordinates[u].length-1]},r)&&(l=!0);for(a=0;a<r.coordinates.length;a++)if(jt({type:"Point",coordinates:r.coordinates[a]},{type:"LineString",coordinates:n.coordinates[u]},{ignoreEndVertices:!0}))return!1}return l;case"MultiLineString":for(l=!1,u=0;u<n.coordinates.length;u++)for(a=0;a<r.coordinates.length;a++){Nn({type:"Point",coordinates:n.coordinates[u][0]},{type:"LineString",coordinates:r.coordinates[a]})&&(l=!0),Nn({type:"Point",coordinates:n.coordinates[u][n.coordinates[u].length-1]},{type:"LineString",coordinates:r.coordinates[a]})&&(l=!0);for(var h=0;h<n.coordinates[u].length;h++)if(jt({type:"Point",coordinates:n.coordinates[u][h]},{type:"LineString",coordinates:r.coordinates[a]},{ignoreEndVertices:!0}))return!1}return l;case"Polygon":for(s=!1,u=0;u<n.coordinates.length;u++)for(a=0;a<n.coordinates.length;a++)if(s||jt({type:"Point",coordinates:n.coordinates[u][a]},{type:"LineString",coordinates:r.coordinates[0]})&&(s=!0),zt({type:"Point",coordinates:n.coordinates[u][a]},r,{ignoreBoundary:!0}))return!1;return s;case"MultiPolygon":for(s=!1,u=0;u<r.coordinates[0].length;u++)for(a=0;a<n.coordinates.length;a++)for(h=0;h<n.coordinates[a].length;h++)if(s||jt({type:"Point",coordinates:n.coordinates[a][h]},{type:"LineString",coordinates:r.coordinates[0][u]})&&(s=!0),zt({type:"Point",coordinates:n.coordinates[a][h]},{type:"Polygon",coordinates:[r.coordinates[0][u]]},{ignoreBoundary:!0}))return!1;return s;default:throw new Error("feature2 "+o+" geometry not supported")}case"Polygon":switch(o){case"Point":for(u=0;u<n.coordinates.length;u++)if(jt(r,{type:"LineString",coordinates:n.coordinates[u]}))return!0;return!1;case"MultiPoint":for(s=!1,u=0;u<r.coordinates.length;u++)if(s||jt({type:"Point",coordinates:r.coordinates[u]},{type:"LineString",coordinates:n.coordinates[0]})&&(s=!0),zt({type:"Point",coordinates:r.coordinates[u]},n,{ignoreBoundary:!0}))return!1;return s;case"LineString":for(s=!1,u=0;u<r.coordinates.length;u++)if(s||jt({type:"Point",coordinates:r.coordinates[u]},{type:"LineString",coordinates:n.coordinates[0]})&&(s=!0),zt({type:"Point",coordinates:r.coordinates[u]},n,{ignoreBoundary:!0}))return!1;return s;case"MultiLineString":for(s=!1,u=0;u<r.coordinates.length;u++)for(a=0;a<r.coordinates[u].length;a++)if(s||jt({type:"Point",coordinates:r.coordinates[u][a]},{type:"LineString",coordinates:n.coordinates[0]})&&(s=!0),zt({type:"Point",coordinates:r.coordinates[u][a]},n,{ignoreBoundary:!0}))return!1;return s;case"Polygon":for(s=!1,u=0;u<n.coordinates[0].length;u++)if(s||jt({type:"Point",coordinates:n.coordinates[0][u]},{type:"LineString",coordinates:r.coordinates[0]})&&(s=!0),zt({type:"Point",coordinates:n.coordinates[0][u]},r,{ignoreBoundary:!0}))return!1;return s;case"MultiPolygon":for(s=!1,u=0;u<r.coordinates[0].length;u++)for(a=0;a<n.coordinates[0].length;a++)if(s||jt({type:"Point",coordinates:n.coordinates[0][a]},{type:"LineString",coordinates:r.coordinates[0][u]})&&(s=!0),zt({type:"Point",coordinates:n.coordinates[0][a]},{type:"Polygon",coordinates:r.coordinates[0][u]},{ignoreBoundary:!0}))return!1;return s;default:throw new Error("feature2 "+o+" geometry not supported")}case"MultiPolygon":switch(o){case"Point":for(u=0;u<n.coordinates[0].length;u++)if(jt(r,{type:"LineString",coordinates:n.coordinates[0][u]}))return!0;return!1;case"MultiPoint":for(s=!1,u=0;u<n.coordinates[0].length;u++)for(a=0;a<r.coordinates.length;a++)if(s||jt({type:"Point",coordinates:r.coordinates[a]},{type:"LineString",coordinates:n.coordinates[0][u]})&&(s=!0),zt({type:"Point",coordinates:r.coordinates[a]},{type:"Polygon",coordinates:n.coordinates[0][u]},{ignoreBoundary:!0}))return!1;return s;case"LineString":for(s=!1,u=0;u<n.coordinates[0].length;u++)for(a=0;a<r.coordinates.length;a++)if(s||jt({type:"Point",coordinates:r.coordinates[a]},{type:"LineString",coordinates:n.coordinates[0][u]})&&(s=!0),zt({type:"Point",coordinates:r.coordinates[a]},{type:"Polygon",coordinates:n.coordinates[0][u]},{ignoreBoundary:!0}))return!1;return s;case"MultiLineString":for(s=!1,u=0;u<n.coordinates.length;u++)for(a=0;a<r.coordinates.length;a++)for(h=0;h<r.coordinates[a].length;h++)if(s||jt({type:"Point",coordinates:r.coordinates[a][h]},{type:"LineString",coordinates:n.coordinates[u][0]})&&(s=!0),zt({type:"Point",coordinates:r.coordinates[a][h]},{type:"Polygon",coordinates:[n.coordinates[u][0]]},{ignoreBoundary:!0}))return!1;return s;case"Polygon":for(s=!1,u=0;u<n.coordinates[0].length;u++)for(a=0;a<n.coordinates[0][u].length;a++)if(s||jt({type:"Point",coordinates:n.coordinates[0][u][a]},{type:"LineString",coordinates:r.coordinates[0]})&&(s=!0),zt({type:"Point",coordinates:n.coordinates[0][u][a]},r,{ignoreBoundary:!0}))return!1;return s;case"MultiPolygon":for(s=!1,u=0;u<n.coordinates[0].length;u++)for(a=0;a<r.coordinates[0].length;a++)for(h=0;h<n.coordinates[0].length;h++)if(s||jt({type:"Point",coordinates:n.coordinates[0][u][h]},{type:"LineString",coordinates:r.coordinates[0][a]})&&(s=!0),zt({type:"Point",coordinates:n.coordinates[0][u][h]},{type:"Polygon",coordinates:r.coordinates[0][a]},{ignoreBoundary:!0}))return!1;return s;default:throw new Error("feature2 "+o+" geometry not supported")}default:throw new Error("feature1 "+i+" geometry not supported")}},t.booleanValid=function(t){if(!t.type)return!1;var e=rt(t),n=e.type,r=e.coordinates;switch(n){case"Point":return r.length>1;case"MultiPoint":for(var i=0;i<r.length;i++)if(r[i].length<2)return!1;return!0;case"LineString":if(r.length<2)return!1;for(i=0;i<r.length;i++)if(r[i].length<2)return!1;return!0;case"MultiLineString":if(r.length<2)return!1;for(i=0;i<r.length;i++)if(r[i].length<2)return!1;return!0;case"Polygon":for(i=0;i<e.coordinates.length;i++){if(r[i].length<4)return!1;if(!Mn(r[i]))return!1;if(Ln(r[i]))return!1;if(i>0&&ue(S([r[0]]),S([r[i]])).features.length>1)return!1}return!0;case"MultiPolygon":for(i=0;i<e.coordinates.length;i++)for(var o=e.coordinates[i],s=0;s<o.length;s++){if(o[s].length<4)return!1;if(!Mn(o[s]))return!1;if(Ln(o[s]))return!1;if(0===s&&!Pn(o,e.coordinates,i))return!1;if(s>0&&ue(S([o[0]]),S([o[s]])).features.length>1)return!1}return!0;default:return!1}},t.booleanWithin=Cn,t.buffer=function(t,e,n){var r=(n=n||{}).units||"kilometers",i=n.steps||8;if(!t)throw new Error("geojson is required");if("object"!==m(n))throw new Error("options must be an object");if("number"!=typeof i)throw new Error("steps must be an number");if(void 0===e)throw new Error("radius is required");if(i<=0)throw new Error("steps must be greater than 0");var o=[];switch(t.type){case"GeometryCollection":return mt(t,(function(t){var n=ui(t,e,r,i);n&&o.push(n)})),C(o);case"FeatureCollection":return vt(t,(function(t){var n=ui(t,e,r,i);n&&vt(n,(function(t){t&&o.push(t)}))})),C(o)}return ui(t,e,r,i)},t.center=An,t.centerMean=fi,t.centerMedian=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!Z(e=e||{}))throw new Error("options is invalid");var n=e.counter||10;if(!U(n))throw new Error("counter must be a number");var r=e.weight,i=fi(t,{weight:e.weight}),o=C([]);vt(t,(function(t){var e;o.features.push(gi(t,{properties:{weight:null==(e=t.properties)?void 0:e[r]}}))}));var s={tolerance:e.tolerance,medianCandidates:[]};return pi(i.geometry.coordinates,[0,0],o,s,n)},t.centerOfMass=function t(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};switch(it(e)){case"Point":return I(K(e),n.properties);case"Polygon":var r=[];ct(e,(function(t){r.push(t)}));var i,o,s,a,u,l,h,c,f=gi(e,{properties:n.properties}),g=f.geometry.coordinates,p=0,v=0,d=0,y=r.map((function(t){return[t[0]-g[0],t[1]-g[1]]}));for(i=0;i<r.length-1;i++)a=(o=y[i])[0],l=o[1],u=(s=y[i+1])[0],d+=c=a*(h=s[1])-u*l,p+=(a+u)*c,v+=(l+h)*c;if(0===d)return f;var m=1/(6*(.5*d));return I([g[0]+m*p,g[1]+m*v],n.properties);default:var _=Oi(e);return _?t(_,{properties:n.properties}):gi(e,{properties:n.properties})}},t.centroid=gi,t.circle=Ri,t.cleanCoords=Le,t.clone=Ai,t.cloneProperties=Fi,t.clusterEach=Bi,t.clusterReduce=Yi,t.clusters=$i,t.clustersDbscan=function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!0!==n.mutate&&(t=Ai(t));var r=n.minPoints||3,i=V(e,n.units),o=new to(t.features.length),s=t.features.map((function(t){return!1})),a=t.features.map((function(t){return!1})),u=t.features.map((function(t){return!1})),l=t.features.map((function(t){return-1}));o.load(t.features.map((function(t,e){var n=v(t.geometry.coordinates,2),r=n[0],i=n[1];return{minX:r,minY:i,maxX:r,maxY:i,index:e}})));var h=function(n){var r=t.features[n],s=v(r.geometry.coordinates,2),a=s[0],u=s[1],l=Math.max(u-i,-90),h=Math.min(u+i,90),c=l<0&&h>0?i:Math.abs(l)<Math.abs(h)?i/Math.cos(z(h)):i/Math.cos(z(l)),f=Math.max(a-c,-360),g=Math.min(a+c,360),p={minX:f,minY:l,maxX:g,maxY:h};return o.search(p).filter((function(n){var i=n.index,o=t.features[i];return ut(r,o,{units:"kilometers"})<=e}))},c=0;return t.features.forEach((function(t,e){if(!s[e]){var n=h(e);if(n.length>=r){var i=c;c++,s[e]=!0,function(t,e){for(var n=0;n<e.length;n++){var i=e[n].index;if(!s[i]){s[i]=!0;var o=h(i);o.length>=r&&e.push.apply(e,d(o))}a[i]||(a[i]=!0,l[i]=t)}}(i,n)}else u[e]=!0}})),t.features.forEach((function(e,n){var r=t.features[n];r.properties||(r.properties={}),l[n]>=0?(r.properties.dbscan=u[n]?"edge":"core",r.properties.cluster=l[n]):r.properties.dbscan="noise"})),t},t.clustersKmeans=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=t.features.length;e.numberOfClusters=e.numberOfClusters||Math.round(Math.sqrt(n/2)),e.numberOfClusters>n&&(e.numberOfClusters=n),!0!==e.mutate&&(t=Ai(t));var r=yt(t),i=r.slice(0,e.numberOfClusters),o=ro(r,e.numberOfClusters,i),s={};return o.centroids.forEach((function(t,e){s[e]=t})),vt(t,(function(t,e){var n=o.idxs[e];t.properties.cluster=n,t.properties.centroid=s[n]})),t},t.collect=function(t,e,n,r){var i=new io(6),o=e.features.map((function(t){var e;return{minX:t.geometry.coordinates[0],minY:t.geometry.coordinates[1],maxX:t.geometry.coordinates[0],maxY:t.geometry.coordinates[1],property:null==(e=t.properties)?void 0:e[n]}}));return i.load(o),t.features.forEach((function(t){t.properties||(t.properties={});var e=Rt(t),n=i.search({minX:e[0],minY:e[1],maxX:e[2],maxY:e[3]}),o=[];n.forEach((function(e){zt([e.minX,e.minY],t)&&o.push(e.property)})),t.properties[r]=o})),t},t.collectionOf=nt,t.combine=function(t){var e={MultiPoint:{coordinates:[],properties:[]},MultiLineString:{coordinates:[],properties:[]},MultiPolygon:{coordinates:[],properties:[]}};return vt(t,(function(t){var n,r,i,o;switch(null==(o=t.geometry)?void 0:o.type){case"Point":e.MultiPoint.coordinates.push(t.geometry.coordinates),e.MultiPoint.properties.push(t.properties);break;case"MultiPoint":(n=e.MultiPoint.coordinates).push.apply(n,d(t.geometry.coordinates)),e.MultiPoint.properties.push(t.properties);break;case"LineString":e.MultiLineString.coordinates.push(t.geometry.coordinates),e.MultiLineString.properties.push(t.properties);break;case"MultiLineString":(r=e.MultiLineString.coordinates).push.apply(r,d(t.geometry.coordinates)),e.MultiLineString.properties.push(t.properties);break;case"Polygon":e.MultiPolygon.coordinates.push(t.geometry.coordinates),e.MultiPolygon.properties.push(t.properties);break;case"MultiPolygon":(i=e.MultiPolygon.coordinates).push.apply(i,d(t.geometry.coordinates)),e.MultiPolygon.properties.push(t.properties)}})),C(Object.keys(e).filter((function(t){return e[t].coordinates.length})).sort().map((function(t){return b({type:t,coordinates:e[t].coordinates},{collectedProperties:e[t].properties})})))},t.concave=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e.maxEdge||1/0,r=function(t){var e=[],n={};return vt(t,(function(t){if(t.geometry){var r=t.geometry.coordinates.join("-");Object.prototype.hasOwnProperty.call(n,r)||(e.push(t),n[r]=!0)}})),C(e)}(t),i=oo(r);if(i.features=i.features.filter((function(t){var r=t.geometry.coordinates[0][0],i=t.geometry.coordinates[0][1],o=t.geometry.coordinates[0][2],s=ut(r,i,e),a=ut(i,o,e),u=ut(r,o,e);return s<=n&&a<=n&&u<=n})),i.features.length<1)return null;var o=Ro(i);return 1===o.coordinates.length&&(o.coordinates=o.coordinates[0],o.type="Polygon"),b(o)},t.containsNumber=$,t.convertArea=X,t.convertLength=j,t.convex=Oi,t.coordAll=yt,t.coordEach=ct,t.coordReduce=ft,t.createBins=zi,t.degreesToRadians=z,t.destination=at,t.difference=function(t){var e=[];if(mt(t,(function(t){e.push(t.coordinates)})),e.length<2)throw new Error("Must have at least two features");var n=t.features[0].properties||{},r=As.apply(Fs,[e[0]].concat(d(e.slice(1))));return 0===r.length?null:1===r.length?S(r[0],n):R(r,n)},t.dissolve=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!Z(e=e||{}))throw new Error("options is invalid");var n=e.propertyName;nt(t,"Polygon","dissolve");var r=[];if(!n)return qs(R(Os.apply(null,t.features.map((function(t){return t.geometry.coordinates})))));var i={};vt(t,(function(t){t.properties&&(Object.prototype.hasOwnProperty.call(i,t.properties[n])||(i[t.properties[n]]=[]),i[t.properties[n]].push(t))}));for(var o=Object.keys(i),s=0;s<o.length;s++){var a=R(Os.apply(null,i[o[s]].map((function(t){return t.geometry.coordinates}))));a&&a.properties&&(a.properties[n]=o[s],r.push(a))}return qs(C(r))},t.distance=ut,t.distanceWeight=Gs,t.earthRadius=x,t.ellipse=js,t.envelope=Us,t.explode=Zs,t.factors=E,t.feature=b,t.featureCollection=C,t.featureEach=vt,t.featureOf=et,t.featureReduce=dt,t.filterProperties=Ui,t.findPoint=St,t.findSegment=Nt,t.flatten=qs,t.flattenEach=xt,t.flattenReduce=Et,t.flip=function(t,e){var n;if(!Z(e=e||{}))throw new Error("options is invalid");var r=null!=(n=e.mutate)&&n;if(!t)throw new Error("geojson is required");return!1!==r&&void 0!==r||(t=Ai(t)),ct(t,(function(t){var e=t[0],n=t[1];t[0]=n,t[1]=e})),t},t.geojsonRbush=Qe,t.geojsonType=tt,t.geomEach=mt,t.geomReduce=_t,t.geometry=w,t.geometryCollection=A,t.getCluster=Gi,t.getCoord=K,t.getCoords=Q,t.getGeom=rt,t.getType=it,t.greatCircle=function(t,e,n){if("object"!==m(n=n||{}))throw new Error("options is invalid");var r=n.properties,i=n.npoints,o=n.offset;if(t=K(t),e=K(e),r=r||{},i=i||100,t[0]===e[0]&&t[1]===e[1]){var s=Array(i);return s.fill([t[0],t[1]]),L(s,r)}return o=o||10,new $s({x:t[0],y:t[1]},{x:e[0],y:e[1]},r).Arc(i,{offset:o}).json()},t.helpers=J,t.hexGrid=ea,t.interpolate=function(t,e,n){if("object"!==m(n=n||{}))throw new Error("options is invalid");var r,i=n.gridType,o=n.property,s=n.weight,a=n.bbox;if(!t)throw new Error("points is required");if(nt(t,"Point","input must contain Points"),!e)throw new Error("cellSize is required");if(void 0!==s&&"number"!=typeof s)throw new Error("weight must be a number");switch(o=o||"elevation",i=i||"square",s=s||1,H(a=null!=a?a:Rt(t)),i){case"point":case"points":r=ia(a,e,n);break;case"square":case"squares":r=sa(a,e,n);break;case"hex":case"hexes":r=ea(a,e,n);break;case"triangle":case"triangles":r=aa(a,e,n);break;default:throw new Error("invalid gridType")}var u=[];return vt(r,(function(e){var r=0,a=0;vt(t,(function(t){var u,l=ut("point"===i?e:gi(e),t,n);if(void 0!==o&&(u=t.properties[o]),void 0===u&&(u=t.geometry.coordinates[2]),void 0===u)throw new Error("zValue is missing");0===l&&(r=u);var h=1/Math.pow(l,s);a+=h,r+=h*u}));var l=Ai(e);l.properties[o]=r/a,u.push(l)})),C(u)},t.intersect=ta,t.invariant=ot,t.isNumber=U,t.isObject=Z,t.isobands=function(t,e,n){if(!Z(n=n||{}))throw new Error("options is invalid");var r=n.zProperty||"elevation",i=n.commonProperties||{},o=n.breaksProperties||[];if(nt(t,"Point","Input must contain Points"),!e)throw new Error("breaks is required");if(!Array.isArray(e))throw new Error("breaks is not an Array");if(!Z(i))throw new Error("commonProperties is not an Object");if(!Array.isArray(o))throw new Error("breaksProperties is not an Array");var s=Pa(t,{zProperty:r,flip:!0}),a=function(t,e,n){for(var r=[],i=1;i<e.length;i++){var o=+e[i-1],s=+e[i],a=Ta(Ca(Ea(t,o,s-o)));r.push(u({groupedRings:a},n,o+"-"+s))}return r}(s,e,r);a=function(t,e,n){var r=Rt(n),i=r[2]-r[0],o=r[3]-r[1],s=r[0],a=r[1],u=e[0].length-1,l=e.length-1,h=i/u,c=o/l;return t.map((function(t){return t.groupedRings=t.groupedRings.map((function(t){return t.map((function(t){return t.map((function(t){return[t[0]*h+s,t[1]*c+a]}))}))})),t}))}(a,s,t);var l=a.map((function(t,e){if(o[e]&&!Z(o[e]))throw new Error("Each mappedProperty is required to be an Object");var n=La(La({},i),o[e]);return n[r]=t[r],R(t.groupedRings,n)}));return C(l)},t.isolines=function(t,e,n){if(!Z(n=n||{}))throw new Error("options is invalid");var r=n.zProperty||"elevation",i=n.commonProperties||{},o=n.breaksProperties||[];if(nt(t,"Point","Input must contain Points"),!e)throw new Error("breaks is required");if(!Array.isArray(e))throw new Error("breaks must be an Array");if(!Z(i))throw new Error("commonProperties must be an Object");if(!Array.isArray(o))throw new Error("breaksProperties must be an Array");var s=Ba(t,{zProperty:r,flip:!0}),a=function(t,e,n){var r=Rt(n),i=r[2]-r[0],o=r[3]-r[1],s=r[0],a=r[1],u=e[0].length-1,l=e.length-1,h=i/u,c=o/l,f=function(t){t[0]=t[0]*h+s,t[1]=t[1]*c+a};return t.forEach((function(t){ct(t,f)})),t}(function(t,e,n,r,i){for(var o=[],s=0;s<e.length;s++){var a=+e[s],u=Ga(Ga({},r),i[s]);u[n]=a;var l=T(ma(t,a,{linearRing:!1,noFrame:!0}),u);o.push(l)}return o}(s,e,r,i,o),s,t);return C(a)},t.kinks=function(t){var e,n,r={type:"FeatureCollection",features:[]};if("LineString"===(n="Feature"===t.type?t.geometry:t).type)e=[n.coordinates];else if("MultiLineString"===n.type)e=n.coordinates;else if("MultiPolygon"===n.type){var i;e=(i=[]).concat.apply(i,d(n.coordinates))}else{if("Polygon"!==n.type)throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");e=n.coordinates}return e.forEach((function(t){e.forEach((function(e){for(var n=0;n<t.length-1;n++)for(var i=n;i<e.length-1;i++){if(t===e){if(1===Math.abs(n-i))continue;if(0===n&&i===t.length-2&&t[n][0]===t[t.length-1][0]&&t[n][1]===t[t.length-1][1])continue}var o=Ya(t[n][0],t[n][1],t[n+1][0],t[n+1][1],e[i][0],e[i][1],e[i+1][0],e[i+1][1]);o&&r.features.push(I([o[0],o[1]]))}}))})),r},t.length=za,t.lengthToDegrees=V,t.lengthToRadians=q,t.lineArc=ja,t.lineChunk=function(t,e,n){if(!Z(n=n||{}))throw new Error("options is invalid");var r=n.units,i=n.reverse;if(!t)throw new Error("geojson is required");if(e<=0)throw new Error("segmentLength must be greater than 0");var o=[];return xt(t,(function(t){i&&(t.geometry.coordinates=t.geometry.coordinates.reverse()),function(t,e,n,r){var i=za(t,{units:n});if(i<=e)return r(t);var o=i/e;Number.isInteger(o)||(o=Math.floor(o)+1);for(var s=0;s<o;s++){r(Ua(t,e*s,e*(s+1),{units:n}),s)}}(t,e,r,(function(t){o.push(t)}))})),C(o)},t.lineEach=wt,t.lineIntersect=ue,t.lineOffset=function(t,e,n){if(!Z(n=n||{}))throw new Error("options is invalid");var r=n.units;if(!t)throw new Error("geojson is required");if(null==e||isNaN(e))throw new Error("distance is required");var i=it(t),o=t.properties;switch(i){case"LineString":return Ja(t,e,r);case"MultiLineString":var s=[];return xt(t,(function(t){s.push(Ja(t,e,r).geometry.coordinates)})),T(s,o);default:throw new Error("geometry "+i+" is not supported")}},t.lineOverlap=kn,t.lineReduce=It,t.lineSegment=$e,t.lineSlice=function(t,e,n){var r=Q(n);if("LineString"!==it(n))throw new Error("line must be a LineString");for(var i,o=fn(n,t),s=fn(n,e),a=[(i=o.properties.index<=s.properties.index?[o,s]:[s,o])[0].geometry.coordinates],u=i[0].properties.index+1;u<i[1].properties.index+1;u++)a.push(r[u]);return a.push(i[1].geometry.coordinates),L(a,n.properties)},t.lineSliceAlong=Ua,t.lineSplit=function(t,e){if(!t)throw new Error("line is required");if(!e)throw new Error("splitter is required");var n=it(t),r=it(e);if("LineString"!==n)throw new Error("line must be LineString");if("FeatureCollection"===r)throw new Error("splitter cannot be a FeatureCollection");if("GeometryCollection"===r)throw new Error("splitter cannot be a GeometryCollection");var i=Qa(e,{precision:7});switch(r){case"Point":return tu(t,i);case"MultiPoint":return $a(t,i);case"LineString":case"MultiLineString":case"Polygon":case"MultiPolygon":return $a(t,ue(t,i,{ignoreSelfIntersections:!0}))}},t.lineString=L,t.lineStrings=P,t.lineToPolygon=function(t){var e,n,r,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=i.properties,s=null==(e=i.autoComplete)||e,a=null==(n=i.orderCoords)||n;if(null!=(r=i.mutate)&&r||(t=Ai(t)),"FeatureCollection"===t.type){var u=[];return t.features.forEach((function(t){u.push(Q(ru(t,{},s,a)))})),R(u,o)}return ru(t,o,s,a)},t.mask=function(t,e,n){var r,i=null!=(r=null==n?void 0:n.mutate)&&r,o=e;e&&!1===i&&(o=Ai(e));var s,a=su(o);return("FeatureCollection"===t.type?ou(2===(s=t).features.length?Os(s.features[0].geometry.coordinates,s.features[1].geometry.coordinates):Os.apply(Fs,s.features.map((function(t){return t.geometry.coordinates})))):"Feature"===t.type?ou(Os(t.geometry.coordinates)):ou(Os(t.coordinates))).geometry.coordinates.forEach((function(t){a.geometry.coordinates.push(t[0])})),a},t.meta=Mt,t.midpoint=function(t,e){return at(t,ut(t,e)/2,st(t,e))},t.moranIndex=function(t,e){var n,r,i=e.inputField,o=e.threshold||1e5,s=e.p||2,u=null!=(n=e.binary)&&n,l=Gs(t,{alpha:e.alpha||-1,binary:u,p:s,standardization:null==(r=e.standardization)||r,threshold:o}),h=[];vt(t,(function(t){var e=t.properties||{};h.push(e[i])}));for(var c=au(h),f=function(t){var e,n=au(t),r=0,i=a(t);try{for(i.s();!(e=i.n()).done;){var o=e.value;r+=Math.pow(o-n,2)}}catch(t){i.e(t)}finally{i.f()}return r/t.length}(h),g=0,p=0,v=0,d=0,y=l.length,m=0;m<y;m++){for(var _=0,x=0;x<y;x++)g+=l[m][x]*(h[m]-c)*(h[x]-c),p+=l[m][x],v+=Math.pow(l[m][x]+l[x][m],2),_+=l[m][x]+l[x][m];d+=Math.pow(_,2)}var E=g/p/f,k=-1/(y-1),b=(y*y*(v*=.5)-y*d+p*p*3)/((y-1)*(y+1)*(p*p))-k*k,w=Math.sqrt(b);return{expectedMoranIndex:k,moranIndex:E,stdNorm:w,zNorm:(E-k)/w}},t.multiLineString=T,t.multiPoint=O,t.multiPolygon=R,t.nearestNeighborAnalysis=function(t,e){var n=(e=e||{}).studyArea||Vt(Rt(t)),r=e.properties||{},i=e.units||"kilometers",o=[];vt(t,(function(t){o.push(gi(t))}));var s=o.length,a=o.map((function(t,e){return ut(t,yu(t,C(o.filter((function(t,n){return n!==e})))).geometry.coordinates,{units:i})})).reduce((function(t,e){return t+e}),0)/s,u=s/X(Lt(n),"meters",i),l=1/(2*Math.sqrt(u)),h=.26136/Math.sqrt(s*u);return r.nearestNeighborAnalysis={units:i,arealUnits:i+"",observedMeanDistance:a,expectedMeanDistance:l,nearestNeighborIndex:a/l,numberOfPoints:s,zScore:(a-l)/h},n.properties=r,n},t.nearestPoint=yu,t.nearestPointOnLine=fn,t.nearestPointToLine=function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=n.units,i=n.properties||{},o=function(t){var e=[];switch(t.geometry?t.geometry.type:t.type){case"GeometryCollection":return mt(t,(function(t){"Point"===t.type&&e.push({type:"Feature",properties:{},geometry:t})})),{type:"FeatureCollection",features:e};case"FeatureCollection":return t.features=t.features.filter((function(t){return"Point"===t.geometry.type})),t;default:throw new Error("points must be a Point Collection")}}(t);if(!o.features.length)throw new Error("points must contain features");if(!e)throw new Error("line is required");if("LineString"!==it(e))throw new Error("line must be a LineString");var s=1/0,a=null;return vt(o,(function(t){var n=mu(t,e,{units:r});n<s&&(s=n,a=t)})),a&&(a.properties=Iu(Iu(Iu({},{dist:s}),a.properties),i)),a},t.planepoint=function(t,e){var n=K(t),r=rt(e).coordinates[0];if(r.length<4)throw new Error("OuterRing of a Polygon must have 4 or more Positions.");var i="Feature"===e.type&&e.properties||{},o=i.a,s=i.b,a=i.c,u=n[0],l=n[1],h=r[0][0],c=r[0][1],f=void 0!==o?o:r[0][2],g=r[1][0],p=r[1][1],v=void 0!==s?s:r[1][2],d=r[2][0],y=r[2][1],m=void 0!==a?a:r[2][2];return(m*(u-h)*(l-p)+f*(u-g)*(l-y)+v*(u-d)*(l-c)-v*(u-h)*(l-y)-m*(u-g)*(l-c)-f*(u-d)*(l-p))/((u-h)*(l-p)+(u-g)*(l-y)+(u-d)*(l-c)-(u-h)*(l-y)-(u-g)*(l-c)-(u-d)*(l-p))},t.point=I,t.pointGrid=ia,t.pointOnFeature=function(t){for(var e=function(t){if("FeatureCollection"!==t.type)return"Feature"!==t.type?C([b(t)]):C([t]);return t}(t),n=An(e),r=!1,i=0;!r&&i<e.features.length;){var o=e.features[i].geometry,s=!1;if("Point"===o.type)n.geometry.coordinates[0]===o.coordinates[0]&&n.geometry.coordinates[1]===o.coordinates[1]&&(r=!0);else if("MultiPoint"===o.type)for(var a=!1,u=0;!a&&u<o.coordinates.length;)n.geometry.coordinates[0]===o.coordinates[u][0]&&n.geometry.coordinates[1]===o.coordinates[u][1]&&(r=!0,a=!0),u++;else if("LineString"===o.type)for(var l=0;!s&&l<o.coordinates.length-1;)Nu(n.geometry.coordinates[0],n.geometry.coordinates[1],o.coordinates[l][0],o.coordinates[l][1],o.coordinates[l+1][0],o.coordinates[l+1][1])&&(s=!0,r=!0),l++;else if("MultiLineString"===o.type)for(var h=0;h<o.coordinates.length;){s=!1;for(var c=0,f=o.coordinates[h];!s&&c<f.length-1;)Nu(n.geometry.coordinates[0],n.geometry.coordinates[1],f[c][0],f[c][1],f[c+1][0],f[c+1][1])&&(s=!0,r=!0),c++;h++}else"Polygon"!==o.type&&"MultiPolygon"!==o.type||zt(n,o)&&(r=!0);i++}if(r)return n;for(var g=C([]),p=0;p<e.features.length;p++)g.features=g.features.concat(Zs(e.features[p]).features);return I(yu(n,g).geometry.coordinates)},t.pointToLineDistance=mu,t.pointToPolygonDistance=function t(e,r){var i,o,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=null!=(i=s.method)?i:"geodesic",u=null!=(o=s.units)?o:"kilometers";if(!e)throw new Error("point is required");if(!r)throw new Error("polygon or multi-polygon is required");var l,h=rt(r);if("MultiPolygon"===h.type){var c=h.coordinates.map((function(n){return t(e,S(n),{method:a,units:u})}));return Math.min.apply(Math,d(c.map(Math.abs)))*(zt(e,r)?-1:1)}if(h.coordinates.length>1){var p=h.coordinates.map((function(n){return t(e,S([n]),{method:a,units:u})})),v=n(l=p)||f(l)||_(l)||g(),y=v[0],m=v.slice(1);if(y>=0)return y;var x=Math.min.apply(Math,d(m));return x<0?Math.abs(x):Math.min(x,Math.abs(y))}var E=le(h),k=1/0;return xt(E,(function(t){k=Math.min(k,mu(e,t,{method:a,units:u}))})),zt(e,h)?-k:k},t.points=N,t.pointsWithinPolygon=Su,t.polygon=S,t.polygonSmooth=function(t,e){(e=e||{}).iterations=e.iterations||1;var n=e.iterations,r=[];if(!t)throw new Error("inputPolys is required");return mt(t,(function(t,e,i){if("Polygon"===t.type){for(var o=[[]],s=0;s<n;s++){var a=[],u=t;s>0&&(u=S(o).geometry),Ru(u,a),o=a.slice(0)}r.push(S(o,i))}else{if("MultiPolygon"!==t.type)throw new Error("geometry is invalid, must be Polygon or MultiPolygon");for(var l=[[[]]],h=0;h<n;h++){var c=[],f=t;h>0&&(f=R(l).geometry),Au(f,c),l=c.slice(0)}r.push(R(l,i))}})),C(r)},t.polygonTangents=function(t,e){var n,r=Q(t),i=Q(e),o=[],s=[],a=Rt(e),u=0,l=null;switch(r[0]>a[0]&&r[0]<a[2]&&r[1]>a[1]&&r[1]<a[3]&&(u=(l=yu(t,Zs(e))).properties.featureIndex),it(e)){case"Polygon":o=i[0][u],s=i[0][0],null!==l&&l.geometry.coordinates[1]<r[1]&&(s=i[0][u]),n=qu(i[0][0],i[0][i[0].length-1],r);var h=v(Du(i[0],r,n,o,s),2);o=h[0],s=h[1];break;case"MultiPolygon":for(var c=0,f=0,g=0,p=0;p<i[0].length;p++){c=p;for(var d=!1,y=0;y<i[0][p].length;y++){if(f=y,g===u){d=!0;break}g++}if(d)break}o=i[0][c][f],s=i[0][c][f],n=qu(i[0][0][0],i[0][0][i[0][0].length-1],r),i.forEach((function(t){var e=v(Du(t[0],r,n,o,s),2);o=e[0],s=e[1]}))}return C([I(o),I(s)])},t.polygonToLine=le,t.polygonize=function(t){var e=Ou.fromGeoJson(t);e.deleteDangles(),e.deleteCutEdges();var n=[],r=[];return e.getEdgeRings().filter((function(t){return t.isValid()})).forEach((function(t){t.isHole()?n.push(t):r.push(t)})),n.forEach((function(t){Tu.findEdgeRingContaining(t,r)&&r.push(t)})),C(r.map((function(t){return t.toPolygon()})))},t.polygons=M,t.projection=ju,t.propEach=gt,t.propReduce=pt,t.propertiesContainsFilter=Xi,t.quadratAnalysis=function(t,e){for(var n=(e=e||{}).studyBbox||Rt(t),r=e.confidenceLevel||20,i=t.features,o=i.length,s=Lt(Vt(n)),u=sa(n,Math.sqrt(s/o*2),{units:"meters"}).features,l={},h=0;h<u.length;h++)l[h]={box:Rt(u[h]),cnt:0};var c,f=0,g=a(i);try{for(g.s();!(c=g.n()).done;)for(var p=c.value,v=0,d=Object.keys(l);v<d.length;v++){var y=d[v],m=l[y].box;if(Uu(K(p),m)){l[y].cnt+=1,f+=1;break}}}catch(t){g.e(t)}finally{g.f()}for(var _=0,x=0,E=Object.keys(l);x<E.length;x++){var k=l[E[x]].cnt;k>_&&(_=k)}for(var b=[],w=Object.keys(l).length,I=f/w,N=0,S=0;S<_+1;S++)N+=Math.exp(-I)*Math.pow(I,S)/Zu(S),b.push(N);for(var M=[],L=0,P=0;P<_+1;P++){for(var C=0,T=Object.keys(l);C<T.length;C++){l[T[C]].cnt===P&&(L+=1)}var O=L/w;M.push(O)}for(var R=0,A=0;A<_+1;A++){var D=Math.abs(b[A]-M[A]);D>R&&(R=D)}var F=Xu[r]/Math.sqrt(w),q={criticalValue:F,isRandom:!0,maxAbsoluteDifference:R,observedDistribution:M};return R>F&&(q.isRandom=!1),q},t.radiansToDegrees=Y,t.radiansToLength=F,t.random=nl,t.randomLineString=$u,t.randomPoint=Ku,t.randomPolygon=Qu,t.randomPosition=Hu,t.rectangleGrid=oa,t.rewind=function(t){var e,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!Z(r=r||{}))throw new Error("options is invalid");var i=null!=(e=r.mutate)&&e,o=null!=(n=r.reverse)&&n;if(!t)throw new Error("<geojson> is required");if("boolean"!=typeof o)throw new Error("<reverse> must be a boolean");if("boolean"!=typeof i)throw new Error("<mutate> must be a boolean");i||"Point"===t.type||"MultiPoint"===t.type||(t=Ai(t));var s=[];switch(t.type){case"GeometryCollection":return mt(t,(function(t){rl(t,o)})),t;case"FeatureCollection":return vt(t,(function(t){vt(rl(t,o),(function(t){s.push(t)}))})),C(s)}return rl(t,o)},t.rhumbBearing=lt,t.rhumbDestination=Bs,t.rhumbDistance=Ys,t.round=D,t.sample=function(t,e){if(!t)throw new Error("fc is required");if(null==e)throw new Error("num is required");if("number"!=typeof e)throw new Error("num must be a number");var n=C(function(t,e){var n,r,i=t.slice(0),o=t.length,s=o-e;for(;o-- >s;)n=i[r=Math.floor((o+1)*Math.random())],i[r]=i[o],i[o]=n;return i.slice(s)}(t.features,e));return n},t.sector=function(t,e,n,r){var i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};if(!Z(i=i||{}))throw new Error("options is invalid");var o=i.properties;if(!t)throw new Error("center is required");if(null==n)throw new Error("bearing1 is required");if(null==r)throw new Error("bearing2 is required");if(!e)throw new Error("radius is required");if("object"!==m(i))throw new Error("options must be an object");if(sl(n)===sl(r))return Ri(t,e,i);var s=Q(t),a=ja(t,e,n,r,i),u=[[s]];return ct(a,(function(t){u[0].push(t)})),u[0].push(s),S(u,o)},t.segmentEach=kt,t.segmentReduce=bt,t.shortestPath=function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!Z(n=n||{}))throw new Error("options is invalid");var r=n.obstacles||C([]),i=n.resolution||100;if(!t)throw new Error("start is required");if(!e)throw new Error("end is required");if(i&&(!U(i)||i<=0))throw new Error("options.resolution must be a number, greater than 0");var o=K(t),s=K(e);if(t=I(o),e=I(s),"FeatureCollection"===r.type){if(0===r.features.length)return L([o,s])}else{if("Polygon"!==r.type)throw new Error("invalid obstacles");r=C([b(rt(r))])}var a=r;a.features.push(t),a.features.push(e);var u=v(Rt(al(Vt(Rt(a)),1.15)),4),l=u[0],h=u[1],c=u[2],f=u[3],g=ut([l,h],[c,h],n)/i;a.features.pop(),a.features.pop();for(var p,d,y=g/ut([l,h],[c,h],n)*(c-l),m=g/ut([l,h],[l,f],n)*(f-h),_=c-l,x=f-h,E=Math.floor(_/y),k=Math.floor(x/m),w=(_-E*y)/2,N=[],S=[],M=1/0,P=1/0,T=f-(x-k*m)/2,O=0;T>=h;){for(var R=[],A=[],D=l+w,F=0;D<=c;){var q=I([D,T]),V=pl(q,r);R.push(V?0:1),A.push(D+"|"+T);var G=ut(q,t);!V&&G<M&&(M=G,p={x:F,y:O});var B=ut(q,e);!V&&B<P&&(P=B,d={x:F,y:O}),D+=y,F++}S.push(R),N.push(A),T-=m,O++}var Y=new cl(S,{diagonal:!0}),z=Y.grid[p.y][p.x],j=Y.grid[d.y][d.x],X=hl.search(Y,z,j),H=[o];return X.forEach((function(t){var e=N[t.x][t.y].split("|");H.push([+e[0],+e[1]])})),H.push(s),Le(L(H))},t.simplify=function(t){var e,n,r,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!Z(i=null!=i?i:{}))throw new Error("options is invalid");var o=null!=(e=i.tolerance)?e:1,s=null!=(n=i.highQuality)&&n,a=null!=(r=i.mutate)&&r;if(!t)throw new Error("geojson is required");if(o&&o<0)throw new Error("invalid tolerance");return!0!==a&&(t=Ai(t)),mt(t,(function(t){!function(t,e,n){var r=t.type;if("Point"===r||"MultiPoint"===r)return t;if(Le(t,{mutate:!0}),"GeometryCollection"!==r)switch(r){case"LineString":t.coordinates=ml(t.coordinates,e,n);break;case"MultiLineString":t.coordinates=t.coordinates.map((function(t){return ml(t,e,n)}));break;case"Polygon":t.coordinates=_l(t.coordinates,e,n);break;case"MultiPolygon":t.coordinates=t.coordinates.map((function(t){return _l(t,e,n)}))}}(t,o,s)})),t},t.square=Ka,t.squareGrid=sa,t.standardDeviationalEllipse=function(t,e){var n;if(!Z(e=e||{}))throw new Error("options is invalid");var r=e.steps||64,i=e.weight,o=e.properties||{};if(!U(r))throw new Error("steps must be a number");if(!Z(o))throw new Error("properties must be a number");var s=yt(t).length,a=fi(t,{weight:i}),u=0,l=0,h=0;vt(t,(function(t){var e,n=i&&(null==(e=t.properties)?void 0:e[i])||1,r=El(Q(t),Q(a));u+=Math.pow(r.x,2)*n,l+=Math.pow(r.y,2)*n,h+=r.x*r.y*n}));var c=u-l,f=Math.sqrt(Math.pow(c,2)+4*Math.pow(h,2)),g=2*h,p=Math.atan((c+f)/g),v=180*p/Math.PI,d=0,y=0,m=0;vt(t,(function(t){var e,n=i&&(null==(e=t.properties)?void 0:e[i])||1,r=El(Q(t),Q(a));d+=Math.pow(r.x*Math.cos(p)-r.y*Math.sin(p),2)*n,y+=Math.pow(r.x*Math.sin(p)+r.y*Math.cos(p),2)*n,m+=n}));var _=Math.sqrt(2*d/m),x=Math.sqrt(2*y/m),E=js(a,_,x,{units:"degrees",angle:v,steps:r,properties:o}),k=Su(t,C([E])),b={meanCenterCoordinates:Q(a),semiMajorAxis:_,semiMinorAxis:x,numberOfFeatures:s,angle:v,percentageWithinEllipse:100*yt(k).length/s};return E.properties=null!=(n=E.properties)?n:{},E.properties.standardDeviationalEllipse=b,E},t.tag=function(t,e,n,r){return t=Ai(t),e=Ai(e),vt(t,(function(t){t.properties||(t.properties={}),vt(e,(function(e){t.properties&&e.properties&&void 0===t.properties[r]&&zt(t,e)&&(t.properties[r]=e.properties[n])}))})),t},t.tesselate=function(t){if(!t.geometry||"Polygon"!==t.geometry.type&&"MultiPolygon"!==t.geometry.type)throw new Error("input must be a Polygon or MultiPolygon");var e={type:"FeatureCollection",features:[]};return"Polygon"===t.geometry.type?e.features=Nl(t.geometry.coordinates):t.geometry.coordinates.forEach((function(t){e.features=e.features.concat(Nl(t))})),e},t.tin=oo,t.toMercator=Vu,t.toWgs84=Gu,t.transformRotate=zs,t.transformScale=al,t.transformTranslate=function(t,e,n,r){if(!Z(r=r||{}))throw new Error("options is invalid");var i=r.units,o=r.zTranslation,s=r.mutate;if(!t)throw new Error("geojson is required");if(null==e||isNaN(e))throw new Error("distance is required");if(o&&"number"!=typeof o&&isNaN(o))throw new Error("zTranslation is not a number");if(o=void 0!==o?o:0,0===e&&0===o)return t;if(null==n||isNaN(n))throw new Error("direction is required");return e<0&&(e=-e,n+=180),!1!==s&&void 0!==s||(t=Ai(t)),ct(t,(function(t){var r=Q(Bs(t,e,n,{units:i}));t[0]=r[0],t[1]=r[1],o&&3===t.length&&(t[2]+=o)})),t},t.triangleGrid=aa,t.truncate=Qa,t.union=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=[];if(mt(t,(function(t){n.push(t.coordinates)})),n.length<2)throw new Error("Must have at least 2 geometries");var r=Os.apply(Fs,[n[0]].concat(d(n.slice(1))));return 0===r.length?null:1===r.length?S(r[0],e.properties):R(r,e.properties)},t.unkinkPolygon=function(t){var e=[];return xt(t,(function(t){"Polygon"===t.geometry.type&&vt(Ll(t),(function(n){e.push(S(n.geometry.coordinates,t.properties))}))})),C(e)},t.validateBBox=H,t.validateId=W,t.voronoi=function(t,e){if(!Z(e=e||{}))throw new Error("options is invalid");var n=e.bbox||[-180,-85,180,85];if(!t)throw new Error("points is required");if(!Array.isArray(n))throw new Error("bbox is invalid");return nt(t,"Point","points"),C(function(){var t=Fl,e=ql,n=null;function r(r){return new mh(r.map((function(n,i){var o=[Math.round(t(n,i,r)/vh)*vh,Math.round(e(n,i,r)/vh)*vh];return o.index=i,o.data=n,o})),n)}return r.polygons=function(t){return r(t).polygons()},r.links=function(t){return r(t).links()},r.triangles=function(t){return r(t).triangles()},r.x=function(e){return arguments.length?(t="function"==typeof e?e:Dl(+e),r):t},r.y=function(t){return arguments.length?(e="function"==typeof t?t:Dl(+t),r):e},r.extent=function(t){return arguments.length?(n=null==t?null:[[+t[0][0],+t[0][1]],[+t[1][0],+t[1][1]]],r):n&&[[n[0][0],n[0][1]],[n[1][0],n[1][1]]]},r.size=function(t){return arguments.length?(n=null==t?null:[[0,0],[+t[0],+t[1]]],r):n&&[n[1][0]-n[0][0],n[1][1]-n[0][1]]},r}().x((function(t){return t.geometry.coordinates[0]})).y((function(t){return t.geometry.coordinates[1]})).extent([[n[0],n[1]],[n[2],n[3]]]).polygons(t.features).map((function(e,n){return Object.assign(function(t){return(t=t.slice()).push(t[0]),S([t])}(e),{properties:Fi(t.features[n].properties)})})))}}));

        
    </script>
    
    <!--
    ============================================================================
    RBush - MIT License
    ============================================================================
    
    Copyright (c) 2024 Volodymyr Agafonkin
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    ============================================================================
    -->
    <!-- RBush library code -->
    <script type="text/javascript">!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?module.exports=i():"function"==typeof define&&define.amd?define(i):(t=t||self).RBush=i()}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});</script>

    <!-- Welcome Overlay -->
    <div id="welcomeOverlay" class="welcome-overlay">
        <div class="welcome-container">
            <div class="welcome-header">
                <div class="language-selector">                    
                    <label for="languageSelect" data-i18n-aria-label="selectLanguageLabel"></label>
                    <select id="languageSelect" onchange="changeLanguage(this.value)">
                        <option value="en">English</option>
                        <option value="es">Espaol</option>
                        <option value="fr">Franais</option>
                        <option value="pt">Portugus</option>
                        <option value="sw">Swahili</option>
                        <option value="zh"></option>
                        <option value="th"></option>
                        <option value="am"></option>
                    </select>
                </div>
                <h1 data-i18n="title">GeoRoots Editor</h1>
                <p class="collaboration-subtitle"><span data-i18n="collaborationText">made in collaboration with</span> <a href="https://efi.int/" target="_blank">European Forest Institute</a></p>
                <p data-i18n="subtitle">This is a simple tool for visual inspection of EU Deforestation Regulation DDS files.</p>
                <p data-i18n="privacyText" class="small-print">Your file and any of its content is only processed locally in your browser and none of your information is sent to GeoRoots, the map providers or anyone else.</p>
                <p data-i18n="licenseText" class="small-print">This software is free, released under GPLv3 open source license, see source code for full disclaimer.</p>
                <p class="small-print"><span data-i18n="downloadText">Download latest version and other tools on</span> <a href="https://georoots.eu/">https://georoots.eu/</a></p>
            </div>
            <div class="welcome-content">
                <div id="fileDropArea" class="file-drop-area">
                    <div class="upload-icon">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                            <path d="M12,12L16,16H13.5V19H10.5V16H8L12,12Z"/>
                        </svg>
                    </div>
                    <p data-i18n="uploadText">Drag & drop your GeoJSON file here</p>
                    <p class="or-text" data-i18n="orText">or</p>
                    <input type="file" id="fileInput" class="hidden" accept=".geojson,.json">
                    <button id="fileSelectButton" class="upload-button" data-i18n="selectGeoJSONButton">Select GeoJSON File</button>
                    <button id="startEmptyProjectButton" class="upload-button button-margin-top" data-i18n="startEmptyProject">Start Empty Project</button>
                </div>
            </div>

        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner"></div>
        <p data-i18n="processingText">Processing GeoJSON data...</p>
    </div>

    <!-- Invalid Features Overlay -->
    <div id="invalidFeaturesOverlay" class="invalid-features-overlay">
        <div class="invalid-features-content">
            <h2 data-i18n="invalidFeaturesTitle">Invalid Features Found</h2>
            <p id="invalidFeaturesMessage"></p>
            <div class="button-group">
                <a href="#" id="downloadInvalidFeatures" class="button" download="invalid_features.geojson" data-i18n="downloadInvalidButton">Download Invalid Features</a>
                <button id="continueWithValid" class="button" data-i18n="continueWithValidButton">Continue</button>
            </div>
        </div>
    </div>

    <!-- Controls Toggle Button -->
    <button id="controlsToggle" class="controls-toggle hidden" data-i18n="startOver">Start Over</button>

    <!-- Editing Controls -->
    <div id="editingControls" class="year-controls hidden">
        <h3 data-i18n="editingControlsTitle">Editing Tools</h3>
        
        <div class="control-group">
            <h4 data-i18n="editingMode">Mode:</h4>
            <button id="btn-pan-mode" class="active" data-i18n="panMode">View</button>
            <button id="btn-edit-mode" data-i18n="editMode">Edit</button>
            <button id="btn-validate-mode" data-i18n="validateMode">Validate</button>
        </div>
        
        <div class="control-group" id="editing-tools">
            <h4 data-i18n="editingTools">Tools:</h4>
            <button id="btn-select-tool" data-i18n="selectTool">Select</button>
            <button id="btn-vertex-tool" data-i18n="vertexTool">Add/Remove Vertex</button>
            <button id="btn-properties-tool" data-i18n="editPropertiesBtn">Edit Properties</button>
        </div>
        
        <div class="control-group" id="snap-controls">
            <h4 data-i18n="snapSettings">Snap Settings:</h4>
            <label class="snap-toggle">
                <input type="checkbox" id="snap-enabled" autocomplete="off"> <span data-i18n="enableSnap">Enable Snap</span>
            </label>
            <div class="snap-radius-container">
                <label for="snap-radius" data-i18n="snapRadius">Snap Radius (pixels):</label>
                <input type="range" id="snap-radius" min="5" max="50" value="10" autocomplete="off">
                <span id="snap-radius-value">10</span>
            </div>
        </div>

        <div class="control-group multipolygon-selection" id="multipolygon-selection">
            <h4 data-i18n="multipolygonSelection">MultiPolygon Selection:</h4>
            <div class="flex-center-gap-margin">
                <label for="polygon-selector" data-i18n="polygonLabel">Polygon:</label>
                <select id="polygon-selector" class="select-flex">
                </select>
            </div>
            <div class="flex-center-gap">
                <label for="ring-selector">Ring:</label>
                <select id="ring-selector" class="select-flex">
                </select>
            </div>
        </div>

        <div class="control-group" id="feature-actions">
            <h4 data-i18n="featureActions">Feature Actions:</h4>
            <div class="action-group-frame">
                <button id="btn-add-point" class="btn-add" data-i18n="addPoint">Add Point</button>
                <button id="btn-add-polygon" class="btn-add" data-i18n="addPolygon">Add Polygon</button>
            </div>
            <button id="btn-remove-feature" class="btn-remove" data-i18n="removeFeature">Remove Feature</button>
            <div class="tool-hint" id="tool-hint"></div>
        </div>

        <div class="control-group">
            <button id="btn-auto-clean" class="upload-button button-full-width-margin" data-i18n="autoClean">Auto-Clean</button>
            <button id="btn-export" class="upload-button button-full-width" data-i18n="export">Export</button>
        </div>
    </div>

    <!-- Legend -->
    <div id="mapLegend" class="legend hidden">
        <h4 data-i18n="legendTitle">Legend</h4>
        <div id="legend-items"></div>
    </div>

    <!-- Map Container -->
    <div id="map"></div>

    <!-- Coordinate Display -->
    <div id="coordinate-display"></div>

    <!-- Validation Report Modal -->
    <div id="validationReportModal" class="properties-modal">
        <div class="validation-report-content">
            <div class="properties-header">
                <h3 data-i18n="validationReport">Validation Report</h3>
                <button class="properties-close" onclick="closeValidationReportModal()">&times;</button>
            </div>
            <div class="validation-report-body">
                <!-- Warning Box for Unsupported Geometry (hidden by default) -->
                <div id="validation-warning-unsupported" class="validation-warning-box" style="display: none;">
                    <h4> <span data-i18n="unsupportedGeometryWarning">Unsupported Geometry Types Detected</span></h4>
                    <p data-i18n="unsupportedGeometryMessage">There are LineStrings and/or MultiLineStrings in your dataset. These geometry types are not supported by EUDR. Running Auto Clean will attempt to convert them into polygons or remove them if they cannot be converted.</p>
                </div>
                
                <!-- Success Box (hidden by default) -->
                <div id="validation-success-box" class="validation-success-box" style="display: none;">
                    <h4> <span data-i18n="validationSuccess">All Checks Passed</span></h4>
                    <p data-i18n="noValidationIssues">Your dataset passed all validation checks. No issues were found.</p>
                </div>
                
                <!-- Overall Statistics -->
                <div class="validation-report-section">
                    <h4 data-i18n="overallStatistics">Overall Statistics</h4>
                    <div class="validation-stat-grid">
                        <div class="validation-stat-row">
                            <span class="validation-stat-label" data-i18n="totalFeatures">Total Features</span>
                            <span class="validation-stat-value" id="val-total-features">0</span>
                        </div>
                        <div class="validation-stat-row">
                            <span class="validation-stat-label" data-i18n="validFeatures">Valid Features</span>
                            <span class="validation-stat-value success" id="val-valid-features">0</span>
                        </div>
                        <div class="validation-stat-row">
                            <span class="validation-stat-label" data-i18n="featuresWithIssues">Features with Issues</span>
                            <span class="validation-stat-value" id="val-features-with-issues">0</span>
                        </div>
                    </div>
                </div>
                
                <!-- Issue Breakdown -->
                <div class="validation-report-section">
                    <h4 data-i18n="issueBreakdown">Issue Breakdown</h4>
                    <div class="validation-stat-grid">
                        <div class="validation-stat-row">
                            <span class="validation-stat-label" data-i18n="invalidGeometries">Invalid Geometries</span>
                            <span class="validation-stat-value" id="val-invalid-geometries">0</span>
                        </div>
                        <div class="validation-stat-row">
                            <span class="validation-stat-label" data-i18n="duplicateVertices">Duplicate Vertices</span>
                            <span class="validation-stat-value" id="val-duplicate-vertices">0</span>
                        </div>
                        <div class="validation-stat-row">
                            <span class="validation-stat-label" data-i18n="duplicateGeometries">Duplicate Geometries</span>
                            <span class="validation-stat-value" id="val-duplicates">0</span>
                        </div>
                        <div class="validation-stat-row">
                            <span class="validation-stat-label" data-i18n="selfIntersections">Self-Intersections</span>
                            <span class="validation-stat-value" id="val-self-intersections">0</span>
                        </div>
                        <div class="validation-stat-row">
                            <span class="validation-stat-label" data-i18n="featuresWithHoles">Features with Holes</span>
                            <span class="validation-stat-value" id="val-holes">0</span>
                        </div>
                        <div class="validation-stat-row">
                            <span class="validation-stat-label" data-i18n="slivers">Slivers</span>
                            <span class="validation-stat-value" id="val-slivers">0</span>
                        </div>
                        <div class="validation-stat-row">
                            <span class="validation-stat-label" data-i18n="overlappingPairs">Overlapping Pairs</span>
                            <span class="validation-stat-value" id="val-overlaps">0</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="validation-report-footer">
                <button class="save-properties-btn" onclick="closeValidationReportModal()" data-i18n="close">Close</button>
            </div>
        </div>
    </div>

    <!-- Properties Modal -->
    <div id="propertiesModal" class="properties-modal">
        <div class="properties-content">
            <div class="properties-header">
                <h3 data-i18n="editProperties">Edit Properties</h3>
                <button class="properties-close" onclick="closePropertiesModal()">&times;</button>
            </div>
            <div id="properties-list"></div>
            <button class="add-property-btn" onclick="addPropertyRow()" data-i18n="addProperty">Add Property</button>
            <button class="save-properties-btn" onclick="saveProperties()" data-i18n="saveProperties">Save</button>
        </div>
    </div>

    <!-- Delete Polygon Confirm Modal -->
    <div id="deletePolygonModal" class="properties-modal">
        <div class="properties-content">
            <div class="properties-header">
                <h3 data-i18n="deletePolygonTitle">Delete Polygon?</h3>
                <button class="properties-close" onclick="closeDeletePolygonModal()">&times;</button>
            </div>
            <div class="info-content">
                <p data-i18n="deletePolygonConfirm">This polygon would have fewer than 3 vertices. Do you want to delete this polygon?</p>
            </div>
            <div class="modal-button-container">
                <button class="add-property-btn danger-button" onclick="confirmDeletePolygon()" data-i18n="remove">Remove</button>
                <button class="save-properties-btn" onclick="closeDeletePolygonModal()" data-i18n="cancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Auto-Clean Selection Modal -->
    <div id="autoCleanModal" class="properties-modal">
        <div class="autoclean-content">
            <div class="autoclean-header">
                <h3 data-i18n="autoCleaner">Auto Cleaner</h3>
                <button class="properties-close" onclick="closeAutoCleanModal()">&times;</button>
            </div>
            <div class="autoclean-body">
                <div class="autoclean-warning" data-i18n="autoCleanWarning">If you need to undo the Auto-Clean changes, use Ctrl/Cmd+Z (undo) or Ctrl/Cmd+Y (redo). Ctrl/Cmd+Q toggles between the last change.</div>
                <div class="autoclean-options">
                    <label class="autoclean-option autoclean-option-mandatory"><input type="checkbox" id="ac-ringclosure" checked disabled> <span data-i18n="closeUnclosedRings">Close Unclosed Rings</span> <span class="mandatory-badge" data-i18n="mandatory">(mandatory)</span></label>
                    <label class="autoclean-option"><input type="checkbox" id="ac-duplicates"> <span data-i18n="removeDuplicateGeometries">Remove Duplicate Geometries</span></label>
                    <label class="autoclean-option"><input type="checkbox" id="ac-selfintersect"> <span data-i18n="fixPolygonSelfIntersection">Fix Polygon Self-Intersection</span></label>
                    <label class="autoclean-option"><input type="checkbox" id="ac-holes"> <span data-i18n="removePolygonHoles">Remove Polygon Holes</span></label>
                    <label class="autoclean-option"><input type="checkbox" id="ac-slivers"> <span data-i18n="removeSlivers">Remove Slivers</span></label>
                    <label class="autoclean-option">
                        <input type="checkbox" id="ac-smallpolygons"> <span data-i18n="removePolygonsBelow">Remove polygons below</span> 
                        <input type="number" id="ac-smallpolygons-area" value="10" min="0" step="0.1" class="number-input-small"> 
                        <span data-i18n="squareMeters">square meters</span>
                    </label>
                    <label class="autoclean-option"><input type="checkbox" id="ac-overlap"> <span data-i18n="removePolygonOverlap">Remove Polygon Overlap</span></label>
                    <label class="autoclean-option"><input type="checkbox" id="ac-pointsinpolygons"> <span data-i18n="removePointsInPolygons">Remove points located within polygons</span></label>
                    <label class="autoclean-option"><input type="checkbox" id="ac-collinear"> <span data-i18n="removeRedundantCollinear">Remove Redundant Collinear Points</span></label>
                </div>
            </div>
            <div class="autoclean-footer">
                <button class="add-property-btn" onclick="closeAutoCleanModal()">Cancel</button>
                <button class="save-properties-btn" onclick="startAutoClean()">Clean</button>
            </div>
        </div>
    </div>

    <!-- Auto-Clean Progress Modal -->
    <div id="autoCleanProgressModal" class="properties-modal">
        <div class="autoclean-content">
            <div class="autoclean-header">
                <h3 data-i18n="autoCleaner">Auto Cleaner</h3>
            </div>
            <div class="progress-container">
                <div id="ac-stage" class="progress-stage" data-i18n="preparing">Preparing</div>
                <div class="progress-bar"><div id="ac-progress" class="progress-fill progress-fill-initial"></div></div>
            </div>
            <div class="autoclean-footer">
                <button class="add-property-btn" id="ac-cancel-btn" onclick="cancelAutoClean()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Validation Progress Modal -->
    <div id="validationProgressModal" class="properties-modal">
        <div class="autoclean-content">
            <div class="autoclean-header">
                <h3 data-i18n="validation">Validation</h3>
            </div>
            <div class="progress-container">
                <div id="val-stage" class="progress-stage" data-i18n="preparing">Preparing</div>
                <div class="progress-bar"><div id="val-progress" class="progress-fill progress-fill-initial"></div></div>
            </div>
            <div class="autoclean-footer">
                <button class="add-property-btn" id="val-use-previous-btn" onclick="usePreviousValidation()" style="display: none; background-color: #40916c; margin-right: 10px;">Use Previous Results</button>
                <button class="add-property-btn" id="val-cancel-btn" onclick="cancelValidation()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div id="exportModal" class="properties-modal">
        <div class="export-content">
            <div class="export-header">
                <h3 data-i18n="exportTitle">Export</h3>
                <button class="properties-close" onclick="closeExportModal()">&times;</button>
            </div>
            <div class="export-body">
                <div class="export-field">
                    <label data-i18n="selectFileName">Select file name:</label>
                    <input type="text" id="export-filename" class="export-filename-input" placeholder="my-geodata" autocomplete="off">
                </div>
                <div class="export-field">
                    <label class="export-checkbox">
                        <input type="checkbox" id="export-with-validation">
                        <span data-i18n="validateAndExport">Validate all and export features with validation</span>
                    </label>
                </div>
            </div>
            <div class="export-footer">
                <button class="export-btn export-geojson-btn" onclick="exportWithFormat('geojson')" data-i18n="exportGeoJSON">Export GeoJSON</button>
                <button class="export-btn export-csv-btn" onclick="exportWithFormat('csv')" data-i18n="exportCSV">Export CSV</button>
                <button class="export-btn export-cancel-btn" onclick="closeExportModal()" data-i18n="cancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Translation Data -->
    <script type="application/json" id="lang-en">
    {
        "title": "GeoRoots Editor",
        "pageTitle": "GeoRoots Editor - GeoJSON Visual Editor",
        "collaborationText": "made in collaboration with",
        "downloadText": "Download latest version and other tools on",
        "subtitle": "This is a visual GeoJSON editor for creating and editing geographic data.",
        "uploadText": "Drag & drop your GeoJSON file here",
        "orText": "or",
        "selectGeoJSONButton": "Select GeoJSON File",
        "privacyText": "Your file and any of its content is only processed locally in your browser and none of your information is sent to GeoRoots, the map providers or anyone else.",
        "licenseText": "This software is free, released under GPLv3 open source license, see source code for full disclaimer.",
        "processingText": "Processing GeoJSON data...",
        "hideControls": "Hide Controls",
        "showControls": "Show Controls",
        "editingControlsTitle": "Editing Tools",
        "editingMode": "Mode:",
        "panMode": "View",
        "editMode": "Edit",
        "validateMode": "Check",
        "editingTools": "Tools:",
        "selectTool": "Select & Edit",
        "vertexTool": "Add/Remove Vertex",
        "editPropertiesBtn": "Edit Properties",
        "featureActions": "Feature Actions:",
        "removeFeature": "Remove Feature",
        "addPoint": "Add Point",
        "addPolygon": "Add Polygon",
        "export": "Export",
        "exportGeoJSON": "Export GeoJSON",
        "exportCSV": "Export CSV",
        "exportTitle": "Export",
        "selectFileName": "Select file name:",
        "validateAndExport": "Check all and export features with quality report",
        "snapSettings": "Snap Settings:",
        "enableSnap": "Enable Snap",
        "snapRadius": "Snap Radius (pixels):",
        "legendTitle": "Legend",
        "plotBoundary": "Plot Boundary",
        "editProperties": "Edit Properties",
        "addProperty": "Add Property",
        "saveProperties": "Save",
        "noProperties": "No properties found",
        "propertiesTitle": "Properties",
        "invalidGeoJSON": "Error processing the file. Please make sure it is a valid GeoJSON file.",
        "streetMap": "Street Map",
        "topoMap": "Topographic Map",
        "satelliteLatest": "Satellite latest",
        "satellite2020": "Satellite from 2020",
        "forestCoverage": "Forest Coverage (GFC 2020v2)",
        "treeCoverLossAttribution": "Tree Cover Loss  Global Forest Watch",
        "esri2020Attribution": "Tiles  Esri 2020  Source: Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": "European Commission JRC - Global Forest Change 2020v2",
        "preparing": "Preparing",
        "outerRing": "Outer Ring",
        "hole": "Hole {i}",
        "keyPlaceholder": "Key",
        "valuePlaceholder": "Value",
        "dismiss": "Dismiss",
        "closeButton": "",
        "selectLanguage": "Select language",
        "cancel": "Cancel",
        "noFeaturesToExport": "No features to export",
        "validatingFeatures": "Checking features...",
        "exportCompleted": "Export completed successfully",
        "exportFailed": "Export failed",
        "turfLibraryNotLoaded": "Error: Turf.js library is not loaded. Cannot proceed with overlap removal.",
        "polygonClippingFailed": "Warning: Polygon clipping failed for a feature. Keeping original part. Error: {0}",
        "turfLoadFailed": "Error: Turf.js library failed to load. Quality checks cannot be performed. Loading data without checks...",
        "turfSelfIntersectionDetectionFailed": "Turf.js library is required for self-intersection detection but is not loaded.",
        "turfOverlapDetectionFailed": "Turf.js library is required for overlap detection but is not loaded.",
        "autoCleaner": "Auto Cleaner",
        "validation": "Data Check",
        "clean": "Clean",
        "remove": "Remove",
        "validateGeometries": "Check Geometries",
        "autoClean": "Auto-Clean",
        "deduplicatingProgress": "Checking for duplicates: feature {0} of {1}...",
        "deduplicatingCompleted": "Duplicate check completed: {0} duplicates found",
        "holesProgress": "Checking for polygon holes: feature {0} of {1}...",
        "holesCompleted": "Hole check completed: {0} features with holes found",
        "deletePolygonTitle": "Delete Polygon?",
        "deletePolygonConfirm": "This polygon would have fewer than 3 vertices. Do you want to delete this polygon?",
        "autoCleanWarning": "If you need to undo the Auto-Clean changes, use Ctrl/Cmd+Z (undo) or Ctrl/Cmd+Y (redo). Ctrl/Cmd+Q toggles between the last change.",
        "closeUnclosedRings": "Close unclosed rings",
        "mandatory": "(mandatory)",
        "removeDuplicateGeometries": "Remove duplicate geometries",
        "fixPolygonSelfIntersection": "Fix polygon self-intersection",
        "removePolygonHoles": "Remove polygon holes",
        "removeSlivers": "Remove slivers and sharp angles (<4)",
        "removePolygonsBelow": "Remove polygons below",
        "squareMeters": "square meters",
        "removePolygonOverlap": "Remove polygon overlap",
        "removePointsInPolygons": "Remove points located within polygons",
        "removeRedundantCollinear": "Remove redundant collinear points",
        "selectToolHint": "Select feature to edit. Drag orange marker to move.",
        "vertexToolHint": "Click green midpoints to add vertices. Click orange vertices to remove. Drag orange vertices to move.",
        "propertiesToolHint": "Click any feature to edit its properties.",
        "removeModeHint": "Remove mode: click any feature to delete it. Click again to cancel.",
        "addPointHint": "Add Point: click on the map to place a new point.",
        "addPolygonHint": "Add Polygon: click to add vertices; right-click to finish.",
        "validationReport": "Data Quality Report",
        "close": "Close",
        "unsupportedGeometryWarning": "Unsupported Geometry Types Detected",
        "unsupportedGeometryMessage": "There are LineStrings and/or MultiLineStrings in your dataset. These geometry types are not supported by EUDR. Running Auto Clean will attempt to convert them into polygons or remove them if they cannot be converted.",
        "validationSuccess": "All Checks Passed",
        "noValidationIssues": "Your dataset passed all quality checks. No issues were found.",
        "overallStatistics": "Overall Statistics",
        "totalFeatures": "Total Features",
        "validFeatures": "Valid Features",
        "featuresWithIssues": "Features with Issues",
        "issueBreakdown": "Issue Breakdown",
        "invalidGeometries": "Invalid Geometries",
        "selfIntersections": "Self-Intersections",
        "featuresWithHoles": "Features with Holes",
        "slivers": "Slivers",
        "overlappingPairs": "Overlapping Pairs",
        "completed": "Completed",
        "errorProcessingGeoJSON": "Error processing GeoJSON: {0}",
        "noOverlapsDetected": "No overlaps detected. Polygons are already clean.",
        "polygonsDividedWarning": "Warning: Some polygons were divided into multiple parts during overlap removal.",
        "overlapRemovalCompleted": "Overlap removal completed successfully.",
        "sliverRemovalCompleted": "Sliver removal completed: removed {0} polygon(s) and {1} vertex/vertices.",
        "noSliversDetected": "Sliver removal completed: no slivers detected.",
        "smallPolygonRemovalCompleted": "Small polygon removal completed: removed {0} polygon(s) smaller than {1} square meters.",
        "noSmallPolygonsFound": "Small polygon removal completed: no polygons smaller than {1} square meters found.",
        "noPolygonsOrPointsFound": "Points in polygons removal: no polygons or points found to process.",
        "pointsInPolygonsRemovalCompleted": "Points in polygons removal completed: removed {0} point(s) located within polygons.",
        "noPointsInPolygonsFound": "Points in polygons removal completed: no points found within polygons.",
        "collinearRemovalFailed": "Warning: Collinear removal failed for feature {0}. Error: {1}",
        "selfIntersectionFixFailed": "Warning: Self-intersection fix failed for feature {0}. Error: {1}",
        "autoCleanRenderUpdateFailed": "Warning: Auto-Clean render update failed. Error: {0}",
        "autoCleanErrorOccurred": "Error: Auto-Clean error occurred. Error: {0}",
        "autoCleanRevertFailed": "Error: Auto-Clean revert failed. Error: {0}",
        "startEmptyProject": "Start Empty Project",
        "startOver": "Start Over",
        "multipolygonSelection": "MultiPolygon Selection:",
        "polygonLabel": "Polygon:",
        "sliverRemovalFailed": "Warning: Sliver removal failed for feature {0}. Error: {1}",
        "allChecksDone": "All checks completed, no quality issues found.",
        "validationSummary": "Quality check completed: {0} valid, {1} invalid out of {2} total features.",
        "validationSummaryWithDuplicates": "Quality check completed: {0} valid, {1} invalid, {2} duplicates out of {3} total features.",
        "validationSummaryWithDuplicatesAndOverlaps": "Quality check completed: {0} valid, {1} invalid, {2} duplicates, {3} overlaps out of {4} total features.",
        "checkingOverlapsProgress": "Checking for overlaps: polygon {0} of {1}...",
        "checkingOverlapsCompleted": "Overlap check completed: {0} overlapping pairs found",
        "processingOverlaps": "Processing overlaps: {0} of ~{1} overlapping geometries",
        "creatingOverlapRemovalPlan": "Creating Overlap Removal Plan, please wait...",
        "noDuplicatePointsToRemove": "No duplicate points to remove",
        "duplicateGeometryRemovalCompleted": "Duplicate geometry removal completed",
        "fixedSelfIntersectingFeatures": "Fixed self-intersecting features",
        "noPolygonHolesToRemove": "No polygon holes to remove",
        "sliverRemovalCompleted": "Sliver removal completed",
        "noOverlapsToRemove": "No overlaps to remove",
        "decomposingOverlappingFeatures": "Decomposing overlapping features...",
        "finalizingClippedGeometries": "Finalizing clipped geometries...",
        "reassemblingFeatures": "Reassembling features...",
        "smallPolygonRemovalCompleted": "Small polygon removal completed",
        "pointsInPolygonsRemovalCompleted": "Points in polygons removal completed",
        "collinearPointRemovalCompleted": "Collinear point removal completed",
        "noSelfIntersectionsToFix": "No self-intersections to fix",
        "identifiedIssues": "Identified Issues",
        "checkingSelfIntersectionsProgress": "Checking for self-intersections: feature {0} of {1}...",
        "checkingSelfIntersectionsCompleted": "Self-intersection check completed: {0} features with self-intersections found",
        "renderingValidationResults": "Rendering results, please wait...",
        "validationErrorOccurred": "Error: Quality check error occurred. {0}",
        "invalidFeaturesTitle": "Invalid Features Found",
        "invalidFeaturesMessage": "Your file contains {count} invalid geometric features that cannot be loaded. This usually means features with no geometry, no coordinates, or less than 3 points for polygons.",
        "downloadInvalidButton": "Download Invalid Features",
        "continueWithValidButton": "Continue with Valid Features",
        "coordinatesCopied": "Coordinates copied: {0}",
        "coordinatesCopyFailed": "Failed to copy coordinates",
        "featureNoLongerExists": "Feature no longer exists. It may have been removed or merged since the check.",
        "noUndoAvailable": "Nothing to undo",
        "noRedoAvailable": "Nothing to redo"
    }
    </script>

    <script type="application/json" id="lang-es">
    {
        "title": "GeoRoots Editor",
        "pageTitle": "GeoRoots Editor - Editor Visual de GeoJSON",
        "collaborationText": "hecho en colaboracin con",
        "downloadText": "Descarga la versin ms reciente y otras herramientas en",
        "subtitle": "Este es un editor visual de GeoJSON para crear y editar datos geogrficos.",
        "uploadText": "Arrastra y suelta tu archivo GeoJSON aqu",
        "orText": "o",
        "selectGeoJSONButton": "Seleccionar archivo GeoJSON",
        "privacyText": "Tu archivo y su contenido solo se procesan localmente en tu navegador y ninguna informacin se enva a GeoRoots, los proveedores de mapas ni a nadie ms.",
        "licenseText": "Este software es gratuito, bajo licencia de cdigo abierto GPLv3; consulta el cdigo fuente para el descargo de responsabilidad completo.",
        "processingText": "Procesando datos GeoJSON...",
        "hideControls": "Ocultar controles",
        "showControls": "Mostrar controles",
        "editingControlsTitle": "Herramientas de Edicin",
        "editingMode": "Modo:",
        "panMode": "Vista",
        "editMode": "Editar",
        "validateMode": "Verificar",
        "editingTools": "Herramientas:",
        "selectTool": "Seleccionar y Editar",
        "vertexTool": "Agregar/Quitar Vrtice",
        "editPropertiesBtn": "Editar Propiedades",
        "featureActions": "Acciones de Elemento:",
        "removeFeature": "Quitar Elemento",
        "addPoint": "Agregar Punto",
        "addPolygon": "Agregar Polgono",
        "export": "Exportar",
        "exportGeoJSON": "Exportar GeoJSON",
        "exportCSV": "Exportar CSV",
        "exportTitle": "Exportar",
        "selectFileName": "Seleccionar nombre de archivo:",
        "validateAndExport": "Verificar todo y exportar elementos con informe de calidad",
        "snapSettings": "Configuracin de Ajuste:",
        "enableSnap": "Habilitar Ajuste",
        "snapRadius": "Radio de Ajuste (pxeles):",
        "legendTitle": "Leyenda",
        "plotBoundary": "Lmite de Parcela",
        "editProperties": "Editar Propiedades",
        "addProperty": "Agregar Propiedad",
        "saveProperties": "Guardar",
        "noProperties": "No se encontraron propiedades",
        "propertiesTitle": "Propiedades",
        "invalidGeoJSON": "Error al procesar el archivo. Por favor, asegrate de que es un archivo GeoJSON vlido.",
        "streetMap": "Mapa de Calles",
        "topoMap": "Mapa Topogrfico",
        "satelliteLatest": "Satlite ms reciente",
        "satellite2020": "Satlite de 2020",
        "forestCoverage": "Cobertura Forestal (GFC 2020v2)",
        "treeCoverLossAttribution": "Prdida de Cobertura Arbrea  Global Forest Watch",
        "esri2020Attribution": "Teselas  Esri 2020  Fuente: Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": "Comisin Europea JRC - Cambio Global de Bosques 2020v2",
        "preparing": "Preparando",
        "outerRing": "Anillo Exterior",
        "hole": "Agujero {i}",
        "keyPlaceholder": "Clave",
        "valuePlaceholder": "Valor",
        "dismiss": "Descartar",
        "closeButton": "",
        "selectLanguage": "Seleccionar idioma",
        "cancel": "Cancelar",
        "noFeaturesToExport": "No hay elementos para exportar",
        "validatingFeatures": "Verificando elementos...",
        "exportCompleted": "Exportacin completada exitosamente",
        "exportFailed": "Exportacin fallida",
        "autoCleaner": "Limpieza Automtica",
        "validation": "Verificacin de Datos",
        "clean": "Limpiar",
        "remove": "Quitar",
        "validateGeometries": "Verificar Geometras",
        "autoClean": "Limpieza Automtica",
        "deduplicatingProgress": "Verificando duplicados: elemento {0} de {1}...",
        "deduplicatingCompleted": "Verificacin de duplicados completada: {0} duplicados encontrados",
        "holesProgress": "Verificando agujeros en polgonos: elemento {0} de {1}...",
        "holesCompleted": "Verificacin de agujeros completada: {0} elementos con agujeros encontrados",
        "deletePolygonTitle": "Eliminar Polgono?",
        "deletePolygonConfirm": "Este polgono tendra menos de 3 vrtices. Quieres eliminar este polgono?",
        "autoCleanWarning": "Si necesitas deshacer los cambios de Limpieza Automtica, usa Ctrl/Cmd+Z (deshacer) o Ctrl/Cmd+Y (rehacer). Ctrl/Cmd+Q alterna entre el ltimo cambio.",
        "closeUnclosedRings": "Cerrar anillos no cerrados",
        "mandatory": "(obligatorio)",
        "removeDuplicateGeometries": "Quitar geometras duplicadas",
        "fixPolygonSelfIntersection": "Corregir auto-interseccin de polgono",
        "removePolygonHoles": "Eliminar agujeros en polgonos",
        "removeSlivers": "Quitar fragmentos y ngulos agudos (<4)",
        "removePolygonsBelow": "Quitar polgonos menores a",
        "squareMeters": "metros cuadrados",
        "removePolygonOverlap": "Quitar superposicin de polgonos",
        "removePointsInPolygons": "Quitar puntos ubicados dentro de polgonos",
        "removeRedundantCollinear": "Quitar puntos colineales redundantes",
        "selectToolHint": "Selecciona un elemento para editar. Arrastra el marcador naranja para mover.",
        "vertexToolHint": "Haz clic en los puntos medios verdes para agregar vrtices. Haz clic en los vrtices naranjas para quitar. Arrastra los vrtices naranjas para mover.",
        "propertiesToolHint": "Haz clic en cualquier elemento para editar sus propiedades.",
        "removeModeHint": "Modo de eliminacin: haz clic en cualquier elemento para eliminarlo. Haz clic de nuevo para cancelar.",
        "addPointHint": "Agregar Punto: haz clic en el mapa para colocar un nuevo punto.",
        "addPolygonHint": "Agregar Polgono: haz clic para agregar vrtices; clic derecho para terminar.",
        "validationReport": "Informe de Calidad de Datos",
        "close": "Cerrar",
        "unsupportedGeometryWarning": "Tipos de Geometra No Soportados Detectados",
        "unsupportedGeometryMessage": "Hay LineStrings y/o MultiLineStrings en su conjunto de datos. Estos tipos de geometra no son compatibles con EUDR. Ejecutar Auto Clean intentar convertirlos en polgonos o eliminarlos si no se pueden convertir.",
        "validationSuccess": "Todas las Verificaciones Pasaron",
        "noValidationIssues": "Su conjunto de datos pas todas las verificaciones de calidad. No se encontraron problemas.",
        "overallStatistics": "Estadsticas Generales",
        "totalFeatures": "Caractersticas Totales",
        "validFeatures": "Caractersticas Vlidas",
        "featuresWithIssues": "Caractersticas con Problemas",
        "issueBreakdown": "Desglose de Problemas",
        "invalidGeometries": "Geometras Invlidas",
        "selfIntersections": "Autointersecciones",
        "featuresWithHoles": "Caractersticas con Agujeros",
        "slivers": "Polgonos Delgados",
        "overlappingPairs": "Pares Superpuestos",
        "completed": "Completado",
        "errorProcessingGeoJSON": "Error procesando GeoJSON: {0}",
        "turfLibraryNotLoaded": "Error: La biblioteca Turf.js no est cargada. No se puede proceder con la eliminacin de superposiciones.",
        "polygonClippingFailed": "Advertencia: El recorte de polgono fall para una caracterstica. Manteniendo parte original. Error: {0}",
        "turfLoadFailed": "Error: La biblioteca Turf.js no se pudo cargar. No se pueden realizar las verificaciones de calidad. Cargando datos sin verificaciones...",
        "turfSelfIntersectionDetectionFailed": "Se requiere la biblioteca Turf.js para la deteccin de auto-interseccin pero no est cargada.",
        "turfOverlapDetectionFailed": "Se requiere la biblioteca Turf.js para la deteccin de superposicin pero no est cargada.",
        "noOverlapsDetected": "No se detectaron superposiciones. Los polgonos ya estn limpios.",
        "polygonsDividedWarning": "Advertencia: Algunos polgonos fueron divididos en mltiples partes durante la eliminacin de superposiciones.",
        "overlapRemovalCompleted": "Eliminacin de superposiciones completada exitosamente.",
        "sliverRemovalCompleted": "Eliminacin de fragmentos completada: se quitaron {0} polgono(s) y {1} vrtice(s).",
        "noSliversDetected": "Eliminacin de fragmentos completada: no se detectaron fragmentos.",
        "smallPolygonRemovalCompleted": "Eliminacin de polgonos pequeos completada: se quitaron {0} polgono(s) menores a {1} metros cuadrados.",
        "noSmallPolygonsFound": "Eliminacin de polgonos pequeos completada: no se encontraron polgonos menores a {1} metros cuadrados.",
        "noPolygonsOrPointsFound": "Eliminacin de puntos en polgonos: no se encontraron polgonos o puntos para procesar.",
        "pointsInPolygonsRemovalCompleted": "Eliminacin de puntos en polgonos completada: se quitaron {0} punto(s) ubicados dentro de polgonos.",
        "noPointsInPolygonsFound": "Eliminacin de puntos en polgonos completada: no se encontraron puntos dentro de polgonos.",
        "collinearRemovalFailed": "Advertencia: La eliminacin colineal fall para el elemento {0}. Error: {1}",
        "polygonClippingFailed": "Advertencia: El recorte de polgono fall para una caracterstica. Manteniendo parte original. Error: {0}",
        "selfIntersectionFixFailed": "Advertencia: La correccin de auto-interseccin fall para el elemento {0}. Error: {1}",
        "autoCleanRenderUpdateFailed": "Advertencia: La actualizacin de renderizado de Limpieza Automtica fall. Error: {0}",
        "autoCleanErrorOccurred": "Error: Ocurri un error de Limpieza Automtica. Error: {0}",
        "autoCleanRevertFailed": "Error: El revertir de Limpieza Automtica fall. Error: {0}",
        "startEmptyProject": "Iniciar Proyecto Vaco",
        "startOver": "Empezar de Nuevo",
        "multipolygonSelection": "Seleccin de MultiPolgono:",
        "polygonLabel": "Polgono:",
        "sliverRemovalFailed": "Advertencia: La eliminacin de fragmentos fall para el elemento {0}. Error: {1}",
        "validationFailed": "Error: La verificacin fall. {0}",
        "allChecksDone": "Todas las verificaciones completadas, no se encontraron problemas de calidad.",
        "validationSummary": "Verificacin de calidad completada: {0} vlidas, {1} invlidas de {2} caractersticas totales.",
        "validationSummaryWithDuplicates": "Verificacin de calidad completada: {0} vlidas, {1} invlidas, {2} duplicadas de {3} caractersticas totales.",
        "validationSummaryWithDuplicatesAndOverlaps": "Verificacin de calidad completada: {0} vlidas, {1} invlidas, {2} duplicadas, {3} superposiciones de {4} caractersticas totales.",
        "checkingOverlapsProgress": "Verificando superposiciones: polgono {0} de {1}...",
        "checkingOverlapsCompleted": "Verificacin de superposiciones completada: {0} pares superpuestos encontrados",
        "processingOverlaps": "Procesando superposiciones: {0} de ~{1} geometras superpuestas",
        "creatingOverlapRemovalPlan": "Creando Plan de Eliminacin de Superposiciones, por favor espere...",
        "noDuplicatePointsToRemove": "No hay puntos duplicados para eliminar",
        "duplicateGeometryRemovalCompleted": "Eliminacin de geometras duplicadas completada",
        "fixedSelfIntersectingFeatures": "Caractersticas autointersectadas corregidas",
        "noPolygonHolesToRemove": "No hay agujeros de polgono para eliminar",
        "sliverRemovalCompleted": "Eliminacin de astillas completada",
        "noOverlapsToRemove": "No hay superposiciones para eliminar",
        "decomposingOverlappingFeatures": "Descomponiendo caractersticas superpuestas...",
        "finalizingClippedGeometries": "Finalizando geometras recortadas...",
        "reassemblingFeatures": "Reensamblando caractersticas...",
        "smallPolygonRemovalCompleted": "Eliminacin de polgonos pequeos completada",
        "pointsInPolygonsRemovalCompleted": "Eliminacin de puntos en polgonos completada",
        "collinearPointRemovalCompleted": "Eliminacin de puntos colineales completada",
        "noSelfIntersectionsToFix": "No hay autointersecciones para corregir",
        "identifiedIssues": "Problemas Identificados",
        "checkingSelfIntersectionsProgress": "Verificando autointersecciones: caracterstica {0} de {1}...",
        "checkingSelfIntersectionsCompleted": "Verificacin de autointersecciones completada: {0} caractersticas con autointersecciones encontradas",
        "renderingValidationResults": "Renderizando resultados, por favor espere...",
        "validationErrorOccurred": "Error: Ocurri un error en la verificacin de calidad. {0}",
        "invalidFeaturesTitle": "Se encontraron caractersticas invlidas",
        "invalidFeaturesMessage": "Su archivo contiene {count} caractersticas geomtricas invlidas que no se pueden cargar. Esto normalmente significa caractersticas sin geometra, sin coordenadas o con menos de 3 puntos para polgonos.",
        "downloadInvalidButton": "Descargar Caractersticas Invlidas",
        "continueWithValidButton": "Continuar con Vlidas",
        "coordinatesCopied": "Coordenadas copiadas: {0}",
        "coordinatesCopyFailed": "Error al copiar coordenadas",
        "featureNoLongerExists": "El elemento ya no existe. Puede haber sido eliminado o fusionado desde la verificacin.",
        "noUndoAvailable": "Nada para deshacer",
        "noRedoAvailable": "Nada para rehacer"
    }
    </script>

    <script type="application/json" id="lang-fr">
    {
        "title": "GeoRoots Editor",
        "pageTitle": "GeoRoots Editor - diteur Visuel GeoJSON",
        "collaborationText": "ralis en collaboration avec",
        "downloadText": "Tlchargez la dernire version et d'autres outils sur",
        "subtitle": "Ceci est un diteur visuel GeoJSON pour crer et diter des donnes gographiques.",
        "uploadText": "Glissez-dposez votre fichier GeoJSON ici",
        "orText": "ou",
        "selectGeoJSONButton": "Slectionner un fichier GeoJSON",
        "privacyText": "Votre fichier et son contenu ne sont traits que localement dans votre navigateur et aucune information n'est envoye  GeoRoots, aux fournisseurs de cartes ou  quiconque.",
        "licenseText": "Ce logiciel est gratuit, publi sous licence open source GPLv3, voir le code source pour la clause de non-responsabilit complte.",
        "processingText": "Traitement des donnes GeoJSON...",
        "hideControls": "Masquer les contrles",
        "showControls": "Afficher les contrles",
        "editingControlsTitle": "Outils d'dition",
        "editingMode": "Mode :",
        "panMode": "Vue",
        "editMode": "diter",
        "validateMode": "Vrifier",
        "editingTools": "Outils :",
        "selectTool": "Slectionner et diter",
        "vertexTool": "Ajouter/Supprimer Sommet",
        "editPropertiesBtn": "diter les Proprits",
        "featureActions": "Actions d'lment :",
        "removeFeature": "Supprimer l'lment",
        "addPoint": "Ajouter un Point",
        "addPolygon": "Ajouter un Polygone",
        "export": "Exporter",
        "exportGeoJSON": "Exporter GeoJSON",
        "exportCSV": "Exporter CSV",
        "exportTitle": "Exporter",
        "selectFileName": "Slectionner le nom du fichier :",
        "validateAndExport": "Vrifier tout et exporter les lments avec rapport de qualit",
        "snapSettings": "Paramtres d'Accrochage :",
        "enableSnap": "Activer l'Accrochage",
        "snapRadius": "Rayon d'Accrochage (pixels) :",
        "legendTitle": "Lgende",
        "plotBoundary": "Limite de Parcelle",
        "editProperties": "diter les Proprits",
        "addProperty": "Ajouter une Proprit",
        "saveProperties": "Enregistrer",
        "noProperties": "Aucune proprit trouve",
        "propertiesTitle": "Proprits",
        "invalidGeoJSON": "Erreur lors du traitement du fichier. Veuillez vous assurer qu'il s'agit d'un fichier GeoJSON valide.",
        "streetMap": "Carte des Rues",
        "topoMap": "Carte Topographique",
        "satelliteLatest": "Satellite le plus rcent",
        "satellite2020": "Satellite de 2020",
        "forestCoverage": "Couverture Forestire (GFC 2020v2)",
        "treeCoverLossAttribution": "Perte de Couvert Arbor  Global Forest Watch",
        "esri2020Attribution": "Tuiles  Esri 2020  Source : Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": "Commission europenne JRC - Changement global des forts 2020v2",
        "preparing": "Prparation",
        "outerRing": "Anneau Extrieur",
        "hole": "Trou {i}",
        "keyPlaceholder": "Cl",
        "valuePlaceholder": "Valeur",
        "dismiss": "Ignorer",
        "closeButton": "",
        "selectLanguage": "Slectionner la langue",
        "cancel": "Annuler",
        "noFeaturesToExport": "Aucun lment  exporter",
        "validatingFeatures": "Vrification des lments...",
        "exportCompleted": "Exportation termine avec succs",
        "exportFailed": "chec de l'exportation",
        "autoCleaner": "Nettoyage Automatique",
        "validation": "Vrification des Donnes",
        "clean": "Nettoyer",
        "remove": "Supprimer",
        "validateGeometries": "Vrifier les Gomtries",
        "autoClean": "Nettoyage Automatique",
        "deduplicatingProgress": "Vrification des doublons : lment {0} sur {1}...",
        "deduplicatingCompleted": "Vrification des doublons termine : {0} doublons trouvs",
        "holesProgress": "Vrification des trous dans les polygones : lment {0} sur {1}...",
        "holesCompleted": "Vrification des trous termine : {0} lments avec des trous trouvs",
        "deletePolygonTitle": "Supprimer le Polygone ?",
        "deletePolygonConfirm": "Ce polygone aurait moins de 3 sommets. Voulez-vous supprimer ce polygone ?",
        "autoCleanWarning": "Si vous devez annuler les modifications du Nettoyage Automatique, utilisez Ctrl/Cmd+Z (annuler) ou Ctrl/Cmd+Y (refaire). Ctrl/Cmd+Q bascule entre le dernier changement.",
        "closeUnclosedRings": "Fermer les anneaux non ferms",
        "mandatory": "(obligatoire)",
        "removeDuplicateGeometries": "Supprimer les gomtries dupliques",
        "fixPolygonSelfIntersection": "Corriger l'auto-intersection du polygone",
        "removePolygonHoles": "Supprimer les trous des polygones",
        "removeSlivers": "Supprimer les lamelles et angles aigus (<4)",
        "removePolygonsBelow": "Supprimer les polygones en dessous de",
        "squareMeters": "mtres carrs",
        "removePolygonOverlap": "Supprimer le chevauchement de polygones",
        "removePointsInPolygons": "Supprimer les points situs dans les polygones",
        "removeRedundantCollinear": "Supprimer les points colinaires redondants",
        "selectToolHint": "Slectionnez un lment  diter. Glissez le marqueur orange pour dplacer.",
        "vertexToolHint": "Cliquez sur les points mdians verts pour ajouter des sommets. Cliquez sur les sommets orange pour supprimer. Glissez les sommets orange pour dplacer.",
        "propertiesToolHint": "Cliquez sur n'importe quel lment pour diter ses proprits.",
        "removeModeHint": "Mode de suppression : cliquez sur n'importe quel lment pour le supprimer. Cliquez  nouveau pour annuler.",
        "addPointHint": "Ajouter un Point : cliquez sur la carte pour placer un nouveau point.",
        "addPolygonHint": "Ajouter un Polygone : cliquez pour ajouter des sommets ; clic droit pour terminer.",
        "validationReport": "Rapport de Qualit des Donnes",
        "close": "Fermer",
        "unsupportedGeometryWarning": "Types de Gomtrie Non Pris en Charge Dtects",
        "unsupportedGeometryMessage": "Il y a des LineStrings et/ou MultiLineStrings dans votre ensemble de donnes. Ces types de gomtrie ne sont pas pris en charge par EUDR. Excuter Auto Clean tentera de les convertir en polygones ou de les supprimer s'ils ne peuvent pas tre convertis.",
        "validationSuccess": "Toutes les Vrifications Russies",
        "noValidationIssues": "Votre ensemble de donnes a russi toutes les vrifications de qualit. Aucun problme dtect.",
        "overallStatistics": "Statistiques Globales",
        "totalFeatures": "Total des Caractristiques",
        "validFeatures": "Caractristiques Valides",
        "featuresWithIssues": "Caractristiques avec Problmes",
        "issueBreakdown": "Rpartition des Problmes",
        "invalidGeometries": "Gomtries Invalides",
        "selfIntersections": "Auto-intersections",
        "featuresWithHoles": "Caractristiques avec Trous",
        "slivers": "Fragments",
        "overlappingPairs": "Paires Superposes",
        "completed": "Termin",
        "errorProcessingGeoJSON": "Erreur lors du traitement de GeoJSON : {0}",
        "turfLibraryNotLoaded": "Erreur : La bibliothque Turf.js n'est pas charge. La suppression des chevauchements ne peut pas continuer.",
        "polygonClippingFailed": "Avertissement : Le dcoupage de polygone a chou pour une caractristique. Conservation de la partie originale. Erreur : {0}",
        "turfLoadFailed": "Erreur : Le chargement de la bibliothque Turf.js a chou. Les vrifications de qualit ne peuvent pas tre effectues. Chargement des donnes sans vrifications...",
        "turfSelfIntersectionDetectionFailed": "La bibliothque Turf.js est requise pour la dtection d'auto-intersection mais n'est pas charge.",
        "turfOverlapDetectionFailed": "La bibliothque Turf.js est requise pour la dtection de chevauchement mais n'est pas charge.",
        "noOverlapsDetected": "Aucun chevauchement dtect. Les polygones sont dj propres.",
        "polygonsDividedWarning": "Avertissement : Certains polygones ont t diviss en plusieurs parties lors de la suppression des chevauchements.",
        "overlapRemovalCompleted": "Suppression des chevauchements termine avec succs.",
        "sliverRemovalCompleted": "Suppression des lamelles termine : {0} polygone(s) et {1} sommet(s) supprims.",
        "noSliversDetected": "Suppression des lamelles termine : aucune lamelle dtecte.",
        "smallPolygonRemovalCompleted": "Suppression des petits polygones termine : {0} polygone(s) de moins de {1} mtres carrs supprims.",
        "noSmallPolygonsFound": "Suppression des petits polygones termine : aucun polygone de moins de {1} mtres carrs trouv.",
        "noPolygonsOrPointsFound": "Suppression des points dans les polygones : aucun polygone ou point trouv  traiter.",
        "pointsInPolygonsRemovalCompleted": "Suppression des points dans les polygones termine : {0} point(s) situ(s) dans les polygones supprims.",
        "noPointsInPolygonsFound": "Suppression des points dans les polygones termine : aucun point trouv dans les polygones.",
        "collinearRemovalFailed": "Avertissement : La suppression colinaire a chou pour l'lment {0}. Erreur : {1}",
        "polygonClippingFailed": "Avertissement : Le dcoupage de polygone a chou pour une caractristique. Conservation de la partie originale. Erreur : {0}",
        "selfIntersectionFixFailed": "Avertissement : La correction d'auto-intersection a chou pour l'lment {0}. Erreur : {1}",
        "autoCleanRenderUpdateFailed": "Avertissement : La mise  jour du rendu du Nettoyage Automatique a chou. Erreur : {0}",
        "autoCleanErrorOccurred": "Erreur : Une erreur de Nettoyage Automatique s'est produite. Erreur : {0}",
        "autoCleanRevertFailed": "Erreur : L'annulation du Nettoyage Automatique a chou. Erreur : {0}",
        "startEmptyProject": "Dmarrer un Projet Vide",
        "startOver": "Recommencer",
        "multipolygonSelection": "Slection de MultiPolygone :",
        "polygonLabel": "Polygone :",
        "sliverRemovalFailed": "Avertissement : La suppression des lamelles a chou pour l'lment {0}. Erreur : {1}",
        "validationFailed": "Erreur : La vrification a chou. {0}",
        "allChecksDone": "Toutes les vrifications termines, aucun problme de qualit trouv.",
        "validationSummary": "Vrification de qualit termine : {0} valides, {1} invalides sur {2} fonctionnalits au total.",
        "validationSummaryWithDuplicates": "Vrification de qualit termine : {0} valides, {1} invalides, {2} doublons sur {3} fonctionnalits au total.",
        "validationSummaryWithDuplicatesAndOverlaps": "Vrification de qualit termine : {0} valides, {1} invalides, {2} doublons, {3} chevauchements sur {4} fonctionnalits au total.",
        "checkingOverlapsProgress": "Vrification des chevauchements : polygone {0} sur {1}...",
        "checkingOverlapsCompleted": "Vrification des chevauchements termine : {0} paires chevauchantes trouves",
        "processingOverlaps": "Traitement des chevauchements : {0} sur ~{1} gomtries chevauchantes",
        "creatingOverlapRemovalPlan": "Cration du Plan de Suppression des Chevauchements, veuillez patienter...",
        "noDuplicatePointsToRemove": "Aucun point en double  supprimer",
        "duplicateGeometryRemovalCompleted": "Suppression des gomtries en double termine",
        "fixedSelfIntersectingFeatures": "Fonctionnalits auto-intersectantes corriges",
        "noPolygonHolesToRemove": "Aucun trou de polygone  supprimer",
        "sliverRemovalCompleted": "Suppression des clats termine",
        "noOverlapsToRemove": "Aucun chevauchement  supprimer",
        "decomposingOverlappingFeatures": "Dcomposition des fonctionnalits chevauchantes...",
        "finalizingClippedGeometries": "Finalisation des gomtries dcoupes...",
        "reassemblingFeatures": "Rassemblage des fonctionnalits...",
        "smallPolygonRemovalCompleted": "Suppression des petits polygones termine",
        "pointsInPolygonsRemovalCompleted": "Suppression des points dans les polygones termine",
        "collinearPointRemovalCompleted": "Suppression des points colinaires termine",
        "noSelfIntersectionsToFix": "Aucune auto-intersection  corriger",
        "identifiedIssues": "Problmes Identifis",
        "checkingSelfIntersectionsProgress": "Vrification des auto-intersections : fonctionnalit {0} sur {1}...",
        "checkingSelfIntersectionsCompleted": "Vrification des auto-intersections termine : {0} fonctionnalits avec auto-intersections trouves",
        "renderingValidationResults": "Rendu des rsultats, veuillez patienter...",
        "validationErrorOccurred": "Erreur : Une erreur de vrification de qualit s'est produite. {0}",
        "invalidFeaturesTitle": "Fonctionnalits non valides trouves",
        "invalidFeaturesMessage": "Votre fichier contient {count} fonctionnalits gomtriques non valides qui ne peuvent pas tre charges. Cela signifie gnralement des fonctionnalits sans gomtrie, sans coordonnes ou avec moins de 3 points pour les polygones.",
        "downloadInvalidButton": "Tlcharger les fonctionnalits non valides",
        "continueWithValidButton": "Continuer avec les valides",
        "coordinatesCopied": "Coordonnes copies : {0}",
        "coordinatesCopyFailed": "chec de la copie des coordonnes",
        "featureNoLongerExists": "La fonctionnalit n'existe plus. Elle a peut-tre t supprime ou fusionne depuis la vrification.",
        "noUndoAvailable": "Rien  annuler",
        "noRedoAvailable": "Rien  rtablir"
    }
    </script>

    <script type="application/json" id="lang-pt">
    {
        "title": "GeoRoots Editor",
        "pageTitle": "GeoRoots Editor - Editor Visual GeoJSON",
        "collaborationText": "feito em colaborao com",
        "downloadText": "Baixe a verso mais recente e outras ferramentas em",
        "subtitle": "Este  um editor visual GeoJSON para criar e editar dados geogrficos.",
        "uploadText": "Arraste e solte seu arquivo GeoJSON aqui",
        "orText": "ou",
        "selectGeoJSONButton": "Selecionar arquivo GeoJSON",
        "privacyText": "Seu arquivo e qualquer contedo dele so processados apenas localmente no seu navegador e nenhuma informao  enviada ao GeoRoots, aos provedores de mapas ou a qualquer outra pessoa.",
        "licenseText": "Este software  gratuito, licenciado sob GPLv3 de cdigo aberto; veja o cdigofonte para o aviso legal completo.",
        "processingText": "Processando dados GeoJSON...",
        "hideControls": "Ocultar controles",
        "showControls": "Mostrar controles",
        "editingControlsTitle": "Ferramentas de Edio",
        "editingMode": "Modo:",
        "panMode": "Visualizar",
        "editMode": "Editar",
        "validateMode": "Verificar",
        "editingTools": "Ferramentas:",
        "selectTool": "Selecionar e Editar",
        "vertexTool": "Adicionar/Remover Vrtice",
        "editPropertiesBtn": "Editar Propriedades",
        "featureActions": "Aes de Elemento:",
        "removeFeature": "Remover Elemento",
        "addPoint": "Adicionar Ponto",
        "addPolygon": "Adicionar Polgono",
        "export": "Exportar",
        "exportGeoJSON": "Exportar GeoJSON",
        "exportCSV": "Exportar CSV",
        "exportTitle": "Exportar",
        "selectFileName": "Selecionar nome do arquivo:",
        "validateAndExport": "Verificar tudo e exportar elementos com relatrio de qualidade",
        "snapSettings": "Configuraes de Alinhamento:",
        "enableSnap": "Ativar Alinhamento",
        "snapRadius": "Raio de Alinhamento (pixels):",
        "legendTitle": "Legenda",
        "plotBoundary": "Limite da Parcela",
        "editProperties": "Editar Propriedades",
        "addProperty": "Adicionar Propriedade",
        "saveProperties": "Salvar",
        "noProperties": "Nenhuma propriedade encontrada",
        "propertiesTitle": "Propriedades",
        "invalidGeoJSON": "Erro ao processar o arquivo. Certifique-se de que  um arquivo GeoJSON vlido.",
        "streetMap": "Mapa de Ruas",
        "topoMap": "Mapa Topogrfico",
        "satelliteLatest": "Satlite mais recente",
        "satellite2020": "Satlite de 2020",
        "forestCoverage": "Cobertura Florestal (GFC 2020v2)",
        "treeCoverLossAttribution": "Perda de Cobertura Arbrea  Global Forest Watch",
        "esri2020Attribution": "Blocos  Esri 2020  Fonte: Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": "Comisso Europeia JRC - Mudana Global das Florestas 2020v2",
        "preparing": "Preparando",
        "outerRing": "Anel Externo",
        "hole": "Buraco {i}",
        "keyPlaceholder": "Chave",
        "valuePlaceholder": "Valor",
        "dismiss": "Dispensar",
        "closeButton": "",
        "selectLanguage": "Selecionar idioma",
        "cancel": "Cancelar",
        "noFeaturesToExport": "Nenhum elemento para exportar",
        "validatingFeatures": "Verificando elementos...",
        "exportCompleted": "Exportao concluda com sucesso",
        "exportFailed": "Falha na exportao",
        "autoCleaner": "Limpeza Automtica",
        "validation": "Verificao de Dados",
        "clean": "Limpar",
        "remove": "Remover",
        "validateGeometries": "Verificar Geometrias",
        "autoClean": "Limpeza Automtica",
        "deduplicatingProgress": "Verificando duplicatas: elemento {0} de {1}...",
        "deduplicatingCompleted": "Verificao de duplicatas concluda: {0} duplicatas encontradas",
        "holesProgress": "Verificando buracos em polgonos: elemento {0} de {1}...",
        "holesCompleted": "Verificao de buracos concluda: {0} elementos com buracos encontrados",
        "deletePolygonTitle": "Excluir Polgono?",
        "deletePolygonConfirm": "Este polgono teria menos de 3 vrtices. Voc quer excluir este polgono?",
        "autoCleanWarning": "Se voc precisar desfazer as alteraes da Limpeza Automtica, use Ctrl/Cmd+Z (desfazer) ou Ctrl/Cmd+Y (refazer). Ctrl/Cmd+Q alterna entre a ltima alterao.",
        "closeUnclosedRings": "Fechar anis no fechados",
        "mandatory": "(obrigatrio)",
        "removeDuplicateGeometries": "Remover geometrias duplicadas",
        "fixPolygonSelfIntersection": "Corrigir auto-interseco do polgono",
        "removePolygonHoles": "Remover buracos de polgonos",
        "removeSlivers": "Remover fragmentos e ngulos agudos (<4)",
        "removePolygonsBelow": "Remover polgonos menores que",
        "squareMeters": "metros quadrados",
        "removePolygonOverlap": "Remover sobreposio de polgonos",
        "removePointsInPolygons": "Remover pontos localizados dentro de polgonos",
        "removeRedundantCollinear": "Remover pontos colineares redundantes",
        "selectToolHint": "Selecione um elemento para editar. Arraste o marcador laranja para mover.",
        "vertexToolHint": "Clique nos pontos mdios verdes para adicionar vrtices. Clique nos vrtices laranja para remover. Arraste os vrtices laranja para mover.",
        "propertiesToolHint": "Clique em qualquer elemento para editar suas propriedades.",
        "removeModeHint": "Modo de remoo: clique em qualquer elemento para exclu-lo. Clique novamente para cancelar.",
        "addPointHint": "Adicionar Ponto: clique no mapa para colocar um novo ponto.",
        "addPolygonHint": "Adicionar Polgono: clique para adicionar vrtices; clique direito para finalizar.",
        "validationReport": "Relatrio de Qualidade de Dados",
        "close": "Fechar",
        "unsupportedGeometryWarning": "Tipos de Geometria No Suportados Detectados",
        "unsupportedGeometryMessage": "Existem LineStrings e/ou MultiLineStrings no seu conjunto de dados. Esses tipos de geometria no so suportados pelo EUDR. Executar Auto Clean tentar convert-los em polgonos ou remov-los se no puderem ser convertidos.",
        "validationSuccess": "Todas as Verificaes Passaram",
        "noValidationIssues": "Seu conjunto de dados passou em todas as verificaes de qualidade. Nenhum problema foi encontrado.",
        "overallStatistics": "Estatsticas Gerais",
        "totalFeatures": "Total de Caractersticas",
        "validFeatures": "Caractersticas Vlidas",
        "featuresWithIssues": "Caractersticas com Problemas",
        "issueBreakdown": "Detalhamento de Problemas",
        "invalidGeometries": "Geometrias Invlidas",
        "selfIntersections": "Autointerseces",
        "featuresWithHoles": "Caractersticas com Buracos",
        "slivers": "Fragmentos",
        "overlappingPairs": "Pares Sobrepostos",
        "completed": "Concludo",
        "errorProcessingGeoJSON": "Erro processando GeoJSON: {0}",
        "turfLibraryNotLoaded": "Erro: A biblioteca Turf.js no est carregada. A remoo de sobreposies no pode prosseguir.",
        "polygonClippingFailed": "Aviso: O recorte de polgono falhou para uma caracterstica. Mantendo parte original. Erro: {0}",
        "turfLoadFailed": "Erro: Falha ao carregar a biblioteca Turf.js. As verificaes de qualidade no podem ser executadas. Carregando dados sem verificaes...",
        "turfSelfIntersectionDetectionFailed": "A biblioteca Turf.js  necessria para deteco de auto-interseco mas no est carregada.",
        "turfOverlapDetectionFailed": "A biblioteca Turf.js  necessria para deteco de sobreposio mas no est carregada.",
        "noOverlapsDetected": "Nenhuma sobreposio detectada. Os polgonos j esto limpos.",
        "polygonsDividedWarning": "Aviso: Alguns polgonos foram divididos em mltiplas partes durante a remoo de sobreposies.",
        "overlapRemovalCompleted": "Remoo de sobreposies concluda com sucesso.",
        "sliverRemovalCompleted": "Remoo de fragmentos concluda: {0} polgono(s) e {1} vrtice(s) removidos.",
        "noSliversDetected": "Remoo de fragmentos concluda: nenhum fragmento detectado.",
        "smallPolygonRemovalCompleted": "Remoo de polgonos pequenos concluda: {0} polgono(s) menores que {1} metros quadrados removidos.",
        "noSmallPolygonsFound": "Remoo de polgonos pequenos concluda: nenhum polgono menor que {1} metros quadrados encontrado.",
        "noPolygonsOrPointsFound": "Remoo de pontos em polgonos: nenhum polgono ou ponto encontrado para processar.",
        "pointsInPolygonsRemovalCompleted": "Remoo de pontos em polgonos concluda: {0} ponto(s) localizado(s) dentro de polgonos removidos.",
        "noPointsInPolygonsFound": "Remoo de pontos em polgonos concluda: nenhum ponto encontrado dentro de polgonos.",
        "collinearRemovalFailed": "Aviso: A remoo colinear falhou para o elemento {0}. Erro: {1}",
        "polygonClippingFailed": "Aviso: O recorte de polgono falhou para uma caracterstica. Mantendo parte original. Erro: {0}",
        "selfIntersectionFixFailed": "Aviso: A correo de auto-interseco falhou para o elemento {0}. Erro: {1}",
        "autoCleanRenderUpdateFailed": "Aviso: A atualizao de renderizao da Limpeza Automtica falhou. Erro: {0}",
        "autoCleanErrorOccurred": "Erro: Ocorreu um erro na Limpeza Automtica. Erro: {0}",
        "autoCleanRevertFailed": "Erro: A reverso da Limpeza Automtica falhou. Erro: {0}",
        "startEmptyProject": "Iniciar Projeto Vazio",
        "startOver": "Comear de Novo",
        "multipolygonSelection": "Seleo de MultiPolgono:",
        "polygonLabel": "Polgono:",
        "sliverRemovalFailed": "Aviso: A remoo de fragmentos falhou para o elemento {0}. Erro: {1}",
        "validationFailed": "Erro: A verificao falhou. {0}",
        "allChecksDone": "Todas as verificaes concludas, nenhum problema de qualidade encontrado.",
        "validationSummary": "Verificao de qualidade concluda: {0} vlidas, {1} invlidas de {2} recursos totais.",
        "validationSummaryWithDuplicates": "Verificao de qualidade concluda: {0} vlidas, {1} invlidas, {2} duplicadas de {3} recursos totais.",
        "validationSummaryWithDuplicatesAndOverlaps": "Verificao de qualidade concluda: {0} vlidas, {1} invlidas, {2} duplicadas, {3} sobreposies de {4} recursos totais.",
        "checkingOverlapsProgress": "Verificando sobreposies: polgono {0} de {1}...",
        "checkingOverlapsCompleted": "Verificao de sobreposies concluda: {0} pares sobrepostos encontrados",
        "processingOverlaps": "Processando sobreposies: {0} de ~{1} geometrias sobrepostas",
        "creatingOverlapRemovalPlan": "Criando Plano de Remoo de Sobreposies, por favor aguarde...",
        "noDuplicatePointsToRemove": "No h pontos duplicados para remover",
        "duplicateGeometryRemovalCompleted": "Remoo de geometrias duplicadas concluda",
        "fixedSelfIntersectingFeatures": "Recursos autointersectados corrigidos",
        "noPolygonHolesToRemove": "No h buracos de polgono para remover",
        "sliverRemovalCompleted": "Remoo de lascas concluda",
        "noOverlapsToRemove": "No h sobreposies para remover",
        "decomposingOverlappingFeatures": "Decompondo recursos sobrepostos...",
        "finalizingClippedGeometries": "Finalizando geometrias cortadas...",
        "reassemblingFeatures": "Remontando recursos...",
        "smallPolygonRemovalCompleted": "Remoo de polgonos pequenos concluda",
        "pointsInPolygonsRemovalCompleted": "Remoo de pontos em polgonos concluda",
        "collinearPointRemovalCompleted": "Remoo de pontos colineares concluda",
        "noSelfIntersectionsToFix": "No h autointerseces para corrigir",
        "identifiedIssues": "Problemas Identificados",
        "checkingSelfIntersectionsProgress": "Verificando autointerseces: recurso {0} de {1}...",
        "checkingSelfIntersectionsCompleted": "Verificao de autointerseces concluda: {0} recursos com autointerseces encontrados",
        "renderingValidationResults": "Renderizando resultados, por favor aguarde...",
        "validationErrorOccurred": "Erro: Ocorreu um erro na verificao de qualidade. {0}",
        "invalidFeaturesTitle": "Recursos invlidos encontrados",
        "invalidFeaturesMessage": "Seu arquivo contm {count} recursos geomtricos invlidos que no podem ser carregados. Isso geralmente significa recursos sem geometria, sem coordenadas ou com menos de 3 pontos para polgonos.",
        "downloadInvalidButton": "Baixar Recursos Invlidos",
        "continueWithValidButton": "Continuar com os Vlidos",
        "coordinatesCopied": "Coordenadas copiadas: {0}",
        "coordinatesCopyFailed": "Falha ao copiar coordenadas",
        "featureNoLongerExists": "O recurso no existe mais. Pode ter sido removido ou mesclado desde a verificao.",
        "noUndoAvailable": "Nada para desfazer",
        "noRedoAvailable": "Nada para refazer"
    }
    </script>

    <script type="application/json" id="lang-sw">
    {
        "title": "GeoRoots Editor",
        "pageTitle": "GeoRoots Editor - Mhariri wa GeoJSON",
        "collaborationText": "imefanywa kwa ushirikiano na",
        "downloadText": "Pakua toleo la hivi karibuni na zana nyingine katika",
        "subtitle": "Hii ni mhariri wa GeoJSON wa kuona kwa kuunda na kuhariri data za kijiografia.",
        "uploadText": "Buruta na udondoshe faili lako la GeoJSON hapa",
        "orText": "au",
        "selectGeoJSONButton": "Chagua Faili ya GeoJSON",
        "privacyText": "Faili lako na maudhui yake yote yanachakatwa tu ndani ya kivinjari chako na hakuna taarifa zako zinazotumwa kwa GeoRoots, watoa ramani au mtu mwingine yeyote.",
        "licenseText": "Programu hii ni bure, chini ya leseni ya vyanzo wazi GPLv3; angalia msimbo chanzo kwa taarifa kamili.",
        "processingText": "Inachakata data ya GeoJSON...",
        "hideControls": "Ficha vidhibiti",
        "showControls": "Onyesha vidhibiti",
        "editingControlsTitle": "Vifaa vya Kuhariri",
        "editingMode": "Hali:",
        "panMode": "Ona",
        "editMode": "Hariri",
        "validateMode": "Angalia",
        "editingTools": "Vifaa:",
        "selectTool": "Chagua na Hariri",
        "vertexTool": "Ongeza/Ondoa Kipeo",
        "editPropertiesBtn": "Hariri Sifa",
        "featureActions": "Vitendo vya Kipengele:",
        "removeFeature": "Ondoa Kipengele",
        "addPoint": "Ongeza Pointi",
        "addPolygon": "Ongeza Poligoni",
        "export": "Hamisha",
        "exportGeoJSON": "Hamisha GeoJSON",
        "exportCSV": "Hamisha CSV",
        "exportTitle": "Hamisha",
        "selectFileName": "Chagua jina la faili:",
        "validateAndExport": "Angalia yote na hamisha vipengele pamoja na ripoti ya ubora",
        "snapSettings": "Mipangilio ya Kukaza:",
        "enableSnap": "Washa Kukaza",
        "snapRadius": "Radi ya Kukaza (pikseli):",
        "legendTitle": "Maelezo",
        "plotBoundary": "Mpaka wa Shamba",
        "editProperties": "Hariri Sifa",
        "addProperty": "Ongeza Sifa",
        "saveProperties": "Hifadhi",
        "noProperties": "Hakuna sifa zilizopatikana",
        "propertiesTitle": "Sifa",
        "invalidGeoJSON": "Hitilafu katika kuchakata faili. Tafadhali hakikisha ni faili halali ya GeoJSON.",
        "streetMap": "Ramani ya Mitaa",
        "topoMap": "Ramani ya Topografia",
        "satelliteLatest": "Satilaiti ya Hivi Karibuni",
        "satellite2020": "Satilaiti ya 2020",
        "forestCoverage": "Ufunikaji wa Misitu (GFC 2020v2)",
        "treeCoverLossAttribution": "Upotevu wa Miti  Global Forest Watch",
        "esri2020Attribution": "Vigae  Esri 2020  Chanzo: Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": "Tume ya Ulaya JRC - Mabadiliko ya Misitu Duniani 2020v2",
        "preparing": "Inatayarisha",
        "outerRing": "Petu la Nje",
        "hole": "Shimo {i}",
        "keyPlaceholder": "Ufunguo",
        "valuePlaceholder": "Thamani",
        "dismiss": "Kataa",
        "closeButton": "",
        "selectLanguage": "Chagua lugha",
        "cancel": "Ghairi",
        "noFeaturesToExport": "Hakuna vipengele vya kuhamisha",
        "validatingFeatures": "Kuangalia vipengele...",
        "exportCompleted": "Uhamishaji umekamilika kwa mafanikio",
        "exportFailed": "Uhamishaji umeshindwa",
        "autoCleaner": "Usafishaji wa Kiotomatiki",
        "validation": "Uangalizi wa Data",
        "clean": "Safisha",
        "remove": "Ondoa",
        "validateGeometries": "Angalia Jiometri",
        "autoClean": "Usafishaji wa Kiotomatiki",
        "deduplicatingProgress": "Kuangalia nakala: kipengele {0} cha {1}...",
        "deduplicatingCompleted": "Uangalizi wa nakala umekamilika: nakala {0} zimepatikana",
        "holesProgress": "Kuangalia tundu katika poligoni: kipengele {0} cha {1}...",
        "holesCompleted": "Uangalizi wa tundu umekamilika: vipengele {0} vyenye tundu vimepatikana",
        "deletePolygonTitle": "Futa Poligoni?",
        "deletePolygonConfirm": "Poligoni hii ingekuwa na vipeo vichache zaidi ya 3. Je, unataka kufuta poligoni hii?",
        "autoCleanWarning": "Ikiwa unahitaji kurejesha mabadiliko ya Usafishaji wa Kiotomatiki, tumia Ctrl/Cmd+Z (rejesha) au Ctrl/Cmd+Y (fanya tena). Ctrl/Cmd+Q hubadilisha kati ya mabadiliko ya mwisho.",
        "closeUnclosedRings": "Funga pete zisizofungwa",
        "mandatory": "(lazima)",
        "removeDuplicateGeometries": "Ondoa jiometri zilizorudiwa",
        "fixPolygonSelfIntersection": "Sahihisha makutano ya poligoni",
        "removePolygonHoles": "Ondoa tundu katika poligoni",
        "removeSlivers": "Ondoa vipande na pembe kali (<4)",
        "removePolygonsBelow": "Ondoa poligoni chini ya",
        "squareMeters": "mita za mraba",
        "removePolygonOverlap": "Ondoa mwingiliano wa poligoni",
        "removePointsInPolygons": "Ondoa pointi zilizomo ndani ya poligoni",
        "removeRedundantCollinear": "Ondoa pointi za collinear zisizohitajika",
        "selectToolHint": "Chagua kipengele cha kuhariri. Buruta alama ya machungwa ili kuhamisha.",
        "vertexToolHint": "Bonyeza pointi za kati za kijani ili kuongeza vipeo. Bonyeza vipeo vya machungwa ili kuondoa. Buruta vipeo vya machungwa ili kusogeza.",
        "propertiesToolHint": "Bonyeza kipengele chochote ili kuhariri sifa zake.",
        "removeModeHint": "Hali ya kuondoa: bonyeza kipengele chochote ili kukifuta. Bonyeza tena ili kughairi.",
        "addPointHint": "Ongeza Pointi: bonyeza ramani ili kuweka pointi mpya.",
        "addPolygonHint": "Ongeza Poligoni: bonyeza ili kuongeza vipeo; bonyeza kulia ili kumaliza.",
        "validationReport": "Ripoti ya Ubora wa Data",
        "close": "Funga",
        "unsupportedGeometryWarning": "Aina za Jiometri Zisizotumika Zimegundulika",
        "unsupportedGeometryMessage": "Kuna LineStrings na/au MultiLineStrings katika seti yako ya data. Aina hizi za jiometri hazitumiki na EUDR. Kuendesha Auto Clean kutajaribu kuzibadilisha kuwa poligoni au kuzitoa ikiwa haziwezi kubadilishwa.",
        "validationSuccess": "Uchunguzi Wote Umefaulu",
        "noValidationIssues": "Seti yako ya data imepita vipimo vyote vya ubora. Hakuna matatizo yaliyopatikana.",
        "overallStatistics": "Takwimu Jumla",
        "totalFeatures": "Jumla ya Vipengele",
        "validFeatures": "Vipengele Halali",
        "featuresWithIssues": "Vipengele Vyenye Matatizo",
        "issueBreakdown": "Mgawanyiko wa Matatizo",
        "invalidGeometries": "Jiometri Batili",
        "selfIntersections": "Makutano ya Kujipigana",
        "featuresWithHoles": "Vipengele Vyenye Mashimo",
        "slivers": "Vipande Vidogo",
        "overlappingPairs": "Jozi Zinazopatana",
        "completed": "Imekamilika",
        "errorProcessingGeoJSON": "Hitilafu katika kuchakata GeoJSON: {0}",
        "turfLibraryNotLoaded": "Hitilafu: Maktaba ya Turf.js haijapakiwa. Kuondoa mwingiliano hawezi kuendelea.",
        "polygonClippingFailed": "Onyo: Kukata poligoni kumeshindwa kwa kipengele. Kuweka sehemu ya asili. Hitilafu: {0}",
        "turfLoadFailed": "Hitilafu: Maktaba ya Turf.js imeshindwa kupakia. Uangalizi wa ubora hauwezi kufanywa. Inapakia data bila uangalizi...",
        "turfSelfIntersectionDetectionFailed": "Maktaba ya Turf.js inahitajika kwa utambuzi wa makutano lakini haijapakiwa.",
        "turfOverlapDetectionFailed": "Maktaba ya Turf.js inahitajika kwa utambuzi wa mwingiliano lakini haijapakiwa.",
        "noOverlapsDetected": "Hakuna mwingiliano uliotambuliwa. Poligoni tayari ni safi.",
        "polygonsDividedWarning": "Onyo: Baadhi ya poligoni ziligawanywa katika sehemu nyingi wakati wa kuondoa mwingiliano.",
        "overlapRemovalCompleted": "Kuondoa mwingiliano kumekamilika kwa mafanikio.",
        "sliverRemovalCompleted": "Kuondoa vipande kumekamilika: {0} poligoni na {1} kipeo/vipeo viliondolewa.",
        "noSliversDetected": "Kuondoa vipande kumekamilika: hakuna vipande vilivyotambuliwa.",
        "smallPolygonRemovalCompleted": "Kuondoa poligoni ndogo kumekamilika: {0} poligoni ndogo zaidi ya {1} mita za mraba ziliondolewa.",
        "noSmallPolygonsFound": "Kuondoa poligoni ndogo kumekamilika: hakuna poligoni ndogo zaidi ya {1} mita za mraba zilizopatikana.",
        "noPolygonsOrPointsFound": "Kuondoa pointi katika poligoni: hakuna poligoni au pointi zilizopatikana kuchakatwa.",
        "pointsInPolygonsRemovalCompleted": "Kuondoa pointi katika poligoni kumekamilika: {0} pointi zilizomo ndani ya poligoni ziliondolewa.",
        "noPointsInPolygonsFound": "Kuondoa pointi katika poligoni kumekamilika: hakuna pointi zilizopatikana ndani ya poligoni.",
        "collinearRemovalFailed": "Onyo: Kuondoa collinear kumeshindwa kwa kipengele {0}. Hitilafu: {1}",
        "polygonClippingFailed": "Onyo: Kukata poligoni kumeshindwa kwa kipengele. Kuweka sehemu ya asili. Hitilafu: {0}",
        "selfIntersectionFixFailed": "Onyo: Kusahihisha makutano kumeshindwa kwa kipengele {0}. Hitilafu: {1}",
        "autoCleanRenderUpdateFailed": "Onyo: Kusasisha render ya Usafishaji wa Kiotomatiki kumeshindwa. Hitilafu: {0}",
        "autoCleanErrorOccurred": "Hitilafu: Hitilafu ya Usafishaji wa Kiotomatiki imetokea. Hitilafu: {0}",
        "autoCleanRevertFailed": "Hitilafu: Kurudisha Usafishaji wa Kiotomatiki kumeshindwa. Hitilafu: {0}",
        "startEmptyProject": "Anza Mradi Tupu",
        "startOver": "Anza Upya",
        "multipolygonSelection": "Uchaguzi wa MultiPoligoni:",
        "polygonLabel": "Poligoni:",
        "sliverRemovalFailed": "Onyo: Kuondoa vipande kumeshindwa kwa kipengele {0}. Hitilafu: {1}",
        "validationFailed": "Hitilafu: Uangalizi umeshindwa. {0}",
        "allChecksDone": "Vichunguzi vyote vimekamilika, hakuna matatizo ya ubora yamepatikana.",
        "validationSummary": "Uangalizi wa ubora umekamilika: {0} sahihi, {1} batili kati ya {2} vipengele jumla.",
        "validationSummaryWithDuplicates": "Uangalizi wa ubora umekamilika: {0} sahihi, {1} batili, {2} marudio kati ya {3} vipengele jumla.",
        "validationSummaryWithDuplicatesAndOverlaps": "Uangalizi wa ubora umekamilika: {0} sahihi, {1} batili, {2} marudio, {3} mipakani kati ya {4} vipengele jumla.",
        "checkingOverlapsProgress": "Kuangalia mipakani: poligoni {0} ya {1}...",
        "checkingOverlapsCompleted": "Uangalizi wa mipakani umekamilika: jozi {0} zinazopakana zimepatikana",
        "processingOverlaps": "Kuchakata mipakani: {0} kati ya ~{1} jiometri zinazopakana",
        "creatingOverlapRemovalPlan": "Kuunda Mpango wa Kuondoa Mipakani, tafadhali subiri...",
        "noDuplicatePointsToRemove": "Hakuna pointi za nakala za kuondoa",
        "duplicateGeometryRemovalCompleted": "Kuondoa jiometri za nakala kumekamilika",
        "fixedSelfIntersectingFeatures": "Vipengele vya kukatika kibinafsi vimerekebisha",
        "noPolygonHolesToRemove": "Hakuna mashimo ya poligoni ya kuondoa",
        "sliverRemovalCompleted": "Kuondoa vipande vidogo kumekamilika",
        "noOverlapsToRemove": "Hakuna mipakani ya kuondoa",
        "decomposingOverlappingFeatures": "Kuvunja vipengele vinavyopakana...",
        "finalizingClippedGeometries": "Kukamilisha jiometri zilizokatakata...",
        "reassemblingFeatures": "Kuunganisha vipengele tena...",
        "smallPolygonRemovalCompleted": "Kuondoa poligoni ndogo kumekamilika",
        "pointsInPolygonsRemovalCompleted": "Kuondoa pointi ndani ya poligoni kumekamilika",
        "collinearPointRemovalCompleted": "Kuondoa pointi za mstari mmoja kumekamilika",
        "noSelfIntersectionsToFix": "Hakuna mikatiko ya kibinafsi ya kurekebisha",
        "identifiedIssues": "Matatizo Yaliyotambuliwa",
        "checkingSelfIntersectionsProgress": "Kuangalia mikatiko ya kibinafsi: kipengele {0} cha {1}...",
        "checkingSelfIntersectionsCompleted": "Uangalizi wa mikatiko ya kibinafsi umekamilika: vipengele {0} vyenye mikatiko ya kibinafsi vimepatikana",
        "renderingValidationResults": "Kuonyesha matokeo, tafadhali subiri...",
        "validationErrorOccurred": "Hitilafu: Hitilafu ya uangalizi wa ubora imetokea. {0}",
        "invalidFeaturesTitle": "Vipengele Batili Vimepatikana",
        "invalidFeaturesMessage": "Faili yako ina {count} vipengele batili vya kijiometri ambavyo haviwezi kupakiwa. Hii kwa kawaida inamaanisha vipengele bila jiometri, bila kuratibu, au chini ya pointi 3 kwa poligoni.",
        "downloadInvalidButton": "Pakua Vipengele Batili",
        "continueWithValidButton": "Endelea na Vilivyo Sahihi",
        "coordinatesCopied": "Kuratibu zimenakiliwa: {0}",
        "coordinatesCopyFailed": "Kushindwa kunakili kuratibu",
        "featureNoLongerExists": "Kipengele hakipo tena. Huenda kimefutwa au kimeunganishwa tangu uangalizi.",
        "noUndoAvailable": "Hakuna cha kutendua",
        "noRedoAvailable": "Hakuna cha kurudia"
    }
    </script>

    <script type="application/json" id="lang-zh">
    {
        "title": "GeoRoots Editor",
        "pageTitle": "GeoRoots Editor - GeoJSON ",
        "collaborationText": "",
        "downloadText": "",
        "subtitle": " GeoJSON ",
        "uploadText": " GeoJSON ",
        "orText": "",
        "selectGeoJSONButton": " GeoJSON ",
        "privacyText": " GeoRoots",
        "licenseText": " GPLv3 ",
        "processingText": " GeoJSON ...",
        "hideControls": "",
        "showControls": "",
        "editingControlsTitle": "",
        "editingMode": "",
        "panMode": "",
        "editMode": "",
        "validateMode": "",
        "editingTools": "",
        "selectTool": "",
        "vertexTool": "/",
        "editPropertiesBtn": "",
        "featureActions": "",
        "removeFeature": "",
        "addPoint": "",
        "addPolygon": "",
        "export": "",
        "exportGeoJSON": " GeoJSON",
        "exportCSV": " CSV",
        "exportTitle": "",
        "selectFileName": "",
        "validateAndExport": "",
        "snapSettings": "",
        "enableSnap": "",
        "snapRadius": "",
        "legendTitle": "",
        "plotBoundary": "",
        "editProperties": "",
        "addProperty": "",
        "saveProperties": "",
        "noProperties": "",
        "propertiesTitle": "",
        "invalidGeoJSON": " GeoJSON ",
        "streetMap": "",
        "topoMap": "",
        "satelliteLatest": "",
        "satellite2020": "2020 ",
        "forestCoverage": "GFC 2020v2",
        "treeCoverLossAttribution": "  Global Forest Watch",
        "esri2020Attribution": "  Esri 2020  Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": " JRC -  2020v2",
        "preparing": "",
        "outerRing": "",
        "hole": " {i}",
        "keyPlaceholder": "",
        "valuePlaceholder": "",
        "dismiss": "",
        "closeButton": "",
        "selectLanguage": "",
        "cancel": "",
        "noFeaturesToExport": "",
        "validatingFeatures": "...",
        "exportCompleted": "",
        "exportFailed": "",
        "autoCleaner": "",
        "validation": "",
        "clean": "",
        "remove": "",
        "validateGeometries": "",
        "autoClean": "",
        "deduplicatingProgress": " {0}  {1} ...",
        "deduplicatingCompleted": " {0} ",
        "holesProgress": " {0}  {1} ...",
        "holesCompleted": " {0} ",
        "deletePolygonTitle": "",
        "deletePolygonConfirm": " 3 ",
        "autoCleanWarning": " Ctrl/Cmd+Z Ctrl/Cmd+YCtrl/Cmd+Q ",
        "closeUnclosedRings": "",
        "mandatory": "()",
        "removeDuplicateGeometries": "",
        "fixPolygonSelfIntersection": "",
        "removePolygonHoles": "",
        "removeSlivers": " (<4)",
        "removePolygonsBelow": "",
        "squareMeters": "",
        "removePolygonOverlap": "",
        "removePointsInPolygons": "",
        "removeRedundantCollinear": "",
        "selectToolHint": "",
        "vertexToolHint": "",
        "propertiesToolHint": "",
        "removeModeHint": "",
        "addPointHint": "",
        "addPolygonHint": "",
        "validationReport": "",
        "close": "",
        "unsupportedGeometryWarning": "",
        "unsupportedGeometryMessage": " LineStrings / MultiLineStrings EUDR ",
        "validationSuccess": "",
        "noValidationIssues": "",
        "overallStatistics": "",
        "totalFeatures": "",
        "validFeatures": "",
        "featuresWithIssues": "",
        "issueBreakdown": "",
        "invalidGeometries": "",
        "selfIntersections": "",
        "featuresWithHoles": "",
        "slivers": "",
        "overlappingPairs": "",
        "completed": "",
        "errorProcessingGeoJSON": " GeoJSON {0}",
        "turfLibraryNotLoaded": "Turf.js ",
        "polygonClippingFailed": "{0}",
        "turfLoadFailed": "Turf.js ...",
        "turfSelfIntersectionDetectionFailed": " Turf.js ",
        "turfOverlapDetectionFailed": " Turf.js ",
        "noOverlapsDetected": "",
        "polygonsDividedWarning": "",
        "overlapRemovalCompleted": "",
        "sliverRemovalCompleted": " {0}  {1} ",
        "noSliversDetected": "",
        "smallPolygonRemovalCompleted": " {0}  {1} ",
        "noSmallPolygonsFound": " {1} ",
        "noPolygonsOrPointsFound": "",
        "pointsInPolygonsRemovalCompleted": " {0} ",
        "noPointsInPolygonsFound": "",
        "collinearRemovalFailed": " {0} {1}",
        "polygonClippingFailed": "{0}",
        "selfIntersectionFixFailed": " {0} {1}",
        "autoCleanRenderUpdateFailed": "{0}",
        "autoCleanErrorOccurred": "{0}",
        "autoCleanRevertFailed": "{0}",
        "startEmptyProject": "",
        "startOver": "",
        "multipolygonSelection": "",
        "polygonLabel": "",
        "sliverRemovalFailed": " {0} {1}",
        "validationFailed": "{0}",
        "allChecksDone": "",
        "validationSummary": "{0} {1}  {2} ",
        "validationSummaryWithDuplicates": "{0} {1} {2}  {3} ",
        "validationSummaryWithDuplicatesAndOverlaps": "{0} {1} {2} {3}  {4} ",
        "checkingOverlapsProgress": " {0}  {1} ...",
        "checkingOverlapsCompleted": " {0} ",
        "processingOverlaps": "{0} / ~{1} ",
        "creatingOverlapRemovalPlan": "...",
        "noDuplicatePointsToRemove": "",
        "duplicateGeometryRemovalCompleted": "",
        "fixedSelfIntersectingFeatures": "",
        "noPolygonHolesToRemove": "",
        "sliverRemovalCompleted": "",
        "noOverlapsToRemove": "",
        "decomposingOverlappingFeatures": "...",
        "finalizingClippedGeometries": "...",
        "reassemblingFeatures": "...",
        "smallPolygonRemovalCompleted": "",
        "pointsInPolygonsRemovalCompleted": "",
        "collinearPointRemovalCompleted": "",
        "noSelfIntersectionsToFix": "",
        "identifiedIssues": "",
        "checkingSelfIntersectionsProgress": " {0}  {1} ...",
        "checkingSelfIntersectionsCompleted": " {0} ",
        "renderingValidationResults": "...",
        "validationErrorOccurred": "{0}",
        "invalidFeaturesTitle": "",
        "invalidFeaturesMessage": " {count} 3",
        "downloadInvalidButton": "",
        "continueWithValidButton": "",
        "coordinatesCopied": "{0}",
        "coordinatesCopyFailed": "",
        "featureNoLongerExists": "",
        "noUndoAvailable": "",
        "noRedoAvailable": ""
    }
    </script>

    <script type="application/json" id="lang-th">
    {
        "title": "GeoRoots Editor",
        "pageTitle": "GeoRoots Editor -  GeoJSON",
        "collaborationText": "",
        "downloadText": "  ",
        "subtitle": " GeoJSON ",
        "uploadText": " GeoJSON ",
        "orText": "",
        "selectGeoJSONButton": " GeoJSON",
        "privacyText": "    GeoRoots  ",
        "licenseText": "  GPLv3 ",
        "processingText": " GeoJSON...",
        "hideControls": "",
        "showControls": "",
        "editingControlsTitle": "",
        "editingMode": ":",
        "panMode": "",
        "editMode": "",
        "validateMode": "",
        "editingTools": ":",
        "selectTool": "",
        "vertexTool": "/",
        "editPropertiesBtn": "",
        "featureActions": ":",
        "removeFeature": "",
        "addPoint": "",
        "addPolygon": "",
        "export": "",
        "exportGeoJSON": " GeoJSON",
        "exportCSV": " CSV",
        "exportTitle": "",
        "selectFileName": ":",
        "validateAndExport": "",
        "snapSettings": ":",
        "enableSnap": "",
        "snapRadius": " ():",
        "legendTitle": "",
        "plotBoundary": "",
        "editProperties": "",
        "addProperty": "",
        "saveProperties": "",
        "noProperties": "",
        "propertiesTitle": "",
        "invalidGeoJSON": "  GeoJSON ",
        "streetMap": "",
        "topoMap": "",
        "satelliteLatest": "",
        "satellite2020": " 2020",
        "forestCoverage": " (GFC 2020v2)",
        "treeCoverLossAttribution": "  Global Forest Watch",
        "esri2020Attribution": "  Esri 2020  : Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": " JRC -  2020v2",
        "preparing": "",
        "outerRing": "",
        "hole": " {i}",
        "keyPlaceholder": "",
        "valuePlaceholder": "",
        "dismiss": "",
        "closeButton": "",
        "selectLanguage": "",
        "cancel": "",
        "noFeaturesToExport": "",
        "validatingFeatures": "...",
        "exportCompleted": "",
        "exportFailed": "",
        "autoCleaner": "",
        "validation": "",
        "clean": "",
        "remove": "",
        "validateGeometries": "",
        "autoClean": "",
        "deduplicatingProgress": ":  {0}  {1}...",
        "deduplicatingCompleted": ":  {0} ",
        "holesProgress": ":  {0}  {1}...",
        "holesCompleted": ":  {0} ",
        "deletePolygonTitle": "?",
        "deletePolygonConfirm": " 3  ?",
        "autoCleanWarning": "  Ctrl/Cmd+Z ()  Ctrl/Cmd+Y () Ctrl/Cmd+Q ",
        "closeUnclosedRings": "",
        "mandatory": "()",
        "removeDuplicateGeometries": "",
        "fixPolygonSelfIntersection": "",
        "removePolygonHoles": "",
        "removeSlivers": " (<4)",
        "removePolygonsBelow": "",
        "squareMeters": "",
        "removePolygonOverlap": "",
        "removePointsInPolygons": "",
        "removeRedundantCollinear": "",
        "selectToolHint": " ",
        "vertexToolHint": "  ",
        "propertiesToolHint": "",
        "removeModeHint": ":  ",
        "addPointHint": ": ",
        "addPolygonHint": ":  ",
        "validationReport": "",
        "close": "",
        "unsupportedGeometryWarning": "",
        "unsupportedGeometryMessage": " LineStrings / MultiLineStrings   EUDR  Auto Clean ",
        "validationSuccess": "",
        "noValidationIssues": " ",
        "overallStatistics": "",
        "totalFeatures": "",
        "validFeatures": "",
        "featuresWithIssues": "",
        "issueBreakdown": "",
        "invalidGeometries": "",
        "selfIntersections": "",
        "featuresWithHoles": "",
        "slivers": "",
        "overlappingPairs": "",
        "completed": "",
        "errorProcessingGeoJSON": " GeoJSON: {0}",
        "turfLibraryNotLoaded": ":  Turf.js  ",
        "polygonClippingFailed": ":   : {0}",
        "turfLoadFailed": ":  Turf.js   ...",
        "turfSelfIntersectionDetectionFailed": " Turf.js  ",
        "turfOverlapDetectionFailed": " Turf.js  ",
        "noOverlapsDetected": " ",
        "polygonsDividedWarning": ": ",
        "overlapRemovalCompleted": "",
        "sliverRemovalCompleted": ":  {0}  {1} ",
        "noSliversDetected": ": ",
        "smallPolygonRemovalCompleted": ":  {0}  {1} ",
        "noSmallPolygonsFound": ":  {1} ",
        "noPolygonsOrPointsFound": ": ",
        "pointsInPolygonsRemovalCompleted": ":  {0} ",
        "noPointsInPolygonsFound": ": ",
        "collinearRemovalFailed": ":  {0} : {1}",
        "polygonClippingFailed": ":   : {0}",
        "selfIntersectionFixFailed": ":  {0} : {1}",
        "autoCleanRenderUpdateFailed": ":  : {0}",
        "autoCleanErrorOccurred": ":  : {0}",
        "autoCleanRevertFailed": ":  : {0}",
        "startEmptyProject": "",
        "startOver": "",
        "multipolygonSelection": ":",
        "polygonLabel": ":",
        "sliverRemovalFailed": ":  {0} : {1}",
        "validationFailed": ":  {0}",
        "allChecksDone": " ",
        "validationSummary": ": {0} , {1}   {2} ",
        "validationSummaryWithDuplicates": ": {0} , {1} , {2}   {3} ",
        "validationSummaryWithDuplicatesAndOverlaps": ": {0} , {1} , {2} , {3}   {4} ",
        "checkingOverlapsProgress": ":  {0}  {1}...",
        "checkingOverlapsCompleted": ":  {0} ",
        "processingOverlaps": ": {0}  ~{1} ",
        "creatingOverlapRemovalPlan": " ...",
        "noDuplicatePointsToRemove": "",
        "duplicateGeometryRemovalCompleted": "",
        "fixedSelfIntersectingFeatures": "",
        "noPolygonHolesToRemove": "",
        "sliverRemovalCompleted": " ",
        "noOverlapsToRemove": "",
        "decomposingOverlappingFeatures": "...",
        "finalizingClippedGeometries": "...",
        "reassemblingFeatures": "...",
        "smallPolygonRemovalCompleted": "",
        "pointsInPolygonsRemovalCompleted": "",
        "collinearPointRemovalCompleted": "",
        "noSelfIntersectionsToFix": "",
        "identifiedIssues": "",
        "checkingSelfIntersectionsProgress": ":  {0}  {1}...",
        "checkingSelfIntersectionsCompleted": ":  {0} ",
        "renderingValidationResults": " ...",
        "validationErrorOccurred": ":  {0}",
        "invalidFeaturesTitle": "",
        "invalidFeaturesMessage": " {count}     3 ",
        "downloadInvalidButton": "",
        "continueWithValidButton": "",
        "coordinatesCopied": ": {0}",
        "coordinatesCopyFailed": "",
        "featureNoLongerExists": " ",
        "noUndoAvailable": "",
        "noRedoAvailable": ""
    }
    </script>

    <script type="application/json" id="lang-am">
    {
        "title": "GeoRoots Editor",
        "pageTitle": "GeoRoots Editor - GeoJSON ",
        "collaborationText": "  ",
        "downloadText": "     ",
        "subtitle": " GeoJSON       ",
        "uploadText": "GeoJSON     ",
        "orText": "",
        "selectGeoJSONButton": "GeoJSON  ",
        "privacyText": "         GeoRoots    ",
        "licenseText": "     GPLv3          ",
        "processingText": "GeoJSON   ...",
        "hideControls": " ",
        "showControls": " ",
        "editingControlsTitle": " ",
        "editingMode": ":",
        "panMode": "",
        "editMode": "",
        "validateMode": "",
        "editingTools": ":",
        "selectTool": "  ",
        "vertexTool": " /",
        "editPropertiesBtn": " ",
        "featureActions": " :",
        "removeFeature": " ",
        "addPoint": " ",
        "addPolygon": " ",
        "export": "",
        "exportGeoJSON": "GeoJSON ",
        "exportCSV": "CSV ",
        "exportTitle": "",
        "selectFileName": "  :",
        "validateAndExport": "       ",
        "snapSettings": " :",
        "enableSnap": " ",
        "snapRadius": "  ():",
        "legendTitle": "",
        "plotBoundary": " ",
        "editProperties": " ",
        "addProperty": " ",
        "saveProperties": "",
        "noProperties": "  ",
        "propertiesTitle": "",
        "invalidGeoJSON": "      GeoJSON   ",
        "streetMap": " ",
        "topoMap": " ",
        "satelliteLatest": "  ",
        "satellite2020": "2020 ",
        "forestCoverage": "  (GFC 2020v2)",
        "treeCoverLossAttribution": "    Global Forest Watch",
        "esri2020Attribution": "  Esri 2020  : Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": "  JRC -    2020v2",
        "preparing": " ",
        "outerRing": " ",
        "hole": " {i}",
        "keyPlaceholder": "",
        "valuePlaceholder": "",
        "dismiss": "",
        "closeButton": "",
        "selectLanguage": " ",
        "cancel": "",
        "noFeaturesToExport": "   ",
        "validatingFeatures": "  ...",
        "exportCompleted": "   ",
        "exportFailed": " ",
        "autoCleaner": "- ",
        "validation": " ",
        "clean": "",
        "remove": "",
        "validateGeometries": " ",
        "autoClean": "- ",
        "deduplicatingProgress": "  :   {0}  {1}...",
        "deduplicatingCompleted": "   : {0}   ",
        "holesProgress": "   :   {0}  {1}...",
        "holesCompleted": "  : {0}     ",
        "deletePolygonTitle": " ?",
        "deletePolygonConfirm": "  3       ?",
        "autoCleanWarning": "-     Ctrl/Cmd+Z ()  Ctrl/Cmd+Y ()  Ctrl/Cmd+Q    ",
        "closeUnclosedRings": "  ",
        "mandatory": "()",
        "removeDuplicateGeometries": "  ",
        "fixPolygonSelfIntersection": "   ",
        "removePolygonHoles": "  ",
        "removeSlivers": "      (<4)",
        "removePolygonsBelow": "    ",
        "squareMeters": " ",
        "removePolygonOverlap": "  ",
        "removePointsInPolygons": "    ",
        "removeRedundantCollinear": "   ",
        "selectToolHint": "      ",
        "vertexToolHint": "             ",
        "propertiesToolHint": "    ",
        "removeModeHint": " :       ",
        "addPointHint": " :      ",
        "addPolygonHint": " :   ;   ",
        "validationReport": "  ",
        "close": "",
        "unsupportedGeometryWarning": "   ",
        "unsupportedGeometryMessage": "   LineStrings / MultiLineStrings      EUDR  Auto Clean         ",
        "validationSuccess": "  ",
        "noValidationIssues": "        ",
        "overallStatistics": " ",
        "totalFeatures": " ",
        "validFeatures": " ",
        "featuresWithIssues": "  ",
        "issueBreakdown": " ",
        "invalidGeometries": "  ",
        "selfIntersections": " ",
        "featuresWithHoles": "  ",
        "slivers": " ",
        "overlappingPairs": " ",
        "completed": "",
        "errorProcessingGeoJSON": "GeoJSON   : {0}",
        "turfLibraryNotLoaded": ": Turf.js -     ",
        "polygonClippingFailed": ":        : {0}",
        "turfLoadFailed": ": Turf.js -           ...",
        "turfSelfIntersectionDetectionFailed": "Turf.js - -    ",
        "turfOverlapDetectionFailed": "Turf.js -     ",
        "noOverlapsDetected": "      ",
        "polygonsDividedWarning": ":          ",
        "overlapRemovalCompleted": "    ",
        "sliverRemovalCompleted": "   : {0} ()  {1} () ",
        "noSliversDetected": "   :    ",
        "smallPolygonRemovalCompleted": "   : {0} () {1}    ",
        "noSmallPolygonsFound": "   : {1}     ",
        "noPolygonsOrPointsFound": "    :     ",
        "pointsInPolygonsRemovalCompleted": "     : {0} ()    ",
        "noPointsInPolygonsFound": "     :     ",
        "collinearRemovalFailed": ":    {0}  : {1}",
        "polygonClippingFailed": ":        : {0}",
        "selfIntersectionFixFailed": ":     {0}  : {1}",
        "autoCleanRenderUpdateFailed": ": -     : {0}",
        "autoCleanErrorOccurred": ": -     : {0}",
        "autoCleanRevertFailed": ": -    : {0}",
        "startEmptyProject": "  ",
        "startOver": " ",
        "multipolygonSelection": "  :",
        "polygonLabel": ":",
        "sliverRemovalFailed": ":     {0}  : {1}",
        "validationFailed": ":   {0}",
        "allChecksDone": "      ",
        "validationSummary": "  : {0}  {1}   {2}  ",
        "validationSummaryWithDuplicates": "  : {0}  {1}   {2}  {3}  ",
        "validationSummaryWithDuplicatesAndOverlaps": "  : {0}  {1}   {2}  {3}  {4}  ",
        "checkingOverlapsProgress": "  :  {0}  {1}...",
        "checkingOverlapsCompleted": "  : {0}   ",
        "processingOverlaps": "  : {0}  ~{1}  ",
        "creatingOverlapRemovalPlan": "      ...",
        "noDuplicatePointsToRemove": "    ",
        "duplicateGeometryRemovalCompleted": "   ",
        "fixedSelfIntersectingFeatures": "   ",
        "noPolygonHolesToRemove": "    ",
        "sliverRemovalCompleted": "   ",
        "noOverlapsToRemove": "   ",
        "decomposingOverlappingFeatures": "   ...",
        "finalizingClippedGeometries": "   ...",
        "reassemblingFeatures": "   ...",
        "smallPolygonRemovalCompleted": "   ",
        "pointsInPolygonsRemovalCompleted": "     ",
        "collinearPointRemovalCompleted": "      ",
        "noSelfIntersectionsToFix": "    ",
        "identifiedIssues": " ",
        "checkingSelfIntersectionsProgress": "   :  {0}  {1}...",
        "checkingSelfIntersectionsCompleted": "   : {0}    ",
        "renderingValidationResults": "    ...",
        "validationErrorOccurred": ":      {0}",
        "invalidFeaturesTitle": "   ",
        "invalidFeaturesMessage": "   {count}              3      ",
        "downloadInvalidButton": "   ",
        "continueWithValidButton": " ",
        "coordinatesCopied": " : {0}",
        "coordinatesCopyFailed": "  ",
        "featureNoLongerExists": "          ",
        "noUndoAvailable": "  ",
        "noRedoAvailable": "   "
    }
    </script>

    <!-- Scripts -->
    
    <!--
    ============================================================================
    Leaflet JavaScript Library - BSD 2-Clause License
    ============================================================================
    
    Copyright (c) 2010-2025, Volodymyr Agafonkin
    Copyright (c) 2010-2011, CloudMade
    All rights reserved.
    
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:
    
    1. Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.
    
    2. Redistributions in binary form must reproduce the above copyright notice,
       this list of conditions and the following disclaimer in the documentation
       and/or other materials provided with the distribution.
    
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
    ============================================================================
    -->
    <script>
    /* @preserve
    * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
    * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
    */
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).leaflet={})}(this,function(t){"use strict";function l(t){for(var e,i,n=1,o=arguments.length;n<o;n++)for(e in i=arguments[n])t[e]=i[e];return t}var R=Object.create||function(t){return N.prototype=t,new N};function N(){}function a(t,e){var i,n=Array.prototype.slice;return t.bind?t.bind.apply(t,n.call(arguments,1)):(i=n.call(arguments,2),function(){return t.apply(e,i.length?i.concat(n.call(arguments)):arguments)})}var D=0;function h(t){return"_leaflet_id"in t||(t._leaflet_id=++D),t._leaflet_id}function j(t,e,i){var n,o,s=function(){n=!1,o&&(r.apply(i,o),o=!1)},r=function(){n?o=arguments:(t.apply(i,arguments),setTimeout(s,e),n=!0)};return r}function H(t,e,i){var n=e[1],e=e[0],o=n-e;return t===n&&i?t:((t-e)%o+o)%o+e}function u(){return!1}function i(t,e){return!1===e?t:(e=Math.pow(10,void 0===e?6:e),Math.round(t*e)/e)}function W(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}function F(t){return W(t).split(/\s+/)}function c(t,e){for(var i in Object.prototype.hasOwnProperty.call(t,"options")||(t.options=t.options?R(t.options):{}),e)t.options[i]=e[i];return t.options}function U(t,e,i){var n,o=[];for(n in t)o.push(encodeURIComponent(i?n.toUpperCase():n)+"="+encodeURIComponent(t[n]));return(e&&-1!==e.indexOf("?")?"&":"?")+o.join("&")}var V=/\{ *([\w_ -]+) *\}/g;function q(t,i){return t.replace(V,function(t,e){e=i[e];if(void 0===e)throw new Error("No value provided for variable "+t);return e="function"==typeof e?e(i):e})}var d=Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)};function G(t,e){for(var i=0;i<t.length;i++)if(t[i]===e)return i;return-1}var K="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";function Y(t){return window["webkit"+t]||window["moz"+t]||window["ms"+t]}var X=0;function J(t){var e=+new Date,i=Math.max(0,16-(e-X));return X=e+i,window.setTimeout(t,i)}var $=window.requestAnimationFrame||Y("RequestAnimationFrame")||J,Q=window.cancelAnimationFrame||Y("CancelAnimationFrame")||Y("CancelRequestAnimationFrame")||function(t){window.clearTimeout(t)};function x(t,e,i){if(!i||$!==J)return $.call(window,a(t,e));t.call(e)}function r(t){t&&Q.call(window,t)}var tt={__proto__:null,extend:l,create:R,bind:a,get lastId(){return D},stamp:h,throttle:j,wrapNum:H,falseFn:u,formatNum:i,trim:W,splitWords:F,setOptions:c,getParamString:U,template:q,isArray:d,indexOf:G,emptyImageUrl:K,requestFn:$,cancelFn:Q,requestAnimFrame:x,cancelAnimFrame:r};function et(){}et.extend=function(t){function e(){c(this),this.initialize&&this.initialize.apply(this,arguments),this.callInitHooks()}var i,n=e.__super__=this.prototype,o=R(n);for(i in(o.constructor=e).prototype=o,this)Object.prototype.hasOwnProperty.call(this,i)&&"prototype"!==i&&"__super__"!==i&&(e[i]=this[i]);if(t.statics&&l(e,t.statics),t.includes){var s=t.includes;if("undefined"!=typeof L&&L&&L.Mixin){s=d(s)?s:[s];for(var r=0;r<s.length;r++)s[r]===L.Mixin.Events&&console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.",(new Error).stack)}l.apply(null,[o].concat(t.includes))}return l(o,t),delete o.statics,delete o.includes,o.options&&(o.options=n.options?R(n.options):{},l(o.options,t.options)),o._initHooks=[],o.callInitHooks=function(){if(!this._initHooksCalled){n.callInitHooks&&n.callInitHooks.call(this),this._initHooksCalled=!0;for(var t=0,e=o._initHooks.length;t<e;t++)o._initHooks[t].call(this)}},e},et.include=function(t){var e=this.prototype.options;return l(this.prototype,t),t.options&&(this.prototype.options=e,this.mergeOptions(t.options)),this},et.mergeOptions=function(t){return l(this.prototype.options,t),this},et.addInitHook=function(t){var e=Array.prototype.slice.call(arguments,1),i="function"==typeof t?t:function(){this[t].apply(this,e)};return this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(i),this};var e={on:function(t,e,i){if("object"==typeof t)for(var n in t)this._on(n,t[n],e);else for(var o=0,s=(t=F(t)).length;o<s;o++)this._on(t[o],e,i);return this},off:function(t,e,i){if(arguments.length)if("object"==typeof t)for(var n in t)this._off(n,t[n],e);else{t=F(t);for(var o=1===arguments.length,s=0,r=t.length;s<r;s++)o?this._off(t[s]):this._off(t[s],e,i)}else delete this._events;return this},_on:function(t,e,i,n){"function"!=typeof e?console.warn("wrong listener type: "+typeof e):!1===this._listens(t,e,i)&&(e={fn:e,ctx:i=i===this?void 0:i},n&&(e.once=!0),this._events=this._events||{},this._events[t]=this._events[t]||[],this._events[t].push(e))},_off:function(t,e,i){var n,o,s;if(this._events&&(n=this._events[t]))if(1===arguments.length){if(this._firingCount)for(o=0,s=n.length;o<s;o++)n[o].fn=u;delete this._events[t]}else"function"!=typeof e?console.warn("wrong listener type: "+typeof e):!1!==(e=this._listens(t,e,i))&&(i=n[e],this._firingCount&&(i.fn=u,this._events[t]=n=n.slice()),n.splice(e,1))},fire:function(t,e,i){if(this.listens(t,i)){var n=l({},e,{type:t,target:this,sourceTarget:e&&e.sourceTarget||this});if(this._events){var o=this._events[t];if(o){this._firingCount=this._firingCount+1||1;for(var s=0,r=o.length;s<r;s++){var a=o[s],h=a.fn;a.once&&this.off(t,h,a.ctx),h.call(a.ctx||this,n)}this._firingCount--}}i&&this._propagateEvent(n)}return this},listens:function(t,e,i,n){"string"!=typeof t&&console.warn('"string" type argument expected');var o=e,s=("function"!=typeof e&&(n=!!e,i=o=void 0),this._events&&this._events[t]);if(s&&s.length&&!1!==this._listens(t,o,i))return!0;if(n)for(var r in this._eventParents)if(this._eventParents[r].listens(t,e,i,n))return!0;return!1},_listens:function(t,e,i){if(this._events){var n=this._events[t]||[];if(!e)return!!n.length;i===this&&(i=void 0);for(var o=0,s=n.length;o<s;o++)if(n[o].fn===e&&n[o].ctx===i)return o}return!1},once:function(t,e,i){if("object"==typeof t)for(var n in t)this._on(n,t[n],e,!0);else for(var o=0,s=(t=F(t)).length;o<s;o++)this._on(t[o],e,i,!0);return this},addEventParent:function(t){return this._eventParents=this._eventParents||{},this._eventParents[h(t)]=t,this},removeEventParent:function(t){return this._eventParents&&delete this._eventParents[h(t)],this},_propagateEvent:function(t){for(var e in this._eventParents)this._eventParents[e].fire(t.type,l({layer:t.target,propagatedFrom:t.target},t),!0)}},it=(e.addEventListener=e.on,e.removeEventListener=e.clearAllEventListeners=e.off,e.addOneTimeEventListener=e.once,e.fireEvent=e.fire,e.hasEventListeners=e.listens,et.extend(e));function p(t,e,i){this.x=i?Math.round(t):t,this.y=i?Math.round(e):e}var nt=Math.trunc||function(t){return 0<t?Math.floor(t):Math.ceil(t)};function m(t,e,i){return t instanceof p?t:d(t)?new p(t[0],t[1]):null==t?t:"object"==typeof t&&"x"in t&&"y"in t?new p(t.x,t.y):new p(t,e,i)}function f(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;n<o;n++)this.extend(i[n])}function _(t,e){return!t||t instanceof f?t:new f(t,e)}function s(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;n<o;n++)this.extend(i[n])}function g(t,e){return t instanceof s?t:new s(t,e)}function v(t,e,i){if(isNaN(t)||isNaN(e))throw new Error("Invalid LatLng object: ("+t+", "+e+")");this.lat=+t,this.lng=+e,void 0!==i&&(this.alt=+i)}function w(t,e,i){return t instanceof v?t:d(t)&&"object"!=typeof t[0]?3===t.length?new v(t[0],t[1],t[2]):2===t.length?new v(t[0],t[1]):null:null==t?t:"object"==typeof t&&"lat"in t?new v(t.lat,"lng"in t?t.lng:t.lon,t.alt):void 0===e?null:new v(t,e,i)}p.prototype={clone:function(){return new p(this.x,this.y)},add:function(t){return this.clone()._add(m(t))},_add:function(t){return this.x+=t.x,this.y+=t.y,this},subtract:function(t){return this.clone()._subtract(m(t))},_subtract:function(t){return this.x-=t.x,this.y-=t.y,this},divideBy:function(t){return this.clone()._divideBy(t)},_divideBy:function(t){return this.x/=t,this.y/=t,this},multiplyBy:function(t){return this.clone()._multiplyBy(t)},_multiplyBy:function(t){return this.x*=t,this.y*=t,this},scaleBy:function(t){return new p(this.x*t.x,this.y*t.y)},unscaleBy:function(t){return new p(this.x/t.x,this.y/t.y)},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},ceil:function(){return this.clone()._ceil()},_ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this},trunc:function(){return this.clone()._trunc()},_trunc:function(){return this.x=nt(this.x),this.y=nt(this.y),this},distanceTo:function(t){var e=(t=m(t)).x-this.x,t=t.y-this.y;return Math.sqrt(e*e+t*t)},equals:function(t){return(t=m(t)).x===this.x&&t.y===this.y},contains:function(t){return t=m(t),Math.abs(t.x)<=Math.abs(this.x)&&Math.abs(t.y)<=Math.abs(this.y)},toString:function(){return"Point("+i(this.x)+", "+i(this.y)+")"}},f.prototype={extend:function(t){var e,i;if(t){if(t instanceof p||"number"==typeof t[0]||"x"in t)e=i=m(t);else if(e=(t=_(t)).min,i=t.max,!e||!i)return this;this.min||this.max?(this.min.x=Math.min(e.x,this.min.x),this.max.x=Math.max(i.x,this.max.x),this.min.y=Math.min(e.y,this.min.y),this.max.y=Math.max(i.y,this.max.y)):(this.min=e.clone(),this.max=i.clone())}return this},getCenter:function(t){return m((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,t)},getBottomLeft:function(){return m(this.min.x,this.max.y)},getTopRight:function(){return m(this.max.x,this.min.y)},getTopLeft:function(){return this.min},getBottomRight:function(){return this.max},getSize:function(){return this.max.subtract(this.min)},contains:function(t){var e,i;return(t=("number"==typeof t[0]||t instanceof p?m:_)(t))instanceof f?(e=t.min,i=t.max):e=i=t,e.x>=this.min.x&&i.x<=this.max.x&&e.y>=this.min.y&&i.y<=this.max.y},intersects:function(t){t=_(t);var e=this.min,i=this.max,n=t.min,t=t.max,o=t.x>=e.x&&n.x<=i.x,t=t.y>=e.y&&n.y<=i.y;return o&&t},overlaps:function(t){t=_(t);var e=this.min,i=this.max,n=t.min,t=t.max,o=t.x>e.x&&n.x<i.x,t=t.y>e.y&&n.y<i.y;return o&&t},isValid:function(){return!(!this.min||!this.max)},pad:function(t){var e=this.min,i=this.max,n=Math.abs(e.x-i.x)*t,t=Math.abs(e.y-i.y)*t;return _(m(e.x-n,e.y-t),m(i.x+n,i.y+t))},equals:function(t){return!!t&&(t=_(t),this.min.equals(t.getTopLeft())&&this.max.equals(t.getBottomRight()))}},s.prototype={extend:function(t){var e,i,n=this._southWest,o=this._northEast;if(t instanceof v)i=e=t;else{if(!(t instanceof s))return t?this.extend(w(t)||g(t)):this;if(e=t._southWest,i=t._northEast,!e||!i)return this}return n||o?(n.lat=Math.min(e.lat,n.lat),n.lng=Math.min(e.lng,n.lng),o.lat=Math.max(i.lat,o.lat),o.lng=Math.max(i.lng,o.lng)):(this._southWest=new v(e.lat,e.lng),this._northEast=new v(i.lat,i.lng)),this},pad:function(t){var e=this._southWest,i=this._northEast,n=Math.abs(e.lat-i.lat)*t,t=Math.abs(e.lng-i.lng)*t;return new s(new v(e.lat-n,e.lng-t),new v(i.lat+n,i.lng+t))},getCenter:function(){return new v((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new v(this.getNorth(),this.getWest())},getSouthEast:function(){return new v(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(t){t=("number"==typeof t[0]||t instanceof v||"lat"in t?w:g)(t);var e,i,n=this._southWest,o=this._northEast;return t instanceof s?(e=t.getSouthWest(),i=t.getNorthEast()):e=i=t,e.lat>=n.lat&&i.lat<=o.lat&&e.lng>=n.lng&&i.lng<=o.lng},intersects:function(t){t=g(t);var e=this._southWest,i=this._northEast,n=t.getSouthWest(),t=t.getNorthEast(),o=t.lat>=e.lat&&n.lat<=i.lat,t=t.lng>=e.lng&&n.lng<=i.lng;return o&&t},overlaps:function(t){t=g(t);var e=this._southWest,i=this._northEast,n=t.getSouthWest(),t=t.getNorthEast(),o=t.lat>e.lat&&n.lat<i.lat,t=t.lng>e.lng&&n.lng<i.lng;return o&&t},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(",")},equals:function(t,e){return!!t&&(t=g(t),this._southWest.equals(t.getSouthWest(),e)&&this._northEast.equals(t.getNorthEast(),e))},isValid:function(){return!(!this._southWest||!this._northEast)}};var ot={latLngToPoint:function(t,e){t=this.projection.project(t),e=this.scale(e);return this.transformation._transform(t,e)},pointToLatLng:function(t,e){e=this.scale(e),t=this.transformation.untransform(t,e);return this.projection.unproject(t)},project:function(t){return this.projection.project(t)},unproject:function(t){return this.projection.unproject(t)},scale:function(t){return 256*Math.pow(2,t)},zoom:function(t){return Math.log(t/256)/Math.LN2},getProjectedBounds:function(t){var e;return this.infinite?null:(e=this.projection.bounds,t=this.scale(t),new f(this.transformation.transform(e.min,t),this.transformation.transform(e.max,t)))},infinite:!(v.prototype={equals:function(t,e){return!!t&&(t=w(t),Math.max(Math.abs(this.lat-t.lat),Math.abs(this.lng-t.lng))<=(void 0===e?1e-9:e))},toString:function(t){return"LatLng("+i(this.lat,t)+", "+i(this.lng,t)+")"},distanceTo:function(t){return st.distance(this,w(t))},wrap:function(){return st.wrapLatLng(this)},toBounds:function(t){var t=180*t/40075017,e=t/Math.cos(Math.PI/180*this.lat);return g([this.lat-t,this.lng-e],[this.lat+t,this.lng+e])},clone:function(){return new v(this.lat,this.lng,this.alt)}}),wrapLatLng:function(t){var e=this.wrapLng?H(t.lng,this.wrapLng,!0):t.lng;return new v(this.wrapLat?H(t.lat,this.wrapLat,!0):t.lat,e,t.alt)},wrapLatLngBounds:function(t){var e=t.getCenter(),i=this.wrapLatLng(e),n=e.lat-i.lat,e=e.lng-i.lng;return 0==n&&0==e?t:(i=t.getSouthWest(),t=t.getNorthEast(),new s(new v(i.lat-n,i.lng-e),new v(t.lat-n,t.lng-e)))}},st=l({},ot,{wrapLng:[-180,180],R:6371e3,distance:function(t,e){var i=Math.PI/180,n=t.lat*i,o=e.lat*i,s=Math.sin((e.lat-t.lat)*i/2),e=Math.sin((e.lng-t.lng)*i/2),t=s*s+Math.cos(n)*Math.cos(o)*e*e,i=2*Math.atan2(Math.sqrt(t),Math.sqrt(1-t));return this.R*i}}),rt=6378137,rt={R:rt,MAX_LATITUDE:85.0511287798,project:function(t){var e=Math.PI/180,i=this.MAX_LATITUDE,i=Math.max(Math.min(i,t.lat),-i),i=Math.sin(i*e);return new p(this.R*t.lng*e,this.R*Math.log((1+i)/(1-i))/2)},unproject:function(t){var e=180/Math.PI;return new v((2*Math.atan(Math.exp(t.y/this.R))-Math.PI/2)*e,t.x*e/this.R)},bounds:new f([-(rt=rt*Math.PI),-rt],[rt,rt])};function at(t,e,i,n){d(t)?(this._a=t[0],this._b=t[1],this._c=t[2],this._d=t[3]):(this._a=t,this._b=e,this._c=i,this._d=n)}function ht(t,e,i,n){return new at(t,e,i,n)}at.prototype={transform:function(t,e){return this._transform(t.clone(),e)},_transform:function(t,e){return t.x=(e=e||1)*(this._a*t.x+this._b),t.y=e*(this._c*t.y+this._d),t},untransform:function(t,e){return new p((t.x/(e=e||1)-this._b)/this._a,(t.y/e-this._d)/this._c)}};var lt=l({},st,{code:"EPSG:3857",projection:rt,transformation:ht(lt=.5/(Math.PI*rt.R),.5,-lt,.5)}),ut=l({},lt,{code:"EPSG:900913"});function ct(t){return document.createElementNS("http://www.w3.org/2000/svg",t)}function dt(t,e){for(var i,n,o,s,r="",a=0,h=t.length;a<h;a++){for(i=0,n=(o=t[a]).length;i<n;i++)r+=(i?"L":"M")+(s=o[i]).x+" "+s.y;r+=e?b.svg?"z":"x":""}return r||"M0 0"}var _t=document.documentElement.style,pt="ActiveXObject"in window,mt=pt&&!document.addEventListener,n="msLaunchUri"in navigator&&!("documentMode"in document),ft=y("webkit"),gt=y("android"),vt=y("android 2")||y("android 3"),yt=parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1],10),yt=gt&&y("Google")&&yt<537&&!("AudioNode"in window),xt=!!window.opera,wt=!n&&y("chrome"),bt=y("gecko")&&!ft&&!xt&&!pt,Pt=!wt&&y("safari"),Lt=y("phantom"),o="OTransition"in _t,Tt=0===navigator.platform.indexOf("Win"),Mt=pt&&"transition"in _t,zt="WebKitCSSMatrix"in window&&"m11"in new window.WebKitCSSMatrix&&!vt,_t="MozPerspective"in _t,Ct=!window.L_DISABLE_3D&&(Mt||zt||_t)&&!o&&!Lt,Zt="undefined"!=typeof orientation||y("mobile"),St=Zt&&ft,Et=Zt&&zt,kt=!window.PointerEvent&&window.MSPointerEvent,Ot=!(!window.PointerEvent&&!kt),At="ontouchstart"in window||!!window.TouchEvent,Bt=!window.L_NO_TOUCH&&(At||Ot),It=Zt&&xt,Rt=Zt&&bt,Nt=1<(window.devicePixelRatio||window.screen.deviceXDPI/window.screen.logicalXDPI),Dt=function(){var t=!1;try{var e=Object.defineProperty({},"passive",{get:function(){t=!0}});window.addEventListener("testPassiveEventSupport",u,e),window.removeEventListener("testPassiveEventSupport",u,e)}catch(t){}return t}(),jt=!!document.createElement("canvas").getContext,Ht=!(!document.createElementNS||!ct("svg").createSVGRect),Wt=!!Ht&&((Wt=document.createElement("div")).innerHTML="<svg/>","http://www.w3.org/2000/svg"===(Wt.firstChild&&Wt.firstChild.namespaceURI));function y(t){return 0<=navigator.userAgent.toLowerCase().indexOf(t)}var b={ie:pt,ielt9:mt,edge:n,webkit:ft,android:gt,android23:vt,androidStock:yt,opera:xt,chrome:wt,gecko:bt,safari:Pt,phantom:Lt,opera12:o,win:Tt,ie3d:Mt,webkit3d:zt,gecko3d:_t,any3d:Ct,mobile:Zt,mobileWebkit:St,mobileWebkit3d:Et,msPointer:kt,pointer:Ot,touch:Bt,touchNative:At,mobileOpera:It,mobileGecko:Rt,retina:Nt,passiveEvents:Dt,canvas:jt,svg:Ht,vml:!Ht&&function(){try{var t=document.createElement("div"),e=(t.innerHTML='<v:shape adj="1"/>',t.firstChild);return e.style.behavior="url(#default#VML)",e&&"object"==typeof e.adj}catch(t){return!1}}(),inlineSvg:Wt,mac:0===navigator.platform.indexOf("Mac"),linux:0===navigator.platform.indexOf("Linux")},Ft=b.msPointer?"MSPointerDown":"pointerdown",Ut=b.msPointer?"MSPointerMove":"pointermove",Vt=b.msPointer?"MSPointerUp":"pointerup",qt=b.msPointer?"MSPointerCancel":"pointercancel",Gt={touchstart:Ft,touchmove:Ut,touchend:Vt,touchcancel:qt},Kt={touchstart:function(t,e){e.MSPOINTER_TYPE_TOUCH&&e.pointerType===e.MSPOINTER_TYPE_TOUCH&&O(e);ee(t,e)},touchmove:ee,touchend:ee,touchcancel:ee},Yt={},Xt=!1;function Jt(t,e,i){return"touchstart"!==e||Xt||(document.addEventListener(Ft,$t,!0),document.addEventListener(Ut,Qt,!0),document.addEventListener(Vt,te,!0),document.addEventListener(qt,te,!0),Xt=!0),Kt[e]?(i=Kt[e].bind(this,i),t.addEventListener(Gt[e],i,!1),i):(console.warn("wrong event specified:",e),u)}function $t(t){Yt[t.pointerId]=t}function Qt(t){Yt[t.pointerId]&&(Yt[t.pointerId]=t)}function te(t){delete Yt[t.pointerId]}function ee(t,e){if(e.pointerType!==(e.MSPOINTER_TYPE_MOUSE||"mouse")){for(var i in e.touches=[],Yt)e.touches.push(Yt[i]);e.changedTouches=[e],t(e)}}var ie=200;function ne(t,i){t.addEventListener("dblclick",i);var n,o=0;function e(t){var e;1!==t.detail?n=t.detail:"mouse"===t.pointerType||t.sourceCapabilities&&!t.sourceCapabilities.firesTouchEvents||((e=Ne(t)).some(function(t){return t instanceof HTMLLabelElement&&t.attributes.for})&&!e.some(function(t){return t instanceof HTMLInputElement||t instanceof HTMLSelectElement})||((e=Date.now())-o<=ie?2===++n&&i(function(t){var e,i,n={};for(i in t)e=t[i],n[i]=e&&e.bind?e.bind(t):e;return(t=n).type="dblclick",n.detail=2,n.isTrusted=!1,n._simulated=!0,n}(t)):n=1,o=e))}return t.addEventListener("click",e),{dblclick:i,simDblclick:e}}var oe,se,re,ae,he,le,ue=we(["transform","webkitTransform","OTransform","MozTransform","msTransform"]),ce=we(["webkitTransition","transition","OTransition","MozTransition","msTransition"]),de="webkitTransition"===ce||"OTransition"===ce?ce+"End":"transitionend";function _e(t){return"string"==typeof t?document.getElementById(t):t}function pe(t,e){var i=t.style[e]||t.currentStyle&&t.currentStyle[e];return"auto"===(i=i&&"auto"!==i||!document.defaultView?i:(t=document.defaultView.getComputedStyle(t,null))?t[e]:null)?null:i}function P(t,e,i){t=document.createElement(t);return t.className=e||"",i&&i.appendChild(t),t}function T(t){var e=t.parentNode;e&&e.removeChild(t)}function me(t){for(;t.firstChild;)t.removeChild(t.firstChild)}function fe(t){var e=t.parentNode;e&&e.lastChild!==t&&e.appendChild(t)}function ge(t){var e=t.parentNode;e&&e.firstChild!==t&&e.insertBefore(t,e.firstChild)}function ve(t,e){return void 0!==t.classList?t.classList.contains(e):0<(t=xe(t)).length&&new RegExp("(^|\\s)"+e+"(\\s|$)").test(t)}function M(t,e){var i;if(void 0!==t.classList)for(var n=F(e),o=0,s=n.length;o<s;o++)t.classList.add(n[o]);else ve(t,e)||ye(t,((i=xe(t))?i+" ":"")+e)}function z(t,e){void 0!==t.classList?t.classList.remove(e):ye(t,W((" "+xe(t)+" ").replace(" "+e+" "," ")))}function ye(t,e){void 0===t.className.baseVal?t.className=e:t.className.baseVal=e}function xe(t){return void 0===(t=t.correspondingElement?t.correspondingElement:t).className.baseVal?t.className:t.className.baseVal}function C(t,e){if("opacity"in t.style)t.style.opacity=e;else if("filter"in t.style){var i=!1,n="DXImageTransform.Microsoft.Alpha";try{i=t.filters.item(n)}catch(t){if(1===e)return}e=Math.round(100*e),i?(i.Enabled=100!==e,i.Opacity=e):t.style.filter+=" progid:"+n+"(opacity="+e+")"}}function we(t){for(var e=document.documentElement.style,i=0;i<t.length;i++)if(t[i]in e)return t[i];return!1}function be(t,e,i){e=e||new p(0,0);t.style[ue]=(b.ie3d?"translate("+e.x+"px,"+e.y+"px)":"translate3d("+e.x+"px,"+e.y+"px,0)")+(i?" scale("+i+")":"")}function Z(t,e){t._leaflet_pos=e,b.any3d?be(t,e):(t.style.left=e.x+"px",t.style.top=e.y+"px")}function Pe(t){return t._leaflet_pos||new p(0,0)}function Le(){S(window,"dragstart",O)}function Te(){k(window,"dragstart",O)}function Me(t){for(;-1===t.tabIndex;)t=t.parentNode;t.style&&(ze(),le=(he=t).style.outlineStyle,t.style.outlineStyle="none",S(window,"keydown",ze))}function ze(){he&&(he.style.outlineStyle=le,le=he=void 0,k(window,"keydown",ze))}function Ce(t){for(;!((t=t.parentNode).offsetWidth&&t.offsetHeight||t===document.body););return t}function Ze(t){var e=t.getBoundingClientRect();return{x:e.width/t.offsetWidth||1,y:e.height/t.offsetHeight||1,boundingClientRect:e}}ae="onselectstart"in document?(re=function(){S(window,"selectstart",O)},function(){k(window,"selectstart",O)}):(se=we(["userSelect","WebkitUserSelect","OUserSelect","MozUserSelect","msUserSelect"]),re=function(){var t;se&&(t=document.documentElement.style,oe=t[se],t[se]="none")},function(){se&&(document.documentElement.style[se]=oe,oe=void 0)});pt={__proto__:null,TRANSFORM:ue,TRANSITION:ce,TRANSITION_END:de,get:_e,getStyle:pe,create:P,remove:T,empty:me,toFront:fe,toBack:ge,hasClass:ve,addClass:M,removeClass:z,setClass:ye,getClass:xe,setOpacity:C,testProp:we,setTransform:be,setPosition:Z,getPosition:Pe,get disableTextSelection(){return re},get enableTextSelection(){return ae},disableImageDrag:Le,enableImageDrag:Te,preventOutline:Me,restoreOutline:ze,getSizedParentNode:Ce,getScale:Ze};function S(t,e,i,n){if(e&&"object"==typeof e)for(var o in e)ke(t,o,e[o],i);else for(var s=0,r=(e=F(e)).length;s<r;s++)ke(t,e[s],i,n);return this}var E="_leaflet_events";function k(t,e,i,n){if(1===arguments.length)Se(t),delete t[E];else if(e&&"object"==typeof e)for(var o in e)Oe(t,o,e[o],i);else if(e=F(e),2===arguments.length)Se(t,function(t){return-1!==G(e,t)});else for(var s=0,r=e.length;s<r;s++)Oe(t,e[s],i,n);return this}function Se(t,e){for(var i in t[E]){var n=i.split(/\d/)[0];e&&!e(n)||Oe(t,n,null,null,i)}}var Ee={mouseenter:"mouseover",mouseleave:"mouseout",wheel:!("onwheel"in window)&&"mousewheel"};function ke(e,t,i,n){var o,s,r=t+h(i)+(n?"_"+h(n):"");e[E]&&e[E][r]||(s=o=function(t){return i.call(n||e,t||window.event)},!b.touchNative&&b.pointer&&0===t.indexOf("touch")?o=Jt(e,t,o):b.touch&&"dblclick"===t?o=ne(e,o):"addEventListener"in e?"touchstart"===t||"touchmove"===t||"wheel"===t||"mousewheel"===t?e.addEventListener(Ee[t]||t,o,!!b.passiveEvents&&{passive:!1}):"mouseenter"===t||"mouseleave"===t?e.addEventListener(Ee[t],o=function(t){t=t||window.event,We(e,t)&&s(t)},!1):e.addEventListener(t,s,!1):e.attachEvent("on"+t,o),e[E]=e[E]||{},e[E][r]=o)}function Oe(t,e,i,n,o){o=o||e+h(i)+(n?"_"+h(n):"");var s,r,i=t[E]&&t[E][o];i&&(!b.touchNative&&b.pointer&&0===e.indexOf("touch")?(n=t,r=i,Gt[s=e]?n.removeEventListener(Gt[s],r,!1):console.warn("wrong event specified:",s)):b.touch&&"dblclick"===e?(n=i,(r=t).removeEventListener("dblclick",n.dblclick),r.removeEventListener("click",n.simDblclick)):"removeEventListener"in t?t.removeEventListener(Ee[e]||e,i,!1):t.detachEvent("on"+e,i),t[E][o]=null)}function Ae(t){return t.stopPropagation?t.stopPropagation():t.originalEvent?t.originalEvent._stopped=!0:t.cancelBubble=!0,this}function Be(t){return ke(t,"wheel",Ae),this}function Ie(t){return S(t,"mousedown touchstart dblclick contextmenu",Ae),t._leaflet_disable_click=!0,this}function O(t){return t.preventDefault?t.preventDefault():t.returnValue=!1,this}function Re(t){return O(t),Ae(t),this}function Ne(t){if(t.composedPath)return t.composedPath();for(var e=[],i=t.target;i;)e.push(i),i=i.parentNode;return e}function De(t,e){var i,n;return e?(n=(i=Ze(e)).boundingClientRect,new p((t.clientX-n.left)/i.x-e.clientLeft,(t.clientY-n.top)/i.y-e.clientTop)):new p(t.clientX,t.clientY)}var je=b.linux&&b.chrome?window.devicePixelRatio:b.mac?3*window.devicePixelRatio:0<window.devicePixelRatio?2*window.devicePixelRatio:1;function He(t){return b.edge?t.wheelDeltaY/2:t.deltaY&&0===t.deltaMode?-t.deltaY/je:t.deltaY&&1===t.deltaMode?20*-t.deltaY:t.deltaY&&2===t.deltaMode?60*-t.deltaY:t.deltaX||t.deltaZ?0:t.wheelDelta?(t.wheelDeltaY||t.wheelDelta)/2:t.detail&&Math.abs(t.detail)<32765?20*-t.detail:t.detail?t.detail/-32765*60:0}function We(t,e){var i=e.relatedTarget;if(!i)return!0;try{for(;i&&i!==t;)i=i.parentNode}catch(t){return!1}return i!==t}var mt={__proto__:null,on:S,off:k,stopPropagation:Ae,disableScrollPropagation:Be,disableClickPropagation:Ie,preventDefault:O,stop:Re,getPropagationPath:Ne,getMousePosition:De,getWheelDelta:He,isExternalTarget:We,addListener:S,removeListener:k},Fe=it.extend({run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._duration=i||.25,this._easeOutPower=1/Math.max(n||.5,.2),this._startPos=Pe(t),this._offset=e.subtract(this._startPos),this._startTime=+new Date,this.fire("start"),this._animate()},stop:function(){this._inProgress&&(this._step(!0),this._complete())},_animate:function(){this._animId=x(this._animate,this),this._step()},_step:function(t){var e=+new Date-this._startTime,i=1e3*this._duration;e<i?this._runFrame(this._easeOut(e/i),t):(this._runFrame(1),this._complete())},_runFrame:function(t,e){t=this._startPos.add(this._offset.multiplyBy(t));e&&t._round(),Z(this._el,t),this.fire("step")},_complete:function(){r(this._animId),this._inProgress=!1,this.fire("end")},_easeOut:function(t){return 1-Math.pow(1-t,this._easeOutPower)}}),A=it.extend({options:{crs:lt,center:void 0,zoom:void 0,minZoom:void 0,maxZoom:void 0,layers:[],maxBounds:void 0,renderer:void 0,zoomAnimation:!0,zoomAnimationThreshold:4,fadeAnimation:!0,markerZoomAnimation:!0,transform3DLimit:8388608,zoomSnap:1,zoomDelta:1,trackResize:!0},initialize:function(t,e){e=c(this,e),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._sizeChanged=!0,this._initContainer(t),this._initLayout(),this._onResize=a(this._onResize,this),this._initEvents(),e.maxBounds&&this.setMaxBounds(e.maxBounds),void 0!==e.zoom&&(this._zoom=this._limitZoom(e.zoom)),e.center&&void 0!==e.zoom&&this.setView(w(e.center),e.zoom,{reset:!0}),this.callInitHooks(),this._zoomAnimated=ce&&b.any3d&&!b.mobileOpera&&this.options.zoomAnimation,this._zoomAnimated&&(this._createAnimProxy(),S(this._proxy,de,this._catchTransitionEnd,this)),this._addLayers(this.options.layers)},setView:function(t,e,i){if((e=void 0===e?this._zoom:this._limitZoom(e),t=this._limitCenter(w(t),e,this.options.maxBounds),i=i||{},this._stop(),this._loaded&&!i.reset&&!0!==i)&&(void 0!==i.animate&&(i.zoom=l({animate:i.animate},i.zoom),i.pan=l({animate:i.animate,duration:i.duration},i.pan)),this._zoom!==e?this._tryAnimatedZoom&&this._tryAnimatedZoom(t,e,i.zoom):this._tryAnimatedPan(t,i.pan)))return clearTimeout(this._sizeTimer),this;return this._resetView(t,e,i.pan&&i.pan.noMoveStart),this},setZoom:function(t,e){return this._loaded?this.setView(this.getCenter(),t,{zoom:e}):(this._zoom=t,this)},zoomIn:function(t,e){return t=t||(b.any3d?this.options.zoomDelta:1),this.setZoom(this._zoom+t,e)},zoomOut:function(t,e){return t=t||(b.any3d?this.options.zoomDelta:1),this.setZoom(this._zoom-t,e)},setZoomAround:function(t,e,i){var n=this.getZoomScale(e),o=this.getSize().divideBy(2),t=(t instanceof p?t:this.latLngToContainerPoint(t)).subtract(o).multiplyBy(1-1/n),n=this.containerPointToLatLng(o.add(t));return this.setView(n,e,{zoom:i})},_getBoundsCenterZoom:function(t,e){e=e||{},t=t.getBounds?t.getBounds():g(t);var i=m(e.paddingTopLeft||e.padding||[0,0]),n=m(e.paddingBottomRight||e.padding||[0,0]),o=this.getBoundsZoom(t,!1,i.add(n));return(o="number"==typeof e.maxZoom?Math.min(e.maxZoom,o):o)===1/0?{center:t.getCenter(),zoom:o}:(e=n.subtract(i).divideBy(2),n=this.project(t.getSouthWest(),o),i=this.project(t.getNorthEast(),o),{center:this.unproject(n.add(i).divideBy(2).add(e),o),zoom:o})},fitBounds:function(t,e){if((t=g(t)).isValid())return t=this._getBoundsCenterZoom(t,e),this.setView(t.center,t.zoom,e);throw new Error("Bounds are not valid.")},fitWorld:function(t){return this.fitBounds([[-90,-180],[90,180]],t)},panTo:function(t,e){return this.setView(t,this._zoom,{pan:e})},panBy:function(t,e){var i;return e=e||{},(t=m(t).round()).x||t.y?(!0===e.animate||this.getSize().contains(t)?(this._panAnim||(this._panAnim=new Fe,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),e.noMoveStart||this.fire("movestart"),!1!==e.animate?(M(this._mapPane,"leaflet-pan-anim"),i=this._getMapPanePos().subtract(t).round(),this._panAnim.run(this._mapPane,i,e.duration||.25,e.easeLinearity)):(this._rawPanBy(t),this.fire("move").fire("moveend"))):this._resetView(this.unproject(this.project(this.getCenter()).add(t)),this.getZoom()),this):this.fire("moveend")},flyTo:function(n,o,t){if(!1===(t=t||{}).animate||!b.any3d)return this.setView(n,o,t);this._stop();var s=this.project(this.getCenter()),r=this.project(n),e=this.getSize(),a=this._zoom,h=(n=w(n),o=void 0===o?a:o,Math.max(e.x,e.y)),i=h*this.getZoomScale(a,o),l=r.distanceTo(s)||1,u=1.42,c=u*u;function d(t){t=(i*i-h*h+(t?-1:1)*c*c*l*l)/(2*(t?i:h)*c*l),t=Math.sqrt(t*t+1)-t;return t<1e-9?-18:Math.log(t)}function _(t){return(Math.exp(t)-Math.exp(-t))/2}function p(t){return(Math.exp(t)+Math.exp(-t))/2}var m=d(0);function f(t){return h*(p(m)*(_(t=m+u*t)/p(t))-_(m))/c}var g=Date.now(),v=(d(1)-m)/u,y=t.duration?1e3*t.duration:1e3*v*.8;return this._moveStart(!0,t.noMoveStart),function t(){var e=(Date.now()-g)/y,i=(1-Math.pow(1-e,1.5))*v;e<=1?(this._flyToFrame=x(t,this),this._move(this.unproject(s.add(r.subtract(s).multiplyBy(f(i)/l)),a),this.getScaleZoom(h/(e=i,h*(p(m)/p(m+u*e))),a),{flyTo:!0})):this._move(n,o)._moveEnd(!0)}.call(this),this},flyToBounds:function(t,e){t=this._getBoundsCenterZoom(t,e);return this.flyTo(t.center,t.zoom,e)},setMaxBounds:function(t){return t=g(t),this.listens("moveend",this._panInsideMaxBounds)&&this.off("moveend",this._panInsideMaxBounds),t.isValid()?(this.options.maxBounds=t,this._loaded&&this._panInsideMaxBounds(),this.on("moveend",this._panInsideMaxBounds)):(this.options.maxBounds=null,this)},setMinZoom:function(t){var e=this.options.minZoom;return this.options.minZoom=t,this._loaded&&e!==t&&(this.fire("zoomlevelschange"),this.getZoom()<this.options.minZoom)?this.setZoom(t):this},setMaxZoom:function(t){var e=this.options.maxZoom;return this.options.maxZoom=t,this._loaded&&e!==t&&(this.fire("zoomlevelschange"),this.getZoom()>this.options.maxZoom)?this.setZoom(t):this},panInsideBounds:function(t,e){this._enforcingBounds=!0;var i=this.getCenter(),t=this._limitCenter(i,this._zoom,g(t));return i.equals(t)||this.panTo(t,e),this._enforcingBounds=!1,this},panInside:function(t,e){var i=m((e=e||{}).paddingTopLeft||e.padding||[0,0]),n=m(e.paddingBottomRight||e.padding||[0,0]),o=this.project(this.getCenter()),t=this.project(t),s=this.getPixelBounds(),i=_([s.min.add(i),s.max.subtract(n)]),s=i.getSize();return i.contains(t)||(this._enforcingBounds=!0,n=t.subtract(i.getCenter()),i=i.extend(t).getSize().subtract(s),o.x+=n.x<0?-i.x:i.x,o.y+=n.y<0?-i.y:i.y,this.panTo(this.unproject(o),e),this._enforcingBounds=!1),this},invalidateSize:function(t){if(!this._loaded)return this;t=l({animate:!1,pan:!0},!0===t?{animate:!0}:t);var e=this.getSize(),i=(this._sizeChanged=!0,this._lastCenter=null,this.getSize()),n=e.divideBy(2).round(),o=i.divideBy(2).round(),n=n.subtract(o);return n.x||n.y?(t.animate&&t.pan?this.panBy(n):(t.pan&&this._rawPanBy(n),this.fire("move"),t.debounceMoveend?(clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(a(this.fire,this,"moveend"),200)):this.fire("moveend")),this.fire("resize",{oldSize:e,newSize:i})):this},stop:function(){return this.setZoom(this._limitZoom(this._zoom)),this.options.zoomSnap||this.fire("viewreset"),this._stop()},locate:function(t){var e,i;return t=this._locateOptions=l({timeout:1e4,watch:!1},t),"geolocation"in navigator?(e=a(this._handleGeolocationResponse,this),i=a(this._handleGeolocationError,this),t.watch?this._locationWatchId=navigator.geolocation.watchPosition(e,i,t):navigator.geolocation.getCurrentPosition(e,i,t)):this._handleGeolocationError({code:0,message:"Geolocation not supported."}),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(t){var e;this._container._leaflet_id&&(e=t.code,t=t.message||(1===e?"permission denied":2===e?"position unavailable":"timeout"),this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire("locationerror",{code:e,message:"Geolocation error: "+t+"."}))},_handleGeolocationResponse:function(t){if(this._container._leaflet_id){var e,i,n=new v(t.coords.latitude,t.coords.longitude),o=n.toBounds(2*t.coords.accuracy),s=this._locateOptions,r=(s.setView&&(e=this.getBoundsZoom(o),this.setView(n,s.maxZoom?Math.min(e,s.maxZoom):e)),{latlng:n,bounds:o,timestamp:t.timestamp});for(i in t.coords)"number"==typeof t.coords[i]&&(r[i]=t.coords[i]);this.fire("locationfound",r)}},addHandler:function(t,e){return e&&(e=this[t]=new e(this),this._handlers.push(e),this.options[t]&&e.enable()),this},remove:function(){if(this._initEvents(!0),this.options.maxBounds&&this.off("moveend",this._panInsideMaxBounds),this._containerId!==this._container._leaflet_id)throw new Error("Map container is being reused by another instance");try{delete this._container._leaflet_id,delete this._containerId}catch(t){this._container._leaflet_id=void 0,this._containerId=void 0}for(var t in void 0!==this._locationWatchId&&this.stopLocate(),this._stop(),T(this._mapPane),this._clearControlPos&&this._clearControlPos(),this._resizeRequest&&(r(this._resizeRequest),this._resizeRequest=null),this._clearHandlers(),this._loaded&&this.fire("unload"),this._layers)this._layers[t].remove();for(t in this._panes)T(this._panes[t]);return this._layers=[],this._panes=[],delete this._mapPane,delete this._renderer,this},createPane:function(t,e){e=P("div","leaflet-pane"+(t?" leaflet-"+t.replace("Pane","")+"-pane":""),e||this._mapPane);return t&&(this._panes[t]=e),e},getCenter:function(){return this._checkIfLoaded(),this._lastCenter&&!this._moved()?this._lastCenter.clone():this.layerPointToLatLng(this._getCenterLayerPoint())},getZoom:function(){return this._zoom},getBounds:function(){var t=this.getPixelBounds();return new s(this.unproject(t.getBottomLeft()),this.unproject(t.getTopRight()))},getMinZoom:function(){return void 0===this.options.minZoom?this._layersMinZoom||0:this.options.minZoom},getMaxZoom:function(){return void 0===this.options.maxZoom?void 0===this._layersMaxZoom?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(t,e,i){t=g(t),i=m(i||[0,0]);var n=this.getZoom()||0,o=this.getMinZoom(),s=this.getMaxZoom(),r=t.getNorthWest(),t=t.getSouthEast(),i=this.getSize().subtract(i),t=_(this.project(t,n),this.project(r,n)).getSize(),r=b.any3d?this.options.zoomSnap:1,a=i.x/t.x,i=i.y/t.y,t=e?Math.max(a,i):Math.min(a,i),n=this.getScaleZoom(t,n);return r&&(n=Math.round(n/(r/100))*(r/100),n=e?Math.ceil(n/r)*r:Math.floor(n/r)*r),Math.max(o,Math.min(s,n))},getSize:function(){return this._size&&!this._sizeChanged||(this._size=new p(this._container.clientWidth||0,this._container.clientHeight||0),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(t,e){t=this._getTopLeftPoint(t,e);return new f(t,t.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._pixelOrigin},getPixelWorldBounds:function(t){return this.options.crs.getProjectedBounds(void 0===t?this.getZoom():t)},getPane:function(t){return"string"==typeof t?this._panes[t]:t},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(t,e){var i=this.options.crs;return e=void 0===e?this._zoom:e,i.scale(t)/i.scale(e)},getScaleZoom:function(t,e){var i=this.options.crs,t=(e=void 0===e?this._zoom:e,i.zoom(t*i.scale(e)));return isNaN(t)?1/0:t},project:function(t,e){return e=void 0===e?this._zoom:e,this.options.crs.latLngToPoint(w(t),e)},unproject:function(t,e){return e=void 0===e?this._zoom:e,this.options.crs.pointToLatLng(m(t),e)},layerPointToLatLng:function(t){t=m(t).add(this.getPixelOrigin());return this.unproject(t)},latLngToLayerPoint:function(t){return this.project(w(t))._round()._subtract(this.getPixelOrigin())},wrapLatLng:function(t){return this.options.crs.wrapLatLng(w(t))},wrapLatLngBounds:function(t){return this.options.crs.wrapLatLngBounds(g(t))},distance:function(t,e){return this.options.crs.distance(w(t),w(e))},containerPointToLayerPoint:function(t){return m(t).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(t){return m(t).add(this._getMapPanePos())},containerPointToLatLng:function(t){t=this.containerPointToLayerPoint(m(t));return this.layerPointToLatLng(t)},latLngToContainerPoint:function(t){return this.layerPointToContainerPoint(this.latLngToLayerPoint(w(t)))},mouseEventToContainerPoint:function(t){return De(t,this._container)},mouseEventToLayerPoint:function(t){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))},mouseEventToLatLng:function(t){return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))},_initContainer:function(t){t=this._container=_e(t);if(!t)throw new Error("Map container not found.");if(t._leaflet_id)throw new Error("Map container is already initialized.");S(t,"scroll",this._onScroll,this),this._containerId=h(t)},_initLayout:function(){var t=this._container,e=(this._fadeAnimated=this.options.fadeAnimation&&b.any3d,M(t,"leaflet-container"+(b.touch?" leaflet-touch":"")+(b.retina?" leaflet-retina":"")+(b.ielt9?" leaflet-oldie":"")+(b.safari?" leaflet-safari":"")+(this._fadeAnimated?" leaflet-fade-anim":"")),pe(t,"position"));"absolute"!==e&&"relative"!==e&&"fixed"!==e&&"sticky"!==e&&(t.style.position="relative"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var t=this._panes={};this._paneRenderers={},this._mapPane=this.createPane("mapPane",this._container),Z(this._mapPane,new p(0,0)),this.createPane("tilePane"),this.createPane("overlayPane"),this.createPane("shadowPane"),this.createPane("markerPane"),this.createPane("tooltipPane"),this.createPane("popupPane"),this.options.markerZoomAnimation||(M(t.markerPane,"leaflet-zoom-hide"),M(t.shadowPane,"leaflet-zoom-hide"))},_resetView:function(t,e,i){Z(this._mapPane,new p(0,0));var n=!this._loaded,o=(this._loaded=!0,e=this._limitZoom(e),this.fire("viewprereset"),this._zoom!==e);this._moveStart(o,i)._move(t,e)._moveEnd(o),this.fire("viewreset"),n&&this.fire("load")},_moveStart:function(t,e){return t&&this.fire("zoomstart"),e||this.fire("movestart"),this},_move:function(t,e,i,n){void 0===e&&(e=this._zoom);var o=this._zoom!==e;return this._zoom=e,this._lastCenter=t,this._pixelOrigin=this._getNewPixelOrigin(t),n?i&&i.pinch&&this.fire("zoom",i):((o||i&&i.pinch)&&this.fire("zoom",i),this.fire("move",i)),this},_moveEnd:function(t){return t&&this.fire("zoomend"),this.fire("moveend")},_stop:function(){return r(this._flyToFrame),this._panAnim&&this._panAnim.stop(),this},_rawPanBy:function(t){Z(this._mapPane,this._getMapPanePos().subtract(t))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_panInsideMaxBounds:function(){this._enforcingBounds||this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error("Set map center and zoom first.")},_initEvents:function(t){this._targets={};var e=t?k:S;e((this._targets[h(this._container)]=this)._container,"click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup",this._handleDOMEvent,this),this.options.trackResize&&e(window,"resize",this._onResize,this),b.any3d&&this.options.transform3DLimit&&(t?this.off:this.on).call(this,"moveend",this._onMoveEnd)},_onResize:function(){r(this._resizeRequest),this._resizeRequest=x(function(){this.invalidateSize({debounceMoveend:!0})},this)},_onScroll:function(){this._container.scrollTop=0,this._container.scrollLeft=0},_onMoveEnd:function(){var t=this._getMapPanePos();Math.max(Math.abs(t.x),Math.abs(t.y))>=this.options.transform3DLimit&&this._resetView(this.getCenter(),this.getZoom())},_findEventTargets:function(t,e){for(var i,n=[],o="mouseout"===e||"mouseover"===e,s=t.target||t.srcElement,r=!1;s;){if((i=this._targets[h(s)])&&("click"===e||"preclick"===e)&&this._draggableMoved(i)){r=!0;break}if(i&&i.listens(e,!0)){if(o&&!We(s,t))break;if(n.push(i),o)break}if(s===this._container)break;s=s.parentNode}return n=n.length||r||o||!this.listens(e,!0)?n:[this]},_isClickDisabled:function(t){for(;t&&t!==this._container;){if(t._leaflet_disable_click)return!0;t=t.parentNode}},_handleDOMEvent:function(t){var e,i=t.target||t.srcElement;!this._loaded||i._leaflet_disable_events||"click"===t.type&&this._isClickDisabled(i)||("mousedown"===(e=t.type)&&Me(i),this._fireDOMEvent(t,e))},_mouseEvents:["click","dblclick","mouseover","mouseout","contextmenu"],_fireDOMEvent:function(t,e,i){"click"===t.type&&((a=l({},t)).type="preclick",this._fireDOMEvent(a,a.type,i));var n=this._findEventTargets(t,e);if(i){for(var o=[],s=0;s<i.length;s++)i[s].listens(e,!0)&&o.push(i[s]);n=o.concat(n)}if(n.length){"contextmenu"===e&&O(t);var r,a=n[0],h={originalEvent:t};for("keypress"!==t.type&&"keydown"!==t.type&&"keyup"!==t.type&&(r=a.getLatLng&&(!a._radius||a._radius<=10),h.containerPoint=r?this.latLngToContainerPoint(a.getLatLng()):this.mouseEventToContainerPoint(t),h.layerPoint=this.containerPointToLayerPoint(h.containerPoint),h.latlng=r?a.getLatLng():this.layerPointToLatLng(h.layerPoint)),s=0;s<n.length;s++)if(n[s].fire(e,h,!0),h.originalEvent._stopped||!1===n[s].options.bubblingMouseEvents&&-1!==G(this._mouseEvents,e))return}},_draggableMoved:function(t){return(t=t.dragging&&t.dragging.enabled()?t:this).dragging&&t.dragging.moved()||this.boxZoom&&this.boxZoom.moved()},_clearHandlers:function(){for(var t=0,e=this._handlers.length;t<e;t++)this._handlers[t].disable()},whenReady:function(t,e){return this._loaded?t.call(e||this,{target:this}):this.on("load",t,e),this},_getMapPanePos:function(){return Pe(this._mapPane)||new p(0,0)},_moved:function(){var t=this._getMapPanePos();return t&&!t.equals([0,0])},_getTopLeftPoint:function(t,e){return(t&&void 0!==e?this._getNewPixelOrigin(t,e):this.getPixelOrigin()).subtract(this._getMapPanePos())},_getNewPixelOrigin:function(t,e){var i=this.getSize()._divideBy(2);return this.project(t,e)._subtract(i)._add(this._getMapPanePos())._round()},_latLngToNewLayerPoint:function(t,e,i){i=this._getNewPixelOrigin(i,e);return this.project(t,e)._subtract(i)},_latLngBoundsToNewLayerBounds:function(t,e,i){i=this._getNewPixelOrigin(i,e);return _([this.project(t.getSouthWest(),e)._subtract(i),this.project(t.getNorthWest(),e)._subtract(i),this.project(t.getSouthEast(),e)._subtract(i),this.project(t.getNorthEast(),e)._subtract(i)])},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(t){return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())},_limitCenter:function(t,e,i){var n,o;return!i||(n=this.project(t,e),o=this.getSize().divideBy(2),o=new f(n.subtract(o),n.add(o)),o=this._getBoundsOffset(o,i,e),Math.abs(o.x)<=1&&Math.abs(o.y)<=1)?t:this.unproject(n.add(o),e)},_limitOffset:function(t,e){var i;return e?(i=new f((i=this.getPixelBounds()).min.add(t),i.max.add(t)),t.add(this._getBoundsOffset(i,e))):t},_getBoundsOffset:function(t,e,i){e=_(this.project(e.getNorthEast(),i),this.project(e.getSouthWest(),i)),i=e.min.subtract(t.min),e=e.max.subtract(t.max);return new p(this._rebound(i.x,-e.x),this._rebound(i.y,-e.y))},_rebound:function(t,e){return 0<t+e?Math.round(t-e)/2:Math.max(0,Math.ceil(t))-Math.max(0,Math.floor(e))},_limitZoom:function(t){var e=this.getMinZoom(),i=this.getMaxZoom(),n=b.any3d?this.options.zoomSnap:1;return n&&(t=Math.round(t/n)*n),Math.max(e,Math.min(i,t))},_onPanTransitionStep:function(){this.fire("move")},_onPanTransitionEnd:function(){z(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},_tryAnimatedPan:function(t,e){t=this._getCenterOffset(t)._trunc();return!(!0!==(e&&e.animate)&&!this.getSize().contains(t))&&(this.panBy(t,e),!0)},_createAnimProxy:function(){var t=this._proxy=P("div","leaflet-proxy leaflet-zoom-animated");this._panes.mapPane.appendChild(t),this.on("zoomanim",function(t){var e=ue,i=this._proxy.style[e];be(this._proxy,this.project(t.center,t.zoom),this.getZoomScale(t.zoom,1)),i===this._proxy.style[e]&&this._animatingZoom&&this._onZoomTransitionEnd()},this),this.on("load moveend",this._animMoveEnd,this),this._on("unload",this._destroyAnimProxy,this)},_destroyAnimProxy:function(){T(this._proxy),this.off("load moveend",this._animMoveEnd,this),delete this._proxy},_animMoveEnd:function(){var t=this.getCenter(),e=this.getZoom();be(this._proxy,this.project(t,e),this.getZoomScale(e,1))},_catchTransitionEnd:function(t){this._animatingZoom&&0<=t.propertyName.indexOf("transform")&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName("leaflet-zoom-animated").length},_tryAnimatedZoom:function(t,e,i){if(!this._animatingZoom){if(i=i||{},!this._zoomAnimated||!1===i.animate||this._nothingToAnimate()||Math.abs(e-this._zoom)>this.options.zoomAnimationThreshold)return!1;var n=this.getZoomScale(e),n=this._getCenterOffset(t)._divideBy(1-1/n);if(!0!==i.animate&&!this.getSize().contains(n))return!1;x(function(){this._moveStart(!0,i.noMoveStart||!1)._animateZoom(t,e,!0)},this)}return!0},_animateZoom:function(t,e,i,n){this._mapPane&&(i&&(this._animatingZoom=!0,this._animateToCenter=t,this._animateToZoom=e,M(this._mapPane,"leaflet-zoom-anim")),this.fire("zoomanim",{center:t,zoom:e,noUpdate:n}),this._tempFireZoomEvent||(this._tempFireZoomEvent=this._zoom!==this._animateToZoom),this._move(this._animateToCenter,this._animateToZoom,void 0,!0),setTimeout(a(this._onZoomTransitionEnd,this),250))},_onZoomTransitionEnd:function(){this._animatingZoom&&(this._mapPane&&z(this._mapPane,"leaflet-zoom-anim"),this._animatingZoom=!1,this._move(this._animateToCenter,this._animateToZoom,void 0,!0),this._tempFireZoomEvent&&this.fire("zoom"),delete this._tempFireZoomEvent,this.fire("move"),this._moveEnd(!0))}});function Ue(t){return new B(t)}var B=et.extend({options:{position:"topright"},initialize:function(t){c(this,t)},getPosition:function(){return this.options.position},setPosition:function(t){var e=this._map;return e&&e.removeControl(this),this.options.position=t,e&&e.addControl(this),this},getContainer:function(){return this._container},addTo:function(t){this.remove(),this._map=t;var e=this._container=this.onAdd(t),i=this.getPosition(),t=t._controlCorners[i];return M(e,"leaflet-control"),-1!==i.indexOf("bottom")?t.insertBefore(e,t.firstChild):t.appendChild(e),this._map.on("unload",this.remove,this),this},remove:function(){return this._map&&(T(this._container),this.onRemove&&this.onRemove(this._map),this._map.off("unload",this.remove,this),this._map=null),this},_refocusOnMap:function(t){this._map&&t&&0<t.screenX&&0<t.screenY&&this._map.getContainer().focus()}}),Ve=(A.include({addControl:function(t){return t.addTo(this),this},removeControl:function(t){return t.remove(),this},_initControlPos:function(){var i=this._controlCorners={},n="leaflet-",o=this._controlContainer=P("div",n+"control-container",this._container);function t(t,e){i[t+e]=P("div",n+t+" "+n+e,o)}t("top","left"),t("top","right"),t("bottom","left"),t("bottom","right")},_clearControlPos:function(){for(var t in this._controlCorners)T(this._controlCorners[t]);T(this._controlContainer),delete this._controlCorners,delete this._controlContainer}}),B.extend({options:{collapsed:!0,position:"topright",autoZIndex:!0,hideSingleBase:!1,sortLayers:!1,sortFunction:function(t,e,i,n){return i<n?-1:n<i?1:0}},initialize:function(t,e,i){for(var n in c(this,i),this._layerControlInputs=[],this._layers=[],this._lastZIndex=0,this._handlingClick=!1,this._preventClick=!1,t)this._addLayer(t[n],n);for(n in e)this._addLayer(e[n],n,!0)},onAdd:function(t){this._initLayout(),this._update(),(this._map=t).on("zoomend",this._checkDisabledLayers,this);for(var e=0;e<this._layers.length;e++)this._layers[e].layer.on("add remove",this._onLayerChange,this);return this._container},addTo:function(t){return B.prototype.addTo.call(this,t),this._expandIfNotCollapsed()},onRemove:function(){this._map.off("zoomend",this._checkDisabledLayers,this);for(var t=0;t<this._layers.length;t++)this._layers[t].layer.off("add remove",this._onLayerChange,this)},addBaseLayer:function(t,e){return this._addLayer(t,e),this._map?this._update():this},addOverlay:function(t,e){return this._addLayer(t,e,!0),this._map?this._update():this},removeLayer:function(t){t.off("add remove",this._onLayerChange,this);t=this._getLayer(h(t));return t&&this._layers.splice(this._layers.indexOf(t),1),this._map?this._update():this},expand:function(){M(this._container,"leaflet-control-layers-expanded"),this._section.style.height=null;var t=this._map.getSize().y-(this._container.offsetTop+50);return t<this._section.clientHeight?(M(this._section,"leaflet-control-layers-scrollbar"),this._section.style.height=t+"px"):z(this._section,"leaflet-control-layers-scrollbar"),this._checkDisabledLayers(),this},collapse:function(){return z(this._container,"leaflet-control-layers-expanded"),this},_initLayout:function(){var t="leaflet-control-layers",e=this._container=P("div",t),i=this.options.collapsed,n=(e.setAttribute("aria-haspopup",!0),Ie(e),Be(e),this._section=P("section",t+"-list")),o=(i&&(this._map.on("click",this.collapse,this),S(e,{mouseenter:this._expandSafely,mouseleave:this.collapse},this)),this._layersLink=P("a",t+"-toggle",e));o.href="#",o.title="Layers",o.setAttribute("role","button"),S(o,{keydown:function(t){13===t.keyCode&&this._expandSafely()},click:function(t){O(t),this._expandSafely()}},this),i||this.expand(),this._baseLayersList=P("div",t+"-base",n),this._separator=P("div",t+"-separator",n),this._overlaysList=P("div",t+"-overlays",n),e.appendChild(n)},_getLayer:function(t){for(var e=0;e<this._layers.length;e++)if(this._layers[e]&&h(this._layers[e].layer)===t)return this._layers[e]},_addLayer:function(t,e,i){this._map&&t.on("add remove",this._onLayerChange,this),this._layers.push({layer:t,name:e,overlay:i}),this.options.sortLayers&&this._layers.sort(a(function(t,e){return this.options.sortFunction(t.layer,e.layer,t.name,e.name)},this)),this.options.autoZIndex&&t.setZIndex&&(this._lastZIndex++,t.setZIndex(this._lastZIndex)),this._expandIfNotCollapsed()},_update:function(){if(this._container){me(this._baseLayersList),me(this._overlaysList),this._layerControlInputs=[];for(var t,e,i,n=0,o=0;o<this._layers.length;o++)i=this._layers[o],this._addItem(i),e=e||i.overlay,t=t||!i.overlay,n+=i.overlay?0:1;this.options.hideSingleBase&&(this._baseLayersList.style.display=(t=t&&1<n)?"":"none"),this._separator.style.display=e&&t?"":"none"}return this},_onLayerChange:function(t){this._handlingClick||this._update();var e=this._getLayer(h(t.target)),t=e.overlay?"add"===t.type?"overlayadd":"overlayremove":"add"===t.type?"baselayerchange":null;t&&this._map.fire(t,e)},_createRadioElement:function(t,e){t='<input type="radio" class="leaflet-control-layers-selector" name="'+t+'"'+(e?' checked="checked"':"")+"/>",e=document.createElement("div");return e.innerHTML=t,e.firstChild},_addItem:function(t){var e,i=document.createElement("label"),n=this._map.hasLayer(t.layer),n=(t.overlay?((e=document.createElement("input")).type="checkbox",e.className="leaflet-control-layers-selector",e.defaultChecked=n):e=this._createRadioElement("leaflet-base-layers_"+h(this),n),this._layerControlInputs.push(e),e.layerId=h(t.layer),S(e,"click",this._onInputClick,this),document.createElement("span")),o=(n.innerHTML=" "+t.name,document.createElement("span"));return i.appendChild(o),o.appendChild(e),o.appendChild(n),(t.overlay?this._overlaysList:this._baseLayersList).appendChild(i),this._checkDisabledLayers(),i},_onInputClick:function(){if(!this._preventClick){var t,e,i=this._layerControlInputs,n=[],o=[];this._handlingClick=!0;for(var s=i.length-1;0<=s;s--)t=i[s],e=this._getLayer(t.layerId).layer,t.checked?n.push(e):t.checked||o.push(e);for(s=0;s<o.length;s++)this._map.hasLayer(o[s])&&this._map.removeLayer(o[s]);for(s=0;s<n.length;s++)this._map.hasLayer(n[s])||this._map.addLayer(n[s]);this._handlingClick=!1,this._refocusOnMap()}},_checkDisabledLayers:function(){for(var t,e,i=this._layerControlInputs,n=this._map.getZoom(),o=i.length-1;0<=o;o--)t=i[o],e=this._getLayer(t.layerId).layer,t.disabled=void 0!==e.options.minZoom&&n<e.options.minZoom||void 0!==e.options.maxZoom&&n>e.options.maxZoom},_expandIfNotCollapsed:function(){return this._map&&!this.options.collapsed&&this.expand(),this},_expandSafely:function(){var t=this._section,e=(this._preventClick=!0,S(t,"click",O),this.expand(),this);setTimeout(function(){k(t,"click",O),e._preventClick=!1})}})),qe=B.extend({options:{position:"topleft",zoomInText:'<span aria-hidden="true">+</span>',zoomInTitle:"Zoom in",zoomOutText:'<span aria-hidden="true">&#x2212;</span>',zoomOutTitle:"Zoom out"},onAdd:function(t){var e="leaflet-control-zoom",i=P("div",e+" leaflet-bar"),n=this.options;return this._zoomInButton=this._createButton(n.zoomInText,n.zoomInTitle,e+"-in",i,this._zoomIn),this._zoomOutButton=this._createButton(n.zoomOutText,n.zoomOutTitle,e+"-out",i,this._zoomOut),this._updateDisabled(),t.on("zoomend zoomlevelschange",this._updateDisabled,this),i},onRemove:function(t){t.off("zoomend zoomlevelschange",this._updateDisabled,this)},disable:function(){return this._disabled=!0,this._updateDisabled(),this},enable:function(){return this._disabled=!1,this._updateDisabled(),this},_zoomIn:function(t){!this._disabled&&this._map._zoom<this._map.getMaxZoom()&&this._map.zoomIn(this._map.options.zoomDelta*(t.shiftKey?3:1))},_zoomOut:function(t){!this._disabled&&this._map._zoom>this._map.getMinZoom()&&this._map.zoomOut(this._map.options.zoomDelta*(t.shiftKey?3:1))},_createButton:function(t,e,i,n,o){i=P("a",i,n);return i.innerHTML=t,i.href="#",i.title=e,i.setAttribute("role","button"),i.setAttribute("aria-label",e),Ie(i),S(i,"click",Re),S(i,"click",o,this),S(i,"click",this._refocusOnMap,this),i},_updateDisabled:function(){var t=this._map,e="leaflet-disabled";z(this._zoomInButton,e),z(this._zoomOutButton,e),this._zoomInButton.setAttribute("aria-disabled","false"),this._zoomOutButton.setAttribute("aria-disabled","false"),!this._disabled&&t._zoom!==t.getMinZoom()||(M(this._zoomOutButton,e),this._zoomOutButton.setAttribute("aria-disabled","true")),!this._disabled&&t._zoom!==t.getMaxZoom()||(M(this._zoomInButton,e),this._zoomInButton.setAttribute("aria-disabled","true"))}}),Ge=(A.mergeOptions({zoomControl:!0}),A.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new qe,this.addControl(this.zoomControl))}),B.extend({options:{position:"bottomleft",maxWidth:100,metric:!0,imperial:!0},onAdd:function(t){var e="leaflet-control-scale",i=P("div",e),n=this.options;return this._addScales(n,e+"-line",i),t.on(n.updateWhenIdle?"moveend":"move",this._update,this),t.whenReady(this._update,this),i},onRemove:function(t){t.off(this.options.updateWhenIdle?"moveend":"move",this._update,this)},_addScales:function(t,e,i){t.metric&&(this._mScale=P("div",e,i)),t.imperial&&(this._iScale=P("div",e,i))},_update:function(){var t=this._map,e=t.getSize().y/2,t=t.distance(t.containerPointToLatLng([0,e]),t.containerPointToLatLng([this.options.maxWidth,e]));this._updateScales(t)},_updateScales:function(t){this.options.metric&&t&&this._updateMetric(t),this.options.imperial&&t&&this._updateImperial(t)},_updateMetric:function(t){var e=this._getRoundNum(t);this._updateScale(this._mScale,e<1e3?e+" m":e/1e3+" km",e/t)},_updateImperial:function(t){var e,i,t=3.2808399*t;5280<t?(i=this._getRoundNum(e=t/5280),this._updateScale(this._iScale,i+" mi",i/e)):(i=this._getRoundNum(t),this._updateScale(this._iScale,i+" ft",i/t))},_updateScale:function(t,e,i){t.style.width=Math.round(this.options.maxWidth*i)+"px",t.innerHTML=e},_getRoundNum:function(t){var e=Math.pow(10,(Math.floor(t)+"").length-1),t=t/e;return e*(t=10<=t?10:5<=t?5:3<=t?3:2<=t?2:1)}})),Ke=B.extend({options:{position:"bottomright",prefix:'<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">'+(b.inlineSvg?'<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg> ':"")+"Leaflet</a>"},initialize:function(t){c(this,t),this._attributions={}},onAdd:function(t){for(var e in(t.attributionControl=this)._container=P("div","leaflet-control-attribution"),Ie(this._container),t._layers)t._layers[e].getAttribution&&this.addAttribution(t._layers[e].getAttribution());return this._update(),t.on("layeradd",this._addAttribution,this),this._container},onRemove:function(t){t.off("layeradd",this._addAttribution,this)},_addAttribution:function(t){t.layer.getAttribution&&(this.addAttribution(t.layer.getAttribution()),t.layer.once("remove",function(){this.removeAttribution(t.layer.getAttribution())},this))},setPrefix:function(t){return this.options.prefix=t,this._update(),this},addAttribution:function(t){return t&&(this._attributions[t]||(this._attributions[t]=0),this._attributions[t]++,this._update()),this},removeAttribution:function(t){return t&&this._attributions[t]&&(this._attributions[t]--,this._update()),this},_update:function(){if(this._map){var t,e=[];for(t in this._attributions)this._attributions[t]&&e.push(t);var i=[];this.options.prefix&&i.push(this.options.prefix),e.length&&i.push(e.join(", ")),this._container.innerHTML=i.join(' <span aria-hidden="true">|</span> ')}}}),n=(A.mergeOptions({attributionControl:!0}),A.addInitHook(function(){this.options.attributionControl&&(new Ke).addTo(this)}),B.Layers=Ve,B.Zoom=qe,B.Scale=Ge,B.Attribution=Ke,Ue.layers=function(t,e,i){return new Ve(t,e,i)},Ue.zoom=function(t){return new qe(t)},Ue.scale=function(t){return new Ge(t)},Ue.attribution=function(t){return new Ke(t)},et.extend({initialize:function(t){this._map=t},enable:function(){return this._enabled||(this._enabled=!0,this.addHooks()),this},disable:function(){return this._enabled&&(this._enabled=!1,this.removeHooks()),this},enabled:function(){return!!this._enabled}})),ft=(n.addTo=function(t,e){return t.addHandler(e,this),this},{Events:e}),Ye=b.touch?"touchstart mousedown":"mousedown",Xe=it.extend({options:{clickTolerance:3},initialize:function(t,e,i,n){c(this,n),this._element=t,this._dragStartTarget=e||t,this._preventOutline=i},enable:function(){this._enabled||(S(this._dragStartTarget,Ye,this._onDown,this),this._enabled=!0)},disable:function(){this._enabled&&(Xe._dragging===this&&this.finishDrag(!0),k(this._dragStartTarget,Ye,this._onDown,this),this._enabled=!1,this._moved=!1)},_onDown:function(t){var e,i;this._enabled&&(this._moved=!1,ve(this._element,"leaflet-zoom-anim")||(t.touches&&1!==t.touches.length?Xe._dragging===this&&this.finishDrag():Xe._dragging||t.shiftKey||1!==t.which&&1!==t.button&&!t.touches||((Xe._dragging=this)._preventOutline&&Me(this._element),Le(),re(),this._moving||(this.fire("down"),i=t.touches?t.touches[0]:t,e=Ce(this._element),this._startPoint=new p(i.clientX,i.clientY),this._startPos=Pe(this._element),this._parentScale=Ze(e),i="mousedown"===t.type,S(document,i?"mousemove":"touchmove",this._onMove,this),S(document,i?"mouseup":"touchend touchcancel",this._onUp,this)))))},_onMove:function(t){var e;this._enabled&&(t.touches&&1<t.touches.length?this._moved=!0:!(e=new p((e=t.touches&&1===t.touches.length?t.touches[0]:t).clientX,e.clientY)._subtract(this._startPoint)).x&&!e.y||Math.abs(e.x)+Math.abs(e.y)<this.options.clickTolerance||(e.x/=this._parentScale.x,e.y/=this._parentScale.y,O(t),this._moved||(this.fire("dragstart"),this._moved=!0,M(document.body,"leaflet-dragging"),this._lastTarget=t.target||t.srcElement,window.SVGElementInstance&&this._lastTarget instanceof window.SVGElementInstance&&(this._lastTarget=this._lastTarget.correspondingUseElement),M(this._lastTarget,"leaflet-drag-target")),this._newPos=this._startPos.add(e),this._moving=!0,this._lastEvent=t,this._updatePosition()))},_updatePosition:function(){var t={originalEvent:this._lastEvent};this.fire("predrag",t),Z(this._element,this._newPos),this.fire("drag",t)},_onUp:function(){this._enabled&&this.finishDrag()},finishDrag:function(t){z(document.body,"leaflet-dragging"),this._lastTarget&&(z(this._lastTarget,"leaflet-drag-target"),this._lastTarget=null),k(document,"mousemove touchmove",this._onMove,this),k(document,"mouseup touchend touchcancel",this._onUp,this),Te(),ae();var e=this._moved&&this._moving;this._moving=!1,Xe._dragging=!1,e&&this.fire("dragend",{noInertia:t,distance:this._newPos.distanceTo(this._startPos)})}});function Je(t,e,i){for(var n,o,s,r,a,h,l,u=[1,4,2,8],c=0,d=t.length;c<d;c++)t[c]._code=si(t[c],e);for(s=0;s<4;s++){for(h=u[s],n=[],c=0,o=(d=t.length)-1;c<d;o=c++)r=t[c],a=t[o],r._code&h?a._code&h||((l=oi(a,r,h,e,i))._code=si(l,e),n.push(l)):(a._code&h&&((l=oi(a,r,h,e,i))._code=si(l,e),n.push(l)),n.push(r));t=n}return t}function $e(t,e){var i,n,o,s,r,a,h;if(!t||0===t.length)throw new Error("latlngs not passed");I(t)||(console.warn("latlngs are not flat! Only the first ring will be used"),t=t[0]);for(var l=w([0,0]),u=g(t),c=(u.getNorthWest().distanceTo(u.getSouthWest())*u.getNorthEast().distanceTo(u.getNorthWest())<1700&&(l=Qe(t)),t.length),d=[],_=0;_<c;_++){var p=w(t[_]);d.push(e.project(w([p.lat-l.lat,p.lng-l.lng])))}for(_=r=a=h=0,i=c-1;_<c;i=_++)n=d[_],o=d[i],s=n.y*o.x-o.y*n.x,a+=(n.x+o.x)*s,h+=(n.y+o.y)*s,r+=3*s;u=0===r?d[0]:[a/r,h/r],u=e.unproject(m(u));return w([u.lat+l.lat,u.lng+l.lng])}function Qe(t){for(var e=0,i=0,n=0,o=0;o<t.length;o++){var s=w(t[o]);e+=s.lat,i+=s.lng,n++}return w([e/n,i/n])}var ti,gt={__proto__:null,clipPolygon:Je,polygonCenter:$e,centroid:Qe};function ei(t,e){if(e&&t.length){var i=t=function(t,e){for(var i=[t[0]],n=1,o=0,s=t.length;n<s;n++)(function(t,e){var i=e.x-t.x,e=e.y-t.y;return i*i+e*e})(t[n],t[o])>e&&(i.push(t[n]),o=n);o<s-1&&i.push(t[s-1]);return i}(t,e=e*e),n=i.length,o=new(typeof Uint8Array!=void 0+""?Uint8Array:Array)(n);o[0]=o[n-1]=1,function t(e,i,n,o,s){var r,a,h,l=0;for(a=o+1;a<=s-1;a++)h=ri(e[a],e[o],e[s],!0),l<h&&(r=a,l=h);n<l&&(i[r]=1,t(e,i,n,o,r),t(e,i,n,r,s))}(i,o,e,0,n-1);var s,r=[];for(s=0;s<n;s++)o[s]&&r.push(i[s]);return r}return t.slice()}function ii(t,e,i){return Math.sqrt(ri(t,e,i,!0))}function ni(t,e,i,n,o){var s,r,a,h=n?ti:si(t,i),l=si(e,i);for(ti=l;;){if(!(h|l))return[t,e];if(h&l)return!1;a=si(r=oi(t,e,s=h||l,i,o),i),s===h?(t=r,h=a):(e=r,l=a)}}function oi(t,e,i,n,o){var s,r,a=e.x-t.x,e=e.y-t.y,h=n.min,n=n.max;return 8&i?(s=t.x+a*(n.y-t.y)/e,r=n.y):4&i?(s=t.x+a*(h.y-t.y)/e,r=h.y):2&i?(s=n.x,r=t.y+e*(n.x-t.x)/a):1&i&&(s=h.x,r=t.y+e*(h.x-t.x)/a),new p(s,r,o)}function si(t,e){var i=0;return t.x<e.min.x?i|=1:t.x>e.max.x&&(i|=2),t.y<e.min.y?i|=4:t.y>e.max.y&&(i|=8),i}function ri(t,e,i,n){var o=e.x,e=e.y,s=i.x-o,r=i.y-e,a=s*s+r*r;return 0<a&&(1<(a=((t.x-o)*s+(t.y-e)*r)/a)?(o=i.x,e=i.y):0<a&&(o+=s*a,e+=r*a)),s=t.x-o,r=t.y-e,n?s*s+r*r:new p(o,e)}function I(t){return!d(t[0])||"object"!=typeof t[0][0]&&void 0!==t[0][0]}function ai(t){return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."),I(t)}function hi(t,e){var i,n,o,s,r,a;if(!t||0===t.length)throw new Error("latlngs not passed");I(t)||(console.warn("latlngs are not flat! Only the first ring will be used"),t=t[0]);for(var h=w([0,0]),l=g(t),u=(l.getNorthWest().distanceTo(l.getSouthWest())*l.getNorthEast().distanceTo(l.getNorthWest())<1700&&(h=Qe(t)),t.length),c=[],d=0;d<u;d++){var _=w(t[d]);c.push(e.project(w([_.lat-h.lat,_.lng-h.lng])))}for(i=d=0;d<u-1;d++)i+=c[d].distanceTo(c[d+1])/2;if(0===i)a=c[0];else for(n=d=0;d<u-1;d++)if(o=c[d],s=c[d+1],i<(n+=r=o.distanceTo(s))){a=[s.x-(r=(n-i)/r)*(s.x-o.x),s.y-r*(s.y-o.y)];break}l=e.unproject(m(a));return w([l.lat+h.lat,l.lng+h.lng])}var vt={__proto__:null,simplify:ei,pointToSegmentDistance:ii,closestPointOnSegment:function(t,e,i){return ri(t,e,i)},clipSegment:ni,_getEdgeIntersection:oi,_getBitCode:si,_sqClosestPointOnSegment:ri,isFlat:I,_flat:ai,polylineCenter:hi},yt={project:function(t){return new p(t.lng,t.lat)},unproject:function(t){return new v(t.y,t.x)},bounds:new f([-180,-90],[180,90])},xt={R:6378137,R_MINOR:6356752.314245179,bounds:new f([-20037508.34279,-15496570.73972],[20037508.34279,18764656.23138]),project:function(t){var e=Math.PI/180,i=this.R,n=t.lat*e,o=this.R_MINOR/i,o=Math.sqrt(1-o*o),s=o*Math.sin(n),s=Math.tan(Math.PI/4-n/2)/Math.pow((1-s)/(1+s),o/2),n=-i*Math.log(Math.max(s,1e-10));return new p(t.lng*e*i,n)},unproject:function(t){for(var e,i=180/Math.PI,n=this.R,o=this.R_MINOR/n,s=Math.sqrt(1-o*o),r=Math.exp(-t.y/n),a=Math.PI/2-2*Math.atan(r),h=0,l=.1;h<15&&1e-7<Math.abs(l);h++)e=s*Math.sin(a),e=Math.pow((1-e)/(1+e),s/2),a+=l=Math.PI/2-2*Math.atan(r*e)-a;return new v(a*i,t.x*i/n)}},wt={__proto__:null,LonLat:yt,Mercator:xt,SphericalMercator:rt},Pt=l({},st,{code:"EPSG:3395",projection:xt,transformation:ht(bt=.5/(Math.PI*xt.R),.5,-bt,.5)}),li=l({},st,{code:"EPSG:4326",projection:yt,transformation:ht(1/180,1,-1/180,.5)}),Lt=l({},ot,{projection:yt,transformation:ht(1,0,-1,0),scale:function(t){return Math.pow(2,t)},zoom:function(t){return Math.log(t)/Math.LN2},distance:function(t,e){var i=e.lng-t.lng,e=e.lat-t.lat;return Math.sqrt(i*i+e*e)},infinite:!0}),o=(ot.Earth=st,ot.EPSG3395=Pt,ot.EPSG3857=lt,ot.EPSG900913=ut,ot.EPSG4326=li,ot.Simple=Lt,it.extend({options:{pane:"overlayPane",attribution:null,bubblingMouseEvents:!0},addTo:function(t){return t.addLayer(this),this},remove:function(){return this.removeFrom(this._map||this._mapToAdd)},removeFrom:function(t){return t&&t.removeLayer(this),this},getPane:function(t){return this._map.getPane(t?this.options[t]||t:this.options.pane)},addInteractiveTarget:function(t){return this._map._targets[h(t)]=this},removeInteractiveTarget:function(t){return delete this._map._targets[h(t)],this},getAttribution:function(){return this.options.attribution},_layerAdd:function(t){var e,i=t.target;i.hasLayer(this)&&(this._map=i,this._zoomAnimated=i._zoomAnimated,this.getEvents&&(e=this.getEvents(),i.on(e,this),this.once("remove",function(){i.off(e,this)},this)),this.onAdd(i),this.fire("add"),i.fire("layeradd",{layer:this}))}})),ui=(A.include({addLayer:function(t){var e;if(t._layerAdd)return e=h(t),this._layers[e]||((this._layers[e]=t)._mapToAdd=this,t.beforeAdd&&t.beforeAdd(this),this.whenReady(t._layerAdd,t)),this;throw new Error("The provided object is not a Layer.")},removeLayer:function(t){var e=h(t);return this._layers[e]&&(this._loaded&&t.onRemove(this),delete this._layers[e],this._loaded&&(this.fire("layerremove",{layer:t}),t.fire("remove")),t._map=t._mapToAdd=null),this},hasLayer:function(t){return h(t)in this._layers},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},_addLayers:function(t){for(var e=0,i=(t=t?d(t)?t:[t]:[]).length;e<i;e++)this.addLayer(t[e])},_addZoomLimit:function(t){isNaN(t.options.maxZoom)&&isNaN(t.options.minZoom)||(this._zoomBoundLayers[h(t)]=t,this._updateZoomLevels())},_removeZoomLimit:function(t){t=h(t);this._zoomBoundLayers[t]&&(delete this._zoomBoundLayers[t],this._updateZoomLevels())},_updateZoomLevels:function(){var t,e=1/0,i=-1/0,n=this._getZoomSpan();for(t in this._zoomBoundLayers)var o=this._zoomBoundLayers[t].options,e=void 0===o.minZoom?e:Math.min(e,o.minZoom),i=void 0===o.maxZoom?i:Math.max(i,o.maxZoom);this._layersMaxZoom=i===-1/0?void 0:i,this._layersMinZoom=e===1/0?void 0:e,n!==this._getZoomSpan()&&this.fire("zoomlevelschange"),void 0===this.options.maxZoom&&this._layersMaxZoom&&this.getZoom()>this._layersMaxZoom&&this.setZoom(this._layersMaxZoom),void 0===this.options.minZoom&&this._layersMinZoom&&this.getZoom()<this._layersMinZoom&&this.setZoom(this._layersMinZoom)}}),o.extend({initialize:function(t,e){var i,n;if(c(this,e),this._layers={},t)for(i=0,n=t.length;i<n;i++)this.addLayer(t[i])},addLayer:function(t){var e=this.getLayerId(t);return this._layers[e]=t,this._map&&this._map.addLayer(t),this},removeLayer:function(t){t=t in this._layers?t:this.getLayerId(t);return this._map&&this._layers[t]&&this._map.removeLayer(this._layers[t]),delete this._layers[t],this},hasLayer:function(t){return("number"==typeof t?t:this.getLayerId(t))in this._layers},clearLayers:function(){return this.eachLayer(this.removeLayer,this)},invoke:function(t){var e,i,n=Array.prototype.slice.call(arguments,1);for(e in this._layers)(i=this._layers[e])[t]&&i[t].apply(i,n);return this},onAdd:function(t){this.eachLayer(t.addLayer,t)},onRemove:function(t){this.eachLayer(t.removeLayer,t)},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},getLayer:function(t){return this._layers[t]},getLayers:function(){var t=[];return this.eachLayer(t.push,t),t},setZIndex:function(t){return this.invoke("setZIndex",t)},getLayerId:h})),ci=ui.extend({addLayer:function(t){return this.hasLayer(t)?this:(t.addEventParent(this),ui.prototype.addLayer.call(this,t),this.fire("layeradd",{layer:t}))},removeLayer:function(t){return this.hasLayer(t)?((t=t in this._layers?this._layers[t]:t).removeEventParent(this),ui.prototype.removeLayer.call(this,t),this.fire("layerremove",{layer:t})):this},setStyle:function(t){return this.invoke("setStyle",t)},bringToFront:function(){return this.invoke("bringToFront")},bringToBack:function(){return this.invoke("bringToBack")},getBounds:function(){var t,e=new s;for(t in this._layers){var i=this._layers[t];e.extend(i.getBounds?i.getBounds():i.getLatLng())}return e}}),di=et.extend({options:{popupAnchor:[0,0],tooltipAnchor:[0,0],crossOrigin:!1},initialize:function(t){c(this,t)},createIcon:function(t){return this._createIcon("icon",t)},createShadow:function(t){return this._createIcon("shadow",t)},_createIcon:function(t,e){var i=this._getIconUrl(t);if(i)return i=this._createImg(i,e&&"IMG"===e.tagName?e:null),this._setIconStyles(i,t),!this.options.crossOrigin&&""!==this.options.crossOrigin||(i.crossOrigin=!0===this.options.crossOrigin?"":this.options.crossOrigin),i;if("icon"===t)throw new Error("iconUrl not set in Icon options (see the docs).");return null},_setIconStyles:function(t,e){var i=this.options,n=i[e+"Size"],n=m(n="number"==typeof n?[n,n]:n),o=m("shadow"===e&&i.shadowAnchor||i.iconAnchor||n&&n.divideBy(2,!0));t.className="leaflet-marker-"+e+" "+(i.className||""),o&&(t.style.marginLeft=-o.x+"px",t.style.marginTop=-o.y+"px"),n&&(t.style.width=n.x+"px",t.style.height=n.y+"px")},_createImg:function(t,e){return(e=e||document.createElement("img")).src=t,e},_getIconUrl:function(t){return b.retina&&this.options[t+"RetinaUrl"]||this.options[t+"Url"]}});var _i=di.extend({options:{iconUrl:"marker-icon.png",iconRetinaUrl:"marker-icon-2x.png",shadowUrl:"marker-shadow.png",iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],tooltipAnchor:[16,-28],shadowSize:[41,41]},_getIconUrl:function(t){return"string"!=typeof _i.imagePath&&(_i.imagePath=this._detectIconPath()),(this.options.imagePath||_i.imagePath)+di.prototype._getIconUrl.call(this,t)},_stripUrl:function(t){function e(t,e,i){return(e=e.exec(t))&&e[i]}return(t=e(t,/^url\((['"])?(.+)\1\)$/,2))&&e(t,/^(.*)marker-icon\.png$/,1)},_detectIconPath:function(){var t=P("div","leaflet-default-icon-path",document.body),e=pe(t,"background-image")||pe(t,"backgroundImage");return document.body.removeChild(t),(e=this._stripUrl(e))?e:(t=document.querySelector('link[href$="leaflet.css"]'))?t.href.substring(0,t.href.length-"leaflet.css".length-1):""}}),pi=n.extend({initialize:function(t){this._marker=t},addHooks:function(){var t=this._marker._icon;this._draggable||(this._draggable=new Xe(t,t,!0)),this._draggable.on({dragstart:this._onDragStart,predrag:this._onPreDrag,drag:this._onDrag,dragend:this._onDragEnd},this).enable(),M(t,"leaflet-marker-draggable")},removeHooks:function(){this._draggable.off({dragstart:this._onDragStart,predrag:this._onPreDrag,drag:this._onDrag,dragend:this._onDragEnd},this).disable(),this._marker._icon&&z(this._marker._icon,"leaflet-marker-draggable")},moved:function(){return this._draggable&&this._draggable._moved},_adjustPan:function(t){var e=this._marker,i=e._map,n=this._marker.options.autoPanSpeed,o=this._marker.options.autoPanPadding,s=Pe(e._icon),r=i.getPixelBounds(),a=i.getPixelOrigin(),a=_(r.min._subtract(a).add(o),r.max._subtract(a).subtract(o));a.contains(s)||(o=m((Math.max(a.max.x,s.x)-a.max.x)/(r.max.x-a.max.x)-(Math.min(a.min.x,s.x)-a.min.x)/(r.min.x-a.min.x),(Math.max(a.max.y,s.y)-a.max.y)/(r.max.y-a.max.y)-(Math.min(a.min.y,s.y)-a.min.y)/(r.min.y-a.min.y)).multiplyBy(n),i.panBy(o,{animate:!1}),this._draggable._newPos._add(o),this._draggable._startPos._add(o),Z(e._icon,this._draggable._newPos),this._onDrag(t),this._panRequest=x(this._adjustPan.bind(this,t)))},_onDragStart:function(){this._oldLatLng=this._marker.getLatLng(),this._marker.closePopup&&this._marker.closePopup(),this._marker.fire("movestart").fire("dragstart")},_onPreDrag:function(t){this._marker.options.autoPan&&(r(this._panRequest),this._panRequest=x(this._adjustPan.bind(this,t)))},_onDrag:function(t){var e=this._marker,i=e._shadow,n=Pe(e._icon),o=e._map.layerPointToLatLng(n);i&&Z(i,n),e._latlng=o,t.latlng=o,t.oldLatLng=this._oldLatLng,e.fire("move",t).fire("drag",t)},_onDragEnd:function(t){r(this._panRequest),delete this._oldLatLng,this._marker.fire("moveend").fire("dragend",t)}}),mi=o.extend({options:{icon:new _i,interactive:!0,keyboard:!0,title:"",alt:"Marker",zIndexOffset:0,opacity:1,riseOnHover:!1,riseOffset:250,pane:"markerPane",shadowPane:"shadowPane",bubblingMouseEvents:!1,autoPanOnFocus:!0,draggable:!1,autoPan:!1,autoPanPadding:[50,50],autoPanSpeed:10},initialize:function(t,e){c(this,e),this._latlng=w(t)},onAdd:function(t){this._zoomAnimated=this._zoomAnimated&&t.options.markerZoomAnimation,this._zoomAnimated&&t.on("zoomanim",this._animateZoom,this),this._initIcon(),this.update()},onRemove:function(t){this.dragging&&this.dragging.enabled()&&(this.options.draggable=!0,this.dragging.removeHooks()),delete this.dragging,this._zoomAnimated&&t.off("zoomanim",this._animateZoom,this),this._removeIcon(),this._removeShadow()},getEvents:function(){return{zoom:this.update,viewreset:this.update}},getLatLng:function(){return this._latlng},setLatLng:function(t){var e=this._latlng;return this._latlng=w(t),this.update(),this.fire("move",{oldLatLng:e,latlng:this._latlng})},setZIndexOffset:function(t){return this.options.zIndexOffset=t,this.update()},getIcon:function(){return this.options.icon},setIcon:function(t){return this.options.icon=t,this._map&&(this._initIcon(),this.update()),this._popup&&this.bindPopup(this._popup,this._popup.options),this},getElement:function(){return this._icon},update:function(){var t;return this._icon&&this._map&&(t=this._map.latLngToLayerPoint(this._latlng).round(),this._setPos(t)),this},_initIcon:function(){var t=this.options,e="leaflet-zoom-"+(this._zoomAnimated?"animated":"hide"),i=t.icon.createIcon(this._icon),n=!1,i=(i!==this._icon&&(this._icon&&this._removeIcon(),n=!0,t.title&&(i.title=t.title),"IMG"===i.tagName&&(i.alt=t.alt||"")),M(i,e),t.keyboard&&(i.tabIndex="0",i.setAttribute("role","button")),this._icon=i,t.riseOnHover&&this.on({mouseover:this._bringToFront,mouseout:this._resetZIndex}),this.options.autoPanOnFocus&&S(i,"focus",this._panOnFocus,this),t.icon.createShadow(this._shadow)),o=!1;i!==this._shadow&&(this._removeShadow(),o=!0),i&&(M(i,e),i.alt=""),this._shadow=i,t.opacity<1&&this._updateOpacity(),n&&this.getPane().appendChild(this._icon),this._initInteraction(),i&&o&&this.getPane(t.shadowPane).appendChild(this._shadow)},_removeIcon:function(){this.options.riseOnHover&&this.off({mouseover:this._bringToFront,mouseout:this._resetZIndex}),this.options.autoPanOnFocus&&k(this._icon,"focus",this._panOnFocus,this),T(this._icon),this.removeInteractiveTarget(this._icon),this._icon=null},_removeShadow:function(){this._shadow&&T(this._shadow),this._shadow=null},_setPos:function(t){this._icon&&Z(this._icon,t),this._shadow&&Z(this._shadow,t),this._zIndex=t.y+this.options.zIndexOffset,this._resetZIndex()},_updateZIndex:function(t){this._icon&&(this._icon.style.zIndex=this._zIndex+t)},_animateZoom:function(t){t=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center).round();this._setPos(t)},_initInteraction:function(){var t;this.options.interactive&&(M(this._icon,"leaflet-interactive"),this.addInteractiveTarget(this._icon),pi&&(t=this.options.draggable,this.dragging&&(t=this.dragging.enabled(),this.dragging.disable()),this.dragging=new pi(this),t&&this.dragging.enable()))},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},_updateOpacity:function(){var t=this.options.opacity;this._icon&&C(this._icon,t),this._shadow&&C(this._shadow,t)},_bringToFront:function(){this._updateZIndex(this.options.riseOffset)},_resetZIndex:function(){this._updateZIndex(0)},_panOnFocus:function(){var t,e,i=this._map;i&&(t=(e=this.options.icon.options).iconSize?m(e.iconSize):m(0,0),e=e.iconAnchor?m(e.iconAnchor):m(0,0),i.panInside(this._latlng,{paddingTopLeft:e,paddingBottomRight:t.subtract(e)}))},_getPopupAnchor:function(){return this.options.icon.options.popupAnchor},_getTooltipAnchor:function(){return this.options.icon.options.tooltipAnchor}});var fi=o.extend({options:{stroke:!0,color:"#3388ff",weight:3,opacity:1,lineCap:"round",lineJoin:"round",dashArray:null,dashOffset:null,fill:!1,fillColor:null,fillOpacity:.2,fillRule:"evenodd",interactive:!0,bubblingMouseEvents:!0},beforeAdd:function(t){this._renderer=t.getRenderer(this)},onAdd:function(){this._renderer._initPath(this),this._reset(),this._renderer._addPath(this)},onRemove:function(){this._renderer._removePath(this)},redraw:function(){return this._map&&this._renderer._updatePath(this),this},setStyle:function(t){return c(this,t),this._renderer&&(this._renderer._updateStyle(this),this.options.stroke&&t&&Object.prototype.hasOwnProperty.call(t,"weight")&&this._updateBounds()),this},bringToFront:function(){return this._renderer&&this._renderer._bringToFront(this),this},bringToBack:function(){return this._renderer&&this._renderer._bringToBack(this),this},getElement:function(){return this._path},_reset:function(){this._project(),this._update()},_clickTolerance:function(){return(this.options.stroke?this.options.weight/2:0)+(this._renderer.options.tolerance||0)}}),gi=fi.extend({options:{fill:!0,radius:10},initialize:function(t,e){c(this,e),this._latlng=w(t),this._radius=this.options.radius},setLatLng:function(t){var e=this._latlng;return this._latlng=w(t),this.redraw(),this.fire("move",{oldLatLng:e,latlng:this._latlng})},getLatLng:function(){return this._latlng},setRadius:function(t){return this.options.radius=this._radius=t,this.redraw()},getRadius:function(){return this._radius},setStyle:function(t){var e=t&&t.radius||this._radius;return fi.prototype.setStyle.call(this,t),this.setRadius(e),this},_project:function(){this._point=this._map.latLngToLayerPoint(this._latlng),this._updateBounds()},_updateBounds:function(){var t=this._radius,e=this._radiusY||t,i=this._clickTolerance(),t=[t+i,e+i];this._pxBounds=new f(this._point.subtract(t),this._point.add(t))},_update:function(){this._map&&this._updatePath()},_updatePath:function(){this._renderer._updateCircle(this)},_empty:function(){return this._radius&&!this._renderer._bounds.intersects(this._pxBounds)},_containsPoint:function(t){return t.distanceTo(this._point)<=this._radius+this._clickTolerance()}});var vi=gi.extend({initialize:function(t,e,i){if(c(this,e="number"==typeof e?l({},i,{radius:e}):e),this._latlng=w(t),isNaN(this.options.radius))throw new Error("Circle radius cannot be NaN");this._mRadius=this.options.radius},setRadius:function(t){return this._mRadius=t,this.redraw()},getRadius:function(){return this._mRadius},getBounds:function(){var t=[this._radius,this._radiusY||this._radius];return new s(this._map.layerPointToLatLng(this._point.subtract(t)),this._map.layerPointToLatLng(this._point.add(t)))},setStyle:fi.prototype.setStyle,_project:function(){var t,e,i,n,o,s=this._latlng.lng,r=this._latlng.lat,a=this._map,h=a.options.crs;h.distance===st.distance?(n=Math.PI/180,o=this._mRadius/st.R/n,t=a.project([r+o,s]),e=a.project([r-o,s]),e=t.add(e).divideBy(2),i=a.unproject(e).lat,n=Math.acos((Math.cos(o*n)-Math.sin(r*n)*Math.sin(i*n))/(Math.cos(r*n)*Math.cos(i*n)))/n,!isNaN(n)&&0!==n||(n=o/Math.cos(Math.PI/180*r)),this._point=e.subtract(a.getPixelOrigin()),this._radius=isNaN(n)?0:e.x-a.project([i,s-n]).x,this._radiusY=e.y-t.y):(o=h.unproject(h.project(this._latlng).subtract([this._mRadius,0])),this._point=a.latLngToLayerPoint(this._latlng),this._radius=this._point.x-a.latLngToLayerPoint(o).x),this._updateBounds()}});var yi=fi.extend({options:{smoothFactor:1,noClip:!1},initialize:function(t,e){c(this,e),this._setLatLngs(t)},getLatLngs:function(){return this._latlngs},setLatLngs:function(t){return this._setLatLngs(t),this.redraw()},isEmpty:function(){return!this._latlngs.length},closestLayerPoint:function(t){for(var e=1/0,i=null,n=ri,o=0,s=this._parts.length;o<s;o++)for(var r=this._parts[o],a=1,h=r.length;a<h;a++){var l,u,c=n(t,l=r[a-1],u=r[a],!0);c<e&&(e=c,i=n(t,l,u))}return i&&(i.distance=Math.sqrt(e)),i},getCenter:function(){if(this._map)return hi(this._defaultShape(),this._map.options.crs);throw new Error("Must add layer to map before using getCenter()")},getBounds:function(){return this._bounds},addLatLng:function(t,e){return e=e||this._defaultShape(),t=w(t),e.push(t),this._bounds.extend(t),this.redraw()},_setLatLngs:function(t){this._bounds=new s,this._latlngs=this._convertLatLngs(t)},_defaultShape:function(){return I(this._latlngs)?this._latlngs:this._latlngs[0]},_convertLatLngs:function(t){for(var e=[],i=I(t),n=0,o=t.length;n<o;n++)i?(e[n]=w(t[n]),this._bounds.extend(e[n])):e[n]=this._convertLatLngs(t[n]);return e},_project:function(){var t=new f;this._rings=[],this._projectLatlngs(this._latlngs,this._rings,t),this._bounds.isValid()&&t.isValid()&&(this._rawPxBounds=t,this._updateBounds())},_updateBounds:function(){var t=this._clickTolerance(),t=new p(t,t);this._rawPxBounds&&(this._pxBounds=new f([this._rawPxBounds.min.subtract(t),this._rawPxBounds.max.add(t)]))},_projectLatlngs:function(t,e,i){var n,o,s=t[0]instanceof v,r=t.length;if(s){for(o=[],n=0;n<r;n++)o[n]=this._map.latLngToLayerPoint(t[n]),i.extend(o[n]);e.push(o)}else for(n=0;n<r;n++)this._projectLatlngs(t[n],e,i)},_clipPoints:function(){var t=this._renderer._bounds;if(this._parts=[],this._pxBounds&&this._pxBounds.intersects(t))if(this.options.noClip)this._parts=this._rings;else for(var e,i,n,o,s=this._parts,r=0,a=0,h=this._rings.length;r<h;r++)for(e=0,i=(o=this._rings[r]).length;e<i-1;e++)(n=ni(o[e],o[e+1],t,e,!0))&&(s[a]=s[a]||[],s[a].push(n[0]),n[1]===o[e+1]&&e!==i-2||(s[a].push(n[1]),a++))},_simplifyPoints:function(){for(var t=this._parts,e=this.options.smoothFactor,i=0,n=t.length;i<n;i++)t[i]=ei(t[i],e)},_update:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),this._updatePath())},_updatePath:function(){this._renderer._updatePoly(this)},_containsPoint:function(t,e){var i,n,o,s,r,a,h=this._clickTolerance();if(this._pxBounds&&this._pxBounds.contains(t))for(i=0,s=this._parts.length;i<s;i++)for(n=0,o=(r=(a=this._parts[i]).length)-1;n<r;o=n++)if((e||0!==n)&&ii(t,a[o],a[n])<=h)return!0;return!1}});yi._flat=ai;var xi=yi.extend({options:{fill:!0},isEmpty:function(){return!this._latlngs.length||!this._latlngs[0].length},getCenter:function(){if(this._map)return $e(this._defaultShape(),this._map.options.crs);throw new Error("Must add layer to map before using getCenter()")},_convertLatLngs:function(t){var t=yi.prototype._convertLatLngs.call(this,t),e=t.length;return 2<=e&&t[0]instanceof v&&t[0].equals(t[e-1])&&t.pop(),t},_setLatLngs:function(t){yi.prototype._setLatLngs.call(this,t),I(this._latlngs)&&(this._latlngs=[this._latlngs])},_defaultShape:function(){return(I(this._latlngs[0])?this._latlngs:this._latlngs[0])[0]},_clipPoints:function(){var t=this._renderer._bounds,e=this.options.weight,e=new p(e,e),t=new f(t.min.subtract(e),t.max.add(e));if(this._parts=[],this._pxBounds&&this._pxBounds.intersects(t))if(this.options.noClip)this._parts=this._rings;else for(var i,n=0,o=this._rings.length;n<o;n++)(i=Je(this._rings[n],t,!0)).length&&this._parts.push(i)},_updatePath:function(){this._renderer._updatePoly(this,!0)},_containsPoint:function(t){var e,i,n,o,s,r,a,h,l=!1;if(!this._pxBounds||!this._pxBounds.contains(t))return!1;for(o=0,a=this._parts.length;o<a;o++)for(s=0,r=(h=(e=this._parts[o]).length)-1;s<h;r=s++)i=e[s],n=e[r],i.y>t.y!=n.y>t.y&&t.x<(n.x-i.x)*(t.y-i.y)/(n.y-i.y)+i.x&&(l=!l);return l||yi.prototype._containsPoint.call(this,t,!0)}});var wi=ci.extend({initialize:function(t,e){c(this,e),this._layers={},t&&this.addData(t)},addData:function(t){var e,i,n,o=d(t)?t:t.features;if(o){for(e=0,i=o.length;e<i;e++)((n=o[e]).geometries||n.geometry||n.features||n.coordinates)&&this.addData(n);return this}var s,r=this.options;return(!r.filter||r.filter(t))&&(s=bi(t,r))?(s.feature=Zi(t),s.defaultOptions=s.options,this.resetStyle(s),r.onEachFeature&&r.onEachFeature(t,s),this.addLayer(s)):this},resetStyle:function(t){return void 0===t?this.eachLayer(this.resetStyle,this):(t.options=l({},t.defaultOptions),this._setLayerStyle(t,this.options.style),this)},setStyle:function(e){return this.eachLayer(function(t){this._setLayerStyle(t,e)},this)},_setLayerStyle:function(t,e){t.setStyle&&("function"==typeof e&&(e=e(t.feature)),t.setStyle(e))}});function bi(t,e){var i,n,o,s,r="Feature"===t.type?t.geometry:t,a=r?r.coordinates:null,h=[],l=e&&e.pointToLayer,u=e&&e.coordsToLatLng||Li;if(!a&&!r)return null;switch(r.type){case"Point":return Pi(l,t,i=u(a),e);case"MultiPoint":for(o=0,s=a.length;o<s;o++)i=u(a[o]),h.push(Pi(l,t,i,e));return new ci(h);case"LineString":case"MultiLineString":return n=Ti(a,"LineString"===r.type?0:1,u),new yi(n,e);case"Polygon":case"MultiPolygon":return n=Ti(a,"Polygon"===r.type?1:2,u),new xi(n,e);case"GeometryCollection":for(o=0,s=r.geometries.length;o<s;o++){var c=bi({geometry:r.geometries[o],type:"Feature",properties:t.properties},e);c&&h.push(c)}return new ci(h);case"FeatureCollection":for(o=0,s=r.features.length;o<s;o++){var d=bi(r.features[o],e);d&&h.push(d)}return new ci(h);default:throw new Error("Invalid GeoJSON object.")}}function Pi(t,e,i,n){return t?t(e,i):new mi(i,n&&n.markersInheritOptions&&n)}function Li(t){return new v(t[1],t[0],t[2])}function Ti(t,e,i){for(var n,o=[],s=0,r=t.length;s<r;s++)n=e?Ti(t[s],e-1,i):(i||Li)(t[s]),o.push(n);return o}function Mi(t,e){return void 0!==(t=w(t)).alt?[i(t.lng,e),i(t.lat,e),i(t.alt,e)]:[i(t.lng,e),i(t.lat,e)]}function zi(t,e,i,n){for(var o=[],s=0,r=t.length;s<r;s++)o.push(e?zi(t[s],I(t[s])?0:e-1,i,n):Mi(t[s],n));return!e&&i&&0<o.length&&o.push(o[0].slice()),o}function Ci(t,e){return t.feature?l({},t.feature,{geometry:e}):Zi(e)}function Zi(t){return"Feature"===t.type||"FeatureCollection"===t.type?t:{type:"Feature",properties:{},geometry:t}}Tt={toGeoJSON:function(t){return Ci(this,{type:"Point",coordinates:Mi(this.getLatLng(),t)})}};function Si(t,e){return new wi(t,e)}mi.include(Tt),vi.include(Tt),gi.include(Tt),yi.include({toGeoJSON:function(t){var e=!I(this._latlngs);return Ci(this,{type:(e?"Multi":"")+"LineString",coordinates:zi(this._latlngs,e?1:0,!1,t)})}}),xi.include({toGeoJSON:function(t){var e=!I(this._latlngs),i=e&&!I(this._latlngs[0]),t=zi(this._latlngs,i?2:e?1:0,!0,t);return Ci(this,{type:(i?"Multi":"")+"Polygon",coordinates:t=e?t:[t]})}}),ui.include({toMultiPoint:function(e){var i=[];return this.eachLayer(function(t){i.push(t.toGeoJSON(e).geometry.coordinates)}),Ci(this,{type:"MultiPoint",coordinates:i})},toGeoJSON:function(e){var i,n,t=this.feature&&this.feature.geometry&&this.feature.geometry.type;return"MultiPoint"===t?this.toMultiPoint(e):(i="GeometryCollection"===t,n=[],this.eachLayer(function(t){t.toGeoJSON&&(t=t.toGeoJSON(e),i?n.push(t.geometry):"FeatureCollection"===(t=Zi(t)).type?n.push.apply(n,t.features):n.push(t))}),i?Ci(this,{geometries:n,type:"GeometryCollection"}):{type:"FeatureCollection",features:n})}});var Mt=Si,Ei=o.extend({options:{opacity:1,alt:"",interactive:!1,crossOrigin:!1,errorOverlayUrl:"",zIndex:1,className:""},initialize:function(t,e,i){this._url=t,this._bounds=g(e),c(this,i)},onAdd:function(){this._image||(this._initImage(),this.options.opacity<1&&this._updateOpacity()),this.options.interactive&&(M(this._image,"leaflet-interactive"),this.addInteractiveTarget(this._image)),this.getPane().appendChild(this._image),this._reset()},onRemove:function(){T(this._image),this.options.interactive&&this.removeInteractiveTarget(this._image)},setOpacity:function(t){return this.options.opacity=t,this._image&&this._updateOpacity(),this},setStyle:function(t){return t.opacity&&this.setOpacity(t.opacity),this},bringToFront:function(){return this._map&&fe(this._image),this},bringToBack:function(){return this._map&&ge(this._image),this},setUrl:function(t){return this._url=t,this._image&&(this._image.src=t),this},setBounds:function(t){return this._bounds=g(t),this._map&&this._reset(),this},getEvents:function(){var t={zoom:this._reset,viewreset:this._reset};return this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},getBounds:function(){return this._bounds},getElement:function(){return this._image},_initImage:function(){var t="IMG"===this._url.tagName,e=this._image=t?this._url:P("img");M(e,"leaflet-image-layer"),this._zoomAnimated&&M(e,"leaflet-zoom-animated"),this.options.className&&M(e,this.options.className),e.onselectstart=u,e.onmousemove=u,e.onload=a(this.fire,this,"load"),e.onerror=a(this._overlayOnError,this,"error"),!this.options.crossOrigin&&""!==this.options.crossOrigin||(e.crossOrigin=!0===this.options.crossOrigin?"":this.options.crossOrigin),this.options.zIndex&&this._updateZIndex(),t?this._url=e.src:(e.src=this._url,e.alt=this.options.alt)},_animateZoom:function(t){var e=this._map.getZoomScale(t.zoom),t=this._map._latLngBoundsToNewLayerBounds(this._bounds,t.zoom,t.center).min;be(this._image,t,e)},_reset:function(){var t=this._image,e=new f(this._map.latLngToLayerPoint(this._bounds.getNorthWest()),this._map.latLngToLayerPoint(this._bounds.getSouthEast())),i=e.getSize();Z(t,e.min),t.style.width=i.x+"px",t.style.height=i.y+"px"},_updateOpacity:function(){C(this._image,this.options.opacity)},_updateZIndex:function(){this._image&&void 0!==this.options.zIndex&&null!==this.options.zIndex&&(this._image.style.zIndex=this.options.zIndex)},_overlayOnError:function(){this.fire("error");var t=this.options.errorOverlayUrl;t&&this._url!==t&&(this._url=t,this._image.src=t)},getCenter:function(){return this._bounds.getCenter()}}),ki=Ei.extend({options:{autoplay:!0,loop:!0,keepAspectRatio:!0,muted:!1,playsInline:!0},_initImage:function(){var t="VIDEO"===this._url.tagName,e=this._image=t?this._url:P("video");if(M(e,"leaflet-image-layer"),this._zoomAnimated&&M(e,"leaflet-zoom-animated"),this.options.className&&M(e,this.options.className),e.onselectstart=u,e.onmousemove=u,e.onloadeddata=a(this.fire,this,"load"),t){for(var i=e.getElementsByTagName("source"),n=[],o=0;o<i.length;o++)n.push(i[o].src);this._url=0<i.length?n:[e.src]}else{d(this._url)||(this._url=[this._url]),!this.options.keepAspectRatio&&Object.prototype.hasOwnProperty.call(e.style,"objectFit")&&(e.style.objectFit="fill"),e.autoplay=!!this.options.autoplay,e.loop=!!this.options.loop,e.muted=!!this.options.muted,e.playsInline=!!this.options.playsInline;for(var s=0;s<this._url.length;s++){var r=P("source");r.src=this._url[s],e.appendChild(r)}}}});var Oi=Ei.extend({_initImage:function(){var t=this._image=this._url;M(t,"leaflet-image-layer"),this._zoomAnimated&&M(t,"leaflet-zoom-animated"),this.options.className&&M(t,this.options.className),t.onselectstart=u,t.onmousemove=u}});var Ai=o.extend({options:{interactive:!1,offset:[0,0],className:"",pane:void 0,content:""},initialize:function(t,e){t&&(t instanceof v||d(t))?(this._latlng=w(t),c(this,e)):(c(this,t),this._source=e),this.options.content&&(this._content=this.options.content)},openOn:function(t){return(t=arguments.length?t:this._source._map).hasLayer(this)||t.addLayer(this),this},close:function(){return this._map&&this._map.removeLayer(this),this},toggle:function(t){return this._map?this.close():(arguments.length?this._source=t:t=this._source,this._prepareOpen(),this.openOn(t._map)),this},onAdd:function(t){this._zoomAnimated=t._zoomAnimated,this._container||this._initLayout(),t._fadeAnimated&&C(this._container,0),clearTimeout(this._removeTimeout),this.getPane().appendChild(this._container),this.update(),t._fadeAnimated&&C(this._container,1),this.bringToFront(),this.options.interactive&&(M(this._container,"leaflet-interactive"),this.addInteractiveTarget(this._container))},onRemove:function(t){t._fadeAnimated?(C(this._container,0),this._removeTimeout=setTimeout(a(T,void 0,this._container),200)):T(this._container),this.options.interactive&&(z(this._container,"leaflet-interactive"),this.removeInteractiveTarget(this._container))},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=w(t),this._map&&(this._updatePosition(),this._adjustPan()),this},getContent:function(){return this._content},setContent:function(t){return this._content=t,this.update(),this},getElement:function(){return this._container},update:function(){this._map&&(this._container.style.visibility="hidden",this._updateContent(),this._updateLayout(),this._updatePosition(),this._container.style.visibility="",this._adjustPan())},getEvents:function(){var t={zoom:this._updatePosition,viewreset:this._updatePosition};return this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},isOpen:function(){return!!this._map&&this._map.hasLayer(this)},bringToFront:function(){return this._map&&fe(this._container),this},bringToBack:function(){return this._map&&ge(this._container),this},_prepareOpen:function(t){if(!(i=this._source)._map)return!1;if(i instanceof ci){var e,i=null,n=this._source._layers;for(e in n)if(n[e]._map){i=n[e];break}if(!i)return!1;this._source=i}if(!t)if(i.getCenter)t=i.getCenter();else if(i.getLatLng)t=i.getLatLng();else{if(!i.getBounds)throw new Error("Unable to get source layer LatLng.");t=i.getBounds().getCenter()}return this.setLatLng(t),this._map&&this.update(),!0},_updateContent:function(){if(this._content){var t=this._contentNode,e="function"==typeof this._content?this._content(this._source||this):this._content;if("string"==typeof e)t.innerHTML=e;else{for(;t.hasChildNodes();)t.removeChild(t.firstChild);t.appendChild(e)}this.fire("contentupdate")}},_updatePosition:function(){var t,e,i;this._map&&(e=this._map.latLngToLayerPoint(this._latlng),t=m(this.options.offset),i=this._getAnchor(),this._zoomAnimated?Z(this._container,e.add(i)):t=t.add(e).add(i),e=this._containerBottom=-t.y,i=this._containerLeft=-Math.round(this._containerWidth/2)+t.x,this._container.style.bottom=e+"px",this._container.style.left=i+"px")},_getAnchor:function(){return[0,0]}}),Bi=(A.include({_initOverlay:function(t,e,i,n){var o=e;return o instanceof t||(o=new t(n).setContent(e)),i&&o.setLatLng(i),o}}),o.include({_initOverlay:function(t,e,i,n){var o=i;return o instanceof t?(c(o,n),o._source=this):(o=e&&!n?e:new t(n,this)).setContent(i),o}}),Ai.extend({options:{pane:"popupPane",offset:[0,7],maxWidth:300,minWidth:50,maxHeight:null,autoPan:!0,autoPanPaddingTopLeft:null,autoPanPaddingBottomRight:null,autoPanPadding:[5,5],keepInView:!1,closeButton:!0,autoClose:!0,closeOnEscapeKey:!0,className:""},openOn:function(t){return!(t=arguments.length?t:this._source._map).hasLayer(this)&&t._popup&&t._popup.options.autoClose&&t.removeLayer(t._popup),t._popup=this,Ai.prototype.openOn.call(this,t)},onAdd:function(t){Ai.prototype.onAdd.call(this,t),t.fire("popupopen",{popup:this}),this._source&&(this._source.fire("popupopen",{popup:this},!0),this._source instanceof fi||this._source.on("preclick",Ae))},onRemove:function(t){Ai.prototype.onRemove.call(this,t),t.fire("popupclose",{popup:this}),this._source&&(this._source.fire("popupclose",{popup:this},!0),this._source instanceof fi||this._source.off("preclick",Ae))},getEvents:function(){var t=Ai.prototype.getEvents.call(this);return(void 0!==this.options.closeOnClick?this.options.closeOnClick:this._map.options.closePopupOnClick)&&(t.preclick=this.close),this.options.keepInView&&(t.moveend=this._adjustPan),t},_initLayout:function(){var t="leaflet-popup",e=this._container=P("div",t+" "+(this.options.className||"")+" leaflet-zoom-animated"),i=this._wrapper=P("div",t+"-content-wrapper",e);this._contentNode=P("div",t+"-content",i),Ie(e),Be(this._contentNode),S(e,"contextmenu",Ae),this._tipContainer=P("div",t+"-tip-container",e),this._tip=P("div",t+"-tip",this._tipContainer),this.options.closeButton&&((i=this._closeButton=P("a",t+"-close-button",e)).setAttribute("role","button"),i.setAttribute("aria-label","Close popup"),i.href="#close",i.innerHTML='<span aria-hidden="true">&#215;</span>',S(i,"click",function(t){O(t),this.close()},this))},_updateLayout:function(){var t=this._contentNode,e=t.style,i=(e.width="",e.whiteSpace="nowrap",t.offsetWidth),i=Math.min(i,this.options.maxWidth),i=(i=Math.max(i,this.options.minWidth),e.width=i+1+"px",e.whiteSpace="",e.height="",t.offsetHeight),n=this.options.maxHeight,o="leaflet-popup-scrolled";(n&&n<i?(e.height=n+"px",M):z)(t,o),this._containerWidth=this._container.offsetWidth},_animateZoom:function(t){var t=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center),e=this._getAnchor();Z(this._container,t.add(e))},_adjustPan:function(){var t,e,i,n,o,s,r,a;this.options.autoPan&&(this._map._panAnim&&this._map._panAnim.stop(),this._autopanning?this._autopanning=!1:(t=this._map,e=parseInt(pe(this._container,"marginBottom"),10)||0,e=this._container.offsetHeight+e,a=this._containerWidth,(i=new p(this._containerLeft,-e-this._containerBottom))._add(Pe(this._container)),i=t.layerPointToContainerPoint(i),o=m(this.options.autoPanPadding),n=m(this.options.autoPanPaddingTopLeft||o),o=m(this.options.autoPanPaddingBottomRight||o),s=t.getSize(),r=0,i.x+a+o.x>s.x&&(r=i.x+a-s.x+o.x),i.x-r-n.x<(a=0)&&(r=i.x-n.x),i.y+e+o.y>s.y&&(a=i.y+e-s.y+o.y),i.y-a-n.y<0&&(a=i.y-n.y),(r||a)&&(this.options.keepInView&&(this._autopanning=!0),t.fire("autopanstart").panBy([r,a]))))},_getAnchor:function(){return m(this._source&&this._source._getPopupAnchor?this._source._getPopupAnchor():[0,0])}})),Ii=(A.mergeOptions({closePopupOnClick:!0}),A.include({openPopup:function(t,e,i){return this._initOverlay(Bi,t,e,i).openOn(this),this},closePopup:function(t){return(t=arguments.length?t:this._popup)&&t.close(),this}}),o.include({bindPopup:function(t,e){return this._popup=this._initOverlay(Bi,this._popup,t,e),this._popupHandlersAdded||(this.on({click:this._openPopup,keypress:this._onKeyPress,remove:this.closePopup,move:this._movePopup}),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this.off({click:this._openPopup,keypress:this._onKeyPress,remove:this.closePopup,move:this._movePopup}),this._popupHandlersAdded=!1,this._popup=null),this},openPopup:function(t){return this._popup&&(this instanceof ci||(this._popup._source=this),this._popup._prepareOpen(t||this._latlng)&&this._popup.openOn(this._map)),this},closePopup:function(){return this._popup&&this._popup.close(),this},togglePopup:function(){return this._popup&&this._popup.toggle(this),this},isPopupOpen:function(){return!!this._popup&&this._popup.isOpen()},setPopupContent:function(t){return this._popup&&this._popup.setContent(t),this},getPopup:function(){return this._popup},_openPopup:function(t){var e;this._popup&&this._map&&(Re(t),e=t.layer||t.target,this._popup._source!==e||e instanceof fi?(this._popup._source=e,this.openPopup(t.latlng)):this._map.hasLayer(this._popup)?this.closePopup():this.openPopup(t.latlng))},_movePopup:function(t){this._popup.setLatLng(t.latlng)},_onKeyPress:function(t){13===t.originalEvent.keyCode&&this._openPopup(t)}}),Ai.extend({options:{pane:"tooltipPane",offset:[0,0],direction:"auto",permanent:!1,sticky:!1,opacity:.9},onAdd:function(t){Ai.prototype.onAdd.call(this,t),this.setOpacity(this.options.opacity),t.fire("tooltipopen",{tooltip:this}),this._source&&(this.addEventParent(this._source),this._source.fire("tooltipopen",{tooltip:this},!0))},onRemove:function(t){Ai.prototype.onRemove.call(this,t),t.fire("tooltipclose",{tooltip:this}),this._source&&(this.removeEventParent(this._source),this._source.fire("tooltipclose",{tooltip:this},!0))},getEvents:function(){var t=Ai.prototype.getEvents.call(this);return this.options.permanent||(t.preclick=this.close),t},_initLayout:function(){var t="leaflet-tooltip "+(this.options.className||"")+" leaflet-zoom-"+(this._zoomAnimated?"animated":"hide");this._contentNode=this._container=P("div",t),this._container.setAttribute("role","tooltip"),this._container.setAttribute("id","leaflet-tooltip-"+h(this))},_updateLayout:function(){},_adjustPan:function(){},_setPosition:function(t){var e,i=this._map,n=this._container,o=i.latLngToContainerPoint(i.getCenter()),i=i.layerPointToContainerPoint(t),s=this.options.direction,r=n.offsetWidth,a=n.offsetHeight,h=m(this.options.offset),l=this._getAnchor(),i="top"===s?(e=r/2,a):"bottom"===s?(e=r/2,0):(e="center"===s?r/2:"right"===s?0:"left"===s?r:i.x<o.x?(s="right",0):(s="left",r+2*(h.x+l.x)),a/2);t=t.subtract(m(e,i,!0)).add(h).add(l),z(n,"leaflet-tooltip-right"),z(n,"leaflet-tooltip-left"),z(n,"leaflet-tooltip-top"),z(n,"leaflet-tooltip-bottom"),M(n,"leaflet-tooltip-"+s),Z(n,t)},_updatePosition:function(){var t=this._map.latLngToLayerPoint(this._latlng);this._setPosition(t)},setOpacity:function(t){this.options.opacity=t,this._container&&C(this._container,t)},_animateZoom:function(t){t=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center);this._setPosition(t)},_getAnchor:function(){return m(this._source&&this._source._getTooltipAnchor&&!this.options.sticky?this._source._getTooltipAnchor():[0,0])}})),Ri=(A.include({openTooltip:function(t,e,i){return this._initOverlay(Ii,t,e,i).openOn(this),this},closeTooltip:function(t){return t.close(),this}}),o.include({bindTooltip:function(t,e){return this._tooltip&&this.isTooltipOpen()&&this.unbindTooltip(),this._tooltip=this._initOverlay(Ii,this._tooltip,t,e),this._initTooltipInteractions(),this._tooltip.options.permanent&&this._map&&this._map.hasLayer(this)&&this.openTooltip(),this},unbindTooltip:function(){return this._tooltip&&(this._initTooltipInteractions(!0),this.closeTooltip(),this._tooltip=null),this},_initTooltipInteractions:function(t){var e,i;!t&&this._tooltipHandlersAdded||(e=t?"off":"on",i={remove:this.closeTooltip,move:this._moveTooltip},this._tooltip.options.permanent?i.add=this._openTooltip:(i.mouseover=this._openTooltip,i.mouseout=this.closeTooltip,i.click=this._openTooltip,this._map?this._addFocusListeners():i.add=this._addFocusListeners),this._tooltip.options.sticky&&(i.mousemove=this._moveTooltip),this[e](i),this._tooltipHandlersAdded=!t)},openTooltip:function(t){return this._tooltip&&(this instanceof ci||(this._tooltip._source=this),this._tooltip._prepareOpen(t)&&(this._tooltip.openOn(this._map),this.getElement?this._setAriaDescribedByOnLayer(this):this.eachLayer&&this.eachLayer(this._setAriaDescribedByOnLayer,this))),this},closeTooltip:function(){if(this._tooltip)return this._tooltip.close()},toggleTooltip:function(){return this._tooltip&&this._tooltip.toggle(this),this},isTooltipOpen:function(){return this._tooltip.isOpen()},setTooltipContent:function(t){return this._tooltip&&this._tooltip.setContent(t),this},getTooltip:function(){return this._tooltip},_addFocusListeners:function(){this.getElement?this._addFocusListenersOnLayer(this):this.eachLayer&&this.eachLayer(this._addFocusListenersOnLayer,this)},_addFocusListenersOnLayer:function(t){var e="function"==typeof t.getElement&&t.getElement();e&&(S(e,"focus",function(){this._tooltip._source=t,this.openTooltip()},this),S(e,"blur",this.closeTooltip,this))},_setAriaDescribedByOnLayer:function(t){t="function"==typeof t.getElement&&t.getElement();t&&t.setAttribute("aria-describedby",this._tooltip._container.id)},_openTooltip:function(t){var e;this._tooltip&&this._map&&(this._map.dragging&&this._map.dragging.moving()&&!this._openOnceFlag?(this._openOnceFlag=!0,(e=this)._map.once("moveend",function(){e._openOnceFlag=!1,e._openTooltip(t)})):(this._tooltip._source=t.layer||t.target,this.openTooltip(this._tooltip.options.sticky?t.latlng:void 0)))},_moveTooltip:function(t){var e=t.latlng;this._tooltip.options.sticky&&t.originalEvent&&(t=this._map.mouseEventToContainerPoint(t.originalEvent),t=this._map.containerPointToLayerPoint(t),e=this._map.layerPointToLatLng(t)),this._tooltip.setLatLng(e)}}),di.extend({options:{iconSize:[12,12],html:!1,bgPos:null,className:"leaflet-div-icon"},createIcon:function(t){var t=t&&"DIV"===t.tagName?t:document.createElement("div"),e=this.options;return e.html instanceof Element?(me(t),t.appendChild(e.html)):t.innerHTML=!1!==e.html?e.html:"",e.bgPos&&(e=m(e.bgPos),t.style.backgroundPosition=-e.x+"px "+-e.y+"px"),this._setIconStyles(t,"icon"),t},createShadow:function(){return null}}));di.Default=_i;var Ni=o.extend({options:{tileSize:256,opacity:1,updateWhenIdle:b.mobile,updateWhenZooming:!0,updateInterval:200,zIndex:1,bounds:null,minZoom:0,maxZoom:void 0,maxNativeZoom:void 0,minNativeZoom:void 0,noWrap:!1,pane:"tilePane",className:"",keepBuffer:2},initialize:function(t){c(this,t)},onAdd:function(){this._initContainer(),this._levels={},this._tiles={},this._resetView()},beforeAdd:function(t){t._addZoomLimit(this)},onRemove:function(t){this._removeAllTiles(),T(this._container),t._removeZoomLimit(this),this._container=null,this._tileZoom=void 0},bringToFront:function(){return this._map&&(fe(this._container),this._setAutoZIndex(Math.max)),this},bringToBack:function(){return this._map&&(ge(this._container),this._setAutoZIndex(Math.min)),this},getContainer:function(){return this._container},setOpacity:function(t){return this.options.opacity=t,this._updateOpacity(),this},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},isLoading:function(){return this._loading},redraw:function(){var t;return this._map&&(this._removeAllTiles(),(t=this._clampZoom(this._map.getZoom()))!==this._tileZoom&&(this._tileZoom=t,this._updateLevels()),this._update()),this},getEvents:function(){var t={viewprereset:this._invalidateAll,viewreset:this._resetView,zoom:this._resetView,moveend:this._onMoveEnd};return this.options.updateWhenIdle||(this._onMove||(this._onMove=j(this._onMoveEnd,this.options.updateInterval,this)),t.move=this._onMove),this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},createTile:function(){return document.createElement("div")},getTileSize:function(){var t=this.options.tileSize;return t instanceof p?t:new p(t,t)},_updateZIndex:function(){this._container&&void 0!==this.options.zIndex&&null!==this.options.zIndex&&(this._container.style.zIndex=this.options.zIndex)},_setAutoZIndex:function(t){for(var e,i=this.getPane().children,n=-t(-1/0,1/0),o=0,s=i.length;o<s;o++)e=i[o].style.zIndex,i[o]!==this._container&&e&&(n=t(n,+e));isFinite(n)&&(this.options.zIndex=n+t(-1,1),this._updateZIndex())},_updateOpacity:function(){if(this._map&&!b.ielt9){C(this._container,this.options.opacity);var t,e=+new Date,i=!1,n=!1;for(t in this._tiles){var o,s=this._tiles[t];s.current&&s.loaded&&(o=Math.min(1,(e-s.loaded)/200),C(s.el,o),o<1?i=!0:(s.active?n=!0:this._onOpaqueTile(s),s.active=!0))}n&&!this._noPrune&&this._pruneTiles(),i&&(r(this._fadeFrame),this._fadeFrame=x(this._updateOpacity,this))}},_onOpaqueTile:u,_initContainer:function(){this._container||(this._container=P("div","leaflet-layer "+(this.options.className||"")),this._updateZIndex(),this.options.opacity<1&&this._updateOpacity(),this.getPane().appendChild(this._container))},_updateLevels:function(){var t=this._tileZoom,e=this.options.maxZoom;if(void 0!==t){for(var i in this._levels)i=Number(i),this._levels[i].el.children.length||i===t?(this._levels[i].el.style.zIndex=e-Math.abs(t-i),this._onUpdateLevel(i)):(T(this._levels[i].el),this._removeTilesAtZoom(i),this._onRemoveLevel(i),delete this._levels[i]);var n=this._levels[t],o=this._map;return n||((n=this._levels[t]={}).el=P("div","leaflet-tile-container leaflet-zoom-animated",this._container),n.el.style.zIndex=e,n.origin=o.project(o.unproject(o.getPixelOrigin()),t).round(),n.zoom=t,this._setZoomTransform(n,o.getCenter(),o.getZoom()),u(n.el.offsetWidth),this._onCreateLevel(n)),this._level=n}},_onUpdateLevel:u,_onRemoveLevel:u,_onCreateLevel:u,_pruneTiles:function(){if(this._map){var t,e,i,n=this._map.getZoom();if(n>this.options.maxZoom||n<this.options.minZoom)this._removeAllTiles();else{for(t in this._tiles)(i=this._tiles[t]).retain=i.current;for(t in this._tiles)(i=this._tiles[t]).current&&!i.active&&(e=i.coords,this._retainParent(e.x,e.y,e.z,e.z-5)||this._retainChildren(e.x,e.y,e.z,e.z+2));for(t in this._tiles)this._tiles[t].retain||this._removeTile(t)}}},_removeTilesAtZoom:function(t){for(var e in this._tiles)this._tiles[e].coords.z===t&&this._removeTile(e)},_removeAllTiles:function(){for(var t in this._tiles)this._removeTile(t)},_invalidateAll:function(){for(var t in this._levels)T(this._levels[t].el),this._onRemoveLevel(Number(t)),delete this._levels[t];this._removeAllTiles(),this._tileZoom=void 0},_retainParent:function(t,e,i,n){var t=Math.floor(t/2),e=Math.floor(e/2),i=i-1,o=new p(+t,+e),o=(o.z=i,this._tileCoordsToKey(o)),o=this._tiles[o];return o&&o.active?o.retain=!0:(o&&o.loaded&&(o.retain=!0),n<i&&this._retainParent(t,e,i,n))},_retainChildren:function(t,e,i,n){for(var o=2*t;o<2*t+2;o++)for(var s=2*e;s<2*e+2;s++){var r=new p(o,s),r=(r.z=i+1,this._tileCoordsToKey(r)),r=this._tiles[r];r&&r.active?r.retain=!0:(r&&r.loaded&&(r.retain=!0),i+1<n&&this._retainChildren(o,s,i+1,n))}},_resetView:function(t){t=t&&(t.pinch||t.flyTo);this._setView(this._map.getCenter(),this._map.getZoom(),t,t)},_animateZoom:function(t){this._setView(t.center,t.zoom,!0,t.noUpdate)},_clampZoom:function(t){var e=this.options;return void 0!==e.minNativeZoom&&t<e.minNativeZoom?e.minNativeZoom:void 0!==e.maxNativeZoom&&e.maxNativeZoom<t?e.maxNativeZoom:t},_setView:function(t,e,i,n){var o=Math.round(e),o=void 0!==this.options.maxZoom&&o>this.options.maxZoom||void 0!==this.options.minZoom&&o<this.options.minZoom?void 0:this._clampZoom(o),s=this.options.updateWhenZooming&&o!==this._tileZoom;n&&!s||(this._tileZoom=o,this._abortLoading&&this._abortLoading(),this._updateLevels(),this._resetGrid(),void 0!==o&&this._update(t),i||this._pruneTiles(),this._noPrune=!!i),this._setZoomTransforms(t,e)},_setZoomTransforms:function(t,e){for(var i in this._levels)this._setZoomTransform(this._levels[i],t,e)},_setZoomTransform:function(t,e,i){var n=this._map.getZoomScale(i,t.zoom),e=t.origin.multiplyBy(n).subtract(this._map._getNewPixelOrigin(e,i)).round();b.any3d?be(t.el,e,n):Z(t.el,e)},_resetGrid:function(){var t=this._map,e=t.options.crs,i=this._tileSize=this.getTileSize(),n=this._tileZoom,o=this._map.getPixelWorldBounds(this._tileZoom);o&&(this._globalTileRange=this._pxBoundsToTileRange(o)),this._wrapX=e.wrapLng&&!this.options.noWrap&&[Math.floor(t.project([0,e.wrapLng[0]],n).x/i.x),Math.ceil(t.project([0,e.wrapLng[1]],n).x/i.y)],this._wrapY=e.wrapLat&&!this.options.noWrap&&[Math.floor(t.project([e.wrapLat[0],0],n).y/i.x),Math.ceil(t.project([e.wrapLat[1],0],n).y/i.y)]},_onMoveEnd:function(){this._map&&!this._map._animatingZoom&&this._update()},_getTiledPixelBounds:function(t){var e=this._map,i=e._animatingZoom?Math.max(e._animateToZoom,e.getZoom()):e.getZoom(),i=e.getZoomScale(i,this._tileZoom),t=e.project(t,this._tileZoom).floor(),e=e.getSize().divideBy(2*i);return new f(t.subtract(e),t.add(e))},_update:function(t){var e=this._map;if(e){var i=this._clampZoom(e.getZoom());if(void 0===t&&(t=e.getCenter()),void 0!==this._tileZoom){var n,e=this._getTiledPixelBounds(t),o=this._pxBoundsToTileRange(e),s=o.getCenter(),r=[],e=this.options.keepBuffer,a=new f(o.getBottomLeft().subtract([e,-e]),o.getTopRight().add([e,-e]));if(!(isFinite(o.min.x)&&isFinite(o.min.y)&&isFinite(o.max.x)&&isFinite(o.max.y)))throw new Error("Attempted to load an infinite number of tiles");for(n in this._tiles){var h=this._tiles[n].coords;h.z===this._tileZoom&&a.contains(new p(h.x,h.y))||(this._tiles[n].current=!1)}if(1<Math.abs(i-this._tileZoom))this._setView(t,i);else{for(var l=o.min.y;l<=o.max.y;l++)for(var u=o.min.x;u<=o.max.x;u++){var c,d=new p(u,l);d.z=this._tileZoom,this._isValidTile(d)&&((c=this._tiles[this._tileCoordsToKey(d)])?c.current=!0:r.push(d))}if(r.sort(function(t,e){return t.distanceTo(s)-e.distanceTo(s)}),0!==r.length){this._loading||(this._loading=!0,this.fire("loading"));for(var _=document.createDocumentFragment(),u=0;u<r.length;u++)this._addTile(r[u],_);this._level.el.appendChild(_)}}}}},_isValidTile:function(t){var e=this._map.options.crs;if(!e.infinite){var i=this._globalTileRange;if(!e.wrapLng&&(t.x<i.min.x||t.x>i.max.x)||!e.wrapLat&&(t.y<i.min.y||t.y>i.max.y))return!1}return!this.options.bounds||(e=this._tileCoordsToBounds(t),g(this.options.bounds).overlaps(e))},_keyToBounds:function(t){return this._tileCoordsToBounds(this._keyToTileCoords(t))},_tileCoordsToNwSe:function(t){var e=this._map,i=this.getTileSize(),n=t.scaleBy(i),i=n.add(i);return[e.unproject(n,t.z),e.unproject(i,t.z)]},_tileCoordsToBounds:function(t){t=this._tileCoordsToNwSe(t),t=new s(t[0],t[1]);return t=this.options.noWrap?t:this._map.wrapLatLngBounds(t)},_tileCoordsToKey:function(t){return t.x+":"+t.y+":"+t.z},_keyToTileCoords:function(t){var t=t.split(":"),e=new p(+t[0],+t[1]);return e.z=+t[2],e},_removeTile:function(t){var e=this._tiles[t];e&&(T(e.el),delete this._tiles[t],this.fire("tileunload",{tile:e.el,coords:this._keyToTileCoords(t)}))},_initTile:function(t){M(t,"leaflet-tile");var e=this.getTileSize();t.style.width=e.x+"px",t.style.height=e.y+"px",t.onselectstart=u,t.onmousemove=u,b.ielt9&&this.options.opacity<1&&C(t,this.options.opacity)},_addTile:function(t,e){var i=this._getTilePos(t),n=this._tileCoordsToKey(t),o=this.createTile(this._wrapCoords(t),a(this._tileReady,this,t));this._initTile(o),this.createTile.length<2&&x(a(this._tileReady,this,t,null,o)),Z(o,i),this._tiles[n]={el:o,coords:t,current:!0},e.appendChild(o),this.fire("tileloadstart",{tile:o,coords:t})},_tileReady:function(t,e,i){e&&this.fire("tileerror",{error:e,tile:i,coords:t});var n=this._tileCoordsToKey(t);(i=this._tiles[n])&&(i.loaded=+new Date,this._map._fadeAnimated?(C(i.el,0),r(this._fadeFrame),this._fadeFrame=x(this._updateOpacity,this)):(i.active=!0,this._pruneTiles()),e||(M(i.el,"leaflet-tile-loaded"),this.fire("tileload",{tile:i.el,coords:t})),this._noTilesToLoad()&&(this._loading=!1,this.fire("load"),b.ielt9||!this._map._fadeAnimated?x(this._pruneTiles,this):setTimeout(a(this._pruneTiles,this),250)))},_getTilePos:function(t){return t.scaleBy(this.getTileSize()).subtract(this._level.origin)},_wrapCoords:function(t){var e=new p(this._wrapX?H(t.x,this._wrapX):t.x,this._wrapY?H(t.y,this._wrapY):t.y);return e.z=t.z,e},_pxBoundsToTileRange:function(t){var e=this.getTileSize();return new f(t.min.unscaleBy(e).floor(),t.max.unscaleBy(e).ceil().subtract([1,1]))},_noTilesToLoad:function(){for(var t in this._tiles)if(!this._tiles[t].loaded)return!1;return!0}});var Di=Ni.extend({options:{minZoom:0,maxZoom:18,subdomains:"abc",errorTileUrl:"",zoomOffset:0,tms:!1,zoomReverse:!1,detectRetina:!1,crossOrigin:!1,referrerPolicy:!1},initialize:function(t,e){this._url=t,(e=c(this,e)).detectRetina&&b.retina&&0<e.maxZoom?(e.tileSize=Math.floor(e.tileSize/2),e.zoomReverse?(e.zoomOffset--,e.minZoom=Math.min(e.maxZoom,e.minZoom+1)):(e.zoomOffset++,e.maxZoom=Math.max(e.minZoom,e.maxZoom-1)),e.minZoom=Math.max(0,e.minZoom)):e.zoomReverse?e.minZoom=Math.min(e.maxZoom,e.minZoom):e.maxZoom=Math.max(e.minZoom,e.maxZoom),"string"==typeof e.subdomains&&(e.subdomains=e.subdomains.split("")),this.on("tileunload",this._onTileRemove)},setUrl:function(t,e){return this._url===t&&void 0===e&&(e=!0),this._url=t,e||this.redraw(),this},createTile:function(t,e){var i=document.createElement("img");return S(i,"load",a(this._tileOnLoad,this,e,i)),S(i,"error",a(this._tileOnError,this,e,i)),!this.options.crossOrigin&&""!==this.options.crossOrigin||(i.crossOrigin=!0===this.options.crossOrigin?"":this.options.crossOrigin),"string"==typeof this.options.referrerPolicy&&(i.referrerPolicy=this.options.referrerPolicy),i.alt="",i.src=this.getTileUrl(t),i},getTileUrl:function(t){var e={r:b.retina?"@2x":"",s:this._getSubdomain(t),x:t.x,y:t.y,z:this._getZoomForUrl()};return this._map&&!this._map.options.crs.infinite&&(t=this._globalTileRange.max.y-t.y,this.options.tms&&(e.y=t),e["-y"]=t),q(this._url,l(e,this.options))},_tileOnLoad:function(t,e){b.ielt9?setTimeout(a(t,this,null,e),0):t(null,e)},_tileOnError:function(t,e,i){var n=this.options.errorTileUrl;n&&e.getAttribute("src")!==n&&(e.src=n),t(i,e)},_onTileRemove:function(t){t.tile.onload=null},_getZoomForUrl:function(){var t=this._tileZoom,e=this.options.maxZoom;return(t=this.options.zoomReverse?e-t:t)+this.options.zoomOffset},_getSubdomain:function(t){t=Math.abs(t.x+t.y)%this.options.subdomains.length;return this.options.subdomains[t]},_abortLoading:function(){var t,e,i;for(t in this._tiles)this._tiles[t].coords.z!==this._tileZoom&&((i=this._tiles[t].el).onload=u,i.onerror=u,i.complete||(i.src=K,e=this._tiles[t].coords,T(i),delete this._tiles[t],this.fire("tileabort",{tile:i,coords:e})))},_removeTile:function(t){var e=this._tiles[t];if(e)return e.el.setAttribute("src",K),Ni.prototype._removeTile.call(this,t)},_tileReady:function(t,e,i){if(this._map&&(!i||i.getAttribute("src")!==K))return Ni.prototype._tileReady.call(this,t,e,i)}});function ji(t,e){return new Di(t,e)}var Hi=Di.extend({defaultWmsParams:{service:"WMS",request:"GetMap",layers:"",styles:"",format:"image/jpeg",transparent:!1,version:"1.1.1"},options:{crs:null,uppercase:!1},initialize:function(t,e){this._url=t;var i,n=l({},this.defaultWmsParams);for(i in e)i in this.options||(n[i]=e[i]);var t=(e=c(this,e)).detectRetina&&b.retina?2:1,o=this.getTileSize();n.width=o.x*t,n.height=o.y*t,this.wmsParams=n},onAdd:function(t){this._crs=this.options.crs||t.options.crs,this._wmsVersion=parseFloat(this.wmsParams.version);var e=1.3<=this._wmsVersion?"crs":"srs";this.wmsParams[e]=this._crs.code,Di.prototype.onAdd.call(this,t)},getTileUrl:function(t){var e=this._tileCoordsToNwSe(t),i=this._crs,i=_(i.project(e[0]),i.project(e[1])),e=i.min,i=i.max,e=(1.3<=this._wmsVersion&&this._crs===li?[e.y,e.x,i.y,i.x]:[e.x,e.y,i.x,i.y]).join(","),i=Di.prototype.getTileUrl.call(this,t);return i+U(this.wmsParams,i,this.options.uppercase)+(this.options.uppercase?"&BBOX=":"&bbox=")+e},setParams:function(t,e){return l(this.wmsParams,t),e||this.redraw(),this}});Di.WMS=Hi,ji.wms=function(t,e){return new Hi(t,e)};var Wi=o.extend({options:{padding:.1},initialize:function(t){c(this,t),h(this),this._layers=this._layers||{}},onAdd:function(){this._container||(this._initContainer(),M(this._container,"leaflet-zoom-animated")),this.getPane().appendChild(this._container),this._update(),this.on("update",this._updatePaths,this)},onRemove:function(){this.off("update",this._updatePaths,this),this._destroyContainer()},getEvents:function(){var t={viewreset:this._reset,zoom:this._onZoom,moveend:this._update,zoomend:this._onZoomEnd};return this._zoomAnimated&&(t.zoomanim=this._onAnimZoom),t},_onAnimZoom:function(t){this._updateTransform(t.center,t.zoom)},_onZoom:function(){this._updateTransform(this._map.getCenter(),this._map.getZoom())},_updateTransform:function(t,e){var i=this._map.getZoomScale(e,this._zoom),n=this._map.getSize().multiplyBy(.5+this.options.padding),o=this._map.project(this._center,e),n=n.multiplyBy(-i).add(o).subtract(this._map._getNewPixelOrigin(t,e));b.any3d?be(this._container,n,i):Z(this._container,n)},_reset:function(){for(var t in this._update(),this._updateTransform(this._center,this._zoom),this._layers)this._layers[t]._reset()},_onZoomEnd:function(){for(var t in this._layers)this._layers[t]._project()},_updatePaths:function(){for(var t in this._layers)this._layers[t]._update()},_update:function(){var t=this.options.padding,e=this._map.getSize(),i=this._map.containerPointToLayerPoint(e.multiplyBy(-t)).round();this._bounds=new f(i,i.add(e.multiplyBy(1+2*t)).round()),this._center=this._map.getCenter(),this._zoom=this._map.getZoom()}}),Fi=Wi.extend({options:{tolerance:0},getEvents:function(){var t=Wi.prototype.getEvents.call(this);return t.viewprereset=this._onViewPreReset,t},_onViewPreReset:function(){this._postponeUpdatePaths=!0},onAdd:function(){Wi.prototype.onAdd.call(this),this._draw()},_initContainer:function(){var t=this._container=document.createElement("canvas");S(t,"mousemove",this._onMouseMove,this),S(t,"click dblclick mousedown mouseup contextmenu",this._onClick,this),S(t,"mouseout",this._handleMouseOut,this),t._leaflet_disable_events=!0,this._ctx=t.getContext("2d")},_destroyContainer:function(){r(this._redrawRequest),delete this._ctx,T(this._container),k(this._container),delete this._container},_updatePaths:function(){if(!this._postponeUpdatePaths){for(var t in this._redrawBounds=null,this._layers)this._layers[t]._update();this._redraw()}},_update:function(){var t,e,i,n;this._map._animatingZoom&&this._bounds||(Wi.prototype._update.call(this),t=this._bounds,e=this._container,i=t.getSize(),n=b.retina?2:1,Z(e,t.min),e.width=n*i.x,e.height=n*i.y,e.style.width=i.x+"px",e.style.height=i.y+"px",b.retina&&this._ctx.scale(2,2),this._ctx.translate(-t.min.x,-t.min.y),this.fire("update"))},_reset:function(){Wi.prototype._reset.call(this),this._postponeUpdatePaths&&(this._postponeUpdatePaths=!1,this._updatePaths())},_initPath:function(t){this._updateDashArray(t);t=(this._layers[h(t)]=t)._order={layer:t,prev:this._drawLast,next:null};this._drawLast&&(this._drawLast.next=t),this._drawLast=t,this._drawFirst=this._drawFirst||this._drawLast},_addPath:function(t){this._requestRedraw(t)},_removePath:function(t){var e=t._order,i=e.next,e=e.prev;i?i.prev=e:this._drawLast=e,e?e.next=i:this._drawFirst=i,delete t._order,delete this._layers[h(t)],this._requestRedraw(t)},_updatePath:function(t){this._extendRedrawBounds(t),t._project(),t._update(),this._requestRedraw(t)},_updateStyle:function(t){this._updateDashArray(t),this._requestRedraw(t)},_updateDashArray:function(t){if("string"==typeof t.options.dashArray){for(var e,i=t.options.dashArray.split(/[, ]+/),n=[],o=0;o<i.length;o++){if(e=Number(i[o]),isNaN(e))return;n.push(e)}t.options._dashArray=n}else t.options._dashArray=t.options.dashArray},_requestRedraw:function(t){this._map&&(this._extendRedrawBounds(t),this._redrawRequest=this._redrawRequest||x(this._redraw,this))},_extendRedrawBounds:function(t){var e;t._pxBounds&&(e=(t.options.weight||0)+1,this._redrawBounds=this._redrawBounds||new f,this._redrawBounds.extend(t._pxBounds.min.subtract([e,e])),this._redrawBounds.extend(t._pxBounds.max.add([e,e])))},_redraw:function(){this._redrawRequest=null,this._redrawBounds&&(this._redrawBounds.min._floor(),this._redrawBounds.max._ceil()),this._clear(),this._draw(),this._redrawBounds=null},_clear:function(){var t,e=this._redrawBounds;e?(t=e.getSize(),this._ctx.clearRect(e.min.x,e.min.y,t.x,t.y)):(this._ctx.save(),this._ctx.setTransform(1,0,0,1,0,0),this._ctx.clearRect(0,0,this._container.width,this._container.height),this._ctx.restore())},_draw:function(){var t,e,i=this._redrawBounds;this._ctx.save(),i&&(e=i.getSize(),this._ctx.beginPath(),this._ctx.rect(i.min.x,i.min.y,e.x,e.y),this._ctx.clip()),this._drawing=!0;for(var n=this._drawFirst;n;n=n.next)t=n.layer,(!i||t._pxBounds&&t._pxBounds.intersects(i))&&t._updatePath();this._drawing=!1,this._ctx.restore()},_updatePoly:function(t,e){if(this._drawing){var i,n,o,s,r=t._parts,a=r.length,h=this._ctx;if(a){for(h.beginPath(),i=0;i<a;i++){for(n=0,o=r[i].length;n<o;n++)s=r[i][n],h[n?"lineTo":"moveTo"](s.x,s.y);e&&h.closePath()}this._fillStroke(h,t)}}},_updateCircle:function(t){var e,i,n,o;this._drawing&&!t._empty()&&(e=t._point,i=this._ctx,n=Math.max(Math.round(t._radius),1),1!=(o=(Math.max(Math.round(t._radiusY),1)||n)/n)&&(i.save(),i.scale(1,o)),i.beginPath(),i.arc(e.x,e.y/o,n,0,2*Math.PI,!1),1!=o&&i.restore(),this._fillStroke(i,t))},_fillStroke:function(t,e){var i=e.options;i.fill&&(t.globalAlpha=i.fillOpacity,t.fillStyle=i.fillColor||i.color,t.fill(i.fillRule||"evenodd")),i.stroke&&0!==i.weight&&(t.setLineDash&&t.setLineDash(e.options&&e.options._dashArray||[]),t.globalAlpha=i.opacity,t.lineWidth=i.weight,t.strokeStyle=i.color,t.lineCap=i.lineCap,t.lineJoin=i.lineJoin,t.stroke())},_onClick:function(t){for(var e,i,n=this._map.mouseEventToLayerPoint(t),o=this._drawFirst;o;o=o.next)(e=o.layer).options.interactive&&e._containsPoint(n)&&(("click"===t.type||"preclick"===t.type)&&this._map._draggableMoved(e)||(i=e));this._fireEvent(!!i&&[i],t)},_onMouseMove:function(t){var e;!this._map||this._map.dragging.moving()||this._map._animatingZoom||(e=this._map.mouseEventToLayerPoint(t),this._handleMouseHover(t,e))},_handleMouseOut:function(t){var e=this._hoveredLayer;e&&(z(this._container,"leaflet-interactive"),this._fireEvent([e],t,"mouseout"),this._hoveredLayer=null,this._mouseHoverThrottled=!1)},_handleMouseHover:function(t,e){if(!this._mouseHoverThrottled){for(var i,n,o=this._drawFirst;o;o=o.next)(i=o.layer).options.interactive&&i._containsPoint(e)&&(n=i);n!==this._hoveredLayer&&(this._handleMouseOut(t),n&&(M(this._container,"leaflet-interactive"),this._fireEvent([n],t,"mouseover"),this._hoveredLayer=n)),this._fireEvent(!!this._hoveredLayer&&[this._hoveredLayer],t),this._mouseHoverThrottled=!0,setTimeout(a(function(){this._mouseHoverThrottled=!1},this),32)}},_fireEvent:function(t,e,i){this._map._fireDOMEvent(e,i||e.type,t)},_bringToFront:function(t){var e,i,n=t._order;n&&(e=n.next,i=n.prev,e&&((e.prev=i)?i.next=e:e&&(this._drawFirst=e),n.prev=this._drawLast,(this._drawLast.next=n).next=null,this._drawLast=n,this._requestRedraw(t)))},_bringToBack:function(t){var e,i,n=t._order;n&&(e=n.next,(i=n.prev)&&((i.next=e)?e.prev=i:i&&(this._drawLast=i),n.prev=null,n.next=this._drawFirst,this._drawFirst.prev=n,this._drawFirst=n,this._requestRedraw(t)))}});function Ui(t){return b.canvas?new Fi(t):null}var Vi=function(){try{return document.namespaces.add("lvml","urn:schemas-microsoft-com:vml"),function(t){return document.createElement("<lvml:"+t+' class="lvml">')}}catch(t){}return function(t){return document.createElement("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}(),zt={_initContainer:function(){this._container=P("div","leaflet-vml-container")},_update:function(){this._map._animatingZoom||(Wi.prototype._update.call(this),this.fire("update"))},_initPath:function(t){var e=t._container=Vi("shape");M(e,"leaflet-vml-shape "+(this.options.className||"")),e.coordsize="1 1",t._path=Vi("path"),e.appendChild(t._path),this._updateStyle(t),this._layers[h(t)]=t},_addPath:function(t){var e=t._container;this._container.appendChild(e),t.options.interactive&&t.addInteractiveTarget(e)},_removePath:function(t){var e=t._container;T(e),t.removeInteractiveTarget(e),delete this._layers[h(t)]},_updateStyle:function(t){var e=t._stroke,i=t._fill,n=t.options,o=t._container;o.stroked=!!n.stroke,o.filled=!!n.fill,n.stroke?(e=e||(t._stroke=Vi("stroke")),o.appendChild(e),e.weight=n.weight+"px",e.color=n.color,e.opacity=n.opacity,n.dashArray?e.dashStyle=d(n.dashArray)?n.dashArray.join(" "):n.dashArray.replace(/( *, *)/g," "):e.dashStyle="",e.endcap=n.lineCap.replace("butt","flat"),e.joinstyle=n.lineJoin):e&&(o.removeChild(e),t._stroke=null),n.fill?(i=i||(t._fill=Vi("fill")),o.appendChild(i),i.color=n.fillColor||n.color,i.opacity=n.fillOpacity):i&&(o.removeChild(i),t._fill=null)},_updateCircle:function(t){var e=t._point.round(),i=Math.round(t._radius),n=Math.round(t._radiusY||i);this._setPath(t,t._empty()?"M0 0":"AL "+e.x+","+e.y+" "+i+","+n+" 0,23592600")},_setPath:function(t,e){t._path.v=e},_bringToFront:function(t){fe(t._container)},_bringToBack:function(t){ge(t._container)}},qi=b.vml?Vi:ct,Gi=Wi.extend({_initContainer:function(){this._container=qi("svg"),this._container.setAttribute("pointer-events","none"),this._rootGroup=qi("g"),this._container.appendChild(this._rootGroup)},_destroyContainer:function(){T(this._container),k(this._container),delete this._container,delete this._rootGroup,delete this._svgSize},_update:function(){var t,e,i;this._map._animatingZoom&&this._bounds||(Wi.prototype._update.call(this),e=(t=this._bounds).getSize(),i=this._container,this._svgSize&&this._svgSize.equals(e)||(this._svgSize=e,i.setAttribute("width",e.x),i.setAttribute("height",e.y)),Z(i,t.min),i.setAttribute("viewBox",[t.min.x,t.min.y,e.x,e.y].join(" ")),this.fire("update"))},_initPath:function(t){var e=t._path=qi("path");t.options.className&&M(e,t.options.className),t.options.interactive&&M(e,"leaflet-interactive"),this._updateStyle(t),this._layers[h(t)]=t},_addPath:function(t){this._rootGroup||this._initContainer(),this._rootGroup.appendChild(t._path),t.addInteractiveTarget(t._path)},_removePath:function(t){T(t._path),t.removeInteractiveTarget(t._path),delete this._layers[h(t)]},_updatePath:function(t){t._project(),t._update()},_updateStyle:function(t){var e=t._path,t=t.options;e&&(t.stroke?(e.setAttribute("stroke",t.color),e.setAttribute("stroke-opacity",t.opacity),e.setAttribute("stroke-width",t.weight),e.setAttribute("stroke-linecap",t.lineCap),e.setAttribute("stroke-linejoin",t.lineJoin),t.dashArray?e.setAttribute("stroke-dasharray",t.dashArray):e.removeAttribute("stroke-dasharray"),t.dashOffset?e.setAttribute("stroke-dashoffset",t.dashOffset):e.removeAttribute("stroke-dashoffset")):e.setAttribute("stroke","none"),t.fill?(e.setAttribute("fill",t.fillColor||t.color),e.setAttribute("fill-opacity",t.fillOpacity),e.setAttribute("fill-rule",t.fillRule||"evenodd")):e.setAttribute("fill","none"))},_updatePoly:function(t,e){this._setPath(t,dt(t._parts,e))},_updateCircle:function(t){var e=t._point,i=Math.max(Math.round(t._radius),1),n="a"+i+","+(Math.max(Math.round(t._radiusY),1)||i)+" 0 1,0 ",e=t._empty()?"M0 0":"M"+(e.x-i)+","+e.y+n+2*i+",0 "+n+2*-i+",0 ";this._setPath(t,e)},_setPath:function(t,e){t._path.setAttribute("d",e)},_bringToFront:function(t){fe(t._path)},_bringToBack:function(t){ge(t._path)}});function Ki(t){return b.svg||b.vml?new Gi(t):null}b.vml&&Gi.include(zt),A.include({getRenderer:function(t){t=(t=t.options.renderer||this._getPaneRenderer(t.options.pane)||this.options.renderer||this._renderer)||(this._renderer=this._createRenderer());return this.hasLayer(t)||this.addLayer(t),t},_getPaneRenderer:function(t){var e;return"overlayPane"!==t&&void 0!==t&&(void 0===(e=this._paneRenderers[t])&&(e=this._createRenderer({pane:t}),this._paneRenderers[t]=e),e)},_createRenderer:function(t){return this.options.preferCanvas&&Ui(t)||Ki(t)}});var Yi=xi.extend({initialize:function(t,e){xi.prototype.initialize.call(this,this._boundsToLatLngs(t),e)},setBounds:function(t){return this.setLatLngs(this._boundsToLatLngs(t))},_boundsToLatLngs:function(t){return[(t=g(t)).getSouthWest(),t.getNorthWest(),t.getNorthEast(),t.getSouthEast()]}});Gi.create=qi,Gi.pointsToPath=dt,wi.geometryToLayer=bi,wi.coordsToLatLng=Li,wi.coordsToLatLngs=Ti,wi.latLngToCoords=Mi,wi.latLngsToCoords=zi,wi.getFeature=Ci,wi.asFeature=Zi,A.mergeOptions({boxZoom:!0});var _t=n.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane,this._resetStateTimeout=0,t.on("unload",this._destroy,this)},addHooks:function(){S(this._container,"mousedown",this._onMouseDown,this)},removeHooks:function(){k(this._container,"mousedown",this._onMouseDown,this)},moved:function(){return this._moved},_destroy:function(){T(this._pane),delete this._pane},_resetState:function(){this._resetStateTimeout=0,this._moved=!1},_clearDeferredResetState:function(){0!==this._resetStateTimeout&&(clearTimeout(this._resetStateTimeout),this._resetStateTimeout=0)},_onMouseDown:function(t){if(!t.shiftKey||1!==t.which&&1!==t.button)return!1;this._clearDeferredResetState(),this._resetState(),re(),Le(),this._startPoint=this._map.mouseEventToContainerPoint(t),S(document,{contextmenu:Re,mousemove:this._onMouseMove,mouseup:this._onMouseUp,keydown:this._onKeyDown},this)},_onMouseMove:function(t){this._moved||(this._moved=!0,this._box=P("div","leaflet-zoom-box",this._container),M(this._container,"leaflet-crosshair"),this._map.fire("boxzoomstart")),this._point=this._map.mouseEventToContainerPoint(t);var t=new f(this._point,this._startPoint),e=t.getSize();Z(this._box,t.min),this._box.style.width=e.x+"px",this._box.style.height=e.y+"px"},_finish:function(){this._moved&&(T(this._box),z(this._container,"leaflet-crosshair")),ae(),Te(),k(document,{contextmenu:Re,mousemove:this._onMouseMove,mouseup:this._onMouseUp,keydown:this._onKeyDown},this)},_onMouseUp:function(t){1!==t.which&&1!==t.button||(this._finish(),this._moved&&(this._clearDeferredResetState(),this._resetStateTimeout=setTimeout(a(this._resetState,this),0),t=new s(this._map.containerPointToLatLng(this._startPoint),this._map.containerPointToLatLng(this._point)),this._map.fitBounds(t).fire("boxzoomend",{boxZoomBounds:t})))},_onKeyDown:function(t){27===t.keyCode&&(this._finish(),this._clearDeferredResetState(),this._resetState())}}),Ct=(A.addInitHook("addHandler","boxZoom",_t),A.mergeOptions({doubleClickZoom:!0}),n.extend({addHooks:function(){this._map.on("dblclick",this._onDoubleClick,this)},removeHooks:function(){this._map.off("dblclick",this._onDoubleClick,this)},_onDoubleClick:function(t){var e=this._map,i=e.getZoom(),n=e.options.zoomDelta,i=t.originalEvent.shiftKey?i-n:i+n;"center"===e.options.doubleClickZoom?e.setZoom(i):e.setZoomAround(t.containerPoint,i)}})),Zt=(A.addInitHook("addHandler","doubleClickZoom",Ct),A.mergeOptions({dragging:!0,inertia:!0,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,easeLinearity:.2,worldCopyJump:!1,maxBoundsViscosity:0}),n.extend({addHooks:function(){var t;this._draggable||(t=this._map,this._draggable=new Xe(t._mapPane,t._container),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),this._draggable.on("predrag",this._onPreDragLimit,this),t.options.worldCopyJump&&(this._draggable.on("predrag",this._onPreDragWrap,this),t.on("zoomend",this._onZoomEnd,this),t.whenReady(this._onZoomEnd,this))),M(this._map._container,"leaflet-grab leaflet-touch-drag"),this._draggable.enable(),this._positions=[],this._times=[]},removeHooks:function(){z(this._map._container,"leaflet-grab"),z(this._map._container,"leaflet-touch-drag"),this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},moving:function(){return this._draggable&&this._draggable._moving},_onDragStart:function(){var t,e=this._map;e._stop(),this._map.options.maxBounds&&this._map.options.maxBoundsViscosity?(t=g(this._map.options.maxBounds),this._offsetLimit=_(this._map.latLngToContainerPoint(t.getNorthWest()).multiplyBy(-1),this._map.latLngToContainerPoint(t.getSouthEast()).multiplyBy(-1).add(this._map.getSize())),this._viscosity=Math.min(1,Math.max(0,this._map.options.maxBoundsViscosity))):this._offsetLimit=null,e.fire("movestart").fire("dragstart"),e.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(t){var e,i;this._map.options.inertia&&(e=this._lastTime=+new Date,i=this._lastPos=this._draggable._absPos||this._draggable._newPos,this._positions.push(i),this._times.push(e),this._prunePositions(e)),this._map.fire("move",t).fire("drag",t)},_prunePositions:function(t){for(;1<this._positions.length&&50<t-this._times[0];)this._positions.shift(),this._times.shift()},_onZoomEnd:function(){var t=this._map.getSize().divideBy(2),e=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=e.subtract(t).x,this._worldWidth=this._map.getPixelWorldBounds().getSize().x},_viscousLimit:function(t,e){return t-(t-e)*this._viscosity},_onPreDragLimit:function(){var t,e;this._viscosity&&this._offsetLimit&&(t=this._draggable._newPos.subtract(this._draggable._startPos),e=this._offsetLimit,t.x<e.min.x&&(t.x=this._viscousLimit(t.x,e.min.x)),t.y<e.min.y&&(t.y=this._viscousLimit(t.y,e.min.y)),t.x>e.max.x&&(t.x=this._viscousLimit(t.x,e.max.x)),t.y>e.max.y&&(t.y=this._viscousLimit(t.y,e.max.y)),this._draggable._newPos=this._draggable._startPos.add(t))},_onPreDragWrap:function(){var t=this._worldWidth,e=Math.round(t/2),i=this._initialWorldOffset,n=this._draggable._newPos.x,o=(n-e+i)%t+e-i,n=(n+e+i)%t-e-i,t=Math.abs(o+i)<Math.abs(n+i)?o:n;this._draggable._absPos=this._draggable._newPos.clone(),this._draggable._newPos.x=t},_onDragEnd:function(t){var e,i,n,o,s=this._map,r=s.options,a=!r.inertia||t.noInertia||this._times.length<2;s.fire("dragend",t),!a&&(this._prunePositions(+new Date),t=this._lastPos.subtract(this._positions[0]),a=(this._lastTime-this._times[0])/1e3,e=r.easeLinearity,a=(t=t.multiplyBy(e/a)).distanceTo([0,0]),i=Math.min(r.inertiaMaxSpeed,a),t=t.multiplyBy(i/a),n=i/(r.inertiaDeceleration*e),(o=t.multiplyBy(-n/2).round()).x||o.y)?(o=s._limitOffset(o,s.options.maxBounds),x(function(){s.panBy(o,{duration:n,easeLinearity:e,noMoveStart:!0,animate:!0})})):s.fire("moveend")}})),St=(A.addInitHook("addHandler","dragging",Zt),A.mergeOptions({keyboard:!0,keyboardPanDelta:80}),n.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61,171],zoomOut:[189,109,54,173]},initialize:function(t){this._map=t,this._setPanDelta(t.options.keyboardPanDelta),this._setZoomDelta(t.options.zoomDelta)},addHooks:function(){var t=this._map._container;t.tabIndex<=0&&(t.tabIndex="0"),S(t,{focus:this._onFocus,blur:this._onBlur,mousedown:this._onMouseDown},this),this._map.on({focus:this._addHooks,blur:this._removeHooks},this)},removeHooks:function(){this._removeHooks(),k(this._map._container,{focus:this._onFocus,blur:this._onBlur,mousedown:this._onMouseDown},this),this._map.off({focus:this._addHooks,blur:this._removeHooks},this)},_onMouseDown:function(){var t,e,i;this._focused||(i=document.body,t=document.documentElement,e=i.scrollTop||t.scrollTop,i=i.scrollLeft||t.scrollLeft,this._map._container.focus(),window.scrollTo(i,e))},_onFocus:function(){this._focused=!0,this._map.fire("focus")},_onBlur:function(){this._focused=!1,this._map.fire("blur")},_setPanDelta:function(t){for(var e=this._panKeys={},i=this.keyCodes,n=0,o=i.left.length;n<o;n++)e[i.left[n]]=[-1*t,0];for(n=0,o=i.right.length;n<o;n++)e[i.right[n]]=[t,0];for(n=0,o=i.down.length;n<o;n++)e[i.down[n]]=[0,t];for(n=0,o=i.up.length;n<o;n++)e[i.up[n]]=[0,-1*t]},_setZoomDelta:function(t){for(var e=this._zoomKeys={},i=this.keyCodes,n=0,o=i.zoomIn.length;n<o;n++)e[i.zoomIn[n]]=t;for(n=0,o=i.zoomOut.length;n<o;n++)e[i.zoomOut[n]]=-t},_addHooks:function(){S(document,"keydown",this._onKeyDown,this)},_removeHooks:function(){k(document,"keydown",this._onKeyDown,this)},_onKeyDown:function(t){if(!(t.altKey||t.ctrlKey||t.metaKey)){var e,i,n=t.keyCode,o=this._map;if(n in this._panKeys)o._panAnim&&o._panAnim._inProgress||(i=this._panKeys[n],t.shiftKey&&(i=m(i).multiplyBy(3)),o.options.maxBounds&&(i=o._limitOffset(m(i),o.options.maxBounds)),o.options.worldCopyJump?(e=o.wrapLatLng(o.unproject(o.project(o.getCenter()).add(i))),o.panTo(e)):o.panBy(i));else if(n in this._zoomKeys)o.setZoom(o.getZoom()+(t.shiftKey?3:1)*this._zoomKeys[n]);else{if(27!==n||!o._popup||!o._popup.options.closeOnEscapeKey)return;o.closePopup()}Re(t)}}})),Et=(A.addInitHook("addHandler","keyboard",St),A.mergeOptions({scrollWheelZoom:!0,wheelDebounceTime:40,wheelPxPerZoomLevel:60}),n.extend({addHooks:function(){S(this._map._container,"wheel",this._onWheelScroll,this),this._delta=0},removeHooks:function(){k(this._map._container,"wheel",this._onWheelScroll,this)},_onWheelScroll:function(t){var e=He(t),i=this._map.options.wheelDebounceTime,e=(this._delta+=e,this._lastMousePos=this._map.mouseEventToContainerPoint(t),this._startTime||(this._startTime=+new Date),Math.max(i-(+new Date-this._startTime),0));clearTimeout(this._timer),this._timer=setTimeout(a(this._performZoom,this),e),Re(t)},_performZoom:function(){var t=this._map,e=t.getZoom(),i=this._map.options.zoomSnap||0,n=(t._stop(),this._delta/(4*this._map.options.wheelPxPerZoomLevel)),n=4*Math.log(2/(1+Math.exp(-Math.abs(n))))/Math.LN2,i=i?Math.ceil(n/i)*i:n,n=t._limitZoom(e+(0<this._delta?i:-i))-e;this._delta=0,this._startTime=null,n&&("center"===t.options.scrollWheelZoom?t.setZoom(e+n):t.setZoomAround(this._lastMousePos,e+n))}})),kt=(A.addInitHook("addHandler","scrollWheelZoom",Et),A.mergeOptions({tapHold:b.touchNative&&b.safari&&b.mobile,tapTolerance:15}),n.extend({addHooks:function(){S(this._map._container,"touchstart",this._onDown,this)},removeHooks:function(){k(this._map._container,"touchstart",this._onDown,this)},_onDown:function(t){var e;clearTimeout(this._holdTimeout),1===t.touches.length&&(e=t.touches[0],this._startPos=this._newPos=new p(e.clientX,e.clientY),this._holdTimeout=setTimeout(a(function(){this._cancel(),this._isTapValid()&&(S(document,"touchend",O),S(document,"touchend touchcancel",this._cancelClickPrevent),this._simulateEvent("contextmenu",e))},this),600),S(document,"touchend touchcancel contextmenu",this._cancel,this),S(document,"touchmove",this._onMove,this))},_cancelClickPrevent:function t(){k(document,"touchend",O),k(document,"touchend touchcancel",t)},_cancel:function(){clearTimeout(this._holdTimeout),k(document,"touchend touchcancel contextmenu",this._cancel,this),k(document,"touchmove",this._onMove,this)},_onMove:function(t){t=t.touches[0];this._newPos=new p(t.clientX,t.clientY)},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_simulateEvent:function(t,e){t=new MouseEvent(t,{bubbles:!0,cancelable:!0,view:window,screenX:e.screenX,screenY:e.screenY,clientX:e.clientX,clientY:e.clientY});t._simulated=!0,e.target.dispatchEvent(t)}})),Ot=(A.addInitHook("addHandler","tapHold",kt),A.mergeOptions({touchZoom:b.touch,bounceAtZoomLimits:!0}),n.extend({addHooks:function(){M(this._map._container,"leaflet-touch-zoom"),S(this._map._container,"touchstart",this._onTouchStart,this)},removeHooks:function(){z(this._map._container,"leaflet-touch-zoom"),k(this._map._container,"touchstart",this._onTouchStart,this)},_onTouchStart:function(t){var e,i,n=this._map;!t.touches||2!==t.touches.length||n._animatingZoom||this._zooming||(e=n.mouseEventToContainerPoint(t.touches[0]),i=n.mouseEventToContainerPoint(t.touches[1]),this._centerPoint=n.getSize()._divideBy(2),this._startLatLng=n.containerPointToLatLng(this._centerPoint),"center"!==n.options.touchZoom&&(this._pinchStartLatLng=n.containerPointToLatLng(e.add(i)._divideBy(2))),this._startDist=e.distanceTo(i),this._startZoom=n.getZoom(),this._moved=!1,this._zooming=!0,n._stop(),S(document,"touchmove",this._onTouchMove,this),S(document,"touchend touchcancel",this._onTouchEnd,this),O(t))},_onTouchMove:function(t){if(t.touches&&2===t.touches.length&&this._zooming){var e=this._map,i=e.mouseEventToContainerPoint(t.touches[0]),n=e.mouseEventToContainerPoint(t.touches[1]),o=i.distanceTo(n)/this._startDist;if(this._zoom=e.getScaleZoom(o,this._startZoom),!e.options.bounceAtZoomLimits&&(this._zoom<e.getMinZoom()&&o<1||this._zoom>e.getMaxZoom()&&1<o)&&(this._zoom=e._limitZoom(this._zoom)),"center"===e.options.touchZoom){if(this._center=this._startLatLng,1==o)return}else{i=i._add(n)._divideBy(2)._subtract(this._centerPoint);if(1==o&&0===i.x&&0===i.y)return;this._center=e.unproject(e.project(this._pinchStartLatLng,this._zoom).subtract(i),this._zoom)}this._moved||(e._moveStart(!0,!1),this._moved=!0),r(this._animRequest);n=a(e._move,e,this._center,this._zoom,{pinch:!0,round:!1},void 0);this._animRequest=x(n,this,!0),O(t)}},_onTouchEnd:function(){this._moved&&this._zooming?(this._zooming=!1,r(this._animRequest),k(document,"touchmove",this._onTouchMove,this),k(document,"touchend touchcancel",this._onTouchEnd,this),this._map.options.zoomAnimation?this._map._animateZoom(this._center,this._map._limitZoom(this._zoom),!0,this._map.options.zoomSnap):this._map._resetView(this._center,this._map._limitZoom(this._zoom))):this._zooming=!1}})),Xi=(A.addInitHook("addHandler","touchZoom",Ot),A.BoxZoom=_t,A.DoubleClickZoom=Ct,A.Drag=Zt,A.Keyboard=St,A.ScrollWheelZoom=Et,A.TapHold=kt,A.TouchZoom=Ot,t.Bounds=f,t.Browser=b,t.CRS=ot,t.Canvas=Fi,t.Circle=vi,t.CircleMarker=gi,t.Class=et,t.Control=B,t.DivIcon=Ri,t.DivOverlay=Ai,t.DomEvent=mt,t.DomUtil=pt,t.Draggable=Xe,t.Evented=it,t.FeatureGroup=ci,t.GeoJSON=wi,t.GridLayer=Ni,t.Handler=n,t.Icon=di,t.ImageOverlay=Ei,t.LatLng=v,t.LatLngBounds=s,t.Layer=o,t.LayerGroup=ui,t.LineUtil=vt,t.Map=A,t.Marker=mi,t.Mixin=ft,t.Path=fi,t.Point=p,t.PolyUtil=gt,t.Polygon=xi,t.Polyline=yi,t.Popup=Bi,t.PosAnimation=Fe,t.Projection=wt,t.Rectangle=Yi,t.Renderer=Wi,t.SVG=Gi,t.SVGOverlay=Oi,t.TileLayer=Di,t.Tooltip=Ii,t.Transformation=at,t.Util=tt,t.VideoOverlay=ki,t.bind=a,t.bounds=_,t.canvas=Ui,t.circle=function(t,e,i){return new vi(t,e,i)},t.circleMarker=function(t,e){return new gi(t,e)},t.control=Ue,t.divIcon=function(t){return new Ri(t)},t.extend=l,t.featureGroup=function(t,e){return new ci(t,e)},t.geoJSON=Si,t.geoJson=Mt,t.gridLayer=function(t){return new Ni(t)},t.icon=function(t){return new di(t)},t.imageOverlay=function(t,e,i){return new Ei(t,e,i)},t.latLng=w,t.latLngBounds=g,t.layerGroup=function(t,e){return new ui(t,e)},t.map=function(t,e){return new A(t,e)},t.marker=function(t,e){return new mi(t,e)},t.point=m,t.polygon=function(t,e){return new xi(t,e)},t.polyline=function(t,e){return new yi(t,e)},t.popup=function(t,e){return new Bi(t,e)},t.rectangle=function(t,e){return new Yi(t,e)},t.setOptions=c,t.stamp=h,t.svg=Ki,t.svgOverlay=function(t,e,i){return new Oi(t,e,i)},t.tileLayer=ji,t.tooltip=function(t,e){return new Ii(t,e)},t.transformation=ht,t.version="1.9.4",t.videoOverlay=function(t,e,i){return new ki(t,e,i)},window.L);t.noConflict=function(){return window.L=Xi,this},window.L=t});
    //# sourceMappingURL=leaflet.js.map
    
    </script>

    <script>
        // Fix Leaflet default marker icons with embedded base64 data URIs
        delete L.Icon.Default.prototype._getIconUrl;
        L.Icon.Default.mergeOptions({
            iconUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAFgUlEQVR4Aa1XA5BjWRTN2oW17d3YaZtr2962HUzbDNpjszW24mRt28p47v7zq/bXZtrp/lWnXr337j3nPCe85NcypgSFdugCpW5YoDAMRaIMqRi6aKq5E3YqDQO3qAwjVWrD8Ncq/RBpykd8oZUb/kaJutow8r1aP9II0WmLKLIsJyv1w/kqw9Ch2MYdB++12Onxee/QMwvf4/Dk/Lfp/i4nxTXtOoQ4pW5Aj7wpici1A9erdAN2OH64x8OSP9j3Ft3b7aWkTg/Fm91siTra0f9on5sQr9INejH6CUUUpavjFNq1B+Oadhxmnfa8RfEmN8VNAsQhPqF55xHkMzz3jSmChWU6f7/XZKNH+9+hBLOHYozuKQPxyMPUKkrX/K0uWnfFaJGS1QPRtZsOPtr3NsW0uyh6NNCOkU3Yz+bXbT3I8G3xE5EXLXtCXbbqwCO9zPQYPRTZ5vIDXD7U+w7rFDEoUUf7ibHIR4y6bLVPXrz8JVZEql13trxwue/uDivd3fkWRbS6/IA2bID4uk0UpF1N8qLlbBlXs4Ee7HLTfV1j54APvODnSfOWBqtKVvjgLKzF5YdEk5ewRkGlK0i33Eofffc7HT56jD7/6U+qH3Cx7SBLNntH5YIPvODnyfIXZYRVDPqgHtLs5ABHD3YzLuespb7t79FY34DjMwrVrcTuwlT55YMPvOBnRrJ4VXTdNnYug5ucHLBjEpt30701A3Ts+HEa73u6dT3FNWwflY86eMHPk+Yu+i6pzUpRrW7SNDg5JHR4KapmM5Wv2E8Tfcb1HoqqHMHU+uWDD7zg54mz5/2BSnizi9T1Dg4QQXLToGNCkb6tb1NU+QAlGr1++eADrzhn/u8Q2YZhQVlZ5+CAOtqfbhmaUCS1ezNFVm2imDbPmPng5wmz+gwh+oHDce0eUtQ6OGDIyR0uUhUsoO3vfDmmgOezH0mZN59x7MBi++WDL1g/eEiU3avlidO671bkLfwbw5XV2P8Pzo0ydy4t2/0eu33xYSOMOD8hTf4CrBtGMSoXfPLchX+J0ruSePw3LZeK0juPJbYzrhkH0io7B3k164hiGvawhOKMLkrQLyVpZg8rHFW7E2uHOL888IBPlNZ1FPzstSJM694fWr6RwpvcJK60+0HCILTBzZLFNdtAzJaohze60T8qBzyh5ZuOg5e7uwQppofEmf2++DYvmySqGBuKaicF1blQjhuHdvCIMvp8whTTfZzI7RldpwtSzL+F1+wkdZ2TBOW2gIF88PBTzD/gpeREAMEbxnJcaJHNHrpzji0gQCS6hdkEeYt9DF/2qPcEC8RM28Hwmr3sdNyht00byAut2k3gufWNtgtOEOFGUwcXWNDbdNbpgBGxEvKkOQsxivJx33iow0Vw5S6SVTrpVq11ysA2Rp7gTfPfktc6zhtXBBC+adRLshf6sG2RfHPZ5EAc4sVZ83yCN00Fk/4kggu40ZTvIEm5g24qtU4KjBrx/BTTH8ifVASAG7gKrnWxJDcU7x8X6Ecczhm3o6YicvsLXWfh3Ch1W0k8x0nXF+0fFxgt4phz8QvypiwCCFKMqXCnqXExjq10beH+UUA7+nG6mdG/Pu0f3LgFcGrl2s0kNNjpmoJ9o4B29CMO8dMT4Q5ox8uitF6fqsrJOr8qnwNbRzv6hSnG5wP+64C7h9lp30hKNtKdWjtdkbuPA19nJ7Tz3zR/ibgARbhb4AlhavcBebmTHcFl2fvYEnW0ox9xMxKBS8btJ+KiEbq9zA4RthQXDhPa0T9TEe69gWupwc6uBUphquXgf+/FrIjweHQS4/pduMe5ERUMHUd9xv8ZR98CxkS4F2n3EUrUZ10EYNw7BWm9x1GiPssi3GgiGRDKWRYZfXlON+dfNbM+GgIwYdwAAAAASUVORK5CYII=',
            iconRetinaUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAFgUlEQVR4Aa1XA5BjWRTN2oW17d3YaZtr2962HUzbDNpjszW24mRt28p47v7zq/bXZtrp/lWnXr337j3nPCe85NcypgSFdugCpW5YoDAMRaIMqRi6aKq5E3YqDQO3qAwjVWrD8Ncq/RBpykd8oZUb/kaJutow8r1aP9II0WmLKLIsJyv1w/kqw9Ch2MYdB++12Onxee/QMwvf4/Dk/Lfp/i4nxTXtOoQ4pW5Aj7wpici1A9erdAN2OH64x8OSP9j3Ft3b7aWkTg/Fm91siTra0f9on5sQr9INejH6CUUUpavjFNq1B+Oadhxmnfa8RfEmN8VNAsQhPqF55xHkMzz3jSmChWU6f7/XZKNH+9+hBLOHYozuKQPxyMPUKkrX/K0uWnfFaJGS1QPRtZsOPtr3NsW0uyh6NNCOkU3Yz+bXbT3I8G3xE5EXLXtCXbbqwCO9zPQYPRTZ5vIDXD7U+w7rFDEoUUf7ibHIR4y6bLVPXrz8JVZEql13trxwue/uDivd3fkWRbS6/IA2bID4uk0UpF1N8qLlbBlXs4Ee7HLTfV1j54APvODnSfOWBqtKVvjgLKzF5YdEk5ewRkGlK0i33Eofffc7HT56jD7/6U+qH3Cx7SBLNntH5YIPvODnyfIXZYRVDPqgHtLs5ABHD3YzLuespb7t79FY34DjMwrVrcTuwlT55YMPvOBnRrJ4VXTdNnYug5ucHLBjEpt30701A3Ts+HEa73u6dT3FNWwflY86eMHPk+Yu+i6pzUpRrW7SNDg5JHR4KapmM5Wv2E8Tfcb1HoqqHMHU+uWDD7zg54mz5/2BSnizi9T1Dg4QQXLToGNCkb6tb1NU+QAlGr1++eADrzhn/u8Q2YZhQVlZ5+CAOtqfbhmaUCS1ezNFVm2imDbPmPng5wmz+gwh+oHDce0eUtQ6OGDIyR0uUhUsoO3vfDmmgOezH0mZN59x7MBi++WDL1g/eEiU3avlidO671bkLfwbw5XV2P8Pzo0ydy4t2/0eu33xYSOMOD8hTf4CrBtGMSoXfPLchX+J0ruSePw3LZeK0juPJbYzrhkH0io7B3k164hiGvawhOKMLkrQLyVpZg8rHFW7E2uHOL888IBPlNZ1FPzstSJM694fWr6RwpvcJK60+0HCILTBzZLFNdtAzJaohze60T8qBzyh5ZuOg5e7uwQppofEmf2++DYvmySqGBuKaicF1blQjhuHdvCIMvp8whTTfZzI7RldpwtSzL+F1+wkdZ2TBOW2gIF88PBTzD/gpeREAMEbxnJcaJHNHrpzji0gQCS6hdkEeYt9DF/2qPcEC8RM28Hwmr3sdNyht00byAut2k3gufWNtgtOEOFGUwcXWNDbdNbpgBGxEvKkOQsxivJx33iow0Vw5S6SVTrpVq11ysA2Rp7gTfPfktc6zhtXBBC+adRLshf6sG2RfHPZ5EAc4sVZ83yCN00Fk/4kggu40ZTvIEm5g24qtU4KjBrx/BTTH8ifVASAG7gKrnWxJDcU7x8X6Ecczhm3o6YicvsLXWfh3Ch1W0k8x0nXF+0fFxgt4phz8QvypiwCCFKMqXCnqXExjq10beH+UUA7+nG6mdG/Pu0f3LgFcGrl2s0kNNjpmoJ9o4B29CMO8dMT4Q5ox8uitF6fqsrJOr8qnwNbRzv6hSnG5wP+64C7h9lp30hKNtKdWjtdkbuPA19nJ7Tz3zR/ibgARbhb4AlhavcBebmTHcFl2fvYEnW0ox9xMxKBS8btJ+KiEbq9zA4RthQXDhPa0T9TEe69gWupwc6uBUphquXgf+/FrIjweHQS4/pduMe5ERUMHUd9xv8ZR98CxkS4F2n3EUrUZ10EYNw7BWm9x1GiPssi3GgiGRDKWRYZfXlON+dfNbM+GgIwYdwAAAAASUVORK5CYII=',
            shadowUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAQAAAACach9AAACMUlEQVR4Ae3ShY7jQBAE0Aoz/f9/HTMzhg1zrdKUrJbdx+Kd2nD8VNudfsL/Th///dyQN2TH6f3y/BGpC379rV+S+qqetBOxImNQXL8JCAr2V4iMQXHGNJxeCfZXhSRBcQMfvkOWUdtfzlLgAENmZDcmo2TVmt8OSM2eXxBp3DjHSMFutqS7SbmemzBiR+xpKCNUIRkdkkYxhAkyGoBvyQFEJEefwSmmvBfJuJ6aKqKWnAkvGZOaZXTUgFqYULWNSHUckZuR1HIIimUExutRxwzOLROIG4vKmCKQt364mIlhSyzAf1m9lHZHJZrlAOMMztRRiKimp/rpdJDc9Awry5xTZCte7FHtuS8wJgeYGrex28xNTd086Dik7vUMscQOa8y4DoGtCCSkAKlNwpgNtphjrC6MIHUkR6YWxxs6Sc5xqn222mmCRFzIt8lEdKx+ikCtg91qS2WpwVfBelJCiQJwvzixfI9cxZQWgiSJelKnwBElKYtDOb2MFbhmUigbReQBV0Cg4+qMXSxXSyGUn4UbF8l+7qdSGnTC0XLCmahIgUHLhLOhpVCtw4CzYXvLQWQbJNmxoCsOKAxSgBJno75avolkRw8iIAFcsdc02e9iyCd8tHwmeSSoKTowIgvscSGZUOA7PuCN5b2BX9mQM7S0wYhMNU74zgsPBj3HU7wguAfnxxjFQGBE6pwN+GjME9zHY7zGp8wVxMShYX9NXvEWD3HbwJf4giO4CFIQxXScH1/TM+04kkBiAAAAAElFTkSuQmCC',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });
    </script>

    
    <!--
    ============================================================================
    Leaflet.markercluster Plugin - MIT License
    ============================================================================
    
    Copyright 2012 David Leaver
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
    ============================================================================
    -->
    <script>
    !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(((e=e||self).Leaflet=e.Leaflet||{},e.Leaflet.markercluster={}))}(this,function(e){"use strict";var t=L.MarkerClusterGroup=L.FeatureGroup.extend({options:{maxClusterRadius:80,iconCreateFunction:null,clusterPane:L.Marker.prototype.options.pane,spiderfyOnEveryZoom:!1,spiderfyOnMaxZoom:!0,showCoverageOnHover:!0,zoomToBoundsOnClick:!0,singleMarkerMode:!1,disableClusteringAtZoom:null,removeOutsideVisibleBounds:!0,animate:!0,animateAddingMarkers:!1,spiderfyShapePositions:null,spiderfyDistanceMultiplier:1,spiderLegPolylineOptions:{weight:1.5,color:"#222",opacity:.5},chunkedLoading:!1,chunkInterval:200,chunkDelay:50,chunkProgress:null,polygonOptions:{}},initialize:function(e){L.Util.setOptions(this,e),this.options.iconCreateFunction||(this.options.iconCreateFunction=this._defaultIconCreateFunction),this._featureGroup=L.featureGroup(),this._featureGroup.addEventParent(this),this._nonPointGroup=L.featureGroup(),this._nonPointGroup.addEventParent(this),this._inZoomAnimation=0,this._needsClustering=[],this._needsRemoving=[],this._currentShownBounds=null,this._queue=[],this._childMarkerEventHandlers={dragstart:this._childMarkerDragStart,move:this._childMarkerMoved,dragend:this._childMarkerDragEnd};var t=L.DomUtil.TRANSITION&&this.options.animate;L.extend(this,t?this._withAnimation:this._noAnimation),this._markerCluster=t?L.MarkerCluster:L.MarkerClusterNonAnimated},addLayer:function(e){if(e instanceof L.LayerGroup)return this.addLayers([e]);if(!e.getLatLng)return this._nonPointGroup.addLayer(e),this.fire("layeradd",{layer:e}),this;if(!this._map)return this._needsClustering.push(e),this.fire("layeradd",{layer:e}),this;if(this.hasLayer(e))return this;this._unspiderfy&&this._unspiderfy(),this._addLayer(e,this._maxZoom),this.fire("layeradd",{layer:e}),this._topClusterLevel._recalculateBounds(),this._refreshClustersIcons();var t=e,i=this._zoom;if(e.__parent)for(;t.__parent._zoom>=i;)t=t.__parent;return this._currentShownBounds.contains(t.getLatLng())&&(this.options.animateAddingMarkers?this._animationAddLayer(e,t):this._animationAddLayerNonAnimated(e,t)),this},removeLayer:function(e){return e instanceof L.LayerGroup?this.removeLayers([e]):(e.getLatLng?this._map?e.__parent&&(this._unspiderfy&&(this._unspiderfy(),this._unspiderfyLayer(e)),this._removeLayer(e,!0),this.fire("layerremove",{layer:e}),this._topClusterLevel._recalculateBounds(),this._refreshClustersIcons(),e.off(this._childMarkerEventHandlers,this),this._featureGroup.hasLayer(e)&&(this._featureGroup.removeLayer(e),e.clusterShow&&e.clusterShow())):(!this._arraySplice(this._needsClustering,e)&&this.hasLayer(e)&&this._needsRemoving.push({layer:e,latlng:e._latlng}),this.fire("layerremove",{layer:e})):(this._nonPointGroup.removeLayer(e),this.fire("layerremove",{layer:e})),this)},addLayers:function(n,s){if(!L.Util.isArray(n))return this.addLayer(n);var o,a=this._featureGroup,h=this._nonPointGroup,l=this.options.chunkedLoading,u=this.options.chunkInterval,_=this.options.chunkProgress,d=n.length,p=0,c=!0;if(this._map){var f=(new Date).getTime(),m=L.bind(function(){var e=(new Date).getTime();for(this._map&&this._unspiderfy&&this._unspiderfy();p<d;p++){if(l&&p%200==0){var t=(new Date).getTime()-e;if(u<t)break}if((o=n[p])instanceof L.LayerGroup)c&&(n=n.slice(),c=!1),this._extractNonGroupLayers(o,n),d=n.length;else if(o.getLatLng){if(!this.hasLayer(o)&&(this._addLayer(o,this._maxZoom),s||this.fire("layeradd",{layer:o}),o.__parent&&2===o.__parent.getChildCount())){var i=o.__parent.getAllChildMarkers(),r=i[0]===o?i[1]:i[0];a.removeLayer(r)}}else h.addLayer(o),s||this.fire("layeradd",{layer:o})}_&&_(p,d,(new Date).getTime()-f),p===d?(this._topClusterLevel._recalculateBounds(),this._refreshClustersIcons(),this._topClusterLevel._recursivelyAddChildrenToMap(null,this._zoom,this._currentShownBounds)):setTimeout(m,this.options.chunkDelay)},this);m()}else for(var e=this._needsClustering;p<d;p++)(o=n[p])instanceof L.LayerGroup?(c&&(n=n.slice(),c=!1),this._extractNonGroupLayers(o,n),d=n.length):o.getLatLng?this.hasLayer(o)||e.push(o):h.addLayer(o);return this},removeLayers:function(e){var t,i,r=e.length,n=this._featureGroup,s=this._nonPointGroup,o=!0;if(!this._map){for(t=0;t<r;t++)(i=e[t])instanceof L.LayerGroup?(o&&(e=e.slice(),o=!1),this._extractNonGroupLayers(i,e),r=e.length):(this._arraySplice(this._needsClustering,i),s.removeLayer(i),this.hasLayer(i)&&this._needsRemoving.push({layer:i,latlng:i._latlng}),this.fire("layerremove",{layer:i}));return this}if(this._unspiderfy){this._unspiderfy();var a=e.slice(),h=r;for(t=0;t<h;t++)(i=a[t])instanceof L.LayerGroup?(this._extractNonGroupLayers(i,a),h=a.length):this._unspiderfyLayer(i)}for(t=0;t<r;t++)(i=e[t])instanceof L.LayerGroup?(o&&(e=e.slice(),o=!1),this._extractNonGroupLayers(i,e),r=e.length):i.__parent?(this._removeLayer(i,!0,!0),this.fire("layerremove",{layer:i}),n.hasLayer(i)&&(n.removeLayer(i),i.clusterShow&&i.clusterShow())):(s.removeLayer(i),this.fire("layerremove",{layer:i}));return this._topClusterLevel._recalculateBounds(),this._refreshClustersIcons(),this._topClusterLevel._recursivelyAddChildrenToMap(null,this._zoom,this._currentShownBounds),this},clearLayers:function(){return this._map||(this._needsClustering=[],this._needsRemoving=[],delete this._gridClusters,delete this._gridUnclustered),this._noanimationUnspiderfy&&this._noanimationUnspiderfy(),this._featureGroup.clearLayers(),this._nonPointGroup.clearLayers(),this.eachLayer(function(e){e.off(this._childMarkerEventHandlers,this),delete e.__parent},this),this._map&&this._generateInitialClusters(),this},getBounds:function(){var e=new L.LatLngBounds;this._topClusterLevel&&e.extend(this._topClusterLevel._bounds);for(var t=this._needsClustering.length-1;0<=t;t--)e.extend(this._needsClustering[t].getLatLng());return e.extend(this._nonPointGroup.getBounds()),e},eachLayer:function(e,t){var i,r,n,s=this._needsClustering.slice(),o=this._needsRemoving;for(this._topClusterLevel&&this._topClusterLevel.getAllChildMarkers(s),r=s.length-1;0<=r;r--){for(i=!0,n=o.length-1;0<=n;n--)if(o[n].layer===s[r]){i=!1;break}i&&e.call(t,s[r])}this._nonPointGroup.eachLayer(e,t)},getLayers:function(){var t=[];return this.eachLayer(function(e){t.push(e)}),t},getLayer:function(t){var i=null;return t=parseInt(t,10),this.eachLayer(function(e){L.stamp(e)===t&&(i=e)}),i},hasLayer:function(e){if(!e)return!1;var t,i=this._needsClustering;for(t=i.length-1;0<=t;t--)if(i[t]===e)return!0;for(t=(i=this._needsRemoving).length-1;0<=t;t--)if(i[t].layer===e)return!1;return!(!e.__parent||e.__parent._group!==this)||this._nonPointGroup.hasLayer(e)},zoomToShowLayer:function(e,t){var i=this._map;"function"!=typeof t&&(t=function(){});var r=function(){!i.hasLayer(e)&&!i.hasLayer(e.__parent)||this._inZoomAnimation||(this._map.off("moveend",r,this),this.off("animationend",r,this),i.hasLayer(e)?t():e.__parent._icon&&(this.once("spiderfied",t,this),e.__parent.spiderfy()))};e._icon&&this._map.getBounds().contains(e.getLatLng())?t():e.__parent._zoom<Math.round(this._map._zoom)?(this._map.on("moveend",r,this),this._map.panTo(e.getLatLng())):(this._map.on("moveend",r,this),this.on("animationend",r,this),e.__parent.zoomToBounds())},onAdd:function(e){var t,i,r;if(this._map=e,!isFinite(this._map.getMaxZoom()))throw"Map has no maxZoom specified";for(this._featureGroup.addTo(e),this._nonPointGroup.addTo(e),this._gridClusters||this._generateInitialClusters(),this._maxLat=e.options.crs.projection.MAX_LATITUDE,t=0,i=this._needsRemoving.length;t<i;t++)(r=this._needsRemoving[t]).newlatlng=r.layer._latlng,r.layer._latlng=r.latlng;for(t=0,i=this._needsRemoving.length;t<i;t++)r=this._needsRemoving[t],this._removeLayer(r.layer,!0),r.layer._latlng=r.newlatlng;this._needsRemoving=[],this._zoom=Math.round(this._map._zoom),this._currentShownBounds=this._getExpandedVisibleBounds(),this._map.on("zoomend",this._zoomEnd,this),this._map.on("moveend",this._moveEnd,this),this._spiderfierOnAdd&&this._spiderfierOnAdd(),this._bindEvents(),i=this._needsClustering,this._needsClustering=[],this.addLayers(i,!0)},onRemove:function(e){e.off("zoomend",this._zoomEnd,this),e.off("moveend",this._moveEnd,this),this._unbindEvents(),this._map._mapPane.className=this._map._mapPane.className.replace(" leaflet-cluster-anim",""),this._spiderfierOnRemove&&this._spiderfierOnRemove(),delete this._maxLat,this._hideCoverage(),this._featureGroup.remove(),this._nonPointGroup.remove(),this._featureGroup.clearLayers(),this._map=null},getVisibleParent:function(e){for(var t=e;t&&!t._icon;)t=t.__parent;return t||null},_arraySplice:function(e,t){for(var i=e.length-1;0<=i;i--)if(e[i]===t)return e.splice(i,1),!0},_removeFromGridUnclustered:function(e,t){for(var i=this._map,r=this._gridUnclustered,n=Math.floor(this._map.getMinZoom());n<=t&&r[t].removeObject(e,i.project(e.getLatLng(),t));t--);},_childMarkerDragStart:function(e){e.target.__dragStart=e.target._latlng},_childMarkerMoved:function(e){if(!this._ignoreMove&&!e.target.__dragStart){var t=e.target._popup&&e.target._popup.isOpen();this._moveChild(e.target,e.oldLatLng,e.latlng),t&&e.target.openPopup()}},_moveChild:function(e,t,i){e._latlng=t,this.removeLayer(e),e._latlng=i,this.addLayer(e)},_childMarkerDragEnd:function(e){var t=e.target.__dragStart;delete e.target.__dragStart,t&&this._moveChild(e.target,t,e.target._latlng)},_removeLayer:function(e,t,i){var r=this._gridClusters,n=this._gridUnclustered,s=this._featureGroup,o=this._map,a=Math.floor(this._map.getMinZoom());t&&this._removeFromGridUnclustered(e,this._maxZoom);var h,l=e.__parent,u=l._markers;for(this._arraySplice(u,e);l&&(l._childCount--,l._boundsNeedUpdate=!0,!(l._zoom<a));)t&&l._childCount<=1?(h=l._markers[0]===e?l._markers[1]:l._markers[0],r[l._zoom].removeObject(l,o.project(l._cLatLng,l._zoom)),n[l._zoom].addObject(h,o.project(h.getLatLng(),l._zoom)),this._arraySplice(l.__parent._childClusters,l),l.__parent._markers.push(h),h.__parent=l.__parent,l._icon&&(s.removeLayer(l),i||s.addLayer(h))):l._iconNeedsUpdate=!0,l=l.__parent;delete e.__parent},_isOrIsParent:function(e,t){for(;t;){if(e===t)return!0;t=t.parentNode}return!1},fire:function(e,t,i){if(t&&t.layer instanceof L.MarkerCluster){if(t.originalEvent&&this._isOrIsParent(t.layer._icon,t.originalEvent.relatedTarget))return;e="cluster"+e}L.FeatureGroup.prototype.fire.call(this,e,t,i)},listens:function(e,t){return L.FeatureGroup.prototype.listens.call(this,e,t)||L.FeatureGroup.prototype.listens.call(this,"cluster"+e,t)},_defaultIconCreateFunction:function(e){var t=e.getChildCount(),i=" marker-cluster-";return i+=t<10?"small":t<100?"medium":"large",new L.DivIcon({html:"<div><span>"+t+"</span></div>",className:"marker-cluster"+i,iconSize:new L.Point(40,40)})},_bindEvents:function(){var e=this._map,t=this.options.spiderfyOnMaxZoom,i=this.options.showCoverageOnHover,r=this.options.zoomToBoundsOnClick,n=this.options.spiderfyOnEveryZoom;(t||r||n)&&this.on("clusterclick clusterkeypress",this._zoomOrSpiderfy,this),i&&(this.on("clustermouseover",this._showCoverage,this),this.on("clustermouseout",this._hideCoverage,this),e.on("zoomend",this._hideCoverage,this))},_zoomOrSpiderfy:function(e){var t=e.layer,i=t;if("clusterkeypress"!==e.type||!e.originalEvent||13===e.originalEvent.keyCode){for(;1===i._childClusters.length;)i=i._childClusters[0];i._zoom===this._maxZoom&&i._childCount===t._childCount&&this.options.spiderfyOnMaxZoom?t.spiderfy():this.options.zoomToBoundsOnClick&&t.zoomToBounds(),this.options.spiderfyOnEveryZoom&&t.spiderfy(),e.originalEvent&&13===e.originalEvent.keyCode&&this._map._container.focus()}},_showCoverage:function(e){var t=this._map;this._inZoomAnimation||(this._shownPolygon&&t.removeLayer(this._shownPolygon),2<e.layer.getChildCount()&&e.layer!==this._spiderfied&&(this._shownPolygon=new L.Polygon(e.layer.getConvexHull(),this.options.polygonOptions),t.addLayer(this._shownPolygon)))},_hideCoverage:function(){this._shownPolygon&&(this._map.removeLayer(this._shownPolygon),this._shownPolygon=null)},_unbindEvents:function(){var e=this.options.spiderfyOnMaxZoom,t=this.options.showCoverageOnHover,i=this.options.zoomToBoundsOnClick,r=this.options.spiderfyOnEveryZoom,n=this._map;(e||i||r)&&this.off("clusterclick clusterkeypress",this._zoomOrSpiderfy,this),t&&(this.off("clustermouseover",this._showCoverage,this),this.off("clustermouseout",this._hideCoverage,this),n.off("zoomend",this._hideCoverage,this))},_zoomEnd:function(){this._map&&(this._mergeSplitClusters(),this._zoom=Math.round(this._map._zoom),this._currentShownBounds=this._getExpandedVisibleBounds())},_moveEnd:function(){if(!this._inZoomAnimation){var e=this._getExpandedVisibleBounds();this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds,Math.floor(this._map.getMinZoom()),this._zoom,e),this._topClusterLevel._recursivelyAddChildrenToMap(null,Math.round(this._map._zoom),e),this._currentShownBounds=e}},_generateInitialClusters:function(){var e=Math.ceil(this._map.getMaxZoom()),t=Math.floor(this._map.getMinZoom()),i=this.options.maxClusterRadius,r=i;"function"!=typeof i&&(r=function(){return i}),null!==this.options.disableClusteringAtZoom&&(e=this.options.disableClusteringAtZoom-1),this._maxZoom=e,this._gridClusters={},this._gridUnclustered={};for(var n=e;t<=n;n--)this._gridClusters[n]=new L.DistanceGrid(r(n)),this._gridUnclustered[n]=new L.DistanceGrid(r(n));this._topClusterLevel=new this._markerCluster(this,t-1)},_addLayer:function(e,t){var i,r,n=this._gridClusters,s=this._gridUnclustered,o=Math.floor(this._map.getMinZoom());for(this.options.singleMarkerMode&&this._overrideMarkerIcon(e),e.on(this._childMarkerEventHandlers,this);o<=t;t--){i=this._map.project(e.getLatLng(),t);var a=n[t].getNearObject(i);if(a)return a._addChild(e),void(e.__parent=a);if(a=s[t].getNearObject(i)){var h=a.__parent;h&&this._removeLayer(a,!1);var l=new this._markerCluster(this,t,a,e);n[t].addObject(l,this._map.project(l._cLatLng,t)),a.__parent=l;var u=e.__parent=l;for(r=t-1;r>h._zoom;r--)u=new this._markerCluster(this,r,u),n[r].addObject(u,this._map.project(a.getLatLng(),r));return h._addChild(u),void this._removeFromGridUnclustered(a,t)}s[t].addObject(e,i)}this._topClusterLevel._addChild(e),e.__parent=this._topClusterLevel},_refreshClustersIcons:function(){this._featureGroup.eachLayer(function(e){e instanceof L.MarkerCluster&&e._iconNeedsUpdate&&e._updateIcon()})},_enqueue:function(e){this._queue.push(e),this._queueTimeout||(this._queueTimeout=setTimeout(L.bind(this._processQueue,this),300))},_processQueue:function(){for(var e=0;e<this._queue.length;e++)this._queue[e].call(this);this._queue.length=0,clearTimeout(this._queueTimeout),this._queueTimeout=null},_mergeSplitClusters:function(){var e=Math.round(this._map._zoom);this._processQueue(),this._zoom<e&&this._currentShownBounds.intersects(this._getExpandedVisibleBounds())?(this._animationStart(),this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds,Math.floor(this._map.getMinZoom()),this._zoom,this._getExpandedVisibleBounds()),this._animationZoomIn(this._zoom,e)):this._zoom>e?(this._animationStart(),this._animationZoomOut(this._zoom,e)):this._moveEnd()},_getExpandedVisibleBounds:function(){return this.options.removeOutsideVisibleBounds?L.Browser.mobile?this._checkBoundsMaxLat(this._map.getBounds()):this._checkBoundsMaxLat(this._map.getBounds().pad(1)):this._mapBoundsInfinite},_checkBoundsMaxLat:function(e){var t=this._maxLat;return void 0!==t&&(e.getNorth()>=t&&(e._northEast.lat=1/0),e.getSouth()<=-t&&(e._southWest.lat=-1/0)),e},_animationAddLayerNonAnimated:function(e,t){if(t===e)this._featureGroup.addLayer(e);else if(2===t._childCount){t._addToMap();var i=t.getAllChildMarkers();this._featureGroup.removeLayer(i[0]),this._featureGroup.removeLayer(i[1])}else t._updateIcon()},_extractNonGroupLayers:function(e,t){var i,r=e.getLayers(),n=0;for(t=t||[];n<r.length;n++)(i=r[n])instanceof L.LayerGroup?this._extractNonGroupLayers(i,t):t.push(i);return t},_overrideMarkerIcon:function(e){return e.options.icon=this.options.iconCreateFunction({getChildCount:function(){return 1},getAllChildMarkers:function(){return[e]}})}});L.MarkerClusterGroup.include({_mapBoundsInfinite:new L.LatLngBounds(new L.LatLng(-1/0,-1/0),new L.LatLng(1/0,1/0))}),L.MarkerClusterGroup.include({_noAnimation:{_animationStart:function(){},_animationZoomIn:function(e,t){this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds,Math.floor(this._map.getMinZoom()),e),this._topClusterLevel._recursivelyAddChildrenToMap(null,t,this._getExpandedVisibleBounds()),this.fire("animationend")},_animationZoomOut:function(e,t){this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds,Math.floor(this._map.getMinZoom()),e),this._topClusterLevel._recursivelyAddChildrenToMap(null,t,this._getExpandedVisibleBounds()),this.fire("animationend")},_animationAddLayer:function(e,t){this._animationAddLayerNonAnimated(e,t)}},_withAnimation:{_animationStart:function(){this._map._mapPane.className+=" leaflet-cluster-anim",this._inZoomAnimation++},_animationZoomIn:function(n,s){var o,a=this._getExpandedVisibleBounds(),h=this._featureGroup,e=Math.floor(this._map.getMinZoom());this._ignoreMove=!0,this._topClusterLevel._recursively(a,n,e,function(e){var t,i=e._latlng,r=e._markers;for(a.contains(i)||(i=null),e._isSingleParent()&&n+1===s?(h.removeLayer(e),e._recursivelyAddChildrenToMap(null,s,a)):(e.clusterHide(),e._recursivelyAddChildrenToMap(i,s,a)),o=r.length-1;0<=o;o--)t=r[o],a.contains(t._latlng)||h.removeLayer(t)}),this._forceLayout(),this._topClusterLevel._recursivelyBecomeVisible(a,s),h.eachLayer(function(e){e instanceof L.MarkerCluster||!e._icon||e.clusterShow()}),this._topClusterLevel._recursively(a,n,s,function(e){e._recursivelyRestoreChildPositions(s)}),this._ignoreMove=!1,this._enqueue(function(){this._topClusterLevel._recursively(a,n,e,function(e){h.removeLayer(e),e.clusterShow()}),this._animationEnd()})},_animationZoomOut:function(e,t){this._animationZoomOutSingle(this._topClusterLevel,e-1,t),this._topClusterLevel._recursivelyAddChildrenToMap(null,t,this._getExpandedVisibleBounds()),this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds,Math.floor(this._map.getMinZoom()),e,this._getExpandedVisibleBounds())},_animationAddLayer:function(e,t){var i=this,r=this._featureGroup;r.addLayer(e),t!==e&&(2<t._childCount?(t._updateIcon(),this._forceLayout(),this._animationStart(),e._setPos(this._map.latLngToLayerPoint(t.getLatLng())),e.clusterHide(),this._enqueue(function(){r.removeLayer(e),e.clusterShow(),i._animationEnd()})):(this._forceLayout(),i._animationStart(),i._animationZoomOutSingle(t,this._map.getMaxZoom(),this._zoom)))}},_animationZoomOutSingle:function(t,i,r){var n=this._getExpandedVisibleBounds(),s=Math.floor(this._map.getMinZoom());t._recursivelyAnimateChildrenInAndAddSelfToMap(n,s,i+1,r);var o=this;this._forceLayout(),t._recursivelyBecomeVisible(n,r),this._enqueue(function(){if(1===t._childCount){var e=t._markers[0];this._ignoreMove=!0,e.setLatLng(e.getLatLng()),this._ignoreMove=!1,e.clusterShow&&e.clusterShow()}else t._recursively(n,r,s,function(e){e._recursivelyRemoveChildrenFromMap(n,s,i+1)});o._animationEnd()})},_animationEnd:function(){this._map&&(this._map._mapPane.className=this._map._mapPane.className.replace(" leaflet-cluster-anim","")),this._inZoomAnimation--,this.fire("animationend")},_forceLayout:function(){L.Util.falseFn(document.body.offsetWidth)}}),L.markerClusterGroup=function(e){return new L.MarkerClusterGroup(e)};var i=L.MarkerCluster=L.Marker.extend({options:L.Icon.prototype.options,initialize:function(e,t,i,r){L.Marker.prototype.initialize.call(this,i?i._cLatLng||i.getLatLng():new L.LatLng(0,0),{icon:this,pane:e.options.clusterPane}),this._group=e,this._zoom=t,this._markers=[],this._childClusters=[],this._childCount=0,this._iconNeedsUpdate=!0,this._boundsNeedUpdate=!0,this._bounds=new L.LatLngBounds,i&&this._addChild(i),r&&this._addChild(r)},getAllChildMarkers:function(e,t){e=e||[];for(var i=this._childClusters.length-1;0<=i;i--)this._childClusters[i].getAllChildMarkers(e,t);for(var r=this._markers.length-1;0<=r;r--)t&&this._markers[r].__dragStart||e.push(this._markers[r]);return e},getChildCount:function(){return this._childCount},zoomToBounds:function(e){for(var t,i=this._childClusters.slice(),r=this._group._map,n=r.getBoundsZoom(this._bounds),s=this._zoom+1,o=r.getZoom();0<i.length&&s<n;){s++;var a=[];for(t=0;t<i.length;t++)a=a.concat(i[t]._childClusters);i=a}s<n?this._group._map.setView(this._latlng,s):n<=o?this._group._map.setView(this._latlng,o+1):this._group._map.fitBounds(this._bounds,e)},getBounds:function(){var e=new L.LatLngBounds;return e.extend(this._bounds),e},_updateIcon:function(){this._iconNeedsUpdate=!0,this._icon&&this.setIcon(this)},createIcon:function(){return this._iconNeedsUpdate&&(this._iconObj=this._group.options.iconCreateFunction(this),this._iconNeedsUpdate=!1),this._iconObj.createIcon()},createShadow:function(){return this._iconObj.createShadow()},_addChild:function(e,t){this._iconNeedsUpdate=!0,this._boundsNeedUpdate=!0,this._setClusterCenter(e),e instanceof L.MarkerCluster?(t||(this._childClusters.push(e),e.__parent=this),this._childCount+=e._childCount):(t||this._markers.push(e),this._childCount++),this.__parent&&this.__parent._addChild(e,!0)},_setClusterCenter:function(e){this._cLatLng||(this._cLatLng=e._cLatLng||e._latlng)},_resetBounds:function(){var e=this._bounds;e._southWest&&(e._southWest.lat=1/0,e._southWest.lng=1/0),e._northEast&&(e._northEast.lat=-1/0,e._northEast.lng=-1/0)},_recalculateBounds:function(){var e,t,i,r,n=this._markers,s=this._childClusters,o=0,a=0,h=this._childCount;if(0!==h){for(this._resetBounds(),e=0;e<n.length;e++)i=n[e]._latlng,this._bounds.extend(i),o+=i.lat,a+=i.lng;for(e=0;e<s.length;e++)(t=s[e])._boundsNeedUpdate&&t._recalculateBounds(),this._bounds.extend(t._bounds),i=t._wLatLng,r=t._childCount,o+=i.lat*r,a+=i.lng*r;this._latlng=this._wLatLng=new L.LatLng(o/h,a/h),this._boundsNeedUpdate=!1}},_addToMap:function(e){e&&(this._backupLatlng=this._latlng,this.setLatLng(e)),this._group._featureGroup.addLayer(this)},_recursivelyAnimateChildrenIn:function(e,n,t){this._recursively(e,this._group._map.getMinZoom(),t-1,function(e){var t,i,r=e._markers;for(t=r.length-1;0<=t;t--)(i=r[t])._icon&&(i._setPos(n),i.clusterHide())},function(e){var t,i,r=e._childClusters;for(t=r.length-1;0<=t;t--)(i=r[t])._icon&&(i._setPos(n),i.clusterHide())})},_recursivelyAnimateChildrenInAndAddSelfToMap:function(t,i,r,n){this._recursively(t,n,i,function(e){e._recursivelyAnimateChildrenIn(t,e._group._map.latLngToLayerPoint(e.getLatLng()).round(),r),e._isSingleParent()&&r-1===n?(e.clusterShow(),e._recursivelyRemoveChildrenFromMap(t,i,r)):e.clusterHide(),e._addToMap()})},_recursivelyBecomeVisible:function(e,t){this._recursively(e,this._group._map.getMinZoom(),t,null,function(e){e.clusterShow()})},_recursivelyAddChildrenToMap:function(r,n,s){this._recursively(s,this._group._map.getMinZoom()-1,n,function(e){if(n!==e._zoom)for(var t=e._markers.length-1;0<=t;t--){var i=e._markers[t];s.contains(i._latlng)&&(r&&(i._backupLatlng=i.getLatLng(),i.setLatLng(r),i.clusterHide&&i.clusterHide()),e._group._featureGroup.addLayer(i))}},function(e){e._addToMap(r)})},_recursivelyRestoreChildPositions:function(e){for(var t=this._markers.length-1;0<=t;t--){var i=this._markers[t];i._backupLatlng&&(i.setLatLng(i._backupLatlng),delete i._backupLatlng)}if(e-1===this._zoom)for(var r=this._childClusters.length-1;0<=r;r--)this._childClusters[r]._restorePosition();else for(var n=this._childClusters.length-1;0<=n;n--)this._childClusters[n]._recursivelyRestoreChildPositions(e)},_restorePosition:function(){this._backupLatlng&&(this.setLatLng(this._backupLatlng),delete this._backupLatlng)},_recursivelyRemoveChildrenFromMap:function(e,t,i,r){var n,s;this._recursively(e,t-1,i-1,function(e){for(s=e._markers.length-1;0<=s;s--)n=e._markers[s],r&&r.contains(n._latlng)||(e._group._featureGroup.removeLayer(n),n.clusterShow&&n.clusterShow())},function(e){for(s=e._childClusters.length-1;0<=s;s--)n=e._childClusters[s],r&&r.contains(n._latlng)||(e._group._featureGroup.removeLayer(n),n.clusterShow&&n.clusterShow())})},_recursively:function(e,t,i,r,n){var s,o,a=this._childClusters,h=this._zoom;if(t<=h&&(r&&r(this),n&&h===i&&n(this)),h<t||h<i)for(s=a.length-1;0<=s;s--)(o=a[s])._boundsNeedUpdate&&o._recalculateBounds(),e.intersects(o._bounds)&&o._recursively(e,t,i,r,n)},_isSingleParent:function(){return 0<this._childClusters.length&&this._childClusters[0]._childCount===this._childCount}});L.Marker.include({clusterHide:function(){var e=this.options.opacity;return this.setOpacity(0),this.options.opacity=e,this},clusterShow:function(){return this.setOpacity(this.options.opacity)}}),L.DistanceGrid=function(e){this._cellSize=e,this._sqCellSize=e*e,this._grid={},this._objectPoint={}},L.DistanceGrid.prototype={addObject:function(e,t){var i=this._getCoord(t.x),r=this._getCoord(t.y),n=this._grid,s=n[r]=n[r]||{},o=s[i]=s[i]||[],a=L.Util.stamp(e);this._objectPoint[a]=t,o.push(e)},updateObject:function(e,t){this.removeObject(e),this.addObject(e,t)},removeObject:function(e,t){var i,r,n=this._getCoord(t.x),s=this._getCoord(t.y),o=this._grid,a=o[s]=o[s]||{},h=a[n]=a[n]||[];for(delete this._objectPoint[L.Util.stamp(e)],i=0,r=h.length;i<r;i++)if(h[i]===e)return h.splice(i,1),1===r&&delete a[n],!0},eachObject:function(e,t){var i,r,n,s,o,a,h=this._grid;for(i in h)for(r in o=h[i])for(n=0,s=(a=o[r]).length;n<s;n++)e.call(t,a[n])&&(n--,s--)},getNearObject:function(e){var t,i,r,n,s,o,a,h,l=this._getCoord(e.x),u=this._getCoord(e.y),_=this._objectPoint,d=this._sqCellSize,p=null;for(t=u-1;t<=u+1;t++)if(n=this._grid[t])for(i=l-1;i<=l+1;i++)if(s=n[i])for(r=0,o=s.length;r<o;r++)a=s[r],((h=this._sqDist(_[L.Util.stamp(a)],e))<d||h<=d&&null===p)&&(d=h,p=a);return p},_getCoord:function(e){var t=Math.floor(e/this._cellSize);return isFinite(t)?t:e},_sqDist:function(e,t){var i=t.x-e.x,r=t.y-e.y;return i*i+r*r}},L.QuickHull={getDistant:function(e,t){var i=t[1].lat-t[0].lat;return(t[0].lng-t[1].lng)*(e.lat-t[0].lat)+i*(e.lng-t[0].lng)},findMostDistantPointFromBaseLine:function(e,t){var i,r,n,s=0,o=null,a=[];for(i=t.length-1;0<=i;i--)r=t[i],0<(n=this.getDistant(r,e))&&(a.push(r),s<n&&(s=n,o=r));return{maxPoint:o,newPoints:a}},buildConvexHull:function(e,t){var i=[],r=this.findMostDistantPointFromBaseLine(e,t);return r.maxPoint?i=(i=i.concat(this.buildConvexHull([e[0],r.maxPoint],r.newPoints))).concat(this.buildConvexHull([r.maxPoint,e[1]],r.newPoints)):[e[0]]},getConvexHull:function(e){var t,i=!1,r=!1,n=!1,s=!1,o=null,a=null,h=null,l=null,u=null,_=null;for(t=e.length-1;0<=t;t--){var d=e[t];(!1===i||d.lat>i)&&(i=(o=d).lat),(!1===r||d.lat<r)&&(r=(a=d).lat),(!1===n||d.lng>n)&&(n=(h=d).lng),(!1===s||d.lng<s)&&(s=(l=d).lng)}return u=r!==i?(_=a,o):(_=l,h),[].concat(this.buildConvexHull([_,u],e),this.buildConvexHull([u,_],e))}},L.MarkerCluster.include({getConvexHull:function(){var e,t,i=this.getAllChildMarkers(),r=[];for(t=i.length-1;0<=t;t--)e=i[t].getLatLng(),r.push(e);return L.QuickHull.getConvexHull(r)}}),L.MarkerCluster.include({_2PI:2*Math.PI,_circleFootSeparation:25,_circleStartAngle:0,_spiralFootSeparation:28,_spiralLengthStart:11,_spiralLengthFactor:5,_circleSpiralSwitchover:9,spiderfy:function(){if(this._group._spiderfied!==this&&!this._group._inZoomAnimation){var e,t=this.getAllChildMarkers(null,!0),i=this._group._map.latLngToLayerPoint(this._latlng);this._group._unspiderfy(),e=(this._group._spiderfied=this)._group.options.spiderfyShapePositions?this._group.options.spiderfyShapePositions(t.length,i):t.length>=this._circleSpiralSwitchover?this._generatePointsSpiral(t.length,i):(i.y+=10,this._generatePointsCircle(t.length,i)),this._animationSpiderfy(t,e)}},unspiderfy:function(e){this._group._inZoomAnimation||(this._animationUnspiderfy(e),this._group._spiderfied=null)},_generatePointsCircle:function(e,t){var i,r,n=this._group.options.spiderfyDistanceMultiplier*this._circleFootSeparation*(2+e)/this._2PI,s=this._2PI/e,o=[];for(n=Math.max(n,35),o.length=e,i=0;i<e;i++)r=this._circleStartAngle+i*s,o[i]=new L.Point(t.x+n*Math.cos(r),t.y+n*Math.sin(r))._round();return o},_generatePointsSpiral:function(e,t){var i,r=this._group.options.spiderfyDistanceMultiplier,n=r*this._spiralLengthStart,s=r*this._spiralFootSeparation,o=r*this._spiralLengthFactor*this._2PI,a=0,h=[];for(i=h.length=e;0<=i;i--)i<e&&(h[i]=new L.Point(t.x+n*Math.cos(a),t.y+n*Math.sin(a))._round()),n+=o/(a+=s/n+5e-4*i);return h},_noanimationUnspiderfy:function(){var e,t,i=this._group,r=i._map,n=i._featureGroup,s=this.getAllChildMarkers(null,!0);for(i._ignoreMove=!0,this.setOpacity(1),t=s.length-1;0<=t;t--)e=s[t],n.removeLayer(e),e._preSpiderfyLatlng&&(e.setLatLng(e._preSpiderfyLatlng),delete e._preSpiderfyLatlng),e.setZIndexOffset&&e.setZIndexOffset(0),e._spiderLeg&&(r.removeLayer(e._spiderLeg),delete e._spiderLeg);i.fire("unspiderfied",{cluster:this,markers:s}),i._ignoreMove=!1,i._spiderfied=null}}),L.MarkerClusterNonAnimated=L.MarkerCluster.extend({_animationSpiderfy:function(e,t){var i,r,n,s,o=this._group,a=o._map,h=o._featureGroup,l=this._group.options.spiderLegPolylineOptions;for(o._ignoreMove=!0,i=0;i<e.length;i++)s=a.layerPointToLatLng(t[i]),r=e[i],n=new L.Polyline([this._latlng,s],l),a.addLayer(n),r._spiderLeg=n,r._preSpiderfyLatlng=r._latlng,r.setLatLng(s),r.setZIndexOffset&&r.setZIndexOffset(1e6),h.addLayer(r);this.setOpacity(.3),o._ignoreMove=!1,o.fire("spiderfied",{cluster:this,markers:e})},_animationUnspiderfy:function(){this._noanimationUnspiderfy()}}),L.MarkerCluster.include({_animationSpiderfy:function(e,t){var i,r,n,s,o,a,h=this,l=this._group,u=l._map,_=l._featureGroup,d=this._latlng,p=u.latLngToLayerPoint(d),c=L.Path.SVG,f=L.extend({},this._group.options.spiderLegPolylineOptions),m=f.opacity;for(void 0===m&&(m=L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity),c?(f.opacity=0,f.className=(f.className||"")+" leaflet-cluster-spider-leg"):f.opacity=m,l._ignoreMove=!0,i=0;i<e.length;i++)r=e[i],a=u.layerPointToLatLng(t[i]),n=new L.Polyline([d,a],f),u.addLayer(n),r._spiderLeg=n,c&&(o=(s=n._path).getTotalLength()+.1,s.style.strokeDasharray=o,s.style.strokeDashoffset=o),r.setZIndexOffset&&r.setZIndexOffset(1e6),r.clusterHide&&r.clusterHide(),_.addLayer(r),r._setPos&&r._setPos(p);for(l._forceLayout(),l._animationStart(),i=e.length-1;0<=i;i--)a=u.layerPointToLatLng(t[i]),(r=e[i])._preSpiderfyLatlng=r._latlng,r.setLatLng(a),r.clusterShow&&r.clusterShow(),c&&((s=(n=r._spiderLeg)._path).style.strokeDashoffset=0,n.setStyle({opacity:m}));this.setOpacity(.3),l._ignoreMove=!1,setTimeout(function(){l._animationEnd(),l.fire("spiderfied",{cluster:h,markers:e})},200)},_animationUnspiderfy:function(e){var t,i,r,n,s,o,a=this,h=this._group,l=h._map,u=h._featureGroup,_=e?l._latLngToNewLayerPoint(this._latlng,e.zoom,e.center):l.latLngToLayerPoint(this._latlng),d=this.getAllChildMarkers(null,!0),p=L.Path.SVG;for(h._ignoreMove=!0,h._animationStart(),this.setOpacity(1),i=d.length-1;0<=i;i--)(t=d[i])._preSpiderfyLatlng&&(t.closePopup(),t.setLatLng(t._preSpiderfyLatlng),delete t._preSpiderfyLatlng,o=!0,t._setPos&&(t._setPos(_),o=!1),t.clusterHide&&(t.clusterHide(),o=!1),o&&u.removeLayer(t),p&&(s=(n=(r=t._spiderLeg)._path).getTotalLength()+.1,n.style.strokeDashoffset=s,r.setStyle({opacity:0})));h._ignoreMove=!1,setTimeout(function(){var e=0;for(i=d.length-1;0<=i;i--)(t=d[i])._spiderLeg&&e++;for(i=d.length-1;0<=i;i--)(t=d[i])._spiderLeg&&(t.clusterShow&&t.clusterShow(),t.setZIndexOffset&&t.setZIndexOffset(0),1<e&&u.removeLayer(t),l.removeLayer(t._spiderLeg),delete t._spiderLeg);h._animationEnd(),h.fire("unspiderfied",{cluster:a,markers:d})},200)}}),L.MarkerClusterGroup.include({_spiderfied:null,unspiderfy:function(){this._unspiderfy.apply(this,arguments)},_spiderfierOnAdd:function(){this._map.on("click",this._unspiderfyWrapper,this),this._map.options.zoomAnimation&&this._map.on("zoomstart",this._unspiderfyZoomStart,this),this._map.on("zoomend",this._noanimationUnspiderfy,this),L.Browser.touch||this._map.getRenderer(this)},_spiderfierOnRemove:function(){this._map.off("click",this._unspiderfyWrapper,this),this._map.off("zoomstart",this._unspiderfyZoomStart,this),this._map.off("zoomanim",this._unspiderfyZoomAnim,this),this._map.off("zoomend",this._noanimationUnspiderfy,this),this._noanimationUnspiderfy()},_unspiderfyZoomStart:function(){this._map&&this._map.on("zoomanim",this._unspiderfyZoomAnim,this)},_unspiderfyZoomAnim:function(e){L.DomUtil.hasClass(this._map._mapPane,"leaflet-touching")||(this._map.off("zoomanim",this._unspiderfyZoomAnim,this),this._unspiderfy(e))},_unspiderfyWrapper:function(){this._unspiderfy()},_unspiderfy:function(e){this._spiderfied&&this._spiderfied.unspiderfy(e)},_noanimationUnspiderfy:function(){this._spiderfied&&this._spiderfied._noanimationUnspiderfy()},_unspiderfyLayer:function(e){e._spiderLeg&&(this._featureGroup.removeLayer(e),e.clusterShow&&e.clusterShow(),e.setZIndexOffset&&e.setZIndexOffset(0),this._map.removeLayer(e._spiderLeg),delete e._spiderLeg)}}),L.MarkerClusterGroup.include({refreshClusters:function(e){return e?e instanceof L.MarkerClusterGroup?e=e._topClusterLevel.getAllChildMarkers():e instanceof L.LayerGroup?e=e._layers:e instanceof L.MarkerCluster?e=e.getAllChildMarkers():e instanceof L.Marker&&(e=[e]):e=this._topClusterLevel.getAllChildMarkers(),this._flagParentsIconsNeedUpdate(e),this._refreshClustersIcons(),this.options.singleMarkerMode&&this._refreshSingleMarkerModeMarkers(e),this},_flagParentsIconsNeedUpdate:function(e){var t,i;for(t in e)for(i=e[t].__parent;i;)i._iconNeedsUpdate=!0,i=i.__parent},_refreshSingleMarkerModeMarkers:function(e){var t,i;for(t in e)i=e[t],this.hasLayer(i)&&i.setIcon(this._overrideMarkerIcon(i))}}),L.Marker.include({refreshIconOptions:function(e,t){var i=this.options.icon;return L.setOptions(i,e),this.setIcon(i),t&&this.__parent&&this.__parent._group.refreshClusters(this),this}}),e.MarkerClusterGroup=t,e.MarkerCluster=i,Object.defineProperty(e,"__esModule",{value:!0})});
    //# sourceMappingURL=leaflet.markercluster.js.map
    </script>

    
    <script>
        // Global variables
        let map;
        let polygonLayer;
        let pointLayer;
        let pointMarkerLayer;
        let polygonMarkerLayer;
        let pointClusterGroup;
        let polygonClusterGroup;
        let combinedClusterGroup;
        let validationClusterGroup;
        let currentGeoJSON;
        let originalFilename; // Store the original loaded filename
        let baseLayers = {};
        let layerControl;
        let currentBaseLayer;
        let satelliteTooltip;
        let middlePanActive = false;
        
        // Global reporting interval (set on data load based on dataset size)
        let globalReportInterval = 50; // Default
        
        // Clustering configuration
        const CLUSTERING_LEVEL = 11;  // Zoom level below which clustering is applied
        const CLUSTERING_FEATURE_LIMIT = 500;  // Minimum features required for clustering
        
        // Track which features have validation errors for cluster coloring
        let featuresWithValidationErrors = new Set();
        let validationErrorNavigator = null; // Control for navigating between errors
        let currentValidationErrorIndex = 0; // Current position in error list
        
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
            // Force snap controls to defaults on fresh load
            if (typeof resetSnapControlsToDefaults === 'function') {
                resetSnapControlsToDefaults();
            }
            // Global Undo/Redo/Toggle (Ctrl/Cmd+Z/Y/Q)
            document.addEventListener('keydown', function(e){
                try {
                    const isInput = e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable);
                    if (isInput) return; // respect native text undo/redo
                    const key = (e.key || '').toLowerCase();
                    if ((e.ctrlKey || e.metaKey) && key === 'z') {
                        e.preventDefault();
                        undoLastChange();
                    } else if ((e.ctrlKey || e.metaKey) && key === 'y') {
                        e.preventDefault();
                        redoLastChange();
                    } else if ((e.ctrlKey || e.metaKey) && key === 'q') {
                        e.preventDefault();
                        toggleLastStep();
                    }
                } catch(_) {}
            }, true);
        });

        // Also reset when page is restored from bfcache or similar navigation
        window.addEventListener('pageshow', function() {
            if (typeof resetSnapControlsToDefaults === 'function') {
                resetSnapControlsToDefaults();
            }
        });

        function initializeApp() {
            initializeTranslations();
            const savedLanguage = localStorage.getItem('georoots-editor-language');
            const browserLanguage = navigator.language.split('-')[0];
            const defaultLanguage = savedLanguage || (translations[browserLanguage] ? browserLanguage : 'en');
            document.getElementById('languageSelect').value = defaultLanguage;
            changeLanguage(defaultLanguage);
            showWelcomeOverlay();
            initializeFileUpload();
        }

        function showWelcomeOverlay() {
            document.getElementById('welcomeOverlay').style.display = 'flex';
            document.getElementById('loadingOverlay').style.display = 'none';
        }
        
        function hideWelcomeOverlay() {
            document.getElementById('welcomeOverlay').style.display = 'none';
        }

        function getBaseLayers() {
            return {
                [getText('streetMap')]: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 22,
                    maxNativeZoom: 19,
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }),
                [getText('topoMap')]: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                    maxZoom: 22,
                    maxNativeZoom: 15,
                    attribution: '&copy; <a href="https://opentopomap.org">OpenTopoMap</a> contributors'
                }),
                [getText('satelliteLatest')]: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    maxZoom: 22,
                    maxNativeZoom: 18,
                    attribution: '&copy; <a href="https://www.esri.com">Esri</a>'
                }),
                [getText('satellite2020')]: L.tileLayer('https://wayback-b.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/WMTS/1.0.0/default028mm/MapServer/tile/29260/{z}/{y}/{x}', {
                    attribution: getText('esri2020Attribution'),
                    maxZoom: 22,
                    maxNativeZoom: 17,
                    tileSize: 256
                })
            };
        }
        function getOverlayMaps() {
            return {};
        }

        function initializeMap() {
            map = L.map('map', {
                center: [0, 0],
                zoom: 2,
                zoomControl: true,
                doubleClickZoom: false  // Disable double-click zoom permanently
            });
            baseLayers = getBaseLayers();
            // Add the first base layer to the map
            const firstBaseLayer = Object.values(baseLayers)[0];
            firstBaseLayer.addTo(map);
            currentBaseLayer = firstBaseLayer;
            polygonLayer = L.layerGroup().addTo(map);
            pointLayer = L.layerGroup().addTo(map);
            pointMarkerLayer = L.layerGroup().addTo(map);
            polygonMarkerLayer = L.layerGroup().addTo(map);
            
            // Initialize cluster groups for large datasets (1000+ features)
            // Combined cluster for zoom < 12 (both points and polygons together)
            combinedClusterGroup = L.markerClusterGroup({
                chunkedLoading: true,
                maxClusterRadius: 80,
                spiderfyOnMaxZoom: false,
                showCoverageOnHover: true,
                zoomToBoundsOnClick: true,
                iconCreateFunction: function(cluster) {
                    const childCount = cluster.getChildCount();
                    let className = 'marker-cluster-small';
                    if (childCount > 100) {
                        className = 'marker-cluster-large';
                    } else if (childCount > 20) {
                        className = 'marker-cluster-medium';
                    }
                    
                    return L.divIcon({
                        html: '<div><span>' + childCount + '</span></div>',
                        className: 'marker-cluster ' + className,
                        iconSize: L.point(40, 40)
                    });
                }
            });
            
            // Validation cluster group (red clusters if any child has validation errors)
            validationClusterGroup = L.markerClusterGroup({
                chunkedLoading: true,
                maxClusterRadius: 80,
                spiderfyOnMaxZoom: false,
                showCoverageOnHover: true,
                zoomToBoundsOnClick: true,
                iconCreateFunction: function(cluster) {
                    const childCount = cluster.getChildCount();
                    const markers = cluster.getAllChildMarkers();
                    
                    // Check if any marker in this cluster has validation errors
                    let hasErrors = false;
                    for (const marker of markers) {
                        if (marker.options && marker.options.validationError) {
                            hasErrors = true;
                            break;
                        }
                    }
                    
                    // Choose size class
                    let sizeClass = 'small';
                    if (childCount > 100) {
                        sizeClass = 'large';
                    } else if (childCount > 20) {
                        sizeClass = 'medium';
                    }
                    
                    // Choose color class based on validation status
                    const className = hasErrors ? 
                        'marker-cluster-validation-' + sizeClass : 
                        'marker-cluster-' + sizeClass;
                    
                    return L.divIcon({
                        html: '<div><span>' + childCount + '</span></div>',
                        className: 'marker-cluster ' + className,
                        iconSize: L.point(40, 40)
                    });
                }
            });
            
            const overlayMaps = getOverlayMaps();
            layerControl = L.control.layers(baseLayers, overlayMaps, { collapsed: false }).addTo(map);
            document.getElementById('editingControls').classList.remove('hidden');
            document.getElementById('mapLegend').classList.remove('hidden');
            document.getElementById('controlsToggle').classList.remove('hidden');
            
            // Initialize editing controls and legend
            initializeEditingControls();
            updateLegend();
            map.on('zoomend', updateLayersByZoom);
            map.on('baselayerchange', function(e) {
                currentBaseLayer = e.layer;
            });
            // Prevent any popup from remaining visible or opening while in Edit mode
            map.on('popupopen', function(ev){
                try {
                    if (currentMode === MODES.EDIT) {
                        if (map && typeof map.closePopup === 'function') map.closePopup(ev && ev.popup ? ev.popup : undefined);
                    }
                } catch(_) {}
            });
            document.getElementById('controlsToggle').addEventListener('click', function() {
                const legend = document.getElementById('mapLegend');
                const controls = document.getElementById('editingControls');
                const button = document.getElementById('controlsToggle');
                if (legend.classList.contains('hidden')) {
                    legend.classList.remove('hidden');
                    controls.classList.remove('hidden');
                    button.textContent = getText('hideControls');
                } else {
                    legend.classList.add('hidden');
                    controls.classList.add('hidden');
                    button.textContent = getText('showControls');
                }
            });

            // Coordinate display functionality
            const coordinateDisplay = document.getElementById('coordinate-display');
            map.on('mousemove', function(e) {
                const lat = e.latlng.lat.toFixed(6);
                const lng = e.latlng.lng.toFixed(6);
                coordinateDisplay.textContent = `Lat: ${lat}, Lon: ${lng}`;
                coordinateDisplay.style.display = 'block';
            });
            
            map.on('mouseout', function() {
                coordinateDisplay.style.display = 'none';
            });

            // Set up right-click to copy coordinates (always active, regardless of mode)
            map.on('contextmenu', function(e) {
                // Only handle right-click when not in polygon drawing mode
                if (currentTool !== EDIT_TOOLS.ADD_POLYGON) {
                    copyCoordinatesToClipboard(e.latlng.lat, e.latlng.lng);
                    L.DomEvent.preventDefault(e);
                }
            });

            // Map-level interactions are now handled by setupInteraction() function

        }


        function initializeFileUpload() {
            const dropArea = document.getElementById('fileDropArea');
            const fileInput = document.getElementById('fileInput');
            const fileSelectButton = document.getElementById('fileSelectButton');
            const startEmptyProjectButton = document.getElementById('startEmptyProjectButton');
            const welcomeOverlay = document.getElementById('welcomeOverlay');
            const loadingOverlay = document.getElementById('loadingOverlay');

            // File select button click
            fileSelectButton.addEventListener('click', function() {
                fileInput.click();
            });

            // File input change event
            fileInput.addEventListener('change', function() {
                if (this.files.length > 0) {
                    handleFile(this.files[0]);
                }
            });

            // Drag and drop events
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, unhighlight, false);
            });

            function highlight() {
                dropArea.classList.add('is-active');
            }

            function unhighlight() {
                dropArea.classList.remove('is-active');
            }

            // Handle dropped file
            dropArea.addEventListener('drop', function(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });


            // Handle the uploaded file
            function handleFile(file) {
                // Clear undo/redo stacks when loading new file
                __undoStack = [];
                __redoStack = [];
                
                // Store original filename (without extension)
                if (file && file.name) {
                    originalFilename = file.name.replace(/\.(geojson|json)$/i, '');
                }
                
                // Show loading overlay
                hideWelcomeOverlay();
                loadingOverlay.style.display = 'flex';
                // Initialize the map if not already done
                if (!map) {
                    initializeMap();
                }

                // Read the file
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const geoJSON = JSON.parse(e.target.result);
                        
                        // Check if Turf.js is loaded
                        if (typeof turf === 'undefined' || typeof turf.booleanValid !== 'function') {
                            console.error('Turf.js library is not loaded or booleanValid is not available');
                            showErrorNotification(getText('turfLoadFailed'), 'amber');
                            
                            // Process without validation
                        processGeoJSON(geoJSON);
                            loadingOverlay.style.display = 'none';
                            return;
                        }
                        
                        // Validate and clean the feature set
                        console.log('Validating and cleaning feature set...');
                        const { validFeatures, invalidFeatures } = validateFeatureSet(geoJSON);
                        
                        console.log(`Validation complete. Valid: ${validFeatures.length}, Invalid: ${invalidFeatures.length}`);
                        
                        // If there are invalid features, show the overlay
                        if (invalidFeatures.length > 0) {
                            loadingOverlay.style.display = 'none';
                            showInvalidFeaturesOverlay(invalidFeatures, validFeatures, geoJSON);
                        } else {
                            // Clean and truncate valid features to 8 decimals
                            const { cleanGeoJSON } = cleanFeatureSet(validFeatures);
                            
                            // Process GeoJSON data
                            processGeoJSON(cleanGeoJSON);
                        // Hide loading overlay
                        loadingOverlay.style.display = 'none';
                        }
                    } catch (error) {
                        showErrorNotification(getText('errorProcessingGeoJSON', error.message || error), 'red');
                        alert(getText('invalidGeoJSON'));
                        
                        // Show welcome overlay again on error
                        showWelcomeOverlay();
                        loadingOverlay.style.display = 'none';
                    }
                };
                reader.readAsText(file);
            }

            // Show invalid features overlay
            function showInvalidFeaturesOverlay(invalidFeatures, validFeatures, originalGeoJSON) {
                const overlay = document.getElementById('invalidFeaturesOverlay');
                const messageElement = document.getElementById('invalidFeaturesMessage');
                const downloadButton = document.getElementById('downloadInvalidFeatures');
                const continueButton = document.getElementById('continueWithValid');
                
                // Update message with count
                const message = getText('invalidFeaturesMessage').replace('{count}', invalidFeatures.length);
                messageElement.textContent = message;
                
                // Create download blob for invalid features
                const invalidGeoJSON = {
                    type: 'FeatureCollection',
                    features: invalidFeatures
                };
                const blob = new Blob([JSON.stringify(invalidGeoJSON, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                downloadButton.href = url;
                
                // Handle continue button
                continueButton.onclick = function() {
                    overlay.style.display = 'none';
                    URL.revokeObjectURL(url);
                    
                    // Clean and truncate valid features to 8 decimals
                    const { cleanGeoJSON, invalidFeatures: additionalInvalid } = cleanFeatureSet(validFeatures);
                    
                    if (additionalInvalid.length > 0) {
                        console.warn(`${additionalInvalid.length} additional features were filtered out during final cleaning`);
                    }
                    
                    // Process clean GeoJSON
                    processGeoJSON(cleanGeoJSON);
                };
                
                // Show the overlay
                overlay.style.display = 'flex';
            }

            // Start empty project: reveal map with no features
            startEmptyProjectButton.addEventListener('click', function(){
                try {
                    hideWelcomeOverlay();
                    if (!map) initializeMap();
                    // Clear original filename when starting empty project
                    originalFilename = undefined;
                    currentGeoJSON = { type: 'FeatureCollection', features: [] };
                    processGeoJSON(currentGeoJSON, true);
                } catch (err) { console.warn('Start empty project failed', err); }
            });
        }

        // ============================================================================
        // VALIDATION AND CLEANING CORE MODULE
        // ============================================================================

        /**
         * Validation Configuration - Defines validation stages and their dependencies
         */
        const VALIDATION_CONFIG = {
            stages: {
                fatalGeometry: { order: 1, level: 'fatal', dependencies: [], autoRunOnLoad: true },
                ringClosure: { order: 1.5, level: 'structural', dependencies: ['fatalGeometry'], fixingFn: 'closeUnclosedRings', mandatory: true },
                geometricValidity: { order: 1.8, level: 'structural', dependencies: ['fatalGeometry', 'ringClosure'], detectionFn: 'findGeometricallyInvalidFeatures' },
                duplicateVertices: { order: 1.9, level: 'structural', dependencies: ['fatalGeometry', 'ringClosure'], detectionFn: 'findDuplicateVertices', fixingFn: 'removeDuplicateVertices', mandatory: true },
                duplicates: { order: 2, level: 'structural', dependencies: ['fatalGeometry', 'ringClosure'], detectionFn: 'findDuplicateGeometries', fixingFn: 'removeDuplicateGeometries' },
                selfIntersections: { order: 3, level: 'structural', dependencies: ['fatalGeometry', 'ringClosure', 'duplicateVertices'], detectionFn: 'findSelfIntersections', fixingFn: 'fixSelfIntersections' },
                holes: { order: 4, level: 'quality', dependencies: ['fatalGeometry'], detectionFn: 'findPolygonsWithHoles', fixingFn: 'removeHoles' },
                slivers: { order: 5, level: 'quality', dependencies: ['fatalGeometry', 'selfIntersections'], detectionFn: 'findSharpAngles', fixingFn: 'removeSlivers' },
                overlaps: { order: 6, level: 'quality', dependencies: ['fatalGeometry', 'selfIntersections'], detectionFn: 'findOverlaps', fixingFn: 'removeOverlaps' },
                smallPolygons: { order: 7, level: 'quality', dependencies: ['fatalGeometry'], fixingFn: 'removeSmallPolygons' },
                pointsInPolygons: { order: 8, level: 'quality', dependencies: ['fatalGeometry'], fixingFn: 'removePointsInPolygons' },
                collinear: { order: 9, level: 'quality', dependencies: ['fatalGeometry'], fixingFn: 'removeCollinearPoints' }
            }
        };

        /** Progress Manager - Tracks progress across multiple stages */
        class ProgressManager {
            constructor(stages, progressCallback) {
                this.stages = stages;
                this.totalWeight = stages.reduce((sum, s) => sum + (s.weight || 1), 0);
                this.currentStageIndex = 0;
                this.progressCallback = progressCallback;
            }
            reportStageProgress(stageProgress, message) {
                const completedWeight = this.stages.slice(0, this.currentStageIndex).reduce((sum, s) => sum + (s.weight || 1), 0);
                const currentWeight = this.stages[this.currentStageIndex]?.weight || 1;
                const absoluteProgress = Math.round(((completedWeight + (stageProgress / 100) * currentWeight) / this.totalWeight) * 100);
                if (this.progressCallback) this.progressCallback(absoluteProgress, message);
            }
            nextStage() { this.currentStageIndex++; }
        }

        /** Extract all coordinates from any geometry type */
        function getAllCoordinatesFromGeometry(geometry) {
            const coords = [];
            if (!geometry || !geometry.type || !geometry.coordinates) return coords;
            function extract(arr, depth) {
                if (depth === 0) { if (Array.isArray(arr) && arr.length >= 2) coords.push(arr); }
                else if (Array.isArray(arr)) { for (const item of arr) extract(item, depth - 1); }
            }
            const depthMap = { 'Point': 0, 'LineString': 1, 'Polygon': 2, 'MultiPoint': 1, 'MultiLineString': 2, 'MultiPolygon': 3 };
            const depth = depthMap[geometry.type];
            if (depth !== undefined) extract(geometry.coordinates, depth);
            return coords;
        }

        /** Check if feature has fatal geometry issues */
        function hasFatalGeometryIssue(feature) {
            if (!feature || !feature.geometry || !feature.geometry.coordinates) return true;
            if (Array.isArray(feature.geometry.coordinates) && feature.geometry.coordinates.length === 0) return true;
            try {
                const coords = getAllCoordinatesFromGeometry(feature.geometry);
                if (coords.length === 0) return true;
                if (coords.length > 1) {
                    const first = coords[0];
                    if (coords.every(c => Math.abs(c[0] - first[0]) < 1e-12 && Math.abs(c[1] - first[1]) < 1e-12)) return true;
                }
                if (coords.some(c => !Array.isArray(c) || c.length < 2 || typeof c[0] !== 'number' || typeof c[1] !== 'number' || !isFinite(c[0]) || !isFinite(c[1]))) return true;
            } catch (e) { return true; }
                    return false;
                }
                
        /** Extract features from various input formats */
        function extractFeatures(input) {
            if (input && input.type === 'FeatureCollection' && Array.isArray(input.features)) return input.features;
            if (Array.isArray(input)) return input;
            if (input && input.geometry) return [input];
            return [];
        }

        /** Validate features for initial load (fatal geometry check only) */
        function validateFeatureSetForLoad(input) {
            const validFeatures = [], fatalFeatures = [];
            extractFeatures(input).forEach(feature => {
                if (hasFatalGeometryIssue(feature)) fatalFeatures.push(feature);
                else validFeatures.push(feature);
            });
            return { validFeatures, fatalFeatures };
        }

        /** Resolve stage order based on dependencies */
        function resolveStageOrder(requestedStages) {
            const config = VALIDATION_CONFIG.stages;
            return requestedStages.filter(name => config[name]).sort((a, b) => (config[a]?.order || 999) - (config[b]?.order || 999));
        }

        /** Check if stage can run */
        /**
         * Check if a validation stage can run based on its dependencies
         * @param {string} stageName - Name of the stage to check
         * @param {Object} results - Current pipeline results
         * @param {Object} options - Pipeline options
         * @returns {boolean} - True if stage can run
         */
        function canRunStage(stageName, results, options) {
            const stageConfig = VALIDATION_CONFIG.stages[stageName];
            if (!stageConfig) {
                console.warn(`Stage "${stageName}" not found in VALIDATION_CONFIG`);
                return false;
            }
            
            // Check dependencies
            for (const depName of stageConfig.dependencies) {
                if (depName === 'fatalGeometry') {
                    // Fatal geometry is always checked before pipeline starts
                    continue;
                }
                
                // Check if dependency stage has been run
                const depConfig = VALIDATION_CONFIG.stages[depName];
                
                // For structural dependencies required by quality stages
                if (depConfig && depConfig.level === 'structural' && stageConfig.level === 'quality') {
                    // If we're fixing, the dependency should have been satisfied by the fixing stage
                    if (options.fix) {
                        // Check if the dependency stage was actually run and fixed issues
                        if (results.issues[depName]) {
                            // Dependency was processed, we can proceed
                            continue;
                } else {
                            // Dependency wasn't run - this is OK, just means no issues were found
                            continue;
                        }
                    } else if (!options.fix) {
                        // Not fixing - detection functions must handle potentially invalid geometries
                        // Quality stages like overlaps/slivers use requireValidGeometry option
                        // to pre-filter invalid geometries during detection
                        continue;
                    }
                }
                
                // For same-level dependencies (e.g., structural->structural)
                if (depConfig && depConfig.level === stageConfig.level) {
                    // Just verify the dependency stage exists in config
                    continue;
                }
                
                // For any other dependency, allow it to run
                // The detection/fixing functions themselves handle edge cases
            }
            
            return true;
        }

        /** Run validation pipeline */
        async function runValidationPipeline(input, options = {}) {
            let requestedStages = options.stages || Object.keys(VALIDATION_CONFIG.stages).filter(k => k !== 'fatalGeometry');
            const shouldFix = options.fix || false;
            
            // When fixing, always include mandatory stages
            if (shouldFix) {
                const mandatoryStages = Object.keys(VALIDATION_CONFIG.stages)
                    .filter(key => VALIDATION_CONFIG.stages[key].mandatory);
                requestedStages = [...new Set([...mandatoryStages, ...requestedStages])];
            }
            
            const orderedStages = resolveStageOrder(requestedStages);
            const progressMgr = new ProgressManager(orderedStages.map(name => ({ name, weight: 1 })), options.progressCallback);
            let features = extractFeatures(input);
            const results = { features, issues: {} };
            for (const stageName of orderedStages) {
                const stageConfig = VALIDATION_CONFIG.stages[stageName];
                if (typeof __autoCleanCancelled !== 'undefined' && __autoCleanCancelled) throw new Error('Auto-Clean cancelled');
                if (typeof __validationCancelled !== 'undefined' && __validationCancelled) throw new Error('Validation cancelled');
                if (!canRunStage(stageName, results, options)) { progressMgr.nextStage(); continue; }
                if (stageConfig.detectionFn) {
                    const detectFn = window[stageConfig.detectionFn];
                    if (detectFn && typeof detectFn === 'function') {
                        const stageResults = await detectFn(results.features, (progress, msg) => progressMgr.reportStageProgress(progress, msg));
                        results.issues[stageName] = stageResults;
                    }
                }
                if (shouldFix && stageConfig.fixingFn) {
                    const fixFn = window[stageConfig.fixingFn];
                    if (fixFn && typeof fixFn === 'function') {
                        results.features = await fixFn(results.features, results.issues[stageName], (progress, msg) => progressMgr.reportStageProgress(progress, msg), options);
                    }
                }
                progressMgr.nextStage();
            }
            return results;
        }

        // ============================================================================
        // END VALIDATION AND CLEANING CORE MODULE
        // ============================================================================

        /**
         * Validates a single feature (now uses fatal geometry check only for load validation)
         * @param {Object} feature - GeoJSON feature to validate
         * @returns {boolean} - true if valid, false if invalid
         */
        function validateFeature(feature) {
            // Use the new fatal geometry check instead of strict turf.booleanValid
            // This allows features with fixable issues (like self-intersections) to load
            return !hasFatalGeometryIssue(feature);
        }
        
        /**
         * Validates a set of features (now uses fatal geometry check only for load validation)
         * @param {Object|Array} input - GeoJSON FeatureCollection or array of features
         * @returns {Object} - { validFeatures: [], invalidFeatures: [] }
         */
        function validateFeatureSet(input) {
            // Use the new load validation function that only filters fatal geometry issues
            const { validFeatures, fatalFeatures } = validateFeatureSetForLoad(input);
            return { validFeatures, invalidFeatures: fatalFeatures };
        }
        
        /**
         * Cleans and validates a feature set, truncating valid features to 8 decimals
         * @param {Object|Array} input - GeoJSON FeatureCollection or array of features
         * @returns {Object} - { cleanGeoJSON: FeatureCollection, invalidFeatures: [] }
         */
        function cleanFeatureSet(input) {
            // Validate the feature set
            const { validFeatures, invalidFeatures } = validateFeatureSet(input);
            
            // DO NOT truncate - preserve high-precision coordinates (10-12 decimals)
            // Duplicate detection/removal will work at 6 decimal precision while preserving original coords
            
            // Create clean GeoJSON FeatureCollection
            const cleanGeoJSON = {
                type: 'FeatureCollection',
                features: Array.isArray(validFeatures) ? validFeatures : [validFeatures]
            };
            
            return { cleanGeoJSON, invalidFeatures };
        }
        
        /**
         * Truncates all coordinates in a dataset to specified precision
         * @param {Object|Array} input - GeoJSON FeatureCollection, array of features, or single feature
         * @param {number} precision - Number of decimal places (default: 6)
         * @returns {Object|Array} - Truncated dataset in same format as input
         */
        function getDatasetAtPrecision(input, precision = 6) {
            // Handle null/undefined input
            if (!input) {
                console.warn('Invalid input to getDatasetAtPrecision');
                return input;
            }
            
            // Handle single feature
            if (input.type === 'Feature' && input.geometry) {
                try {
                    return turf.truncate(input, { precision: precision });
                } catch (err) {
                    console.warn('Could not truncate feature:', err);
                    return input;
                }
            }
            
            // Handle FeatureCollection
            if (input.type === 'FeatureCollection' && Array.isArray(input.features)) {
                const truncatedFeatures = input.features.map((feature, index) => {
                    try {
                        return turf.truncate(feature, { precision: precision });
                    } catch (err) {
                        console.warn(`Could not truncate feature ${index}:`, err);
                        return feature;
                    }
                });
                
                return {
                    type: 'FeatureCollection',
                    features: truncatedFeatures
                };
            }
            
            // Handle array of features
            if (Array.isArray(input)) {
                return input.map((feature, index) => {
                    try {
                        return turf.truncate(feature, { precision: precision });
                    } catch (err) {
                        console.warn(`Could not truncate feature ${index}:`, err);
                        return feature;
                    }
                });
            }
            
            // Handle geometry object
            if (input.type && input.coordinates) {
                try {
                    const tempFeature = turf.feature(input);
                    const truncated = turf.truncate(tempFeature, { precision: precision });
                    return truncated.geometry;
                } catch (err) {
                    console.warn('Could not truncate geometry:', err);
                    return input;
                }
            }
            
            console.warn('Unrecognized input format for getDatasetAtPrecision');
            return input;
        }
        
        /**
         * Round a coordinate pair [lng, lat] to specified precision using Turf.js
         * @param {Array} coord - [lng, lat]
         * @param {number} precision - Number of decimal places (default: 6)
         * @returns {Array} - Rounded [lng, lat]
         */
        function roundCoordinatePair(coord, precision = 6) {
            return [
                turf.round(coord[0], precision),
                turf.round(coord[1], precision)
            ];
        }
        
        /**
         * Find features with duplicate vertices after rounding to 6 decimals
         * Checks both consecutive and non-consecutive duplicate vertices
         * @param {Array|Object} input - Array of features or FeatureCollection
         * @param {Function} progressCallback - Optional callback for progress updates
         * @returns {Object} - { invalidFeatures: [{featureIndex, reason, duplicateType}] }
         */
        async function findDuplicateVertices(input, progressCallback = null) {
            const features = extractFeatures(input);
            const invalidFeatures = [];
            const total = features.length;
            
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                
                if (!feature || !feature.geometry) continue;
                
                const geomType = feature.geometry.type;
                
                // Only check Polygon and MultiPolygon
                if (geomType !== 'Polygon' && geomType !== 'MultiPolygon') continue;
                
                try {
                    let hasConsecutiveDuplicates = false;
                    let hasNonConsecutiveDuplicates = false;
                    
                    const checkRing = (ring, ringIndex = 0) => {
                        if (!ring || ring.length < 2) return;
                        
                        // Round all coordinates to 6 decimals
                        const roundedRing = ring.map(coord => roundCoordinatePair(coord, 6));
                        
                        // Check for consecutive duplicates
                        for (let j = 1; j < roundedRing.length; j++) {
                            const prev = roundedRing[j - 1];
                            const curr = roundedRing[j];
                            if (prev[0] === curr[0] && prev[1] === curr[1]) {
                                hasConsecutiveDuplicates = true;
                                break;
                            }
                        }
                        
                        // Check for non-consecutive duplicates
                        // Exclude the last coordinate (closing point) from this check
                        const bodyRing = roundedRing.slice(0, -1);
                        for (let j = 0; j < bodyRing.length; j++) {
                            for (let k = j + 2; k < bodyRing.length; k++) {
                                const coordJ = bodyRing[j];
                                const coordK = bodyRing[k];
                                if (coordJ[0] === coordK[0] && coordJ[1] === coordK[1]) {
                                    hasNonConsecutiveDuplicates = true;
                                    break;
                                }
                            }
                            if (hasNonConsecutiveDuplicates) break;
                        }
                    };
                    
                    if (geomType === 'Polygon') {
                        // Check all rings (outer + holes)
                        for (const ring of feature.geometry.coordinates) {
                            checkRing(ring);
                            if (hasConsecutiveDuplicates || hasNonConsecutiveDuplicates) break;
                        }
                    } else if (geomType === 'MultiPolygon') {
                        // Check all polygons and their rings, track which sub-polygons have issues
                        let subPolygonIndices = [];
                        for (let polyIdx = 0; polyIdx < feature.geometry.coordinates.length; polyIdx++) {
                            const polygon = feature.geometry.coordinates[polyIdx];
                            let polyHasIssues = false;
                            for (const ring of polygon) {
                                checkRing(ring);
                                if (hasConsecutiveDuplicates || hasNonConsecutiveDuplicates) {
                                    polyHasIssues = true;
                                    break;
                                }
                            }
                            if (polyHasIssues) {
                                subPolygonIndices.push(polyIdx);
                            }
                        }
                        // Store sub-polygon indices for later use
                        if (subPolygonIndices.length > 0) {
                            feature.__subPolygonIndicesWithDuplicates = subPolygonIndices;
                        }
                    }
                    
                    // Flag the feature if duplicates found
                    if (hasConsecutiveDuplicates && hasNonConsecutiveDuplicates) {
                        invalidFeatures.push({
                            featureIndex: i,
                            reason: 'Consecutive and non-consecutive duplicate vertices after rounding to 6 decimals',
                            duplicateType: 'both',
                            subPolygonIndices: feature.__subPolygonIndicesWithDuplicates || null
                        });
                    } else if (hasConsecutiveDuplicates) {
                        invalidFeatures.push({
                            featureIndex: i,
                            reason: 'Consecutive duplicate vertices after rounding to 6 decimals',
                            duplicateType: 'consecutive',
                            subPolygonIndices: feature.__subPolygonIndicesWithDuplicates || null
                        });
                    } else if (hasNonConsecutiveDuplicates) {
                        invalidFeatures.push({
                            featureIndex: i,
                            reason: 'Non-consecutive duplicate vertices (overlapping sides) after rounding to 6 decimals',
                            duplicateType: 'non-consecutive',
                            subPolygonIndices: feature.__subPolygonIndicesWithDuplicates || null
                        });
                    }
                    
                    // Clean up temporary property
                    if (feature.__subPolygonIndicesWithDuplicates) {
                        delete feature.__subPolygonIndicesWithDuplicates;
                    }
                } catch (e) {
                    console.warn(`Error checking duplicate vertices for feature ${i}:`, e);
                }
                
                // Report progress
                if (i % globalReportInterval === 0 || i === total - 1) {
                    if (progressCallback) {
                        const progress = Math.round(((i + 1) / total) * 100);
                        progressCallback(progress, `Checking duplicate vertices: feature ${i + 1} of ${total}...`);
                    }
                    if (typeof __validationCancelled !== 'undefined' && __validationCancelled) break;
                    await delay(0);
                }
            }
            
            if (progressCallback) {
                const message = invalidFeatures.length > 0
                    ? `Duplicate vertex check completed: ${invalidFeatures.length} features with duplicates found`
                    : 'No duplicate vertices found';
                progressCallback(100, message);
            }
            
            return { invalidFeatures };
        }
        
        /**
         * Find geometrically invalid features using Turf.js validation
         * @param {Array|Object} input - Array of features or FeatureCollection
         * @param {Function} progressCallback - Optional callback for progress updates
         * @returns {Object} - { invalidFeatures: [{featureIndex, reason}] }
         */
        async function findGeometricallyInvalidFeatures(input, progressCallback = null) {
            const features = extractFeatures(input);
            const invalidFeatures = [];
            const total = features.length;
            
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                
                if (!feature || !feature.geometry) {
                    invalidFeatures.push({
                        featureIndex: i,
                        reason: 'Missing geometry'
                    });
                } else {
                    try {
                        const geomType = feature.geometry.type;
                        
                        // Check for EUDR unsupported geometry types
                        const supportedTypes = ['Point', 'MultiPoint', 'Polygon', 'MultiPolygon'];
                        if (!supportedTypes.includes(geomType)) {
                            invalidFeatures.push({
                                featureIndex: i,
                                reason: 'EUDR unsupported geometry'
                            });
                            continue; // Skip further validation for unsupported types
                        }
                        
                        // Check if geometry is valid according to Turf.js
                        if (typeof turf !== 'undefined' && typeof turf.booleanValid === 'function') {
                            let isValid = true;
                            
                            // For MultiPolygon, check each sub-polygon individually
                            // to avoid false positives from sub-polygons sharing vertices
                            if (geomType === 'MultiPolygon') {
                                const coords = feature.geometry.coordinates;
                                for (let polyIndex = 0; polyIndex < coords.length; polyIndex++) {
                                    const subPolygon = {
                                        type: 'Feature',
                                        geometry: {
                                            type: 'Polygon',
                                            coordinates: coords[polyIndex]
                                        },
                                        properties: {}
                                    };
                                    
                                    if (!turf.booleanValid(subPolygon)) {
                                        isValid = false;
                                        break;
                                    }
                                }
                            } else {
                                // For other geometry types, check as-is
                                isValid = turf.booleanValid(feature);
                            }
                            
                            if (!isValid) {
                                invalidFeatures.push({
                                    featureIndex: i,
                                    reason: 'Invalid geometry structure'
                                });
                            }
                        }
                    } catch (e) {
                        invalidFeatures.push({
                            featureIndex: i,
                            reason: `Validation error: ${e.message}`
                        });
                    }
                }
                
                // Report progress
                if (i % globalReportInterval === 0) {
                    if (progressCallback) {
                        const progress = Math.round((i / total) * 100);
                        progressCallback(progress, `Checking geometric validity: feature ${i + 1} of ${total}...`);
                    }
                    if (typeof __validationCancelled !== 'undefined' && __validationCancelled) break;
                    await delay(0);
                }
            }
            
            if (progressCallback) {
                const message = invalidFeatures.length > 0
                    ? `Geometric validity check completed: ${invalidFeatures.length} invalid features found`
                    : 'All features are geometrically valid';
                progressCallback(100, message);
            }
            
            return { invalidFeatures };
        }
        
        /**
         * Finds and removes duplicate features based on geometry using RBush spatial index
         * Features are truncated to 6 decimals for comparison
         * @param {Object|Array} input - GeoJSON FeatureCollection or array of features
         * @param {Function} progressCallback - Optional callback for progress updates
         * @returns {Object} - { uniqueFeatures: [], duplicateFeatures: [] }
         */
        async function findDuplicates(input, progressCallback = null) {
            const uniqueFeatures = [];
            const duplicateFeatures = []; // Will store { feature, featureIndex }
            
            // Handle both FeatureCollection and array of features
            let features = [];
            if (input && input.type === 'FeatureCollection' && Array.isArray(input.features)) {
                features = input.features;
            } else if (Array.isArray(input)) {
                features = input;
            } else if (input && input.geometry) {
                // Single feature - no duplicates possible
                return { uniqueFeatures: [input], duplicateFeatures: [] };
            } else {
                console.warn('Invalid input to findDuplicates');
                return { uniqueFeatures: [], duplicateFeatures: [] };
            }
            
            const totalFeatures = features.length;
            
            // Truncate all features to 6 decimals for comparison
            const truncatedDataset = getDatasetAtPrecision(features, 6);
            const truncatedArray = Array.isArray(truncatedDataset) ? truncatedDataset : [truncatedDataset];
            
            const truncatedForComparison = features.map((feature, index) => ({
                original: feature,
                truncated: truncatedArray[index] || feature,
                index: index
            }));
            
            // Create RBush spatial index for efficient spatial queries
            const spatialIndex = new RBush();
            
            for (let i = 0; i < truncatedForComparison.length; i++) {
                const item = truncatedForComparison[i];
                const feature = item.truncated;
                
                if (!feature || !feature.geometry) {
                    // Keep features without geometry as unique (they'll be filtered elsewhere)
                    uniqueFeatures.push(item.original);
                    continue;
                }
                
                let isDuplicate = false;
                
                try {
                    // Get bounding box of current feature
                    const bbox = turf.bbox(feature);
                    
                    // Search for features with overlapping bounding boxes
                    const candidates = spatialIndex.search({
                        minX: bbox[0],
                        minY: bbox[1],
                        maxX: bbox[2],
                        maxY: bbox[3]
                    });
                    
                    // Only check against spatially nearby features
                    for (const candidate of candidates) {
                        try {
                            // Use turf.booleanEqual to compare geometries
                            if (turf.booleanEqual(feature.geometry, candidate.feature.geometry)) {
                                isDuplicate = true;
                                // Mark BOTH features as duplicates
                                duplicateFeatures.push({ feature: item.original, featureIndex: item.index });
                                // Also mark the candidate (the feature already in the index) as duplicate
                                if (!duplicateFeatures.find(d => d.featureIndex === candidate.featureIndex)) {
                                    duplicateFeatures.push({ feature: candidate.originalFeature, featureIndex: candidate.featureIndex });
                                }
                                break;
                            }
                        } catch (err) {
                            // If comparison fails, assume not duplicate
                            continue;
                        }
                    }
                    
                    if (!isDuplicate) {
                        // Add to spatial index and unique features
                        // RBush requires objects with minX, minY, maxX, maxY properties
                        spatialIndex.insert({
                            minX: bbox[0],
                            minY: bbox[1],
                            maxX: bbox[2],
                            maxY: bbox[3],
                            feature: feature,
                            originalFeature: item.original,
                            featureIndex: item.index
                        });
                        uniqueFeatures.push(item.original);
                    }
                } catch (err) {
                    // If spatial operations fail, keep as unique
                    console.warn(`Spatial operation failed for feature ${i}:`, err);
                    uniqueFeatures.push(item.original);
                }
                
                // Yield control to keep UI responsive
                if (i % globalReportInterval === 0) {
                    if (progressCallback) {
                        const progress = Math.round((i / totalFeatures) * 100);
                        const message = getText('deduplicatingProgress', i + 1, totalFeatures);
                        progressCallback(progress, message);
                    }
                    if (typeof __validationCancelled !== 'undefined' && __validationCancelled) break;
                    await delay(0);
                }
            }
            
            if (progressCallback) {
                const completionMessage = getText('deduplicatingCompleted', duplicateFeatures.length);
                progressCallback(100, completionMessage);
            }
            
            return { uniqueFeatures, duplicateFeatures };
        }

        /**
         * Find duplicate geometries - both entire features and individual points
         * @param {Object|Array} input - GeoJSON FeatureCollection or array of features
         * @param {Function} progressCallback - Optional callback for progress updates
         * @returns {Object} - { uniqueFeatures, duplicateFeatures, duplicatePointFeatures }
         */
        async function findDuplicateGeometries(input, progressCallback = null) {
            // Run detection for whole features
            const featureDuplicates = await findDuplicates(input, progressCallback ? (prog, msg) => progressCallback(prog * 0.4, msg) : null);
            
            // Run detection for individual points
            const pointDuplicates = await findDuplicatePoints(input, progressCallback ? (prog, msg) => progressCallback(40 + prog * 0.3, msg) : null);
            
            // Run detection for sub-polygons within MultiPolygons
            const subPolygonDuplicates = await findDuplicateSubPolygons(input, progressCallback ? (prog, msg) => progressCallback(70 + prog * 0.3, msg) : null);
            
            // Combine all duplicate features (but deduplicate the list)
            const allDuplicates = [...featureDuplicates.duplicateFeatures, ...subPolygonDuplicates];
            
            return {
                uniqueFeatures: featureDuplicates.uniqueFeatures,
                duplicateFeatures: allDuplicates,
                duplicatePointFeatures: pointDuplicates.duplicatePointFeatures
            };
        }
        
        /**
         * Find duplicate sub-polygons (check if sub-polygons from MultiPolygons duplicate standalone Polygons or other sub-polygons)
         * @param {Object|Array} input - GeoJSON FeatureCollection or array of features
         * @param {Function} progressCallback - Optional callback for progress updates
         * @returns {Array} - Array of duplicate items like findDuplicates
         */
        async function findDuplicateSubPolygons(input, progressCallback = null) {
            // Handle both FeatureCollection and array of features
            let features = [];
            if (input && input.type === 'FeatureCollection' && Array.isArray(input.features)) {
                features = input.features;
            } else if (Array.isArray(input)) {
                features = input;
            } else {
                return [];
            }
            
            const duplicates = [];
            const seenPolygons = new Map(); // coordString -> {featureIndex, polyIndex}
            
            // Truncate to 6 decimals for comparison
            const truncatedDataset = getDatasetAtPrecision(features, 6);
            const truncatedArray = Array.isArray(truncatedDataset) ? truncatedDataset : [truncatedDataset];
            
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                const truncatedFeature = truncatedArray[i] || feature;
                
                if (!feature || !feature.geometry) continue;
                
                const geomType = feature.geometry.type;
                
                if (geomType === 'Polygon') {
                    // Check if this Polygon duplicates any already seen
                    const coordString = JSON.stringify(truncatedFeature.geometry.coordinates);
                    if (seenPolygons.has(coordString)) {
                        // This is a duplicate (explicitly set polyIndex to null for standalone Polygons)
                        duplicates.push({ feature: feature, featureIndex: i, polyIndex: null });
                        // Also mark the original
                        const original = seenPolygons.get(coordString);
                        if (!duplicates.find(d => d.featureIndex === original.featureIndex && d.polyIndex === original.polyIndex)) {
                            duplicates.push({ feature: features[original.featureIndex], featureIndex: original.featureIndex, polyIndex: original.polyIndex });
                        }
                    } else {
                        seenPolygons.set(coordString, { featureIndex: i, polyIndex: null });
                    }
                } else if (geomType === 'MultiPolygon') {
                    // Check each sub-polygon
                    for (let polyIdx = 0; polyIdx < feature.geometry.coordinates.length; polyIdx++) {
                        const subPolyString = JSON.stringify(truncatedFeature.geometry.coordinates[polyIdx]);
                        
                        if (seenPolygons.has(subPolyString)) {
                            // This sub-polygon is a duplicate
                            duplicates.push({ feature: feature, featureIndex: i, polyIndex: polyIdx });
                            // Also mark the original
                            const original = seenPolygons.get(subPolyString);
                            if (!duplicates.find(d => d.featureIndex === original.featureIndex && 
                                                      (original.polyIndex === null || d.polyIndex === original.polyIndex))) {
                                duplicates.push({ feature: features[original.featureIndex], featureIndex: original.featureIndex, polyIndex: original.polyIndex });
                            }
                        } else {
                            seenPolygons.set(subPolyString, { featureIndex: i, polyIndex: polyIdx });
                        }
                    }
                }
                
                // Report progress
                if (i % globalReportInterval === 0 || i === features.length - 1) {
                    if (progressCallback) {
                        const progress = Math.round(((i + 1) / features.length) * 100);
                        progressCallback(progress, `Checking sub-polygons: ${i + 1} of ${features.length}...`);
                    }
                    await delay(0);
                }
            }
            
            if (progressCallback) {
                const message = duplicates.length > 0
                    ? `Sub-polygon check completed: ${duplicates.length} duplicate sub-polygons found`
                    : 'No duplicate sub-polygons found';
                progressCallback(100, message);
            }
            
            return duplicates;
        }

        /**
         * Find duplicate individual points within and across Point/MultiPoint features
         * @param {Object|Array} input - GeoJSON FeatureCollection or array of features
         * @param {Function} progressCallback - Optional callback for progress updates
         * @returns {Object} - { duplicatePointFeatures: [{featureIndex, pointIndices, duplicateOf}] }
         */
        async function findDuplicatePoints(input, progressCallback = null) {
            const duplicatePointFeatures = [];
            
            // Handle both FeatureCollection and array of features
            let features = [];
            if (input && input.type === 'FeatureCollection' && Array.isArray(input.features)) {
                features = input.features;
            } else if (Array.isArray(input)) {
                features = input;
            } else if (input && input.geometry) {
                features = [input];
            } else {
                console.warn('Invalid input to findDuplicatePoints');
                return { duplicatePointFeatures: [] };
            }
            
            const totalFeatures = features.length;
            
            // Map to track all points: "lng,lat" -> [{featureIndex, pointIndex}]
            const pointMap = new Map();
            
            // First pass: collect all points rounded to 6 decimals
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                if (!feature || !feature.geometry) continue;
                
                const geomType = feature.geometry.type;
                
                if (geomType === 'Point') {
                    const coords = feature.geometry.coordinates;
                    if (Array.isArray(coords) && coords.length >= 2) {
                        const roundedCoords = roundCoordinatePair(coords, 6);
                        const key = `${roundedCoords[0]},${roundedCoords[1]}`;
                        
                        if (!pointMap.has(key)) {
                            pointMap.set(key, []);
                        }
                        pointMap.get(key).push({ featureIndex: i, pointIndex: null }); // null for standalone Point
                    }
                } else if (geomType === 'MultiPoint') {
                    const coords = feature.geometry.coordinates;
                    if (Array.isArray(coords)) {
                        for (let ptIdx = 0; ptIdx < coords.length; ptIdx++) {
                            const coord = coords[ptIdx];
                            if (Array.isArray(coord) && coord.length >= 2) {
                                const roundedCoords = roundCoordinatePair(coord, 6);
                                const key = `${roundedCoords[0]},${roundedCoords[1]}`;
                                
                                if (!pointMap.has(key)) {
                                    pointMap.set(key, []);
                                }
                                pointMap.get(key).push({ featureIndex: i, pointIndex: ptIdx });
                            }
                        }
                    }
                }
                
                // Report progress
                if (i % globalReportInterval === 0 || i === totalFeatures - 1) {
                    if (progressCallback) {
                        const progress = Math.round(((i + 1) / totalFeatures) * 50); // First pass is 50%
                        progressCallback(progress, `Scanning points: ${i + 1} of ${totalFeatures}...`);
                    }
                    if (typeof __validationCancelled !== 'undefined' && __validationCancelled) break;
                    await delay(0);
                }
            }
            
            // Second pass: identify duplicates
            let processedPoints = 0;
            const totalPoints = pointMap.size;
            
            for (const [coordKey, locations] of pointMap.entries()) {
                if (locations.length > 1) {
                    // This point appears multiple times - all are duplicates
                    for (const loc of locations) {
                        duplicatePointFeatures.push({
                            featureIndex: loc.featureIndex,
                            pointIndex: loc.pointIndex, // null for Point, index for MultiPoint
                            coordKey: coordKey,
                            duplicateCount: locations.length,
                            duplicateOf: locations.filter(l => l !== loc).map(l => l.featureIndex)
                        });
                    }
                }
                
                processedPoints++;
                if (processedPoints % 100 === 0 || processedPoints === totalPoints) {
                    if (progressCallback) {
                        const progress = 50 + Math.round((processedPoints / totalPoints) * 50); // Second pass is 50%
                        progressCallback(progress, `Checking for duplicates: ${processedPoints} of ${totalPoints} unique points...`);
                    }
                    if (typeof __validationCancelled !== 'undefined' && __validationCancelled) break;
                    await delay(0);
                }
            }
            
            if (progressCallback) {
                const message = duplicatePointFeatures.length > 0
                    ? `Duplicate point check completed: ${duplicatePointFeatures.length} duplicate points found`
                    : 'No duplicate points found';
                progressCallback(100, message);
            }
            
            return { duplicatePointFeatures };
        }

        /**
         * Remove duplicate points from Point/MultiPoint features
         * @param {Array} features - Array of features
         * @param {Object} duplicatePointResults - Results from findDuplicatePoints
         * @param {Function} progressCallback - Progress callback
         * @param {Object} options - Options object
         * @returns {Array} - Cleaned features
         */
        async function removeDuplicatePoints(features, duplicatePointResults, progressCallback, options) {
            if (!duplicatePointResults || !duplicatePointResults.duplicatePointFeatures || duplicatePointResults.duplicatePointFeatures.length === 0) {
                if (progressCallback) progressCallback(100, getText('noDuplicatePointsToRemove'));
                return features;
            }
            
            const duplicatePoints = duplicatePointResults.duplicatePointFeatures;
            
            // Group duplicates by coordinate key to determine which to keep
            const coordKeyMap = new Map(); // coordKey -> [{featureIndex, pointIndex}]
            for (const dup of duplicatePoints) {
                if (!coordKeyMap.has(dup.coordKey)) {
                    coordKeyMap.set(dup.coordKey, []);
                }
                coordKeyMap.get(dup.coordKey).push({
                    featureIndex: dup.featureIndex,
                    pointIndex: dup.pointIndex
                });
            }
            
            // For each coordinate, keep only the first occurrence (lowest feature index, then lowest point index)
            const pointsToRemove = new Map(); // featureIndex -> Set of pointIndices to remove (or 'all' for entire Point)
            
            for (const [coordKey, locations] of coordKeyMap.entries()) {
                // Sort by feature index first, then by point index (null = -1 for sorting, so Points come before MultiPoints)
                locations.sort((a, b) => {
                    if (a.featureIndex !== b.featureIndex) {
                        return a.featureIndex - b.featureIndex;
                    }
                    // Same feature - sort by point index (null treated as -1)
                    const aIdx = a.pointIndex === null ? -1 : a.pointIndex;
                    const bIdx = b.pointIndex === null ? -1 : b.pointIndex;
                    return aIdx - bIdx;
                });
                
                // Keep the first, remove the rest
                
                for (let i = 1; i < locations.length; i++) {
                    const loc = locations[i];
                    if (!pointsToRemove.has(loc.featureIndex)) {
                        pointsToRemove.set(loc.featureIndex, new Set());
                    }
                    if (loc.pointIndex === null) {
                        // This is a standalone Point - mark entire feature for removal
                        pointsToRemove.get(loc.featureIndex).add('all');
                    } else {
                        // This is a point in a MultiPoint - mark specific point for removal
                        pointsToRemove.get(loc.featureIndex).add(loc.pointIndex);
                    }
                }
            }
            
            const cleanedFeatures = [];
            let removedPointCount = 0;
            let removedFeatureCount = 0;
            
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                
                if (!pointsToRemove.has(i)) {
                    // No duplicates in this feature
                    cleanedFeatures.push(feature);
                    continue;
                }
                
                const toRemove = pointsToRemove.get(i);
                
                if (toRemove.has('all')) {
                    // Remove entire Point feature
                    removedFeatureCount++;
                    removedPointCount++;
                    continue;
                }
                
                // This is a MultiPoint with specific points to remove
                if (feature.geometry && feature.geometry.type === 'MultiPoint') {
                    const coords = feature.geometry.coordinates;
                    const filteredCoords = coords.filter((coord, idx) => !toRemove.has(idx));
                    
                    removedPointCount += (coords.length - filteredCoords.length);
                    
                    if (filteredCoords.length === 0) {
                        // All points removed, remove entire feature
                        removedFeatureCount++;
                    } else if (filteredCoords.length === 1) {
                        // Convert to Point
                        const updatedFeature = { ...feature };
                        updatedFeature.geometry = {
                            type: 'Point',
                            coordinates: filteredCoords[0]
                        };
                        cleanedFeatures.push(updatedFeature);
                    } else {
                        // Keep as MultiPoint
                        const updatedFeature = { ...feature };
                        updatedFeature.geometry = {
                            type: 'MultiPoint',
                            coordinates: filteredCoords
                        };
                        cleanedFeatures.push(updatedFeature);
                    }
                } else {
                    // Shouldn't happen, but keep feature as-is
                    cleanedFeatures.push(feature);
                }
                
                // Report progress
                if (i % globalReportInterval === 0 || i === features.length - 1) {
                    if (progressCallback) {
                        const progress = Math.round(((i + 1) / features.length) * 100);
                        progressCallback(progress, `Removing duplicate points: ${i + 1} of ${features.length}...`);
                    }
                    if (typeof __autoCleanCancelled !== 'undefined' && __autoCleanCancelled) {
                        throw new Error('Auto-Clean cancelled');
                    }
                    await delay(0);
                }
            }
            
            if (progressCallback) {
                const message = `Duplicate point removal completed: ${removedPointCount} points removed, ${removedFeatureCount} features removed`;
                progressCallback(100, message);
            }
            
            return cleanedFeatures;
        }

        /**
         * Remove duplicate geometries - both entire features and individual points
         * @param {Array} features - Array of features
         * @param {Object} duplicateResults - Results from findDuplicateGeometries
         * @param {Function} progressCallback - Progress callback
         * @param {Object} options - Options object
         * @returns {Array} - Cleaned features
         */
        async function removeDuplicateGeometries(features, duplicateResults, progressCallback, options) {
            // We need to rebuild uniqueFeatures to KEEP all Point/MultiPoint features (including duplicates)
            // because removeDuplicatePoints will handle those separately
            
            // First, identify which original features are Point/MultiPoint
            const pointIndices = new Set();
            for (let i = 0; i < features.length; i++) {
                const geomType = features[i]?.geometry?.type;
                if (geomType === 'Point' || geomType === 'MultiPoint') {
                    pointIndices.add(i);
                }
            }
            
            // Build a set of duplicate Point/MultiPoint indices to add back
            const duplicatePointIndices = new Set(
                duplicateResults.duplicateFeatures
                    .filter(dup => pointIndices.has(dup.featureIndex))
                    .map(dup => dup.featureIndex)
            );
            
            // Start with uniqueFeatures and add back any Point/MultiPoint duplicates
            const afterFeatureRemoval = [...duplicateResults.uniqueFeatures];
            for (const dupIdx of duplicatePointIndices) {
                // Check if this duplicate is already in uniqueFeatures
                const alreadyIncluded = afterFeatureRemoval.some((f, idx) => features[dupIdx] === f);
                if (!alreadyIncluded) {
                    afterFeatureRemoval.push(features[dupIdx]);
                }
            }
            
            // Build index mapping: original index -> new index in afterFeatureRemoval using __persistentId
            const indexMap = new Map(); // oldIndex -> newIndex
            for (let oldIndex = 0; oldIndex < features.length; oldIndex++) {
                const originalFeature = features[oldIndex];
                if (!originalFeature || originalFeature.__persistentId === undefined) continue;
                
                const newIdx = afterFeatureRemoval.findIndex(f => 
                    f && f.__persistentId === originalFeature.__persistentId
                );
                if (newIdx !== -1) {
                    indexMap.set(oldIndex, newIdx);
                }
            }
            
            // Handle sub-polygon duplicates (from findDuplicateSubPolygons)
            // This includes duplicates where a standalone Polygon duplicates a MultiPolygon sub-polygon
            // polyIndex can be null (for standalone Polygon) or a number (for sub-polygon)
            const subPolygonDuplicates = duplicateResults.duplicateFeatures.filter(d => d.polyIndex !== undefined);
            const subPolyByFeature = new Map(); // featureIndex -> Set of polyIndices to remove
            const standalonePolygonsToRemove = new Set(); // Standalone Polygons that duplicate sub-polygons
            
            // Group sub-polygon duplicates by coordinate to determine what to keep/remove
            const subPolyCoordMap = new Map(); // coordString -> [{featureIndex, polyIndex, mappedIndex}]
            
            for (const dup of subPolygonDuplicates) {
                const mappedIdx = indexMap.get(dup.featureIndex);
                if (mappedIdx === undefined) continue; // Feature was removed
                
                const feature = afterFeatureRemoval[mappedIdx];
                if (!feature || !feature.geometry) continue;
                
                // Get coordinate string for this duplicate
                let coordString;
                if (dup.polyIndex === null && feature.geometry.type === 'Polygon') {
                    // Standalone Polygon
                    coordString = JSON.stringify(feature.geometry.coordinates);
                } else if (feature.geometry.type === 'MultiPolygon' && dup.polyIndex !== null) {
                    // Sub-polygon from MultiPolygon
                    coordString = JSON.stringify(feature.geometry.coordinates[dup.polyIndex]);
                } else {
                    continue;
                }
                
                if (!subPolyCoordMap.has(coordString)) {
                    subPolyCoordMap.set(coordString, []);
                }
                subPolyCoordMap.get(coordString).push({
                    featureIndex: dup.featureIndex,
                    polyIndex: dup.polyIndex,
                    mappedIndex: mappedIdx,
                    geomType: feature.geometry.type
                });
            }
            
            // For each duplicate coordinate, decide what to remove
            for (const [coordString, instances] of subPolyCoordMap.entries()) {
                if (instances.length < 2) continue; // Not actually duplicates
                
                // Sort: keep first occurrence (lowest original feature index, then lowest polyIndex)
                instances.sort((a, b) => {
                    if (a.featureIndex !== b.featureIndex) {
                        return a.featureIndex - b.featureIndex;
                    }
                    const aIdx = a.polyIndex === null ? -1 : a.polyIndex;
                    const bIdx = b.polyIndex === null ? -1 : b.polyIndex;
                    return aIdx - bIdx;
                });
                
                // Remove all except the first
                for (let i = 1; i < instances.length; i++) {
                    const inst = instances[i];
                    if (inst.polyIndex === null) {
                        // Standalone Polygon - mark entire feature for removal
                        standalonePolygonsToRemove.add(inst.mappedIndex);
                    } else {
                        // Sub-polygon from MultiPolygon - mark just that sub-polygon
                        if (!subPolyByFeature.has(inst.mappedIndex)) {
                            subPolyByFeature.set(inst.mappedIndex, new Set());
                        }
                        subPolyByFeature.get(inst.mappedIndex).add(inst.polyIndex);
                    }
                }
            }
            
            // Remove standalone Polygons marked as duplicates
            for (const idx of standalonePolygonsToRemove) {
                afterFeatureRemoval[idx] = null;
            }
            
            // Remove duplicate sub-polygons from MultiPolygons
            for (const [featureIdx, subPolyIndices] of subPolyByFeature.entries()) {
                const feature = afterFeatureRemoval[featureIdx];
                if (!feature || feature.geometry.type !== 'MultiPolygon') continue;
                
                // Filter out duplicate sub-polygons
                const newCoords = feature.geometry.coordinates.filter((coords, idx) => !subPolyIndices.has(idx));
                
                if (newCoords.length === 0) {
                    // All sub-polygons were duplicates, mark for removal
                    afterFeatureRemoval[featureIdx] = null;
                } else if (newCoords.length === 1) {
                    // Convert to Polygon
                    afterFeatureRemoval[featureIdx] = {
                        ...feature,
                        geometry: {
                            type: 'Polygon',
                            coordinates: newCoords[0]
                        }
                    };
                } else {
                    // Keep as MultiPolygon with remaining sub-polygons
                    afterFeatureRemoval[featureIdx] = {
                        ...feature,
                        geometry: {
                            type: 'MultiPolygon',
                            coordinates: newCoords
                        }
                    };
                }
            }
            
            // Filter out null features (those marked for removal)
            const afterSubPolyRemoval = afterFeatureRemoval.filter(f => f !== null);
            
            // Rebuild index mapping for the next stage using __persistentId for reliable matching
            const indexMap2 = new Map();
            for (let oldIndex = 0; oldIndex < features.length; oldIndex++) {
                const originalFeature = features[oldIndex];
                if (!originalFeature || originalFeature.__persistentId === undefined) continue;
                
                const newIdx = afterSubPolyRemoval.findIndex(f => 
                    f && f.__persistentId === originalFeature.__persistentId
                );
                if (newIdx !== -1) {
                    indexMap2.set(oldIndex, newIdx);
                }
            }
            
            // Remap duplicatePointFeatures indices to the new array
            const remappedDuplicatePointFeatures = duplicateResults.duplicatePointFeatures
                .filter(dup => indexMap2.has(dup.featureIndex)) // Only keep if feature wasn't removed
                .map(dup => ({
                    ...dup,
                    featureIndex: indexMap2.get(dup.featureIndex) // Map to new index
                }));
            
            // Then remove duplicate points (this handles Point and MultiPoint duplicates)
            const afterPointRemoval = await removeDuplicatePoints(afterSubPolyRemoval, { 
                duplicatePointFeatures: remappedDuplicatePointFeatures
            }, progressCallback ? (prog, msg) => progressCallback(50 + prog * 0.5, msg) : null, options);
            
            if (progressCallback) {
                progressCallback(100, getText('duplicateGeometryRemovalCompleted'));
            }
            
            return afterPointRemoval;
        }

        /**
         * Finds features with self-intersections using Turf.js kinks
         * @param {Object|Array} input - GeoJSON FeatureCollection or array of features
         * @param {Function} progressCallback - Optional callback for progress updates
         * @returns {Object} - { selfIntersectingFeatures: [{feature, featureIndex, kinks}] }
         */
        async function findSelfIntersections(input, progressCallback = null) {
            const selfIntersectingFeatures = [];
            
            // Check if Turf.js is available
            if (typeof turf === 'undefined' || typeof turf.kinks !== 'function') {
                console.error('Turf.js is not loaded or kinks function is not available');
                if (typeof showErrorNotification === 'function') {
                    showErrorNotification(getText('turfSelfIntersectionDetectionFailed'), 'red');
                }
                return { selfIntersectingFeatures: [] };
            }
            
            // Handle both FeatureCollection and array of features
            let features = [];
            if (input && input.type === 'FeatureCollection' && Array.isArray(input.features)) {
                features = input.features;
            } else if (Array.isArray(input)) {
                features = input;
            } else if (input && input.geometry) {
                // Single feature
                features = [input];
            } else {
                console.warn('Invalid input to findSelfIntersections');
                return { selfIntersectingFeatures: [] };
            }
            
            const totalFeatures = features.length;
            
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                
                // Check for cancellation
                if (typeof __validationCancelled !== 'undefined' && __validationCancelled) {
                    break;
                }
                
                if (!feature || !feature.geometry) continue;
                
                const geomType = feature.geometry.type;
                
                // kinks works on LineString, MultiLineString, Polygon, and MultiPolygon
                if (geomType === 'Polygon' || geomType === 'LineString' || geomType === 'MultiLineString') {
                    // For Polygon and LineString, check the entire feature
                    try {
                        const kinksResult = turf.kinks(feature);
                        
                        // If kinks returns any points, the feature has self-intersections
                        if (kinksResult && kinksResult.features && kinksResult.features.length > 0) {
                            selfIntersectingFeatures.push({
                                feature: feature,
                                featureIndex: i,
                                kinks: kinksResult.features,
                                kinkCount: kinksResult.features.length
                            });
                        }
                    } catch (err) {
                        console.warn(`Failed to check feature ${i} for self-intersections:`, err);
                    }
                } else if (geomType === 'MultiPolygon') {
                    // For MultiPolygon, check each sub-polygon individually to avoid false positives
                    // from shared vertices between sub-polygons
                    try {
                        let allKinks = [];
                        let subPolygonIndices = []; // Track which sub-polygons have issues
                        const coords = feature.geometry.coordinates;
                        
                        for (let polyIndex = 0; polyIndex < coords.length; polyIndex++) {
                            const subPolygon = {
                                type: 'Feature',
                                geometry: {
                                    type: 'Polygon',
                                    coordinates: coords[polyIndex]
                                },
                                properties: {}
                            };
                            
                            const kinksResult = turf.kinks(subPolygon);
                            if (kinksResult && kinksResult.features && kinksResult.features.length > 0) {
                                allKinks.push(...kinksResult.features);
                                subPolygonIndices.push(polyIndex);
                            }
                        }
                        
                        // Only flag if actual self-intersections found within sub-polygons
                        if (allKinks.length > 0) {
                            selfIntersectingFeatures.push({
                                feature: feature,
                                featureIndex: i,
                                kinks: allKinks,
                                kinkCount: allKinks.length,
                                subPolygonIndices: subPolygonIndices
                            });
                        }
                    } catch (err) {
                        console.warn(`Failed to check feature ${i} for self-intersections:`, err);
                    }
                }
                
                // Report progress
                if (i % globalReportInterval === 0) {
                    if (progressCallback) {
                        const progress = Math.round((i / totalFeatures) * 100);
                        const message = getText('checkingSelfIntersectionsProgress', i + 1, totalFeatures);
                        progressCallback(progress, message);
                    }
                    await delay(0);
                }
            }
            
            if (progressCallback) {
                const completionMessage = getText('checkingSelfIntersectionsCompleted', selfIntersectingFeatures.length);
                progressCallback(100, completionMessage);
            }
            
            
            return { selfIntersectingFeatures };
        }

        /**
         * Builds polygon units (outer rings) and an RBush spatial index for polygon operations
         * @param {Object|Array} input - GeoJSON FeatureCollection or array of features
         * @param {Object} options - { skipFeatureIndexes?: number[] }
         * @returns {Object} - { polygonUnits: Array, spatialIndex: RBush }
         */
        async function buildPolygonUnitsIndex(input, options = {}) {
            const skipFeatureIndexes = (options && Array.isArray(options.skipFeatureIndexes))
                ? new Set(options.skipFeatureIndexes)
                : null;

            let features = [];
            if (input && input.type === 'FeatureCollection' && Array.isArray(input.features)) {
                features = input.features;
            } else if (Array.isArray(input)) {
                features = input;
            } else {
                return { polygonUnits: [], spatialIndex: new RBush() };
            }

            const polygonUnits = [];
            for (let fi = 0; fi < features.length; fi++) {
                if (skipFeatureIndexes && skipFeatureIndexes.has(fi)) {
                    if ((fi % globalReportInterval) === 0) await delay(0);
                    continue;
                }
                const f = features[fi];
                if (!f || !f.geometry) continue;
                const g = f.geometry;
                try {
                    if (g.type === 'Polygon' && g.coordinates && g.coordinates[0] && g.coordinates[0].length >= 4) {
                        const ring = g.coordinates[0];
                        if (!ring || !Array.isArray(ring) || ring.length < 4) continue;
                        let validCoords = true;
                        for (let c of ring) {
                            if (!Array.isArray(c) || c.length < 2 || typeof c[0] !== 'number' || typeof c[1] !== 'number' ||
                                isNaN(c[0]) || isNaN(c[1]) || !isFinite(c[0]) || !isFinite(c[1])) { validCoords = false; break; }
                        }
                        if (!validCoords) continue;
                        
                        // If requireValidGeometry, validate before indexing
                        if (options.requireValidGeometry) {
                            try {
                                const tempFeature = { type: 'Feature', geometry: g };
                                if (!turf.booleanValid(tempFeature)) continue;
                            } catch (e) { continue; }
                        }
                        
                        const bbox = turf.bbox(f);
                        if (!bbox || !Array.isArray(bbox) || bbox.length !== 4) continue;
                        polygonUnits.push({ featureIndex: fi, feature: f, ring: ring, bbox: bbox });
                    } else if (g.type === 'MultiPolygon' && g.coordinates) {
                        for (let pi = 0; pi < g.coordinates.length; pi++) {
                            const poly = g.coordinates[pi];
                            if (poly && poly[0] && poly[0].length >= 4) {
                                const ring = poly[0];
                                if (!ring || !Array.isArray(ring) || ring.length < 4) continue;
                                let validCoords = true;
                                for (let c of ring) {
                                    if (!Array.isArray(c) || c.length < 2 || typeof c[0] !== 'number' || typeof c[1] !== 'number' ||
                                        isNaN(c[0]) || isNaN(c[1]) || !isFinite(c[0]) || !isFinite(c[1])) { validCoords = false; break; }
                                }
                                if (!validCoords) continue;
                                
                                const tempFeature = { type: 'Feature', geometry: { type: 'Polygon', coordinates: poly } };
                                
                                // If requireValidGeometry, validate before indexing
                                if (options.requireValidGeometry) {
                                    try {
                                        if (!turf.booleanValid(tempFeature)) continue;
                                    } catch (e) { continue; }
                                }
                                
                                const bbox = turf.bbox(tempFeature);
                                if (!bbox || !Array.isArray(bbox) || bbox.length !== 4) continue;
                                polygonUnits.push({ featureIndex: fi, feature: f, ring: ring, bbox: bbox, polyIndex: pi });
                            }
                        }
                    }
                } catch (_) {}
                if ((fi % globalReportInterval) === 0) await delay(0);
            }

            const spatialIndex = new RBush();
            for (const unit of polygonUnits) {
                spatialIndex.insert({ minX: unit.bbox[0], minY: unit.bbox[1], maxX: unit.bbox[2], maxY: unit.bbox[3], unit: unit });
            }
            return { polygonUnits, spatialIndex };
        }

        /**
         * Finds polygon features that contain holes (inner rings)
         * @param {Object|Array} input
         * @param {Function} progressCallback
         * @returns {Object} - { featuresWithHoles: [{ feature, featureIndex, holesCount }] }
         */
        async function findPolygonsWithHoles(input, progressCallback = null) {
            const featuresWithHoles = [];
            let features = [];
            if (input && input.type === 'FeatureCollection' && Array.isArray(input.features)) {
                features = input.features;
            } else if (Array.isArray(input)) {
                features = input;
            } else if (input && input.geometry) {
                features = [input];
            } else {
                return { featuresWithHoles: [] };
            }
            const total = features.length;
            for (let i = 0; i < features.length; i++) {
                if (typeof __validationCancelled !== 'undefined' && __validationCancelled) break;
                const f = features[i];
                if (!f || !f.geometry) continue;
                const g = f.geometry;
                try {
                    if (g.type === 'Polygon' && Array.isArray(g.coordinates)) {
                        const rings = g.coordinates;
                        let holes = 0;
                        for (let r = 1; r < rings.length; r++) {
                            const ring = rings[r];
                            if (Array.isArray(ring) && ring.length >= 4) holes++;
                        }
                        if (holes > 0) featuresWithHoles.push({ feature: f, featureIndex: i, holesCount: holes });
                    } else if (g.type === 'MultiPolygon' && Array.isArray(g.coordinates)) {
                        let holes = 0;
                        for (let p = 0; p < g.coordinates.length; p++) {
                            const poly = g.coordinates[p];
                            if (!Array.isArray(poly)) continue;
                            for (let r = 1; r < poly.length; r++) {
                                const ring = poly[r];
                                if (Array.isArray(ring) && ring.length >= 4) holes++;
                            }
                        }
                        if (holes > 0) featuresWithHoles.push({ feature: f, featureIndex: i, holesCount: holes });
                    }
                } catch (_) { }
                if ((i % globalReportInterval) === 0) {
                    if (progressCallback) {
                        const progress = Math.round((i / total) * 100);
                        const message = getText('holesProgress', i + 1, total);
                        progressCallback(progress, message);
                    }
                    if (typeof __validationCancelled !== 'undefined' && __validationCancelled) break;
                    await delay(0);
                }
            }
            if (progressCallback) {
                const completionMessage = getText('holesCompleted', featuresWithHoles.length);
                progressCallback(100, completionMessage);
            }
            return { featuresWithHoles };
        }

        /**
         * Finds polygons with sharp angles (slivers) on outer rings below threshold degrees
         * @param {Object|Array} input - GeoJSON FeatureCollection or array of features
         * @param {Function} progressCallback - Optional callback for progress updates
         * @param {Object} options - Optional settings (degreeThreshold: default 4)
         * @returns {Object} - { featuresWithSharpAngles: [{ feature, featureIndex, count }] }
         */
        async function findSharpAngles(input, progressCallback = null, options = {}) {
            const degreeThreshold = options?.degreeThreshold || 4;
            const featuresWithSharpAngles = [];
            const radThreshold = degreeThreshold * Math.PI / 180;
            
            // Use the same angle calculation as stageRemoveSlivers
            function computeAngleRadians(prev, curr, next) {
                const ux = prev[0] - curr[0];
                const uy = prev[1] - curr[1];
                const vx = next[0] - curr[0];
                const vy = next[1] - curr[1];
                const du = Math.hypot(ux, uy);
                const dv = Math.hypot(vx, vy);
                if (du === 0 || dv === 0) return Math.PI; // degenerate, treat as straight
                let cosTheta = (ux * vx + uy * vy) / (du * dv);
                if (cosTheta > 1) cosTheta = 1; else if (cosTheta < -1) cosTheta = -1;
                return Math.acos(cosTheta);
            }
            
            function countSharpAnglesInRing(ring) {
                if (!Array.isArray(ring) || ring.length < 4) return 0;
                const closed = __gr_closeRing(__gr_removeConsecutiveDuplicates(ring));
                const n = closed.length - 1; // last equals first
                let count = 0;
                for (let i = 0; i < n; i++) {
                    const prev = closed[(i - 1 + n) % n];
                    const curr = closed[i];
                    const next = closed[(i + 1) % n];
                    const ang = computeAngleRadians(prev, curr, next);
                    if (ang < radThreshold) count++;
                }
                return count;
            }
            let features = [];
            if (input && input.type === 'FeatureCollection' && Array.isArray(input.features)) {
                features = input.features;
            } else if (Array.isArray(input)) {
                features = input;
            } else if (input && input.geometry) {
                features = [input];
            } else {
                return { featuresWithSharpAngles: [] };
            }
            const total = features.length;
            for (let i = 0; i < features.length; i++) {
                if (typeof __validationCancelled !== 'undefined' && __validationCancelled) break;
                const f = features[i];
                if (!f || !f.geometry) continue;
                const g = f.geometry;
                try {
                    let count = 0;
                    let subPolygonIndices = []; // Track which sub-polygons have issues
                    
                    if (g.type === 'Polygon' && g.coordinates && g.coordinates[0]) {
                        count += countSharpAnglesInRing(g.coordinates[0]);
                    } else if (g.type === 'MultiPolygon' && Array.isArray(g.coordinates)) {
                        for (let p = 0; p < g.coordinates.length; p++) {
                            const poly = g.coordinates[p];
                            if (poly && poly[0]) {
                                const sharpAnglesInPoly = countSharpAnglesInRing(poly[0]);
                                if (sharpAnglesInPoly > 0) {
                                    subPolygonIndices.push(p);
                                    count += sharpAnglesInPoly;
                                }
                            }
                        }
                    }
                    if (count > 0) {
                        featuresWithSharpAngles.push({ 
                            feature: f, 
                            featureIndex: i, 
                            count: count,
                            subPolygonIndices: subPolygonIndices.length > 0 ? subPolygonIndices : null
                        });
                    }
                } catch (_) { }
                
                // Report progress
                if ((i % globalReportInterval) === 0 || i === total - 1) {
                    if (progressCallback) {
                        const progress = Math.round(((i + 1) / total) * 100);
                        progressCallback(progress, `Checking for slivers: feature ${i + 1} of ${total}...`);
                    }
                    if (typeof __validationCancelled !== 'undefined' && __validationCancelled) break;
                    await delay(0);
                }
            }
            if (progressCallback) progressCallback(100, `Sliver check completed: ${featuresWithSharpAngles.length} features with sharp angles found`);
            return { featuresWithSharpAngles };
        }

        /**
         * Finds overlapping polygon features using Turf.js and RBush spatial index
         * @param {Object|Array} input - GeoJSON FeatureCollection or array of features
         * @param {Function} progressCallback - Optional callback for progress updates
         * @returns {Object} - { overlappingPairs: [{featureA, featureB, indexA, indexB}] }
         */
        async function findOverlaps(input, progressCallback = null, options = {}) {
            const overlappingPairs = [];
            const skipFeatureIndexes = (options && Array.isArray(options.skipFeatureIndexes)) 
                ? new Set(options.skipFeatureIndexes) 
                : null;
            
            // Check if Turf.js is available
            if (typeof turf === 'undefined' || typeof turf.booleanIntersects !== 'function') {
                console.error('Turf.js is not loaded or booleanIntersects function is not available');
                if (typeof showErrorNotification === 'function') {
                    showErrorNotification(getText('turfOverlapDetectionFailed'), 'red');
                }
                return { overlappingPairs: [] };
            }
            
            // Handle both FeatureCollection and array of features
            let features = [];
            if (input && input.type === 'FeatureCollection' && Array.isArray(input.features)) {
                features = input.features;
            } else if (Array.isArray(input)) {
                features = input;
            } else if (input && input.geometry) {
                // Single feature - no overlaps possible
                return { overlappingPairs: [] };
            } else {
                console.warn('Invalid input to findOverlaps');
                return { overlappingPairs: [] };
            }
            
            const totalFeatures = features.length;
            
            
            // Use shared helper to extract polygon units and build the spatial index
            const { polygonUnits, spatialIndex } = await buildPolygonUnitsIndex(features, { skipFeatureIndexes, requireValidGeometry: true });
            
            // Check for overlaps using spatial index
            const checkedPairs = new Set(); // Track checked pairs to avoid duplicates
            
            for (let i = 0; i < polygonUnits.length; i++) {
                const unitA = polygonUnits[i];
                
                // Check for cancellation
                if (typeof __validationCancelled !== 'undefined' && __validationCancelled) { break; }
                
                // Search for spatially nearby candidates
                const candidates = spatialIndex.search({
                    minX: unitA.bbox[0],
                    minY: unitA.bbox[1],
                    maxX: unitA.bbox[2],
                    maxY: unitA.bbox[3]
                });
                
                for (const candidate of candidates) {
                    const unitB = candidate.unit;
                    
                    // Skip self-comparison (same feature AND same sub-polygon)
                    // But allow comparison of different sub-polygons from the same MultiPolygon
                    if (unitA.featureIndex === unitB.featureIndex && unitA.polyIndex === unitB.polyIndex) continue;
                    
                    // Skip if we've already checked this pair (order-independent)
                    // Include polyIndex to handle sub-polygons within MultiPolygons
                    const keyA = `${unitA.featureIndex}:${unitA.polyIndex !== undefined ? unitA.polyIndex : 0}`;
                    const keyB = `${unitB.featureIndex}:${unitB.polyIndex !== undefined ? unitB.polyIndex : 0}`;
                    const pairKey = keyA < keyB ? `${keyA}-${keyB}` : `${keyB}-${keyA}`;
                    
                    if (checkedPairs.has(pairKey)) continue;
                    checkedPairs.add(pairKey);
                    
                    // Check for actual overlap using Turf.js
                    try {
                        
                        // Ensure Turf.js is available
                        if (typeof turf === 'undefined' || typeof turf.booleanIntersects !== 'function') {
                            console.error('Turf.js booleanIntersects not available for overlap detection');
                            continue;
                        }
                        
                        // Validate that both units have valid rings
                        if (!unitA.ring || !Array.isArray(unitA.ring) || unitA.ring.length < 4) {
                            console.warn(`Invalid ring for feature ${unitA.featureIndex}`);
                            continue;
                        }
                        if (!unitB.ring || !Array.isArray(unitB.ring) || unitB.ring.length < 4) {
                            console.warn(`Invalid ring for feature ${unitB.featureIndex}`);
                            continue;
                        }
                        
                        
                        // Validate coordinates in rings
                        let validA = true;
                        for (let c of unitA.ring) {
                            if (!Array.isArray(c) || c.length < 2 || typeof c[0] !== 'number' || typeof c[1] !== 'number') {
                                validA = false;
                                break;
                            }
                        }
                        if (!validA) {
                            console.warn(`Invalid coordinates in ring for feature ${unitA.featureIndex}`);
                            continue;
                        }
                        
                        let validB = true;
                        for (let c of unitB.ring) {
                            if (!Array.isArray(c) || c.length < 2 || typeof c[0] !== 'number' || typeof c[1] !== 'number') {
                                validB = false;
                                break;
                            }
                        }
                        if (!validB) {
                            console.warn(`Invalid coordinates in ring for feature ${unitB.featureIndex}`);
                            continue;
                        }
                        
                        const polyA = {
                            type: 'Feature',
                            geometry: { type: 'Polygon', coordinates: [unitA.ring] },
                            properties: {}
                        };
                        const polyB = {
                            type: 'Feature',
                            geometry: { type: 'Polygon', coordinates: [unitB.ring] },
                            properties: {}
                        };
                        

                        
                        // Validate the constructed features with turf.booleanValid before overlap check
                        let validPolyA = false;
                        let validPolyB = false;
                        try {
                            validPolyA = turf.booleanValid(polyA);
                        } catch (e) {
                            // Skip invalid geometry
                        }
                        try {
                            validPolyB = turf.booleanValid(polyB);
                        } catch (e) {
                            // Skip invalid geometry
                        }
                        
                        if (!validPolyA || !validPolyB) {
                            continue; // Skip pairs with invalid geometries
                        }
                        
                        // Check if these are duplicates (identical geometries) and skip if so
                        try {
                            if (turf.booleanEqual(polyA, polyB)) {
                                continue; // Skip duplicate-to-duplicate comparison
                            }
                        } catch (equalErr) {
                            // If booleanEqual fails, continue to intersection check
                        }
                        
                        // Check for actual area overlap using turf.intersect
                        // Use simple area threshold to distinguish real overlaps from edge-sharing artifacts
                        let hasAreaOverlap = false;
                        try {
                            const intersection = turf.intersect(turf.featureCollection([polyA, polyB]));
                            
                            if (intersection && intersection.geometry) {
                                const intersectionType = intersection.geometry.type;
                                
                                // Only consider it an overlap if the intersection is a Polygon or MultiPolygon
                                // (which have area), not a LineString or Point (which don't have area)
                                if (intersectionType === 'Polygon' || intersectionType === 'MultiPolygon') {
                                    // Calculate the area of the intersection
                                    const intersectionArea = turf.area(intersection);
                                        
                                        // Only flag as overlap if the area is significant (more than 1 square meter)
                                    // Edge-sharing artifacts have near-zero area, real overlaps have > 1 m
                                    const minOverlapArea = 1; // 1 square meter threshold
                                        if (intersectionArea > minOverlapArea) {
                                            hasAreaOverlap = true;
                                        }
                                    }
                            }
                        } catch (intersectErr) {
                            // Skip this pair if intersection calculation fails
                            continue;
                        }
                        
                        if (hasAreaOverlap) {
                            // Get persistent IDs for display
                            const persistentIdA = (unitA.feature && typeof unitA.feature.__persistentId === 'number') 
                                ? unitA.feature.__persistentId 
                                : unitA.featureIndex;
                            const persistentIdB = (unitB.feature && typeof unitB.feature.__persistentId === 'number') 
                                ? unitB.feature.__persistentId 
                                : unitB.featureIndex;
                            
                            overlappingPairs.push({
                                featureA: unitA.feature,
                                featureB: unitB.feature,
                                indexA: unitA.featureIndex,
                                indexB: unitB.featureIndex,
                                persistentIdA: persistentIdA,
                                persistentIdB: persistentIdB,
                                subPolygonIndexA: unitA.polyIndex !== undefined ? unitA.polyIndex : null,
                                subPolygonIndexB: unitB.polyIndex !== undefined ? unitB.polyIndex : null
                            });
                        }
                    } catch (err) {
                        // If overlap check fails, skip this pair
                        console.warn(`Overlap check failed for features ${unitA.featureIndex} and ${unitB.featureIndex}:`, err);
                    }
                }
                
                // Report progress
                if (i % globalReportInterval === 0) {
                    if (progressCallback) {
                        const progress = Math.round((i / polygonUnits.length) * 100);
                        const message = getText('checkingOverlapsProgress', i + 1, polygonUnits.length);
                        progressCallback(progress, message);
                    }
                    await delay(0);
                }
            }
            
            if (progressCallback) {
                const completionMessage = getText('checkingOverlapsCompleted', overlappingPairs.length);
                progressCallback(100, completionMessage);
            }
            
            
            return { overlappingPairs };
        }

        // ============================================================================
        // FIXING/CLEANING WRAPPER FUNCTIONS FOR VALIDATION PIPELINE
        // ============================================================================

        /** Close unclosed rings in all polygon geometries and convert/remove unsupported types */
        async function closeUnclosedRings(features, detectionResults, progressCallback, options) {
            // Modify features in place for performance (features are already copied by pipeline)
            const validFeatures = [];
            let processedCount = 0;
            let closedCount = 0;
            let convertedCount = 0;
            let removedCount = 0;
            const total = features.length;
            
            for (let i = 0; i < features.length; i++) {
                const f = features[i];
                
                if (!f || !f.geometry) {
                    validFeatures.push(f);
                    processedCount++;
                    continue;
                }
                
                const g = f.geometry;
                let shouldKeep = true;
                
                try {
                    // Handle Polygon - close any unclosed rings
                    if (g.type === 'Polygon' && Array.isArray(g.coordinates)) {
                        for (let r = 0; r < g.coordinates.length; r++) {
                            const ring = g.coordinates[r];
                            if (Array.isArray(ring) && ring.length > 0) {
                                const first = ring[0];
                                const last = ring[ring.length - 1];
                                // Check if ring is unclosed
                                if (first[0] !== last[0] || first[1] !== last[1]) {
                                    ring.push([first[0], first[1]]);
                                    closedCount++;
                                }
                            }
                        }
                        validFeatures.push(f);
                    }
                    // Handle MultiPolygon - close any unclosed rings
                    else if (g.type === 'MultiPolygon' && Array.isArray(g.coordinates)) {
                        for (let p = 0; p < g.coordinates.length; p++) {
                            const poly = g.coordinates[p];
                            if (Array.isArray(poly)) {
                                for (let r = 0; r < poly.length; r++) {
                                    const ring = poly[r];
                                    if (Array.isArray(ring) && ring.length > 0) {
                                        const first = ring[0];
                                        const last = ring[ring.length - 1];
                                        // Check if ring is unclosed
                                        if (first[0] !== last[0] || first[1] !== last[1]) {
                                            ring.push([first[0], first[1]]);
                                            closedCount++;
                                        }
                                    }
                                }
                            }
                        }
                        validFeatures.push(f);
                    }
                    // Handle LineString - try to close and convert to Polygon
                    else if (g.type === 'LineString' && Array.isArray(g.coordinates)) {
                        if (g.coordinates.length >= 3) {
                            // Close the line and convert to polygon
                            const coords = g.coordinates.slice();
                            const first = coords[0];
                            const last = coords[coords.length - 1];
                            if (first[0] !== last[0] || first[1] !== last[1]) {
                                coords.push([first[0], first[1]]);
                            }
                            // Create polygon from closed linestring
                            f.geometry = {
                                type: 'Polygon',
                                coordinates: [coords]
                            };
                            validFeatures.push(f);
                            convertedCount++;
                        } else {
                            // Not enough points to make a polygon, remove
                            removedCount++;
                        }
                    }
                    // Handle MultiLineString - try to close and convert to MultiPolygon
                    else if (g.type === 'MultiLineString' && Array.isArray(g.coordinates)) {
                        const polygons = [];
                        for (const lineCoords of g.coordinates) {
                            if (Array.isArray(lineCoords) && lineCoords.length >= 3) {
                                const coords = lineCoords.slice();
                                const first = coords[0];
                                const last = coords[coords.length - 1];
                                if (first[0] !== last[0] || first[1] !== last[1]) {
                                    coords.push([first[0], first[1]]);
                                }
                                polygons.push([coords]);
                            }
                        }
                        if (polygons.length > 0) {
                            if (polygons.length === 1) {
                                // Single polygon
                                f.geometry = {
                                    type: 'Polygon',
                                    coordinates: polygons[0]
                                };
                            } else {
                                // Multiple polygons
                                f.geometry = {
                                    type: 'MultiPolygon',
                                    coordinates: polygons
                                };
                            }
                            validFeatures.push(f);
                            convertedCount++;
                        } else {
                            // No valid polygons, remove
                            removedCount++;
                        }
                    }
                    // Keep Point and MultiPoint as-is
                    else if (g.type === 'Point' || g.type === 'MultiPoint') {
                        validFeatures.push(f);
                    }
                    // Remove unsupported types (GeometryCollection, etc.)
                    else {
                        removedCount++;
                        console.warn(`Removed feature ${i} with unsupported geometry type: ${g.type}`);
                    }
                } catch (e) {
                    console.warn(`Error processing feature ${i}:`, e);
                    removedCount++;
                }
                
                processedCount++;
                
                // Report progress and yield to UI
                if (processedCount % globalReportInterval === 0 || processedCount === total) {
                    if (progressCallback) {
                        const progress = Math.round((processedCount / total) * 100);
                        progressCallback(progress, `Processing geometries: feature ${processedCount} of ${total}`);
                    }
                    
                    if (typeof __autoCleanCancelled !== 'undefined' && __autoCleanCancelled) {
                        throw new Error('Auto-Clean cancelled');
                    }
                    
                    await delay(0);
                }
            }
            
            if (progressCallback) {
                const messages = [];
                if (closedCount > 0) messages.push(`${closedCount} rings closed`);
                if (convertedCount > 0) messages.push(`${convertedCount} linestrings converted to polygons`);
                if (removedCount > 0) messages.push(`${removedCount} unsupported features removed`);
                
                const summary = messages.length > 0 ? messages.join(', ') : 'All geometries valid';
                progressCallback(100, `Geometry processing complete: ${summary}`);
            }
            
            return validFeatures;
        }

        /** Remove duplicate features from dataset */
        async function removeDuplicates(features, duplicateResults, progressCallback, options) {
            if (!duplicateResults || !duplicateResults.uniqueFeatures) {
                return features;
            }
            
            const removedCount = duplicateResults.duplicateFeatures?.length || 0;
            
            if (progressCallback) {
                progressCallback(100, `Removed ${removedCount} duplicate features`);
            }
            
            return duplicateResults.uniqueFeatures;
        }

        /**
         * Remove duplicate vertices from features (after rounding to 6 decimals)
         * @param {Array} features - Array of features
         * @param {Object} duplicateVertexResults - Results from findDuplicateVertices
         * @param {Function} progressCallback - Progress callback
         * @param {Object} options - Options object
         * @returns {Array} - Cleaned features
         */
        async function removeDuplicateVertices(features, duplicateVertexResults, progressCallback, options) {
            const cleanedFeatures = [];
            const total = features.length;
            let processedCount = 0;
            
            // Create a set of indices that have duplicate vertices for efficient lookup
            const featureIndicesWithDuplicates = new Set();
            if (duplicateVertexResults && duplicateVertexResults.invalidFeatures) {
                duplicateVertexResults.invalidFeatures.forEach(item => {
                    featureIndicesWithDuplicates.add(item.featureIndex);
                });
            }
            
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                
                // If this feature doesn't have duplicate vertices, keep it as-is
                if (!featureIndicesWithDuplicates.has(i)) {
                    cleanedFeatures.push(feature);
                    continue;
                }
                
                if (!feature || !feature.geometry) {
                    cleanedFeatures.push(feature);
                    continue;
                }
                
                const geomType = feature.geometry.type;
                
                // Only process Polygon and MultiPolygon
                if (geomType !== 'Polygon' && geomType !== 'MultiPolygon') {
                    cleanedFeatures.push(feature);
                    continue;
                }
                
                try {
                    const cleanedFeature = { ...feature };
                    
                    /**
                     * Clean ring by removing duplicates at 6 decimal precision
                     * BUT preserving original high-precision coordinates for kept vertices
                     */
                    const cleanRing = (ring) => {
                        if (!ring || ring.length < 2) return ring;
                        
                        // Step 1: Find consecutive duplicates at 6 decimal precision
                        const consecutiveDuplicateIndices = __gr_findConsecutiveDuplicates(ring, 6);
                        
                        // Step 2: DO NOT remove non-consecutive duplicates (B-shaped rings)
                        // Let the self-intersection fixer handle these by splitting and keeping the longer portion
                        // const nonConsecutiveDuplicateIndices = __gr_findNonConsecutiveDuplicates(ring, 6);
                        
                        // Step 3: Only remove consecutive duplicates
                        const indicesToRemove = new Set(consecutiveDuplicateIndices);
                        
                        // Step 4: Build cleaned ring using ORIGINAL coordinates of kept indices
                        const kept = [];
                        for (let j = 0; j < ring.length; j++) {
                            if (!indicesToRemove.has(j)) {
                                // Keep original high-precision coordinate
                                kept.push(ring[j]);
                            }
                        }
                        
                        // Step 5: Ensure closure with original precision
                        if (kept.length >= 3) {
                            const first = kept[0];
                            const last = kept[kept.length - 1];
                            
                            // Compare at 6 decimal precision to check if closed
                            const multiplier = 1e6;
                            const firstRounded = [
                                Math.round(first[0] * multiplier) / multiplier,
                                Math.round(first[1] * multiplier) / multiplier
                            ];
                            const lastRounded = [
                                Math.round(last[0] * multiplier) / multiplier,
                                Math.round(last[1] * multiplier) / multiplier
                            ];
                            
                            if (firstRounded[0] !== lastRounded[0] || firstRounded[1] !== lastRounded[1]) {
                                // Close with original first coordinate (preserving precision)
                                kept.push([first[0], first[1]]);
                            }
                        }
                        
                        return kept;
                    };
                    
                    if (geomType === 'Polygon') {
                        const cleanedCoords = feature.geometry.coordinates.map(ring => cleanRing(ring)).filter(ring => ring.length >= 4);
                        if (cleanedCoords.length === 0) {
                            // All rings were filtered out, skip this feature
                            const persistentId = typeof feature.__persistentId === 'number' ? feature.__persistentId : i;
                            console.warn(`Feature ${i} (persistent ID: ${persistentId}) has no valid rings after removing duplicate vertices, removing feature`);
                            processedCount++;
                            continue;
                        }
                        cleanedFeature.geometry = {
                            type: 'Polygon',
                            coordinates: cleanedCoords
                        };
                    } else if (geomType === 'MultiPolygon') {
                        const cleanedCoords = feature.geometry.coordinates
                            .map(polygon => polygon.map(ring => cleanRing(ring)).filter(ring => ring.length >= 4))
                            .filter(polygon => polygon.length > 0);
                        if (cleanedCoords.length === 0) {
                            // All polygons were filtered out, skip this feature
                            const persistentId = typeof feature.__persistentId === 'number' ? feature.__persistentId : i;
                            console.warn(`Feature ${i} (persistent ID: ${persistentId}) has no valid polygons after removing duplicate vertices, removing feature`);
                            processedCount++;
                            continue;
                        }
                        cleanedFeature.geometry = {
                            type: 'MultiPolygon',
                            coordinates: cleanedCoords
                        };
                    }
                    
                    cleanedFeatures.push(cleanedFeature);
                    processedCount++;
                } catch (e) {
                    console.warn(`Error cleaning duplicate vertices for feature ${i}:`, e);
                    cleanedFeatures.push(feature);
                }
                
                // Report progress
                if (i % globalReportInterval === 0 || i === total - 1) {
                    if (progressCallback) {
                        const progress = Math.round(((i + 1) / total) * 100);
                        progressCallback(progress, `Removing duplicate vertices: feature ${i + 1} of ${total}...`);
                    }
                    if (typeof __autoCleanCancelled !== 'undefined' && __autoCleanCancelled) {
                        throw new Error('Auto-Clean cancelled');
                    }
                    await delay(0);
                }
            }
            
            if (progressCallback) {
                progressCallback(100, `Duplicate vertex removal completed: ${processedCount} features processed`);
            }
            
            return cleanedFeatures;
        }
        
        /** Fix self-intersections in features */
        async function fixSelfIntersections(features, selfIntersectResults, progressCallback, options) {
            // Extract feature indices that have self-intersections
            const featureIndices = selfIntersectResults?.selfIntersectingFeatures?.map(item => item.featureIndex) || null;
            
            const original = currentGeoJSON ? currentGeoJSON.features : null;
            if (currentGeoJSON) currentGeoJSON.features = features;
            try {
                // Pass the specific feature indices to only process those features
                await stageFixSelfIntersection(options?.autoCleanOptions || {}, featureIndices, progressCallback);
                const result = currentGeoJSON ? currentGeoJSON.features : features;
                if (progressCallback) progressCallback(100, getText('fixedSelfIntersectingFeatures'));
                return result;
            } finally {
                if (currentGeoJSON && original) currentGeoJSON.features = original;
            }
        }
        /** Remove holes from polygons (keep outer ring only) */
        async function removeHoles(features, holesResults, progressCallback, options) {
            // Get list of features with holes from detection results
            const featuresWithHoles = holesResults?.featuresWithHoles || [];
            
            if (featuresWithHoles.length === 0) {
                if (progressCallback) {
                    progressCallback(100, getText('noPolygonHolesToRemove'));
                }
                return features;
            }
            
            // Modify features in place for performance (undo snapshot already taken)
            
            let processedCount = 0;
            let holesRemovedCount = 0;
            const totalToProcess = featuresWithHoles.length;
            
            // Only process features that were detected to have holes
            for (const holeItem of featuresWithHoles) {
                const featureIndex = holeItem.featureIndex;
                const f = features[featureIndex];
                
                if (!f || !f.geometry) {
                    processedCount++;
                    continue;
                }
                
                const g = f.geometry;
                
                try {
                    if (g.type === 'Polygon' && Array.isArray(g.coordinates) && g.coordinates.length > 1) {
                        // Has holes - keep only the outer ring (first ring)
                        const holesCount = g.coordinates.length - 1;
                        g.coordinates = [g.coordinates[0]]; // Keep only outer ring
                        holesRemovedCount += holesCount;
                    } else if (g.type === 'MultiPolygon' && Array.isArray(g.coordinates)) {
                        // Process each polygon in the multipolygon
                        for (let p = 0; p < g.coordinates.length; p++) {
                            const poly = g.coordinates[p];
                            if (Array.isArray(poly) && poly.length > 1) {
                                const holesCount = poly.length - 1;
                                g.coordinates[p] = [poly[0]]; // Keep only outer ring
                                holesRemovedCount += holesCount;
                            }
                        }
                    }
                } catch (e) {
                    console.warn(`Error removing holes from feature ${featureIndex}:`, e);
                }
                
                processedCount++;
                if (progressCallback && (processedCount % globalReportInterval === 0 || processedCount === totalToProcess)) {
                    const progress = Math.round((processedCount / totalToProcess) * 100);
                    progressCallback(progress, `Removing holes: feature ${processedCount} of ${totalToProcess}`);
                }
                
                // Check for cancellation
                if (typeof __autoCleanCancelled !== 'undefined' && __autoCleanCancelled) {
                    throw new Error('Auto-Clean cancelled');
                }
                
                await delay(0);
            }
            
            if (progressCallback) {
                progressCallback(100, `Removed ${holesRemovedCount} holes from ${featuresWithHoles.length} polygons`);
            }
            
            return features;
        }

        /** Remove sliver polygons (sharp angles) */
        async function removeSlivers(features, sliverResults, progressCallback, options) {
            const original = currentGeoJSON ? currentGeoJSON.features : null;
            if (currentGeoJSON) currentGeoJSON.features = features;
            try {
                await stageRemoveSlivers(options?.autoCleanOptions || {}, progressCallback, sliverResults);
                const result = currentGeoJSON ? currentGeoJSON.features : features;
                if (progressCallback) progressCallback(100, getText('sliverRemovalCompleted'));
                return result;
            } finally {
                if (currentGeoJSON && original) currentGeoJSON.features = original;
            }
        }

        /** Remove overlapping polygons */
        async function removeOverlaps(features, overlapResults, progressCallback, options) {
            // Check if Turf.js is available
            if (typeof turf === 'undefined' || typeof turf.difference !== 'function') {
                console.error('Turf.js is required for overlap removal');
                return features;
            }

            console.log('removeOverlaps', overlapResults);
            
            // Extract overlapping pairs from detection results
            const overlappingPairs = overlapResults?.overlappingPairs || [];
            
            if (overlappingPairs.length === 0) {
                if (progressCallback) progressCallback(100, getText('noOverlapsToRemove'));
                return features;
            }
            
            // Extract configuration options for validation
            const requestedStages = options?.stages || [];
            const autoCleanOptions = options?.autoCleanOptions || {};
            
            // ========================================================================
            // PHASE 1: DECOMPOSE - Extract ONLY features that have overlaps
            // ========================================================================
            
            if (progressCallback) progressCallback(10, getText('decomposingOverlappingFeatures'));
            
            // Build a Set of feature indices that appear in overlappingPairs
            const featuresWithOverlaps = new Set();
            for (const pair of overlappingPairs) {
                featuresWithOverlaps.add(pair.indexA);
                featuresWithOverlaps.add(pair.indexB);
            }
            
            const geometries = []; // Array of { id, geometry, originalFeatureIndex, originalSubIndex, area, properties, modified }
            const nonPolygonFeatures = new Map(); // featureIdx -> feature (for Point, MultiPoint, LineString, etc.)
            let nextGeomId = 0;
            
            // Only process features that have overlaps
            for (let featureIdx = 0; featureIdx < features.length; featureIdx++) {
                // Skip features that don't have overlaps
                if (!featuresWithOverlaps.has(featureIdx)) {
                    continue;
                }
                const feature = features[featureIdx];
                if (!feature || !feature.geometry) continue;
                
                const geomType = feature.geometry.type;
                
                if (geomType === 'Polygon') {
                    try {
                        // Validate geometry first (same validation as detection phase)
                        // This ensures we only process geometries that were also detected
                        if (!turf.booleanValid(feature)) {
                            console.warn(`Skipping invalid Polygon at feature ${featureIdx} (not detected in overlap scan)`);
                            continue;
                        }
                        
                        const area = turf.area(feature);
                        geometries.push({
                            id: nextGeomId++,
                            geometry: feature.geometry,
                            originalFeatureIndex: featureIdx,
                            originalSubIndex: null,
                            area: area,
                            properties: feature.properties || {},
                            modified: false
                        });
                    } catch (e) {
                        console.warn(`Could not process Polygon at feature ${featureIdx}:`, e);
                    }
                } else if (geomType === 'MultiPolygon') {
                    // Decompose MultiPolygon into individual Polygons
                    for (let subIdx = 0; subIdx < feature.geometry.coordinates.length; subIdx++) {
                        try {
                            const polyCoords = feature.geometry.coordinates[subIdx];
                            const polyGeometry = { type: 'Polygon', coordinates: polyCoords };
                            const polyFeature = { type: 'Feature', geometry: polyGeometry, properties: {} };
                            
                            // Validate geometry first (same validation as detection phase)
                            // This ensures we only process geometries that were also detected
                            if (!turf.booleanValid(polyFeature)) {
                                console.warn(`Skipping invalid sub-polygon ${subIdx} of feature ${featureIdx} (not detected in overlap scan)`);
                                continue;
                            }
                            
                            const area = turf.area(polyFeature);
                            
                            geometries.push({
                                id: nextGeomId++,
                                geometry: polyGeometry,
                                originalFeatureIndex: featureIdx,
                                originalSubIndex: subIdx,
                                area: area,
                                properties: feature.properties || {},
                                modified: false
                            });
                        } catch (e) {
                            console.warn(`Could not process sub-polygon ${subIdx} of feature ${featureIdx}:`, e);
                        }
                    }
                } else {
                    // Non-polygon geometry (Point, MultiPoint, LineString, MultiLineString, GeometryCollection)
                    // Store these to add back unchanged during reassembly
                    nonPolygonFeatures.set(featureIdx, feature);
                }
            }
            
            if (geometries.length === 0) {
                console.warn('No valid polygon geometries to process');
                // If we have non-polygon features, return them unchanged
                if (nonPolygonFeatures.size > 0) {
                    return features;
                }
                return features;
            }
            
            // Build overlap map: geomId -> Set of overlapping geomIds
            const overlapMap = new Map();
            
            for (const pair of overlappingPairs) {
                const { indexA, indexB, subPolygonIndexA, subPolygonIndexB } = pair;
                
                // Find geometry IDs corresponding to this pair
                const geomA = geometries.find(g => 
                    g.originalFeatureIndex === indexA && 
                    (subPolygonIndexA === null || subPolygonIndexA === undefined ? g.originalSubIndex === null : g.originalSubIndex === subPolygonIndexA)
                );
                const geomB = geometries.find(g => 
                    g.originalFeatureIndex === indexB && 
                    (subPolygonIndexB === null || subPolygonIndexB === undefined ? g.originalSubIndex === null : g.originalSubIndex === subPolygonIndexB)
                );
                
                if (geomA && geomB) {
                    if (!overlapMap.has(geomA.id)) overlapMap.set(geomA.id, new Set());
                    if (!overlapMap.has(geomB.id)) overlapMap.set(geomB.id, new Set());
                    overlapMap.get(geomA.id).add(geomB.id);
                    overlapMap.get(geomB.id).add(geomA.id);
                }
            }
            
            // ========================================================================
            // HELPER: Validate and clean a clipped geometry immediately
            // ========================================================================
            
            async function validateAndCleanClippedGeometry(geom, requestedStages, autoCleanOptions) {
                try {
                    // Create temporary feature for validation
                    let tempFeature = {
                        type: 'Feature',
                        geometry: geom.geometry,
                        properties: geom.properties
                    };
                    
                    // 1. Close unclosed rings (mandatory)
                    const closedFeatures = await closeUnclosedRings([tempFeature], null, null, { autoCleanOptions });
                    if (!closedFeatures || closedFeatures.length === 0) {
                        return { isValid: false };
                    }
                    tempFeature = closedFeatures[0];
                    
                    // 2. Remove duplicate vertices (mandatory)
                    const dedupedFeatures = await removeDuplicateVertices([tempFeature], null, null, { autoCleanOptions });
                    if (!dedupedFeatures || dedupedFeatures.length === 0 || !dedupedFeatures[0] || !dedupedFeatures[0].geometry) {
                        return { isValid: false };
                    }
                    tempFeature = dedupedFeatures[0];
                    
                    // 3. Fix self-intersections (if they exist)
                    // First check if there are self-intersections
                    const selfIntersectionResults = await findSelfIntersections([tempFeature]);
                    if (selfIntersectionResults && selfIntersectionResults.featuresWithSelfIntersections && 
                        selfIntersectionResults.featuresWithSelfIntersections.length > 0) {
                        // Try to fix them
                        const fixedFeatures = await fixSelfIntersections([tempFeature], selfIntersectionResults, null, { autoCleanOptions });
                        if (!fixedFeatures || fixedFeatures.length === 0 || !fixedFeatures[0] || !fixedFeatures[0].geometry) {
                            return { isValid: false };
                        }
                        tempFeature = fixedFeatures[0];
                    }
                    
                    // 4. Validate with turf.booleanValid (after attempting fixes)
                    try {
                        if (!turf.booleanValid(tempFeature)) {
                            return { isValid: false };
                        }
                    } catch (e) {
                        // Re-throw cancellation errors so they propagate up
                        if (e.message === 'Auto-Clean cancelled') {
                            throw e;
                        }
                        return { isValid: false };
                    }
                    
                    // 5. Remove slivers iteratively (if enabled)
                    if (requestedStages.includes('slivers')) {
                        const maxSliverIterations = 20;
                        let sliverIterations = 0;
                        let hasSlivers = true;
                        
                        while (hasSlivers && sliverIterations < maxSliverIterations) {
                            const sharpAngleResults = await findSharpAngles([tempFeature]);
                            if (!sharpAngleResults || !sharpAngleResults.featuresWithSharpAngles || sharpAngleResults.featuresWithSharpAngles.length === 0) {
                                // No more slivers - success!
                                hasSlivers = false;
                                break;
                            }
                            
                            // Try to remove slivers
                            const desliveredFeatures = await removeSlivers([tempFeature], sharpAngleResults, null, { autoCleanOptions });
                            if (!desliveredFeatures || desliveredFeatures.length === 0 || !desliveredFeatures[0] || !desliveredFeatures[0].geometry) {
                                // Geometry became invalid during sliver removal - reject it
                                console.warn(`Sliver removal invalidated geometry after ${sliverIterations + 1} iterations`);
                                return { isValid: false };
                            }
                            
                            tempFeature = desliveredFeatures[0];
                            sliverIterations++;
                        }
                        
                        // Final check: if we hit max iterations and still have slivers, reject
                        if (hasSlivers && sliverIterations >= maxSliverIterations) {
                            console.warn(`Max sliver removal iterations (${maxSliverIterations}) reached - geometry still has slivers, rejecting`);
                            return { isValid: false };
                        }
                    }
                    
                    // 6. Check for small polygons (if enabled)
                    if (requestedStages.includes('smallPolygons')) {
                        const minAreaSquareMeters = autoCleanOptions.smallpolygonsArea || 10;
                        try {
                            const area = turf.area(tempFeature);
                            if (area < minAreaSquareMeters) {
                                return { isValid: false };
                            }
                        } catch (e) {
                            // Re-throw cancellation errors so they propagate up
                            if (e.message === 'Auto-Clean cancelled') {
                                throw e;
                            }
                            return { isValid: false };
                        }
                    }
                    
                    // Geometry is valid - check if it was cleaned
                    const wasCleaned = tempFeature.geometry !== geom.geometry;
                    if (wasCleaned) {
                        return {
                            isValid: true,
                            cleaned: true,
                            geometry: tempFeature.geometry,
                            area: turf.area(tempFeature)
                        };
                            } else {
                        return { isValid: true, cleaned: false };
                    }
                    
                    } catch (e) {
                    // Re-throw cancellation errors so they propagate up
                    if (e.message === 'Auto-Clean cancelled') {
                        throw e;
                    }
                    console.warn(`Error validating clipped geometry:`, e);
                    return { isValid: false };
                }
            }
            
            // ========================================================================
            // PHASE 2: ITERATIVE CLIPPING with area recalculation and re-sorting
            // ========================================================================
            
            if (progressCallback) progressCallback(20, getText('creatingOverlapRemovalPlan'));
            
            const geometriesToRemove = new Set();
            const processedGeomIds = new Set();
            let clippedCount = 0;
            let removedCount = 0;
            
            // Sort geometries by area (largest first) - this is our initial processing order
            geometries.sort((a, b) => b.area - a.area);
            
            let totalIterations = 0;
            const initialGeomCount = geometries.length;
            // Count geometries that actually have overlaps (for progress tracking)
            const initialOverlapCount = new Set(overlapMap.keys()).size;
            // Safety limit: allow for splits that could increase the overlap count, plus buffer
            const maxIterations = initialOverlapCount * 10;
            
            while (totalIterations < maxIterations) {
                totalIterations++;
                
                // Find the largest unprocessed geometry THAT HAS OVERLAPS
                let currentGeom = null;
                for (const geom of geometries) {
                    if (!processedGeomIds.has(geom.id) && 
                        !geometriesToRemove.has(geom.id) &&
                        overlapMap.has(geom.id)) {
                        currentGeom = geom;
                        break;
                    }
                }
                
                if (!currentGeom) break; // All geometries with overlaps have been processed
                
                // Mark as processed (this geometry won't be clipped by anything)
                processedGeomIds.add(currentGeom.id);
                
                // Find all overlapping geometries that haven't been processed yet
                const overlappingIds = overlapMap.get(currentGeom.id) || new Set();
                const geometriesToClip = [];
                
                for (const overlapId of overlappingIds) {
                    if (!processedGeomIds.has(overlapId) && !geometriesToRemove.has(overlapId)) {
                        const overlapGeom = geometries.find(g => g.id === overlapId);
                        if (overlapGeom) {
                            geometriesToClip.push(overlapGeom);
                        }
                    }
                }
                
                // Clip each overlapping geometry against the current (larger) geometry
                for (const smallerGeom of geometriesToClip) {
                    try {
                        const largerFeature = { type: 'Feature', geometry: currentGeom.geometry, properties: {} };
                        const smallerFeature = { type: 'Feature', geometry: smallerGeom.geometry, properties: {} };
                        
                        // Perform clip: subtract larger from smaller
                        const difference = turf.difference(turf.featureCollection([smallerFeature, largerFeature]));
                        
                        if (difference && difference.geometry) {
                            // Validate the clipped result has valid coordinates
                            const coords = difference.geometry.coordinates;
                            if (!coords || !Array.isArray(coords) || coords.length === 0) {
                                // Invalid result, remove geometry
                                geometriesToRemove.add(smallerGeom.id);
                                removedCount++;
                                continue;
                            }
                            
                            // Handle different result types
                            if (difference.geometry.type === 'Polygon') {
                                // Validate polygon has valid ring structure
                                if (!Array.isArray(coords[0]) || coords[0].length < 4) {
                                    geometriesToRemove.add(smallerGeom.id);
                                    removedCount++;
                    continue;
                }
                
                                // Simple case: result is a single polygon
                                smallerGeom.geometry = difference.geometry;
                                try {
                                    smallerGeom.area = turf.area(difference);
                                    smallerGeom.modified = true;
                                    
                                    // Immediately validate and clean the clipped geometry
                                    const validationResult = await validateAndCleanClippedGeometry(smallerGeom, requestedStages, autoCleanOptions);
                                    if (!validationResult.isValid) {
                                        geometriesToRemove.add(smallerGeom.id);
                                        removedCount++;
                                    } else if (validationResult.cleaned) {
                                        // Update with cleaned geometry
                                        smallerGeom.geometry = validationResult.geometry;
                                        smallerGeom.area = validationResult.area;
                                    }
                                    
                                    clippedCount++;
                                } catch (e) {
                                    // Re-throw cancellation errors so they propagate up
                                    if (e.message === 'Auto-Clean cancelled') {
                                        throw e;
                                    }
                                    // Area calculation failed, geometry is invalid
                                    geometriesToRemove.add(smallerGeom.id);
                                    removedCount++;
                                }
                            } else if (difference.geometry.type === 'MultiPolygon') {
                                // Clipping produced multiple polygons - split into separate geometries
                                // Keep the largest part in the original geometry, create new ones for the rest
                                const parts = difference.geometry.coordinates;
                                
                                if (parts.length > 0) {
                                    // Calculate areas for all parts and validate them
                                    const partAreas = [];
                                    for (let idx = 0; idx < parts.length; idx++) {
                                        const polyCoords = parts[idx];
                                        // Validate polygon structure
                                        if (!Array.isArray(polyCoords) || polyCoords.length === 0 ||
                                            !Array.isArray(polyCoords[0]) || polyCoords[0].length < 4) {
                                            continue; // Skip invalid parts
                                        }
                                        try {
                                            const area = turf.area({ type: 'Feature', geometry: { type: 'Polygon', coordinates: polyCoords }, properties: {} });
                                            if (area > 0) {
                                                partAreas.push({ idx, coords: polyCoords, area });
                                            }
                                        } catch (e) {
                                            // Re-throw cancellation errors so they propagate up
                                            if (e.message === 'Auto-Clean cancelled') {
                                                throw e;
                                            }
                                            // Skip parts that cause area calculation errors
                                        }
                                    }
                                    
                                    if (partAreas.length === 0) {
                                        // No valid parts, remove geometry
                                        geometriesToRemove.add(smallerGeom.id);
                                        removedCount++;
                            continue;
                        }
                        
                                    // Sort by area descending
                                    partAreas.sort((a, b) => b.area - a.area);
                                    
                                    // First (largest) part replaces the original geometry
                                    smallerGeom.geometry = { type: 'Polygon', coordinates: partAreas[0].coords };
                                    smallerGeom.area = partAreas[0].area;
                                    smallerGeom.modified = true;
                                    
                                    // Validate the main clipped geometry immediately
                                    const mainValidationResult = await validateAndCleanClippedGeometry(smallerGeom, requestedStages, autoCleanOptions);
                                    if (!mainValidationResult.isValid) {
                                        geometriesToRemove.add(smallerGeom.id);
                                        removedCount++;
                                        continue; // Don't create additional geometries if main is invalid
                                    } else if (mainValidationResult.cleaned) {
                                        smallerGeom.geometry = mainValidationResult.geometry;
                                        smallerGeom.area = mainValidationResult.area;
                                    }
                                    
                                    // Create new geometry entries for remaining parts
                                    for (let i = 1; i < partAreas.length; i++) {
                                        const newGeom = {
                                            id: nextGeomId++,
                                            geometry: { type: 'Polygon', coordinates: partAreas[i].coords },
                                            originalFeatureIndex: smallerGeom.originalFeatureIndex,
                                            originalSubIndex: smallerGeom.originalSubIndex,
                                            area: partAreas[i].area,
                                            properties: smallerGeom.properties,
                                            modified: true
                                        };
                                        
                                        // Validate each new split geometry immediately
                                        const newValidationResult = await validateAndCleanClippedGeometry(newGeom, requestedStages, autoCleanOptions);
                                        if (!newValidationResult.isValid) {
                                            // Don't add invalid geometries
                            continue;
                                        } else if (newValidationResult.cleaned) {
                                            newGeom.geometry = newValidationResult.geometry;
                                            newGeom.area = newValidationResult.area;
                                        }
                                        
                                        geometries.push(newGeom);
                                        
                                        // Inherit overlap relationships from the original geometry
                                        // (excluding the current geometry being processed, which was just clipped)
                                        const inheritedOverlaps = new Set();
                                        const originalOverlaps = overlapMap.get(smallerGeom.id) || new Set();
                                        for (const overlapId of originalOverlaps) {
                                            if (overlapId !== currentGeom.id && !processedGeomIds.has(overlapId)) {
                                                inheritedOverlaps.add(overlapId);
                                                // Add bidirectional relationship
                                                if (!overlapMap.has(overlapId)) overlapMap.set(overlapId, new Set());
                                                overlapMap.get(overlapId).add(newGeom.id);
                                            }
                                        }
                                        overlapMap.set(newGeom.id, inheritedOverlaps);
                                    }
                                    
                                    clippedCount++;
                                } else {
                                    // Empty result
                                    geometriesToRemove.add(smallerGeom.id);
                                    removedCount++;
                                }
                            } else {
                                // Unexpected geometry type, remove
                                geometriesToRemove.add(smallerGeom.id);
                                removedCount++;
                            }
                        } else {
                            // No difference - geometry was completely covered
                            geometriesToRemove.add(smallerGeom.id);
                            removedCount++;
                        }
                    } catch (e) {
                        // Re-throw cancellation errors so they propagate up
                        if (e.message === 'Auto-Clean cancelled') {
                            throw e;
                        }
                        console.warn(`Error clipping geometry ${smallerGeom.id} against ${currentGeom.id}:`, e);
                        // On error, remove the smaller geometry to be safe
                        geometriesToRemove.add(smallerGeom.id);
                        removedCount++;
                    }
                }
                
                // Re-sort unprocessed geometries by updated areas
                geometries.sort((a, b) => {
                    // Processed items go to the end
                    if (processedGeomIds.has(a.id) && !processedGeomIds.has(b.id)) return 1;
                    if (!processedGeomIds.has(a.id) && processedGeomIds.has(b.id)) return -1;
                    // Removed items go to the very end
                    if (geometriesToRemove.has(a.id) && !geometriesToRemove.has(b.id)) return 1;
                    if (!geometriesToRemove.has(a.id) && geometriesToRemove.has(b.id)) return -1;
                    // Otherwise sort by area descending
                    return b.area - a.area;
                });
                
                // Progress update and yield to UI (every 50 iterations)
                if ((processedGeomIds.size % 50 === 0) || processedGeomIds.size >= initialOverlapCount) {
                    if (progressCallback) {
                        const progress = 20 + Math.min(50, Math.round((processedGeomIds.size / Math.max(initialOverlapCount, 1)) * 50));
                        progressCallback(progress, getText('processingOverlaps', processedGeomIds.size, initialOverlapCount));
                    }
                    await delay(0);
                    if (__autoCleanCancelled) throw new Error('Auto-Clean cancelled');
                }
            }
            
            // ========================================================================
            // PHASE 3: (Validation now happens inline during clipping in Phase 2)
            // ========================================================================
            
            // Phase 3 is no longer needed - validation happens immediately after each clip
            // This prevents invalid geometries from being used in subsequent clipping operations
            
            if (progressCallback) progressCallback(75, getText('finalizingClippedGeometries'));
            
            // ========================================================================
            // PHASE 4: REASSEMBLE - Reconstruct features from geometries
            // ========================================================================
            
            if (progressCallback) progressCallback(85, getText('reassemblingFeatures'));
            
            // Group geometries by originalFeatureIndex
            const featureGroups = new Map();
            
            for (const geom of geometries) {
                if (geometriesToRemove.has(geom.id)) continue;
                
                const featureIdx = geom.originalFeatureIndex;
                if (!featureGroups.has(featureIdx)) {
                    featureGroups.set(featureIdx, []);
                }
                featureGroups.get(featureIdx).push(geom);
            }
            
            // Helper function to validate geometry has valid coordinates
            function isValidGeometry(geom) {
                if (!geom || !geom.geometry || !geom.geometry.coordinates) {
                    return false;
                }
                
                const coords = geom.geometry.coordinates;
                const type = geom.geometry.type;
                
                if (type === 'Polygon') {
                    // Must have at least one ring with at least 4 points
                    if (!Array.isArray(coords) || coords.length === 0) return false;
                    if (!Array.isArray(coords[0]) || coords[0].length < 4) return false;
                    // Check first point is valid
                    if (!Array.isArray(coords[0][0]) || coords[0][0].length < 2) return false;
                    if (typeof coords[0][0][0] !== 'number' || typeof coords[0][0][1] !== 'number') return false;
                    return true;
                } else if (type === 'MultiPolygon') {
                    // Must have at least one polygon
                    if (!Array.isArray(coords) || coords.length === 0) return false;
                    // Each polygon must have at least one ring with at least 4 points
                    for (const poly of coords) {
                        if (!Array.isArray(poly) || poly.length === 0) return false;
                        if (!Array.isArray(poly[0]) || poly[0].length < 4) return false;
                        if (!Array.isArray(poly[0][0]) || poly[0][0].length < 2) return false;
                        if (typeof poly[0][0][0] !== 'number' || typeof poly[0][0][1] !== 'number') return false;
                    }
                    return true;
                }
                
                return false;
            }
            
            // Build result features array
            const resultFeatures = [];
            let featuresWithEmptyGeometry = 0;
            
            for (let featureIdx = 0; featureIdx < features.length; featureIdx++) {
                // Check if this is a non-polygon feature that should be preserved unchanged
                if (nonPolygonFeatures.has(featureIdx)) {
                    resultFeatures.push(nonPolygonFeatures.get(featureIdx));
                    continue;
                }
                
                const group = featureGroups.get(featureIdx);
                
                if (!group || group.length === 0) {
                    // Feature wasn't processed (had no overlaps) - keep it unchanged
                    if (!featuresWithOverlaps.has(featureIdx)) {
                        resultFeatures.push(features[featureIdx]);
                        continue;
                    }
                    // Feature had overlaps but was completely removed during clipping
                    continue;
                }
                
                // Get original feature to preserve __persistentId and other top-level properties
                const originalFeature = features[featureIdx];
                
                // Filter out invalid geometries
                const validGeometries = group.filter(g => isValidGeometry(g));
                
                if (validGeometries.length === 0) {
                    // All geometries in this feature are invalid, skip the feature
                    const persistentId = (originalFeature && typeof originalFeature.__persistentId === 'number') 
                        ? originalFeature.__persistentId : featureIdx;
                    console.warn(`Feature ${featureIdx} (persistent ID: ${persistentId}) has no valid geometries after overlap removal`);
                    featuresWithEmptyGeometry++;
                    continue;
                }
                
                // Use properties from the first valid geometry in the group
                const properties = validGeometries[0].properties;
                
                if (validGeometries.length === 1) {
                    // Single geometry -> create Polygon feature
                    const newFeature = {
                        type: 'Feature',
                        geometry: validGeometries[0].geometry,
                        properties: properties
                    };
                    
                    // Preserve __persistentId if it exists
                    if (originalFeature && typeof originalFeature.__persistentId === 'number') {
                        newFeature.__persistentId = originalFeature.__persistentId;
                    }
                    
                    resultFeatures.push(newFeature);
                } else {
                    // Multiple geometries -> create MultiPolygon feature
                    const coordinates = validGeometries.map(g => g.geometry.coordinates);
                    const newFeature = {
                        type: 'Feature',
                        geometry: {
                            type: 'MultiPolygon',
                            coordinates: coordinates
                        },
                        properties: properties
                    };
                    
                    // Preserve __persistentId if it exists
                    if (originalFeature && typeof originalFeature.__persistentId === 'number') {
                        newFeature.__persistentId = originalFeature.__persistentId;
                    }
                    
                    resultFeatures.push(newFeature);
                }
            }
            
            if (featuresWithEmptyGeometry > 0) {
                console.warn(`Removed ${featuresWithEmptyGeometry} features with empty/invalid geometries during overlap removal`);
            }
            
            if (progressCallback) {
                progressCallback(100, `Overlap removal completed: ${clippedCount} clipped, ${removedCount} removed`);
            }
            
            console.log(`Overlap removal: ${clippedCount} geometries clipped, ${removedCount} geometries removed (validation performed inline)`);
            console.log(`Result: ${features.length} input features -> ${resultFeatures.length} output features`);
            
            return resultFeatures;
        }

        /** Remove small polygons below area threshold */
        async function removeSmallPolygons(features, results, progressCallback, options) {
            const original = currentGeoJSON ? currentGeoJSON.features : null;
            if (currentGeoJSON) currentGeoJSON.features = features;
            try {
                await stageRemoveSmallPolygons(options?.autoCleanOptions || {}, progressCallback);
                const result = currentGeoJSON ? currentGeoJSON.features : features;
                if (progressCallback) progressCallback(100, getText('smallPolygonRemovalCompleted'));
                return result;
            } finally {
                if (currentGeoJSON && original) currentGeoJSON.features = original;
            }
        }

        /** Remove points that are located within polygons */
        async function removePointsInPolygons(features, results, progressCallback, options) {
            const original = currentGeoJSON ? currentGeoJSON.features : null;
            if (currentGeoJSON) currentGeoJSON.features = features;
            try {
                await stageRemovePointsInPolygons(options?.autoCleanOptions || {}, progressCallback);
                const result = currentGeoJSON ? currentGeoJSON.features : features;
                if (progressCallback) progressCallback(100, getText('pointsInPolygonsRemovalCompleted'));
                return result;
            } finally {
                if (currentGeoJSON && original) currentGeoJSON.features = original;
            }
        }

        /** Remove redundant collinear points */
        async function removeCollinearPoints(features, results, progressCallback, options) {
            const original = currentGeoJSON ? currentGeoJSON.features : null;
            if (currentGeoJSON) currentGeoJSON.features = features;
            try {
                await stageRemoveCollinear(options?.autoCleanOptions || {}, progressCallback);
                const result = currentGeoJSON ? currentGeoJSON.features : features;
                if (progressCallback) progressCallback(100, getText('collinearPointRemovalCompleted'));
                return result;
            } finally {
                if (currentGeoJSON && original) currentGeoJSON.features = original;
            }
        }

        // ============================================================================
        // END FIXING/CLEANING WRAPPER FUNCTIONS
        // ============================================================================

        /**
         * Calculate signed area of a ring to determine winding order
         * Positive area = counter-clockwise, Negative area = clockwise
         * Using shoelace formula
         */
        function getSignedArea(ring) {
            if (!ring || ring.length < 3) return 0;
            
            let area = 0;
            const n = ring.length;
            
            for (let i = 0; i < n - 1; i++) {
                const [x1, y1] = ring[i];
                const [x2, y2] = ring[i + 1];
                area += (x2 - x1) * (y2 + y1);
            }
            
            return area / 2;
        }

        /**
         * Ensure all exterior rings are counter-clockwise (GeoJSON spec)
         * Exterior rings should have positive signed area
         */
        function ensureCorrectWindingOrder(coordinates, isHole = false) {
            if (!coordinates || coordinates.length < 3) return coordinates;
            
            const signedArea = getSignedArea(coordinates);
            const isCounterClockwise = signedArea > 0;
            
            // Exterior rings should be counter-clockwise (positive area)
            // Holes should be clockwise (negative area)
            const needsReversal = isHole ? isCounterClockwise : !isCounterClockwise;
            
            if (needsReversal) {
                // Reverse the ring, but keep the closing coordinate at the end
                const reversed = coordinates.slice(0, -1).reverse();
                reversed.push(reversed[0]); // Re-close the ring
                return reversed;
            }
            
            return coordinates;
        }

        /**
         * Normalize winding order for a single feature's geometry
         * Call this after any geometry modification during editing
         */
        function normalizeFeatureWindingOrder(feature) {
            if (!feature || !feature.geometry) return;
            
            const geom = feature.geometry;
            
            if (geom.type === 'Polygon') {
                // First ring is exterior (counter-clockwise), rest are holes (clockwise)
                geom.coordinates[0] = ensureCorrectWindingOrder(geom.coordinates[0], false);
                for (let i = 1; i < geom.coordinates.length; i++) {
                    geom.coordinates[i] = ensureCorrectWindingOrder(geom.coordinates[i], true);
                }
            } else if (geom.type === 'MultiPolygon') {
                // Each polygon: first ring is exterior, rest are holes
                geom.coordinates.forEach(polygon => {
                    polygon[0] = ensureCorrectWindingOrder(polygon[0], false);
                    for (let i = 1; i < polygon.length; i++) {
                        polygon[i] = ensureCorrectWindingOrder(polygon[i], true);
                    }
                });
            }
        }

        /**
         * Normalize winding order for all polygons in a GeoJSON FeatureCollection
         * Ensures consistent rendering with fillRule: 'nonzero'
         */
        function normalizeWindingOrder(geoJSON) {
            console.log('Normalizing winding order');
            if (!geoJSON || !geoJSON.features) return geoJSON;
            
            geoJSON.features.forEach(feature => {
                normalizeFeatureWindingOrder(feature);
            });
            
            return geoJSON;
        }

        function processGeoJSON(geoJSON, suppressFit = false) {
            // Normalize winding order for consistent rendering with fillRule: 'nonzero'
            geoJSON = normalizeWindingOrder(geoJSON);
            // Store the current GeoJSON data
            currentGeoJSON = geoJSON;
            
            // Clear previous validation results since dataset changed
            __lastValidationStore = null;
            
            // Clear existing layers
            polygonLayer.clearLayers();
            pointLayer.clearLayers();
            pointMarkerLayer.clearLayers();
            polygonMarkerLayer.clearLayers();
            if (combinedClusterGroup) combinedClusterGroup.clearLayers();
            
            // Determine if clustering should be used based on feature count
            const featureCount = geoJSON.features ? geoJSON.features.length : 0;
            const useClustering = featureCount >= CLUSTERING_FEATURE_LIMIT;
            
            // Set global reporting interval based on dataset size
            if (featureCount >= 10000) {
                globalReportInterval = 1000;
            } else if (featureCount >= 1000) {
                globalReportInterval = 100;
            } else {
                globalReportInterval = 50;
            }
            
            // Calculate bounds to fit the map to the data
            let bounds = null;
            
            // Process each feature in the GeoJSON
            if (geoJSON.features && geoJSON.features.length > 0) {
                // Initialize persistent feature IDs before processing
                initializeFeatureIds(geoJSON.features);
                
                geoJSON.features.forEach(function(feature, __index) {
                    // Assign array index for compatibility (but use __persistentId for display)
                    try { feature.__featureIndex = __index; } catch(_) {}
                    // Get feature bounds
                    const featureBounds = getFeatureBounds(feature);
                    if (featureBounds) {
                        if (!bounds) {
                            bounds = featureBounds;
                        } else {
                            bounds.extend(featureBounds);
                        }
                    }
                    
                    if (feature.geometry) {
                        // Process based on geometry type
                        if (feature.geometry.type === 'Point') {
                            processPointFeature(feature, useClustering);
                        } else if (feature.geometry.type === 'MultiPoint') {
                            processMultiPointFeature(feature, useClustering);
                        } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                            processPolygonFeature(feature, useClustering);
                        }
                    }
                });
                
                // Fit map to data bounds if available
                if (bounds && !suppressFit) {
                    map.fitBounds(bounds);
                }
                
                // Update layers based on current zoom
                updateLayersByZoom();
            
                // Update legend
                updateLegend();
            }
        }
        
        function getFeatureBounds(feature) {
            if (!feature || !feature.geometry || !feature.geometry.coordinates) return null;
            
                const coords = feature.geometry.coordinates;
            
            if (feature.geometry.type === 'Point') {
                if (!Array.isArray(coords) || coords.length < 2) return null;
                const latLng = L.latLng(coords[1], coords[0]);
                return L.latLngBounds([latLng]);
            } else if (feature.geometry.type === 'MultiPoint') {
                if (!Array.isArray(coords) || coords.length === 0) return null;
                const latLngs = coords.map(coord => L.latLng(coord[1], coord[0]));
                return L.latLngBounds(latLngs);
            } else if (feature.geometry.type === 'Polygon') {
                if (!Array.isArray(coords) || coords.length === 0 || !Array.isArray(coords[0]) || coords[0].length === 0) return null;
                const ring = coords[0];
                const latLngs = ring.map(coord => L.latLng(coord[1], coord[0]));
                return L.latLngBounds(latLngs);
            } else if (feature.geometry.type === 'MultiPolygon') {
                if (!Array.isArray(coords) || coords.length === 0) return null;
                let allLatLngs = [];
                for (const polygon of coords) {
                    if (Array.isArray(polygon) && polygon.length > 0 && Array.isArray(polygon[0])) {
                    polygon[0].forEach(coord => {
                        allLatLngs.push(L.latLng(coord[1], coord[0]));
                    });
                    }
                }
                if (allLatLngs.length === 0) return null;
                return L.latLngBounds(allLatLngs);
            }
            
            return null;
        }
        
        function processPointFeature(feature, useClustering = false) {
            // Validate feature has valid geometry before processing
            if (!feature || !feature.geometry || !feature.geometry.coordinates) {
                const persistentId = (feature && typeof feature.__persistentId === 'number') ? feature.__persistentId : 'unknown';
                console.warn(`Skipping point feature with invalid geometry. Persistent ID: ${persistentId}`, feature);
                return;
            }
            
            const coords = feature.geometry.coordinates;
            if (!Array.isArray(coords) || coords.length < 2) {
                const persistentId = typeof feature.__persistentId === 'number' ? feature.__persistentId : 'unknown';
                console.warn(`Skipping point feature with invalid coordinates. Persistent ID: ${persistentId}`, feature);
                return;
            }
            
            const latLng = L.latLng(coords[1], coords[0]);
            
            // Create a marker for zoom levels <= 15 or for clustering
            const marker = L.marker(latLng);
            marker.feature = feature; // Tag marker with feature reference for removal
            // Pre-bind popup content so repeated clicks reliably open it in view mode
            try { marker.bindPopup(createFeaturePopupContent(feature)); } catch(_) {}
            
            // Popup/interaction handled on click
            let highZoomShape = null;
            marker.on('click', function(e) {
                // If a polygon is currently selected for vertex editing, deselect it first
                if (currentMode === MODES.EDIT && isEditingVertices) {
                    disableVertexEditing();
                }
                // In Edit mode, never allow default popup open on marker click
                if (currentMode === MODES.EDIT) {
                    try { if (e && e.originalEvent && L && L.DomEvent && L.DomEvent.stop) L.DomEvent.stop(e.originalEvent); } catch(_) {}
                    try { if (marker && marker.closePopup) marker.closePopup(); } catch(_) {}
                }
                // Remove feature flow
                if (currentTool === EDIT_TOOLS.REMOVE) {
                    try {
                        pushUndoSnapshot('remove-point', feature, 'delete');
                        removeFeature(feature, marker, marker.highZoomShape);
                    } catch(err) { console.error('Remove point error:', err); }
                    e.stopPropagation && e.stopPropagation();
                    return;
                }
                // View mode: show Leaflet popup
                if (currentMode !== MODES.EDIT) {
                    try {
                        // Ensure latest content in case properties changed
                        const p = marker.getPopup();
                        if (p && typeof p.setContent === 'function') {
                            p.setContent(createFeaturePopupContent(feature));
                        } else {
                            marker.bindPopup(createFeaturePopupContent(feature));
                        }
                        marker.openPopup();
                    } catch(_) {}
                    e.stopPropagation && e.stopPropagation();
                    return;
                }
                // Edit mode + Properties tool: open modal
                if (currentTool === EDIT_TOOLS.PROPERTIES) {
                    openPropertiesModal(feature);
                    e.stopPropagation && e.stopPropagation();
                    return;
                }
                // Edit mode + Select or Vertex tool: NOT available for markers (only for circles when zoomed in)
                // Markers are only shown when zoomed out, editing is only available when zoomed in
                if (currentTool === EDIT_TOOLS.SELECT || currentTool === EDIT_TOOLS.VERTEX) {
                    // Do nothing - editing not available for markers
                    e.stopPropagation && e.stopPropagation();
                    return;
                }
            });
            
            // Add marker to appropriate layer (cluster group for large datasets, regular layer otherwise)
            if (useClustering) {
                combinedClusterGroup.addLayer(marker);
            } else {
                pointMarkerLayer.addLayer(marker);
            }
            
            // Create circle marker for zoom levels > 15 (fixed pixel size, doesn't scale with zoom)
                highZoomShape = L.circleMarker(latLng, {
                    radius: 6,
                    color: '#3388ff',
                    weight: 1,
                    fillColor: '#3388ff',
                    fillOpacity: 0.9
                });
            // Disable built-in dragging - we use manual dragging system for editing
            if (highZoomShape && highZoomShape.dragging) {
                highZoomShape.dragging.disable();
            }
            if (highZoomShape) {
                // Store references so we can switch between marker and highZoomShape during editing
                marker.highZoomShape = highZoomShape;
                highZoomShape.marker = marker;
                highZoomShape.feature = feature; // Tag shape with feature reference for removal
                
                highZoomShape.on('click', function(e) {
                    if (currentMode === MODES.EDIT && isEditingVertices) {
                        disableVertexEditing();
                    }
                    if (currentTool === EDIT_TOOLS.REMOVE) {
                        try {
                            pushUndoSnapshot('remove-point', feature, 'delete');
                            removeFeature(feature, marker, highZoomShape);
                        } catch(err) { console.error('Remove point shape error:', err); }
                        e.stopPropagation && e.stopPropagation();
                        return;
                    }
                    // View mode: show popup; Edit mode + Properties tool: open modal
                    if (currentMode !== MODES.EDIT) {
                        // Show popup in View mode
                        try {
                            const popupContent = createFeaturePopupContent(feature);
                            highZoomShape.bindPopup(popupContent).openPopup(e.latlng);
                        } catch(_) {}
                        e.stopPropagation && e.stopPropagation();
                        return;
                    }
                    if (currentTool === EDIT_TOOLS.PROPERTIES) {
                        openPropertiesModal(feature);
                        e.stopPropagation && e.stopPropagation();
                        return;
                    }
                    // Edit mode + Select or Vertex tool: enable point dragging
                    if (currentTool === EDIT_TOOLS.SELECT || currentTool === EDIT_TOOLS.VERTEX) {
                        enablePointEditing(highZoomShape, feature);
                        e.stopPropagation && e.stopPropagation();
                        return;
                    }
                });
                pointLayer.addLayer(highZoomShape);
            }
        }
        
        function processMultiPointFeature(feature, useClustering = false) {
            // For MultiPoint, create a marker for each point in the coordinates array
            const pointCoords = feature.geometry.coordinates;
            
            pointCoords.forEach((coords, pointIndex) => {
                const latLng = L.latLng(coords[1], coords[0]);
                
                // Create a marker for zoom levels <= 15 or for clustering
                const marker = L.marker(latLng);
                marker.feature = feature; // Tag marker with feature reference
                marker.pointIndex = pointIndex; // Tag with which point in the MultiPoint
                
                // Pre-bind popup content
                try { marker.bindPopup(createFeaturePopupContent(feature)); } catch(_) {}
                
                // Marker click handler
                marker.on('click', function(e) {
                    // If a polygon is currently selected for vertex editing, deselect it first
                    if (currentMode === MODES.EDIT && isEditingVertices) {
                        disableVertexEditing();
                    }
                    // In Edit mode, never allow default popup open on marker click
                    if (currentMode === MODES.EDIT) {
                        try { if (e && e.originalEvent && L && L.DomEvent && L.DomEvent.stop) L.DomEvent.stop(e.originalEvent); } catch(_) {}
                        try { if (marker && marker.closePopup) marker.closePopup(); } catch(_) {}
                    }
                    // Remove individual point from MultiPoint
                    if (currentTool === EDIT_TOOLS.REMOVE) {
                        try {
                            removePointFromMultiPoint(feature, pointIndex, marker, marker.highZoomShape);
                        } catch(err) { console.error('Remove MultiPoint error:', err); }
                        e.stopPropagation && e.stopPropagation();
                        return;
                    }
                    // View mode: show Leaflet popup
                    if (currentMode !== MODES.EDIT) {
                        try {
                            const p = marker.getPopup();
                            if (p && typeof p.setContent === 'function') {
                                p.setContent(createFeaturePopupContent(feature));
                            } else {
                                marker.bindPopup(createFeaturePopupContent(feature));
                            }
                            marker.openPopup();
                        } catch(_) {}
                        e.stopPropagation && e.stopPropagation();
                        return;
                    }
                    // Edit mode + Properties tool: open modal
                    if (currentTool === EDIT_TOOLS.PROPERTIES) {
                        openPropertiesModal(feature);
                        e.stopPropagation && e.stopPropagation();
                        return;
                    }
                });
                
                // Add marker to appropriate layer
                if (useClustering) {
                    combinedClusterGroup.addLayer(marker);
                } else {
                    pointMarkerLayer.addLayer(marker);
                }
                
                // Create circle marker for zoom levels > 15
                const highZoomShape = L.circleMarker(latLng, {
                    radius: 6,
                    color: '#3388ff',
                    weight: 1,
                    fillColor: '#3388ff',
                    fillOpacity: 0.9
                });
                
                // Disable built-in dragging - we use manual dragging system for editing
                if (highZoomShape && highZoomShape.dragging) {
                    highZoomShape.dragging.disable();
                }
                
                // Store cross-references
                marker.highZoomShape = highZoomShape;
                highZoomShape.marker = marker;
                highZoomShape.feature = feature;
                highZoomShape.pointIndex = pointIndex;
                
                // HighZoomShape click handler
                highZoomShape.on('click', function(e) {
                    if (currentMode === MODES.EDIT && isEditingVertices) {
                        disableVertexEditing();
                    }
                    // Remove individual point from MultiPoint
                    if (currentTool === EDIT_TOOLS.REMOVE) {
                        try {
                            removePointFromMultiPoint(feature, pointIndex, marker, highZoomShape);
                        } catch(err) { console.error('Remove MultiPoint shape error:', err); }
                        e.stopPropagation && e.stopPropagation();
                        return;
                    }
                    // View mode: show popup
                    if (currentMode !== MODES.EDIT) {
                        try {
                            const popupContent = createFeaturePopupContent(feature);
                            highZoomShape.bindPopup(popupContent).openPopup(e.latlng);
                        } catch(_) {}
                        e.stopPropagation && e.stopPropagation();
                        return;
                    }
                    // Edit mode + Properties tool: open modal
                    if (currentTool === EDIT_TOOLS.PROPERTIES) {
                        openPropertiesModal(feature);
                        e.stopPropagation && e.stopPropagation();
                        return;
                    }
                    // Edit mode + Select or Vertex tool: enable point dragging
                    if (currentTool === EDIT_TOOLS.SELECT || currentTool === EDIT_TOOLS.VERTEX) {
                        enablePointEditing(highZoomShape, feature);
                        e.stopPropagation && e.stopPropagation();
                        return;
                    }
                });
                
                pointLayer.addLayer(highZoomShape);
            });
        }
        
        function processPolygonFeature(feature, useClustering = false) {
            // Validate feature has valid geometry before processing
            if (!feature || !feature.geometry || !feature.geometry.type || !feature.geometry.coordinates) {
                const persistentId = (feature && typeof feature.__persistentId === 'number') ? feature.__persistentId : 'unknown';
                console.warn(`Skipping feature with invalid geometry. Persistent ID: ${persistentId}`, feature);
                return;
            }
            
            // Validate coordinates structure based on geometry type
            const coords = feature.geometry.coordinates;
            if (feature.geometry.type === 'Polygon') {
                if (!Array.isArray(coords) || coords.length === 0 || !Array.isArray(coords[0]) || coords[0].length < 4) {
                    const persistentId = typeof feature.__persistentId === 'number' ? feature.__persistentId : 'unknown';
                    console.warn(`Skipping Polygon feature with invalid coordinates. Persistent ID: ${persistentId}`, feature);
                    return;
                }
            } else if (feature.geometry.type === 'MultiPolygon') {
                if (!Array.isArray(coords) || coords.length === 0) {
                    const persistentId = typeof feature.__persistentId === 'number' ? feature.__persistentId : 'unknown';
                    console.warn(`Skipping MultiPolygon feature with empty coordinates. Persistent ID: ${persistentId}`, feature);
                    return;
                }
                // Check that at least one polygon is valid
                let hasValidPoly = false;
                for (const poly of coords) {
                    if (Array.isArray(poly) && poly.length > 0 && Array.isArray(poly[0]) && poly[0].length >= 4) {
                        hasValidPoly = true;
                        break;
                    }
                }
                if (!hasValidPoly) {
                    const persistentId = typeof feature.__persistentId === 'number' ? feature.__persistentId : 'unknown';
                    console.warn(`Skipping MultiPolygon feature with all invalid polygons. Persistent ID: ${persistentId}`, feature);
                    return;
                }
            }
            
            // Create the polygon
            const geoJSONLayer = L.geoJSON(feature, {
                style: function() {
                    return {
                        fillColor: '#3388ff',
                        weight: 2,
                        opacity: 0.8,
                        color: '#3388ff',
                        fillOpacity: 0.15,
                        fillRule: 'nonzero'
                    };
                },
                onEachFeature: function(feature, layer) {
                    // Setup editing/interaction; bind popup in view mode only
                    setupFeatureInteraction(layer, feature);
                    layer.on('click', function(e) {
                        if (currentMode !== MODES.EDIT) {
                            const popupContent = createFeaturePopupContent(feature);
                            layer.bindPopup(popupContent).openPopup(e.latlng);
                        } else {
                            if (layer.getPopup()) layer.unbindPopup();
                        }
                        // Stop propagation to prevent map empty-click deselection
                        if (e && e.originalEvent) { try { L.DomEvent && L.DomEvent.stop ? L.DomEvent.stop(e.originalEvent) : (e.originalEvent.stopPropagation && e.originalEvent.stopPropagation()); } catch(_) {} }
                        if (e && e.stopPropagation) e.stopPropagation();
                    });
                }
            });
            
            // Add polygon to the polygon layer
            polygonLayer.addLayer(geoJSONLayer);
            
            // Calculate centroid for marker representation
            try {
                let centroid;
                if (feature.geometry.type === 'Polygon') {
                    centroid = calculatePolygonCentroid(feature.geometry.coordinates[0]);
                } else if (feature.geometry.type === 'MultiPolygon') {
                    // For simplicity, use the first polygon's centroid
                    centroid = calculatePolygonCentroid(feature.geometry.coordinates[0][0]);
                }
                
                if (centroid) {
                    // Create a marker at the centroid
                    const marker = L.marker([centroid[1], centroid[0]]);
                    
                    // Add popup with feature properties
                    const popupContent = createFeaturePopupContent(feature);
                    marker.bindPopup(popupContent);
                    // Tag marker with feature reference for removal later
                    marker.feature = feature;
                    
                    // Add click handler for removal
                    marker.on('click', function(e) {
                        if (currentTool === EDIT_TOOLS.REMOVE) {
                            try {
                                removeFeature(feature);
                            } catch(err) { console.error('Remove polygon marker error:', err); }
                            e.stopPropagation && e.stopPropagation();
                            return;
                        }
                    });
                    
                    // Add to appropriate layer (cluster group for large datasets, regular layer otherwise)
                    if (useClustering) {
                        combinedClusterGroup.addLayer(marker);
                    } else {
                        polygonMarkerLayer.addLayer(marker);
                    }
                }
            } catch (e) {
                console.error('Error creating centroid:', e);
            }
        }
        
        function calculatePolygonCentroid(coordinates) {
            // Simple centroid calculation for a polygon
            if (!coordinates || coordinates.length === 0) return null;
            
            let x = 0;
            let y = 0;
            let numPoints = 0;
            
            for (let i = 0; i < coordinates.length; i++) {
                x += coordinates[i][0];
                y += coordinates[i][1];
                numPoints++;
            }
            
            return [x / numPoints, y / numPoints];
        }
        
        // Escapes text for safe HTML insertion in popups
        function escapeHtml(unsafeText) {
            if (unsafeText === null || unsafeText === undefined) return '';
            return String(unsafeText)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        // Formats property values into readable strings before escaping
        function formatPropertyValue(value) {
            if (value === null || value === undefined) return '';
            const valueType = typeof value;
            if (valueType === 'string' || valueType === 'number' || valueType === 'boolean') {
                return String(value);
            }
            try {
                return JSON.stringify(value);
            } catch (e) {
                return String(value);
            }
        }

        // Validates if a string is a safe, clickable URL
        function isValidUrl(value) {
            if (!value || typeof value !== 'string') return false;
            
            const trimmed = value.trim();
            
            // Quick check for http/https prefix
            if (!trimmed.startsWith('http://') && !trimmed.startsWith('https://')) {
                return false;
            }
            
            // Validate URL structure using URL constructor
            try {
                const url = new URL(trimmed);
                // Additional security: only allow http and https protocols
                if (url.protocol !== 'http:' && url.protocol !== 'https:') {
                    return false;
                }
                return true;
            } catch (e) {
                return false;
            }
        }

        // Creates a secure clickable link with proper attributes
        function createSafeLink(url) {
            // Double-check URL validity
            if (!isValidUrl(url)) {
                return escapeHtml(url);
            }
            
            const trimmedUrl = url.trim();
            
            // Escape the URL for safe insertion in href attribute
            // encodeURI handles special characters while preserving URL structure
            const safeHref = encodeURI(trimmedUrl);
            
            // For display, show truncated version if URL is very long
            let displayText = trimmedUrl;
            if (trimmedUrl.length > 50) {
                displayText = trimmedUrl.substring(0, 47) + '...';
            }
            
            // Escape the display text for safe HTML insertion
            const safeDisplayText = escapeHtml(displayText);
            
            // Create link with security attributes:
            // - target="_blank": opens in new tab
            // - rel="noopener noreferrer": prevents window.opener access and referrer leaking
            return `<a href="${safeHref}" target="_blank" rel="noopener noreferrer">${safeDisplayText}</a>`;
        }

        function createFeaturePopupContent(feature) {
            const properties = (feature && feature.properties) || {};
            const idx = (feature && typeof feature.__persistentId === 'number') ? feature.__persistentId : '';
            const geometryType = (feature && feature.geometry && feature.geometry.type) ? feature.geometry.type : 'Unknown';
            let content = '<div class="info-box">';
            content += `<div class="info-title">Feature ${escapeHtml(String(idx))} - ${escapeHtml(geometryType)}</div>`;
            content += '<div class="info-content">';
            for (const key in properties) {
                if (Object.prototype.hasOwnProperty.call(properties, key)) {
                    const value = properties[key];
                    const safeKey = escapeHtml(key);
                    
                    // Format the value first
                    const formattedValue = formatPropertyValue(value);
                    
                    // Check if the formatted value is a valid URL
                    let safeValue;
                    if (isValidUrl(formattedValue)) {
                        // Create a clickable link for valid URLs
                        safeValue = createSafeLink(formattedValue);
                    } else {
                        // Escape as plain text for non-URLs
                        safeValue = escapeHtml(formattedValue);
                    }
                    
                    content += `<strong>${safeKey}:</strong> ${safeValue}<br>`;
                }
            }
            content += '</div></div>';
            return content;
        }
        
        function updateLayersByZoom() {
            if (!map) return;
            
            const zoom = map.getZoom();
            const featureCount = currentGeoJSON && currentGeoJSON.features ? currentGeoJSON.features.length : 0;
            const useClustering = featureCount >= CLUSTERING_FEATURE_LIMIT;
            
            // If zoomed out, we are either clustering or replacing polygons with point markers
            if (zoom <= CLUSTERING_LEVEL) {

                // If we are using clustering for dataset
                if (useClustering) {
                    // Disable normal layers first
                    if (map.hasLayer(polygonLayer)) map.removeLayer(polygonLayer);
                    if (map.hasLayer(pointLayer)) map.removeLayer(pointLayer);
                    if (map.hasLayer(pointMarkerLayer)) map.removeLayer(pointMarkerLayer);
                    if (map.hasLayer(polygonMarkerLayer)) map.removeLayer(polygonMarkerLayer);
                    if (validationOverlayGroup && map.hasLayer(validationOverlayGroup)) {
                        map.removeLayer(validationOverlayGroup);
                    }

                    // Now choose if we are doing validation or not
                    if (currentMode === MODES.VALIDATION){
                        // Zoomed out: show validation clusters, hide individual overlays and normal clusters
                        if (!map.hasLayer(validationClusterGroup)) map.addLayer(validationClusterGroup);
                        if (map.hasLayer(combinedClusterGroup)) map.removeLayer(combinedClusterGroup);
                        
                    } else {
                        // Show normal combined clustering, hide validation
                        if (!map.hasLayer(combinedClusterGroup)) map.addLayer(combinedClusterGroup);
                        if (validationClusterGroup && map.hasLayer(validationClusterGroup)) {
                            map.removeLayer(validationClusterGroup);
                        }
                    }
                    
                } else {
                    // Not using clustering, but show markers when zoomed out
                    // Disable cluster and normal layers first
                    if (map.hasLayer(combinedClusterGroup)) map.removeLayer(combinedClusterGroup);
                    if (validationClusterGroup && map.hasLayer(validationClusterGroup)) {
                        map.removeLayer(validationClusterGroup);
                    }
                    if (map.hasLayer(polygonLayer)) map.removeLayer(polygonLayer);
                    if (map.hasLayer(pointLayer)) map.removeLayer(pointLayer);
                    
                    if (currentMode === MODES.VALIDATION) {
                        // In validation mode, hide validation overlays when zoomed out (too cluttered)
                        if (validationOverlayGroup && map.hasLayer(validationOverlayGroup)) {
                            map.removeLayer(validationOverlayGroup);
                        }
                        // Show markers for navigation
                        if (!map.hasLayer(pointMarkerLayer)) map.addLayer(pointMarkerLayer);
                    if (!map.hasLayer(polygonMarkerLayer)) map.addLayer(polygonMarkerLayer);
                    } else {
                        // Normal mode: show markers and hide validation overlays
                        if (validationOverlayGroup && map.hasLayer(validationOverlayGroup)) {
                            map.removeLayer(validationOverlayGroup);
                        }
                        if (!map.hasLayer(pointMarkerLayer)) map.addLayer(pointMarkerLayer);
                        if (!map.hasLayer(polygonMarkerLayer)) map.addLayer(polygonMarkerLayer);
                    }
                    
                }

            } else {
                // We are zoomed in
                // Remove clustering and Marker layers if exists
                if (map.hasLayer(combinedClusterGroup)) map.removeLayer(combinedClusterGroup);
                if (map.hasLayer(polygonMarkerLayer)) map.removeLayer(polygonMarkerLayer);
                if (map.hasLayer(pointMarkerLayer)) map.removeLayer(pointMarkerLayer);

                if (currentMode === MODES.VALIDATION){
                    // Show Validation overlay when zoomed in
                    if (validationOverlayGroup && !map.hasLayer(validationOverlayGroup)) {
                       map.addLayer(validationOverlayGroup);
                    }
                    // Hide validation clusters
                    if (validationClusterGroup && map.hasLayer(validationClusterGroup)) {
                       map.removeLayer(validationClusterGroup);
                    }
                } else {
                    // Hide validation overlays in non-validation modes
                    if (validationOverlayGroup && map.hasLayer(validationOverlayGroup)) {
                       map.removeLayer(validationOverlayGroup);
                    } 
                    if (validationClusterGroup && map.hasLayer(validationClusterGroup)) {
                       map.removeLayer(validationClusterGroup);
                    }
                    // Show normal layers
                    if (!map.hasLayer(polygonLayer)) map.addLayer(polygonLayer);
                    if (!map.hasLayer(pointLayer)) map.addLayer(pointLayer);
                }

            }

            
        }
        
        function updateCircleRadii() { /* no-op: points no longer scaled by area */ }




        

        // Simple legend for GeoJSON features
        function updateLegend() {
            const legendItems = document.getElementById('legend-items');
            
            // Clear existing legend items
            legendItems.innerHTML = '';
            
            // Add polygon legend item
            const polygonLegendItem = document.createElement('div');
            polygonLegendItem.className = 'legend-item';
            
            const polygonColorBox = document.createElement('div');
            polygonColorBox.className = 'legend-color';
            polygonColorBox.style.border = '2px solid #3388ff';
            polygonColorBox.style.backgroundColor = 'transparent';
            
            const polygonLabel = document.createElement('span');
            polygonLabel.textContent = getText('plotBoundary');
            
            polygonLegendItem.appendChild(polygonColorBox);
            polygonLegendItem.appendChild(polygonLabel);
            legendItems.appendChild(polygonLegendItem);
        }

        // ========================================
        // MODE MANAGEMENT SYSTEM
        // ========================================
        
        // Mode constants
        const MODES = {
            VIEW: 'view',
            EDIT: 'edit',
            VALIDATION: 'validation'
        };
        
        // Edit mode tools
        const EDIT_TOOLS = {
            SELECT: 'select',
            VERTEX: 'vertex',
            PROPERTIES: 'properties',
            ADD_POLYGON: 'add-polygon',
            ADD_POINT: 'add-point',
            REMOVE: 'remove'
        };
        
        // Current mode and tool state
        let currentMode = MODES.VIEW;
        
        /**
         * Central mode switching function - handles all mode transitions
         */
        function switchMode(newMode, newTool = null) {
            
            // Stop any active polygon drawing when switching modes
            if (typeof window.__stopPolygonDrawing === 'function') {
                window.__stopPolygonDrawing();
            }
            
            // Deselect any currently selected features when switching modes
            if (typeof disableVertexEditing === 'function') {
                disableVertexEditing();
            }
            if (typeof disablePointEditing === 'function') {
                disablePointEditing();
            }
            selectedFeature = null;
            
            // Close any open popups when switching modes
            if (map && typeof map.closePopup === 'function') {
                map.closePopup();
            }
            
            // Always clear hint and re-enable map dragging when switching modes/tools
            // Individual tools will set their own hints and disable dragging if needed
            setHint('');
            if (map && map.dragging && map.dragging.enable) {
                map.dragging.enable();
            }
            
            // Clean up when exiting validation mode
            if (currentMode === MODES.VALIDATION && newMode !== MODES.VALIDATION) {
                // Close validation progress if open
                if (typeof closeValidationProgress === 'function') {
                    closeValidationProgress();
                }
                // Hide validation navigator control
                if (typeof hideValidationNavigator === 'function') {
                    hideValidationNavigator();
                }
                // Clear validation overlays
                if (validationOverlayGroup) {
                    validationOverlayGroup.clearLayers();
                    if (map.hasLayer(validationOverlayGroup)) {
                        map.removeLayer(validationOverlayGroup);
                    }
                }
                if (validationClusterGroup) {
                    validationClusterGroup.clearLayers();
                    if (map.hasLayer(validationClusterGroup)) {
                        map.removeLayer(validationClusterGroup);
                    }
                }
            }
            
            // Update mode
            currentMode = newMode;
            
            // Handle tool selection based on mode
            if (newMode === MODES.VIEW || newMode === MODES.VALIDATION) {
                currentTool = null;
            } else if (newMode === MODES.EDIT) {
                currentTool = newTool || EDIT_TOOLS.SELECT;
            }
            
            // Special handling for validation mode
            if (newMode === MODES.VALIDATION) {
                // Always start validation (user can choose to use previous results via button in progress dialog)
                stageValidateGeometries({});
            }
            
            // Update button states
            const viewBtn = document.getElementById('btn-pan-mode');
            const editBtn = document.getElementById('btn-edit-mode');
            const validateBtn = document.getElementById('btn-validate-mode');
            
            if (viewBtn) viewBtn.classList.toggle('active', currentMode === MODES.VIEW);
            if (editBtn) editBtn.classList.toggle('active', currentMode === MODES.EDIT);
            if (validateBtn) validateBtn.classList.toggle('active', currentMode === MODES.VALIDATION);
            
            // Update tool button states
            updateToolButtonStates();
            
            // Setup interactions based on new mode and tool
            setupInteraction();
            
            // Update layers
            updateLayersByZoom();
        }
        
        // Editing functionality
        let currentTool = EDIT_TOOLS.SELECT;
        let selectedFeature = null;
        let snapEnabled = false;
        let snapRadius = 10;
        
        /**
         * Set or clear the tool hint message
         */
        function setHint(text) {
            const hintEl = document.getElementById('tool-hint');
            if (!hintEl) return;
            if (text) { 
                hintEl.textContent = text; 
                hintEl.style.display = 'block'; 
            } else { 
                hintEl.textContent = ''; 
                hintEl.style.display = 'none'; 
            }
        }
        
        
        /**
         * Update tool button states based on current tool
         */
        function updateToolButtonStates() {
            if (currentMode !== MODES.EDIT) {
                // Clear all tool button states when not in edit mode
                const toolButtons = ['btn-select-tool', 'btn-vertex-tool', 'btn-properties-tool', 
                                   'btn-add-point', 'btn-add-polygon', 'btn-remove-feature'];
                toolButtons.forEach(btnId => {
                    const btn = document.getElementById(btnId);
                    if (btn) btn.classList.remove('active');
                });
                return;
            }
            
            // Update tool button states for edit mode
            document.getElementById('btn-select-tool').classList.toggle('active', currentTool === EDIT_TOOLS.SELECT);
            document.getElementById('btn-vertex-tool').classList.toggle('active', currentTool === EDIT_TOOLS.VERTEX);
            document.getElementById('btn-properties-tool').classList.toggle('active', currentTool === EDIT_TOOLS.PROPERTIES);
            document.getElementById('btn-add-point').classList.toggle('active', currentTool === EDIT_TOOLS.ADD_POINT);
            document.getElementById('btn-add-polygon').classList.toggle('active', currentTool === EDIT_TOOLS.ADD_POLYGON);
            document.getElementById('btn-remove-feature').classList.toggle('active', currentTool === EDIT_TOOLS.REMOVE);
        }
        
        /**
         * Main interaction setup function - manages all map and feature interactions
         * based on current mode and tool state
         */
        function setupInteraction() {
            // Remove all existing map event listeners to prevent duplicates
            // Note: contextmenu is NOT removed here - it's set up once in initializeMap() and remains active
            map.off('click');
            map.off('mousedown');
            map.off('mouseup');
            
            // Setup interactions based on current mode and tool
            setupMapInteraction();
            
            // Setup specialized interactions for specific modes/tools
            if (currentMode === MODES.EDIT) {
                if (currentTool === EDIT_TOOLS.ADD_POLYGON) {
                    setupDrawingInteraction();
                } else if (currentTool === EDIT_TOOLS.VERTEX) {
                    setupEditingInteraction();
                }
            }
        }
        
        /**
         * Setup map-level interactions (clicks, context menu, mouse events)
         */
        function setupMapInteraction() {
            // Set cursor based on current tool
            if (currentTool === EDIT_TOOLS.ADD_POINT || currentTool === EDIT_TOOLS.ADD_POLYGON) {
                setCursorCrosshair(true);
            } else {
                setCursorCrosshair(false);
            }
            // Map-level handlers for adding new features
            map.on('click', function(e) {
                if (currentTool === EDIT_TOOLS.ADD_POINT) {
                    const pt = { type: 'Feature', properties: {}, geometry: { type: 'Point', coordinates: [e.latlng.lng, e.latlng.lat] } };
                    ensureFeatureId(pt);
                    if (currentGeoJSON && currentGeoJSON.features) {
                        const newIndex = currentGeoJSON.features.length;
                        currentGeoJSON.features.push(pt);
                        pushUndoSnapshot(EDIT_TOOLS.ADD_POINT, newIndex, 'add');
                        
                        // Note: We intentionally do NOT clear __lastValidationStore here.
                        // New features won't have validation overlays (correct - they weren't validated)
                        
                        // Efficient addition: only process the new feature
                        const newFeatureCount = currentGeoJSON.features.length;
                        const oldFeatureCount = newFeatureCount - 1;
                        const shouldUseClustering = newFeatureCount >= CLUSTERING_FEATURE_LIMIT;
                        const wasUseClustering = oldFeatureCount >= CLUSTERING_FEATURE_LIMIT;
                        
                        if (wasUseClustering !== shouldUseClustering) {
                            // Crossed threshold - need to rebuild everything
                            processGeoJSON(currentGeoJSON, true);
                        } else {
                            // Just add the new feature without rebuilding everything
                            processPointFeature(pt, shouldUseClustering);
                            // Update layers if needed based on current zoom
                            if (shouldUseClustering && combinedClusterGroup && map.hasLayer(combinedClusterGroup)) {
                                // Cluster is visible - force redraw to update counts
                                map.removeLayer(combinedClusterGroup);
                                map.addLayer(combinedClusterGroup);
                            }
                        }
                    }
                    // Reset UI: hide hint, select & edit tool
                    const hintEl = document.getElementById('tool-hint');
                    if (hintEl) { hintEl.textContent = ''; hintEl.style.display = 'none'; }
                    setEditingTool(EDIT_TOOLS.SELECT);
                    setCursorCrosshair(false);
                    if (map && map.dragging && map.dragging.enable) map.dragging.enable();
                    return;
                }
            });

            // Empty-map click: in Edit mode, clear current polygon/point selection if not clicking a feature
            map.on('click', function(e) {
                try {
                    if (currentMode !== MODES.EDIT) return;
                    // Do not clear selection while add polygon/point or remove action is active
                    if (currentTool === EDIT_TOOLS.ADD_POINT || currentTool === EDIT_TOOLS.ADD_POLYGON || currentTool === EDIT_TOOLS.REMOVE) return;
                    // Skip clearing right after vertex drag/snapping concludes
                    if (__draggingVertexActive || __suppressEmptyDeselect) return;
                    // If click originated on an interactive layer/marker, ignore (not an empty map click)
                    const oe = e && e.originalEvent ? e.originalEvent : null;
                    if (oe) {
                        // If already stopped upstream, ignore
                        if (oe._stopped || oe.defaultPrevented) return;
                        const t = oe.target;
                        if (t && t.classList) {
                            const cls = t.classList;
                            if (cls.contains('leaflet-interactive') || cls.contains('leaflet-marker-icon') || cls.contains('vertex-marker') || cls.contains('edge-marker')) {
                                return;
                            }
                        }
                    }
                    if (isEditingVertices) disableVertexEditing();
                    if (typeof disablePointEditing === 'function') disablePointEditing();
                } catch (_) {}
            });

            // Note: Right-click to copy coordinates is set up once in initializeMap() and remains active

            // Enable middle-mouse panning in all modes
            let middlePanActive = false;
            let middlePanWasDisabled = false;
            map.on('mousedown', function(e) {
                const oe = e.originalEvent || {};
                if (oe.button === 1) { // Middle mouse button
                    try {
                        oe.preventDefault && oe.preventDefault();
                        oe.stopPropagation && oe.stopPropagation();
                    } catch (_) {}
                    // Only enable dragging if it was disabled; remember previous state
                    middlePanWasDisabled = !(map.dragging && map.dragging.enabled && map.dragging.enabled());
                    if (middlePanWasDisabled && map.dragging && map.dragging.enable) map.dragging.enable();
                    middlePanActive = true;
                    // Manually kick off Leaflet's drag handler so the pan starts immediately
                    try {
                        if (map.dragging && map.dragging._draggable && typeof map.dragging._draggable._onDown === 'function') {
                            map.dragging._draggable._onDown(oe);
                        }
                    } catch (err) {
                        console.warn('Middle-pan start error', err);
                    }
                }
            });
            map.on('mouseup', function() {
                if (middlePanActive) {
                    // Restore dragging state only if we enabled it for middle-pan
                    if (middlePanWasDisabled && map.dragging && map.dragging.disable) map.dragging.disable();
                    middlePanActive = false;
                    middlePanWasDisabled = false;
                }
            });
        }
        
        /**
         * Setup polygon drawing interactions
         */
        function setupDrawingInteraction() {
            // Start polygon drawing if not already active
            if (!drawingPolygon) {
                startPolygonDrawing();
            }
            // Ensure crosshair cursor is set for drawing mode
            setCursorCrosshair(true);
        }
        
        /**
         * Setup vertex/edge editing interactions
         */
        function setupEditingInteraction() {
            // Vertex and edge editing interactions are handled by the existing
            // onVertexClick and onEdgeClick functions when markers are created
            // This function ensures the editing state is properly initialized
            // The actual event binding happens in createVertexMarker() and createEdgeMarker()
        }
        
        // Point relocation editing state
        let isEditingPoint = false;
        let editingPointMarker = null;
        let editingPointFeature = null;

        function enablePointEditing(circleMarker, feature) {
            try {
                // Always disable any existing editing first
                if (editingPointMarker) {
                    disablePointEditing();
                }
                
                // Change to orange to indicate editing mode
                circleMarker.setStyle({
                    color: '#ff7800',
                    weight: 3,
                    fillColor: '#ff7800',
                    fillOpacity: 0.8,
                    radius: 8  // Make it larger when editing
                });
                
                // Implement manual dragging for circles
                let isDragging = false;
                let hasStarted = false;
                
                const onMouseDown = function(e) {
                    if (e.originalEvent.button !== 0) return; // Only left click
                    isDragging = true;
                    hasStarted = false;
                    map.dragging.disable();
                    e.originalEvent.preventDefault();
                    L.DomEvent.stopPropagation(e);
                };
                
                const onMouseMove = function(e) {
                    if (isDragging) {
                        if (!hasStarted) {
                            pushUndoSnapshot('point-drag', feature, 'edit');
                            hasStarted = true;
                        }
                        circleMarker.setLatLng(e.latlng);
                        
                        // Update coordinates based on geometry type
                        if (feature.geometry.type === 'Point') {
                            // For Point: coordinates is [lng, lat]
                            feature.geometry.coordinates = [e.latlng.lng, e.latlng.lat];
                        } else if (feature.geometry.type === 'MultiPoint') {
                            // For MultiPoint: coordinates is [[lng1, lat1], [lng2, lat2], ...]
                            // Use pointIndex to update the correct point
                            const pointIndex = circleMarker.pointIndex || 0;
                            if (feature.geometry.coordinates[pointIndex]) {
                                feature.geometry.coordinates[pointIndex] = [e.latlng.lng, e.latlng.lat];
                            }
                        }
                        
                        // Also update the marker position if it exists
                        if (circleMarker.marker) {
                            circleMarker.marker.setLatLng(e.latlng);
                        }
                    }
                };
                
                const onMouseUp = function(e) {
                    if (isDragging) {
                        isDragging = false;
                        map.dragging.enable();
                    }
                };
                
                circleMarker.on('mousedown', onMouseDown);
                map.on('mousemove', onMouseMove);
                map.on('mouseup', onMouseUp);
                
                // Store cleanup functions
                circleMarker._pointEditCleanup = function() {
                    // Re-enable map dragging in case it was left disabled
                    if (map && map.dragging) {
                        map.dragging.enable();
                    }
                    // Remove event handlers
                    circleMarker.off('mousedown', onMouseDown);
                    map.off('mousemove', onMouseMove);
                    map.off('mouseup', onMouseUp);
                };
                
                isEditingPoint = true;
                editingPointMarker = circleMarker;
                editingPointFeature = feature;
            } catch(err) { console.warn('Enable point edit failed', err); }
        }

        function disablePointEditing() {
            if (!editingPointMarker) return;
            try {
                // Clean up manual dragging event handlers FIRST
                if (editingPointMarker._pointEditCleanup) {
                    editingPointMarker._pointEditCleanup();
                    delete editingPointMarker._pointEditCleanup;
                }
                
                // Restore default style for circle/circleMarker
                editingPointMarker.setStyle({
                    color: '#3388ff',
                    weight: 1,
                    fillColor: '#3388ff',
                    fillOpacity: 0.9,
                    radius: 6  // Restore original radius
                });
            } catch(err) { console.warn('Disable point edit failed', err); }
            
            // Clear state AFTER cleanup
            isEditingPoint = false;
            editingPointMarker = null;
            editingPointFeature = null;
        }


        function initializeEditingControls() {
            // Mode switching
            document.getElementById('btn-pan-mode').addEventListener('click', () => switchMode(MODES.VIEW));
            document.getElementById('btn-edit-mode').addEventListener('click', () => {
                switchMode(MODES.EDIT, EDIT_TOOLS.SELECT);
                setHint(getText('selectToolHint'));
            });
            document.getElementById('btn-validate-mode').addEventListener('click', () => {
                if (currentMode === MODES.VALIDATION) {
                    // Exit validation mode
                    switchMode(MODES.VIEW);
                } else {
                    // Enter validation mode - switchMode will trigger validation
                    switchMode(MODES.VALIDATION);
                }
            });
            
            // Tool switching
            document.getElementById('btn-select-tool').addEventListener('click', () => {
                switchMode(MODES.EDIT, EDIT_TOOLS.SELECT);
                setHint(getText('selectToolHint'));
            });
            
            document.getElementById('btn-vertex-tool').addEventListener('click', () => {
                switchMode(MODES.EDIT, EDIT_TOOLS.VERTEX);
                setHint(getText('vertexToolHint'));
            });
            
            document.getElementById('btn-properties-tool').addEventListener('click', () => {
                switchMode(MODES.EDIT, EDIT_TOOLS.PROPERTIES);
                setHint(getText('propertiesToolHint'));
            });

            // Feature action buttons
            document.getElementById('btn-remove-feature').addEventListener('click', () => {
                if (currentTool === EDIT_TOOLS.REMOVE) {
                    // Toggle off - return to SELECT tool
                    switchMode(MODES.EDIT, EDIT_TOOLS.SELECT);
                    setHint(getText('selectToolHint'));
                } else {
                    // Activate remove mode
                    switchMode(MODES.EDIT, EDIT_TOOLS.REMOVE);
                    setHint(getText('removeModeHint'));
                }
            });
            
            document.getElementById('btn-add-point').addEventListener('click', () => {
                if (currentTool === EDIT_TOOLS.ADD_POINT) {
                    // Toggle off - return to SELECT tool
                    switchMode(MODES.EDIT, EDIT_TOOLS.SELECT);
                    setHint(getText('selectToolHint'));
                } else {
                    // Activate add point mode
                    switchMode(MODES.EDIT, EDIT_TOOLS.ADD_POINT);
                    setHint(getText('addPointHint'));
                    if (map && map.dragging && map.dragging.disable) map.dragging.disable();
                }
            });
            
            document.getElementById('btn-add-polygon').addEventListener('click', () => {
                if (currentTool === EDIT_TOOLS.ADD_POLYGON) {
                    // Toggle off - return to SELECT tool
                    if (typeof window.__stopPolygonDrawing === 'function') window.__stopPolygonDrawing();
                    switchMode(MODES.EDIT, EDIT_TOOLS.SELECT);
                    setHint(getText('selectToolHint'));
                } else {
                    // Activate add polygon mode
                    switchMode(MODES.EDIT, EDIT_TOOLS.ADD_POLYGON);
                    setHint(getText('addPolygonHint'));
                    if (map && map.dragging && map.dragging.disable) map.dragging.disable();
                }
            });
            
            document.getElementById('btn-export').addEventListener('click', showExportModal);
            // Auto-Clean button
            const autoCleanBtn = document.getElementById('btn-auto-clean');
            if (autoCleanBtn) {
                autoCleanBtn.addEventListener('click', () => {
                    // Clear any current selection/edit state and disable validation UI
                    if (typeof resetEditingAndSelectionState === 'function') resetEditingAndSelectionState();
                    if (typeof deactivateGeometryValidation === 'function') deactivateGeometryValidation(true);
                    openAutoCleanModal();
                });
            }
            
            // Snap controls
            document.getElementById('snap-enabled').addEventListener('change', (e) => {
                snapEnabled = e.target.checked;
            });
            
            document.getElementById('snap-radius').addEventListener('input', (e) => {
                snapRadius = parseInt(e.target.value);
                document.getElementById('snap-radius-value').textContent = snapRadius;
            });

            // Ensure snap controls start at defaults on initial UI setup
            if (typeof resetSnapControlsToDefaults === 'function') {
                resetSnapControlsToDefaults();
            }
        }


        // Auto-Clean modal helpers
        function openAutoCleanModal() {
            const modal = document.getElementById('autoCleanModal');
            if (modal) modal.classList.add('show');
        }
        function closeAutoCleanModal() {
            const modal = document.getElementById('autoCleanModal');
            if (modal) modal.classList.remove('show');
        }
        
        /**
         * Open the validation report modal with validation results
         * @param {Object} validationData - Object containing all validation statistics
         */
        function openValidationReportModal(validationData) {
            const modal = document.getElementById('validationReportModal');
            if (!modal) return;
            
            // Show/hide warning box for unsupported geometry types
            const hasUnsupportedGeometry = validationData.unsupportedTypes && validationData.unsupportedTypes.length > 0;
            const warningBox = document.getElementById('validation-warning-unsupported');
            if (warningBox) {
                warningBox.style.display = hasUnsupportedGeometry ? 'block' : 'none';
            }
            
            // Show/hide success box
            const successBox = document.getElementById('validation-success-box');
            if (successBox) {
                successBox.style.display = (!validationData.hasIssues && !hasUnsupportedGeometry) ? 'block' : 'none';
            }
            
            // Populate overall statistics
            document.getElementById('val-total-features').textContent = validationData.totalFeatures || 0;
            document.getElementById('val-valid-features').textContent = validationData.validFeatures || 0;
            
            const featuresWithIssuesEl = document.getElementById('val-features-with-issues');
            const issuesCount = validationData.featuresWithIssues || 0;
            featuresWithIssuesEl.textContent = issuesCount;
            featuresWithIssuesEl.className = 'validation-stat-value ' + (issuesCount > 0 ? 'danger' : 'success');
            
            // Populate issue breakdown
            const invalidGeomEl = document.getElementById('val-invalid-geometries');
            const invalidCount = validationData.invalidGeometries || 0;
            invalidGeomEl.textContent = invalidCount;
            invalidGeomEl.className = 'validation-stat-value ' + (invalidCount > 0 ? 'danger' : '');
            
            const duplicateVerticesEl = document.getElementById('val-duplicate-vertices');
            const dupVertCount = validationData.duplicateVertices || 0;
            duplicateVerticesEl.textContent = dupVertCount;
            duplicateVerticesEl.className = 'validation-stat-value ' + (dupVertCount > 0 ? 'danger' : '');
            
            const duplicatesEl = document.getElementById('val-duplicates');
            const dupCount = (validationData.duplicates || 0) + (validationData.duplicatePoints || 0);
            duplicatesEl.textContent = dupCount;
            duplicatesEl.className = 'validation-stat-value ' + (dupCount > 0 ? 'warning' : '');
            
            const selfIntEl = document.getElementById('val-self-intersections');
            const selfIntCount = validationData.selfIntersections || 0;
            selfIntEl.textContent = selfIntCount;
            selfIntEl.className = 'validation-stat-value ' + (selfIntCount > 0 ? 'danger' : '');
            
            const holesEl = document.getElementById('val-holes');
            const holesCount = validationData.holes || 0;
            holesEl.textContent = holesCount;
            holesEl.className = 'validation-stat-value ' + (holesCount > 0 ? 'warning' : '');
            
            const sliversEl = document.getElementById('val-slivers');
            const sliversCount = validationData.slivers || 0;
            sliversEl.textContent = sliversCount;
            sliversEl.className = 'validation-stat-value ' + (sliversCount > 0 ? 'warning' : '');
            
            const overlapsEl = document.getElementById('val-overlaps');
            const overlapsCount = validationData.overlaps || 0;
            overlapsEl.textContent = overlapsCount;
            overlapsEl.className = 'validation-stat-value ' + (overlapsCount > 0 ? 'warning' : '');
            
            // Show the modal
            modal.classList.add('show');
        }
        
        /**
         * Close the validation report modal
         */
        function closeValidationReportModal() {
            const modal = document.getElementById('validationReportModal');
            if (modal) modal.classList.remove('show');
        }
        
        // Deselect any active selection/edit state and disable validation overlay/button
        function resetEditingAndSelectionState() {
            try {
                if (typeof isEditingVertices !== 'undefined' && isEditingVertices) {
                    if (typeof disableVertexEditing === 'function') disableVertexEditing();
                }
                if (typeof disablePointEditing === 'function') disablePointEditing();
                if (typeof window.__stopPolygonDrawing === 'function') window.__stopPolygonDrawing();
                // Disarm transient actions; keep persistent tool selection intact
                try {
                    // Keep the currently selected tool active; only disarm transient actions
                    // ['btn-select-tool','btn-vertex-tool','btn-properties-tool'].forEach(id=>{ const el=document.getElementById(id); if (el) el.classList.remove('active'); });
                    // Button states are now handled by updateToolButtonStates()
                    setCursorCrosshair(false);
                    if (map && map.dragging && map.dragging.enable) map.dragging.enable();
                } catch (_) {}
                // Tool states are now handled by the centralized tool selection system
                // Preserve currentTool selection; do not clear it here
                const hintEl = document.getElementById('tool-hint'); if (hintEl) { hintEl.textContent=''; hintEl.style.display='none'; }
                if (typeof closePropertiesModal === 'function') {
                    try { closePropertiesModal(); } catch(_){ }
                }
            } catch (e) { console.warn('resetEditingAndSelectionState error', e); }
        }
        function deactivateGeometryValidation(disableButton = true) {
            try {
                if (typeof validationOverlayVisible !== 'undefined' && validationOverlayVisible) {
                    if (typeof validationOverlayGroup !== 'undefined' && validationOverlayGroup && typeof map !== 'undefined' && map) {
                        try { map.removeLayer(validationOverlayGroup); } catch(_){}
                    }
                    validationOverlayVisible = false;
                    validationOverlayGroup = null;
                }
                // Hide validation navigator control
                hideValidationNavigator();
                if (typeof closeValidationProgress === 'function') closeValidationProgress();
                
                // Switch back to VIEW mode if we're in VALIDATION mode
                if (currentMode === MODES.VALIDATION) {
                    currentMode = MODES.VIEW;
                    // Update all mode button states
                    const viewBtn = document.getElementById('btn-pan-mode');
                    const editBtn = document.getElementById('btn-edit-mode');
                    const validateBtn = document.getElementById('btn-validate-mode');
                    if (viewBtn) viewBtn.classList.add('active');
                    if (editBtn) editBtn.classList.remove('active');
                    if (validateBtn) validateBtn.classList.remove('active');
                    // Keep the validate button enabled so it's ready for new validation
                    if (validateBtn) validateBtn.removeAttribute('disabled');
                } else {
                    // Just update validate button if not in validation mode
                    const vbtn = document.getElementById('btn-validate-mode');
                if (vbtn) {
                    vbtn.classList.remove('active');
                    vbtn.removeAttribute('disabled');
                    }
                }
            } catch (e) { console.warn('deactivateGeometryValidation error', e); }
        }
        function openAutoCleanProgress() {
            const pm = document.getElementById('autoCleanProgressModal');
            const bar = document.getElementById('ac-progress');
            const stage = document.getElementById('ac-stage');
            if (bar) bar.style.width = '0%';
            if (stage) stage.textContent = getText('preparing');
            if (pm) pm.classList.add('show');
        }
        function closeAutoCleanProgress() {
            const pm = document.getElementById('autoCleanProgressModal');
            if (pm) pm.classList.remove('show');
        }

        // Cancellation flag
        let __autoCleanCancelled = false;

        function cancelAutoClean() {
            __autoCleanCancelled = true;
        }

        function readAutoCleanOptions() {
            return {
                validate: document.getElementById('ac-validate')?.checked || false,
                duplicates: document.getElementById('ac-duplicates')?.checked || false,
                selfIntersect: document.getElementById('ac-selfintersect')?.checked || false,
                holes: document.getElementById('ac-holes')?.checked || false,
                collinear: document.getElementById('ac-collinear')?.checked || false,
                overlap: document.getElementById('ac-overlap')?.checked || false,
                slivers: document.getElementById('ac-slivers')?.checked || false,
                smallpolygons: document.getElementById('ac-smallpolygons')?.checked || false,
                smallpolygonsArea: parseFloat(document.getElementById('ac-smallpolygons-area')?.value) || 10,
                pointsinpolygons: document.getElementById('ac-pointsinpolygons')?.checked || false,
            };
        }

        function setProgress(pct, label) {
            const bar = document.getElementById('ac-progress');
            const stage = document.getElementById('ac-stage');
            if (bar) bar.style.width = Math.max(0, Math.min(100, pct)) + '%';
            if (stage && label) stage.textContent = label;
        }

        // Validation modal helpers
        function openValidationProgress() {
            const pm = document.getElementById('validationProgressModal');
            const bar = document.getElementById('val-progress');
            const stage = document.getElementById('val-stage');
            const usePrevBtn = document.getElementById('val-use-previous-btn');
            
            if (bar) bar.style.width = '0%';
            if (stage) stage.textContent = getText('preparing');
            
            // Show "Use Previous Results" button only if previous results exist
            if (usePrevBtn) {
                usePrevBtn.style.display = (__lastValidationStore && __lastValidationStore.validatedFeatures) ? 'inline-block' : 'none';
            }
            
            if (pm) pm.classList.add('show');
        }
        function closeValidationProgress() {
            const pm = document.getElementById('validationProgressModal');
            if (pm) pm.classList.remove('show');
        }
        function setValidationProgress(pct, label) {
            const bar = document.getElementById('val-progress');
            const stage = document.getElementById('val-stage');
            if (bar) bar.style.width = Math.max(0, Math.min(100, pct)) + '%';
            if (stage && label) stage.textContent = label;
        }

        // Simulated async delay
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Global notification function - shows notifications with three levels: green, amber, red
        function showErrorNotification(message, level = 'amber') {
            try {
                // Ensure container exists (bottom-right, stacked)
                let container = document.getElementById('gr-toast-container');
                if (!container) {
                    container = document.createElement('div');
                    container.id = 'gr-toast-container';
                    container.style.position = 'fixed';
                    container.style.bottom = '16px';
                    container.style.right = '16px';
                    container.style.zIndex = '999999';
                    container.style.display = 'flex';
                    container.style.flexDirection = 'column';
                    container.style.alignItems = 'flex-end';
                    container.style.gap = '10px';
                    container.style.pointerEvents = 'none'; // allow map clicks except on toasts
                    document.body.appendChild(container);
                }

                // Build toast element
                const toast = document.createElement('div');
                toast.setAttribute('role', 'status');
                toast.setAttribute('aria-live', 'polite');
                toast.style.display = 'flex';
                toast.style.alignItems = 'flex-start';
                toast.style.gap = '10px';
                toast.style.padding = '10px 12px';
                toast.style.borderRadius = '8px';
                toast.style.boxShadow = '0 4px 16px rgba(0,0,0,0.15)';
                toast.style.fontSize = '14px';
                toast.style.maxWidth = '320px';
                toast.style.color = '#fff';
                toast.style.pointerEvents = 'auto';
                toast.style.opacity = '0';
                toast.style.transform = 'translateY(8px)';
                toast.style.transition = 'opacity 150ms ease, transform 150ms ease';

                // Color by level
                const lvl = (level || '').toString().toLowerCase();
                let bg = '#ff6b35', border = '#e55a2b';
                if (lvl === 'green' || lvl === 'success') { bg = '#28a745'; border = '#1e7e34'; }
                else if (lvl === 'red' || lvl === 'error') { bg = '#dc3545'; border = '#bd2130'; }
                toast.style.background = bg;
                toast.style.border = `1px solid ${border}`;

                // Message span (text only)
                const msg = document.createElement('span');
                msg.textContent = message;
                msg.style.whiteSpace = 'pre-wrap';
                msg.style.wordBreak = 'break-word';

                // Close button
                const closeBtn = document.createElement('button');
                closeBtn.type = 'button';
                closeBtn.setAttribute('aria-label', 'Dismiss');
                closeBtn.textContent = getText('closeButton');
                closeBtn.style.background = 'transparent';
                closeBtn.style.color = '#fff';
                closeBtn.style.border = 'none';
                closeBtn.style.fontSize = '18px';
                closeBtn.style.lineHeight = '1';
                closeBtn.style.cursor = 'pointer';
                closeBtn.style.padding = '0 2px';
                closeBtn.style.marginLeft = '2px';

                function removeToast() {
                    try {
                        toast.style.opacity = '0';
                        toast.style.transform = 'translateY(8px)';
                        setTimeout(() => { if (toast.parentElement) toast.parentElement.removeChild(toast); }, 160);
                    } catch(_) {}
                }
                closeBtn.addEventListener('click', function(e){ e.stopPropagation && e.stopPropagation(); removeToast(); });

                toast.appendChild(msg);
                toast.appendChild(closeBtn);
                container.appendChild(toast);

                // Animate in
                requestAnimationFrame(() => {
                    toast.style.opacity = '1';
                    toast.style.transform = 'translateY(0)';
                });

                // Auto-dismiss after 6s
                setTimeout(removeToast, 6000);
            } catch(_) {}
        }

        // Clipboard copy function for coordinates
        function copyCoordinatesToClipboard(lat, lng) {
            const coordinates = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            
            // Use the modern Clipboard API if available
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(coordinates).then(() => {
                    showErrorNotification(getText('coordinatesCopied', coordinates), 'green');
                }).catch(() => {
                    // Fallback to legacy method
                    fallbackCopyToClipboard(coordinates);
                });
            } else {
                // Fallback for older browsers or non-secure contexts
                fallbackCopyToClipboard(coordinates);
            }
        }

        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showErrorNotification(getText('coordinatesCopied', text), 'green');
                } else {
                    showErrorNotification(getText('coordinatesCopyFailed'), 'red');
                }
            } catch (err) {
                showErrorNotification(getText('coordinatesCopyFailed'), 'red');
            }
            
            document.body.removeChild(textArea);
        }

        
        
        async function stageRemoveDuplicates(options) {
            if (!currentGeoJSON || !currentGeoJSON.features) return;
            
            // Use the async findDuplicates function with progress updates
            const { uniqueFeatures, duplicateFeatures } = await findDuplicates(currentGeoJSON, (progress, message) => {
                setProgress(progress, message);
            });
            
            // Update current GeoJSON with unique features only
            currentGeoJSON.features = uniqueFeatures;
            
            // Allow UI to update
            await delay(0);
                if (__autoCleanCancelled) throw new Error('Auto-Clean cancelled');
            }
        
        async function stageRemoveCollinear(options, progressCallback = null) {
            if (!currentGeoJSON || !currentGeoJSON.features) return;
            const tol = 1e-12; // tolerance for collinearity check
            const features = currentGeoJSON.features;
            const total = features.length;
            for (let idx = 0; idx < features.length; idx++) {
                const f = features[idx];
                if (!f || !f.geometry) continue;
                try {
                    if (f.geometry.type === 'Polygon') {
                        const rings = f.geometry.coordinates || [];
                        const out = [];
                        for (let r = 0; r < rings.length; r++) {
                            let ring = rings[r];
                            if (!Array.isArray(ring) || ring.length < 4) { out.push(ring); continue; }
                            ring = __gr_removeConsecutiveDuplicates(ring); // Don't round - preserve coordinate precision
                            const cleaned = __gr_removeCollinear(ring, tol);
                            if (Array.isArray(cleaned) && cleaned.length >= 4) {
                                out.push(cleaned);
                            } else {
                                // keep original if cleaning would invalidate
                                out.push(ring);
                            }
                        }
                        f.geometry.coordinates = out;
                    } else if (f.geometry.type === 'MultiPolygon') {
                        const polys = f.geometry.coordinates || [];
                        const cleanedPolys = [];
                        for (let p = 0; p < polys.length; p++) {
                            const rings = polys[p] || [];
                            const out = [];
                            for (let r = 0; r < rings.length; r++) {
                                let ring = rings[r];
                                if (!Array.isArray(ring) || ring.length < 4) { out.push(ring); continue; }
                                ring = __gr_removeConsecutiveDuplicates(ring); // Don't round - preserve coordinate precision
                                const cleaned = __gr_removeCollinear(ring, tol);
                                if (Array.isArray(cleaned) && cleaned.length >= 4) {
                                    out.push(cleaned);
                                } else {
                                    out.push(ring);
                                }
                            }
                            cleanedPolys.push(out);
                        }
                        f.geometry.coordinates = cleanedPolys;
                    }
                } catch (e) {
                    showErrorNotification(getText('collinearRemovalFailed', idx, e.message || e), 'amber');
                }
                
                // Report progress
                if ((idx % globalReportInterval) === 0 || idx === total - 1) {
                    if (progressCallback) {
                        const progress = Math.round(((idx + 1) / total) * 100);
                        progressCallback(progress, `Removing collinear points: feature ${idx + 1} of ${total}`);
                    }
                if (__autoCleanCancelled) throw new Error('Auto-Clean cancelled');
                    await delay(0);
                }
            }
        }
        
        /**
         * Remove overlapping polygons using Turf.js difference operation
         * Strategy: Sort polygons by area (largest first), clip smaller polygons against larger ones
         */
        async function stageRemoveOverlap(options) {
            if (!currentGeoJSON || !currentGeoJSON.features) return;

            // Check if Turf.js is available
            if (typeof turf === 'undefined' || typeof turf.difference !== 'function') {
                showErrorNotification(getText('turfLibraryNotLoaded'), 'red');
                return;
            }

            const features = currentGeoJSON.features;
            const polygonFeatures = [];
            
            // Extract polygon/multipolygon features with area calculation
            // Only include geometrically valid features (same as detection)
            for (let i = 0; i < features.length; i++) {
                const f = features[i];
                if (!f || !f.geometry) continue;
                
                const gType = f.geometry.type;
                if (gType === 'Polygon' || gType === 'MultiPolygon') {
                    try {
                        // Validate geometry before processing (same as detection phase)
                        if (!turf.booleanValid(f)) {
                            console.warn(`Skipping feature ${i} with invalid geometry`);
                            continue;
                        }
                        
                        const area = turf.area(f);
                        polygonFeatures.push({
                            feature: f,
                            originalIndex: i,
                            area: area,
                            processed: false,
                            removed: false
                        });
                    } catch (e) {
                        console.warn(`Could not calculate area for feature ${i}:`, e);
                    }
                }
                
                if ((i % 50) === 0) await delay(0);
                if (__autoCleanCancelled) throw new Error('Auto-Clean cancelled');
            }

            // Sort by area descending (largest first)
            polygonFeatures.sort((a, b) => b.area - a.area);
            
            const totalPolygons = features.filter(f => f && f.geometry && (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon')).length;
            const skippedCount = totalPolygons - polygonFeatures.length;

            // Build spatial index for efficient overlap detection
            const spatialIndex = new RBush();
            for (const item of polygonFeatures) {
                try {
                    const bbox = turf.bbox(item.feature);
                    spatialIndex.insert({
                        minX: bbox[0],
                        minY: bbox[1],
                        maxX: bbox[2],
                        maxY: bbox[3],
                        item: item
                    });
                    } catch (e) {
                    console.warn(`Could not create bbox for feature:`, e);
                }
            }

            let clippedCount = 0;
            let removedCount = 0;

            // Process each polygon (largest to smallest)
            for (let i = 0; i < polygonFeatures.length; i++) {
                const larger = polygonFeatures[i];
                
                if (larger.removed) continue;
                
                // Find potential overlapping candidates using spatial index
                let bbox;
                try {
                    bbox = turf.bbox(larger.feature);
                } catch (e) {
                    console.warn(`Could not get bbox for feature ${larger.originalIndex}:`, e);
                    continue;
                }
                
                const candidates = spatialIndex.search({
                    minX: bbox[0],
                    minY: bbox[1],
                    maxX: bbox[2],
                    maxY: bbox[3]
                });

                // Process smaller polygons that overlap with this larger one
                for (const candidate of candidates) {
                    const smaller = candidate.item;
                    
                    // Skip self, already removed, or larger/equal polygons
                    if (smaller === larger || smaller.removed || smaller.area >= larger.area) continue;

                    try {
                        // Check if there's actual overlap (not just bbox overlap)
                        const intersection = turf.intersect(larger.feature, smaller.feature);
                        
                        if (intersection) {
                            // Verify it's an area overlap, not just edge sharing
                            const intersectionArea = turf.area(intersection);
                            
                            if (intersectionArea > 1e-6) { // Minimum overlap threshold (1 square mm)
                                // Clip the smaller polygon
                                const difference = turf.difference(smaller.feature, larger.feature);
                                
                                if (difference) {
                                    // Validate the result
                                    try {
                                        if (turf.booleanValid(difference)) {
                                            // Update the feature geometry
                                            smaller.feature.geometry = difference.geometry;
                                            
                                            // Recalculate area
                                            smaller.area = turf.area(smaller.feature);
                                            
                                            clippedCount++;
                                    } else {
                                            // Invalid result, mark for removal
                                            smaller.removed = true;
                                            removedCount++;
                                        }
                                    } catch (validationError) {
                                        // Validation failed, mark for removal
                                        smaller.removed = true;
                                        removedCount++;
                                    }
                                } else {
                                    // Difference returned null = smaller was completely covered
                                    smaller.removed = true;
                                    removedCount++;
                                }
                            }
                                    }
                                } catch (e) {
                        console.warn(`Error processing overlap between features ${larger.originalIndex} and ${smaller.originalIndex}:`, e);
                    }
                }

                // Progress reporting (always 50 for overlap fix)
                if ((i % 50) === 0) {
                            await delay(0);
                            if (__autoCleanCancelled) throw new Error('Auto-Clean cancelled');
                }
            }

            // Remove marked features from currentGeoJSON
            const keptFeatures = features.filter((f, idx) => {
                const polyItem = polygonFeatures.find(p => p.originalIndex === idx);
                return !polyItem || !polyItem.removed;
            });

            currentGeoJSON.features = keptFeatures;

            // Show notification
            if (removedCount > 0 || clippedCount > 0) {
                showErrorNotification(
                    `Overlap removal completed: ${clippedCount} polygons clipped, ${removedCount} polygons removed`,
                    'green'
                );
                } else {
                showErrorNotification(getText('noOverlapsDetected'), 'green');
            }
        }

        async function stageRemoveSlivers(options, progressCallback = null, sliverResults = null) {
            if (!currentGeoJSON || !currentGeoJSON.features) return;
            const degreeThreshold = 4; // degrees
            const radThreshold = degreeThreshold * Math.PI / 180;

            let removedPolygonUnits = 0; // number of entire Polygon or MultiPolygon polygon parts removed
            let removedVertices = 0;     // number of vertices removed from rings
            
            // If sliverResults provided, only process those features
            const featuresWithSlivers = sliverResults?.featuresWithSharpAngles || null;
            const sliverIndexSet = featuresWithSlivers ? new Set(featuresWithSlivers.map(item => item.featureIndex)) : null;

            function computeAngleRadians(prev, curr, next) {
                const ux = prev[0] - curr[0];
                const uy = prev[1] - curr[1];
                const vx = next[0] - curr[0];
                const vy = next[1] - curr[1];
                const du = Math.hypot(ux, uy);
                const dv = Math.hypot(vx, vy);
                if (du === 0 || dv === 0) return Math.PI; // degenerate, treat as straight
                let cosTheta = (ux * vx + uy * vy) / (du * dv);
                if (cosTheta > 1) cosTheta = 1; else if (cosTheta < -1) cosTheta = -1;
                return Math.acos(cosTheta);
            }

            function countAcuteAngles(ring) {
                if (!Array.isArray(ring) || ring.length < 4) return 0;
                const closed = __gr_closeRing(__gr_removeConsecutiveDuplicates(ring));
                const n = closed.length - 1; // last equals first
                let count = 0;
                for (let i = 0; i < n; i++) {
                    const prev = closed[(i - 1 + n) % n];
                    const curr = closed[i];
                    const next = closed[(i + 1) % n];
                    const ang = computeAngleRadians(prev, curr, next);
                    if (ang < radThreshold) count++;
                }
                return count;
            }

            function removeAcuteVerticesFromRing(ring) {
                if (!Array.isArray(ring) || ring.length < 4) return ring;
                // Work on open ring (exclude duplicated closing point), then close at end
                const closed = __gr_closeRing(__gr_removeConsecutiveDuplicates(ring));
                const n = closed.length - 1;
                const open = closed.slice(0, n);
                const kept = [];
                for (let i = 0; i < n; i++) {
                    const prev = open[(i - 1 + n) % n];
                    const curr = open[i];
                    const next = open[(i + 1) % n];
                    const ang = computeAngleRadians(prev, curr, next);
                    if (ang < radThreshold) {
                        removedVertices++;
                        continue; // drop offending vertex
                    }
                    kept.push(curr);
                }
                if (kept.length < 3) return [];
                let out = kept.slice();
                out.push([out[0][0], out[0][1]]);
                // Only remove consecutive duplicates, NOT collinear points
                // Sliver removal should only remove sharp angles, not straighten the polygon
                out = __gr_removeConsecutiveDuplicates(out);
                return out;
            }

            const features = currentGeoJSON.features;
            const newFeatures = [];
            
            // Determine which features to process
            let processedCount = 0;
            const totalToProcess = sliverIndexSet ? sliverIndexSet.size : features.length;
            
            for (let fi = 0; fi < features.length; fi++) {
                const f = features[fi];
                
                // If we have sliver results, skip features not in the set
                if (sliverIndexSet && !sliverIndexSet.has(fi)) {
                    newFeatures.push(f);
                    continue;
                }
                
                if (!f || !f.geometry) { 
                    newFeatures.push(f); 
                    processedCount++;
                    continue; 
                }
                
                try {
                    const g = f.geometry;
                    if (g.type === 'Polygon') {
                        const rings = g.coordinates || [];
                        // If exterior ring has at least two acute angles, treat as sliver polygon and remove it
                        if (rings.length > 0 && countAcuteAngles(rings[0]) >= 2) {
                            removedPolygonUnits++;
                            // drop this feature entirely
                        } else {
                            // Otherwise, remove offending vertices from all rings
                            const cleanedRings = [];
                            for (let r = 0; r < rings.length; r++) {
                                const cleaned = removeAcuteVerticesFromRing(rings[r]);
                                if (Array.isArray(cleaned) && cleaned.length >= 4) cleanedRings.push(cleaned);
                            }
                            if (cleanedRings.length > 0) {
                                const clone = JSON.parse(JSON.stringify(f));
                                clone.geometry.coordinates = cleanedRings;
                                newFeatures.push(clone);
                            } else {
                                // Polygon became invalid after vertex removals
                                removedPolygonUnits++;
                            }
                        }
                    } else if (g.type === 'MultiPolygon') {
                        const polys = g.coordinates || [];
                        const keptPolys = [];
                        for (let pi = 0; pi < polys.length; pi++) {
                            const polyRings = polys[pi] || [];
                            if (polyRings.length === 0) continue;
                            // If exterior ring has at least two acute angles, treat as sliver polygon unit and remove
                            if (countAcuteAngles(polyRings[0]) >= 2) {
                                removedPolygonUnits++;
                                continue;
                            }
                            // Otherwise, remove offending vertices from its rings
                            const cleanedRings = [];
                            for (let r = 0; r < polyRings.length; r++) {
                                const cleaned = removeAcuteVerticesFromRing(polyRings[r]);
                                if (Array.isArray(cleaned) && cleaned.length >= 4) cleanedRings.push(cleaned);
                            }
                            if (cleanedRings.length > 0) {
                                keptPolys.push(cleanedRings);
                            } else {
                                removedPolygonUnits++;
                            }
                        }
                        if (keptPolys.length > 0) {
                            const clone = JSON.parse(JSON.stringify(f));
                            clone.geometry.coordinates = keptPolys;
                            newFeatures.push(clone);
                        } else {
                            // Everything removed for this feature
                        }
                    } else {
                        // Non-polygonal features are forwarded unchanged
                        newFeatures.push(f);
                    }
                } catch (e) {
                    newFeatures.push(f);
                }
                
                processedCount++;
                
                // Report progress every 10 features
                if ((processedCount % 10) === 0 || processedCount === totalToProcess) {
                    if (progressCallback) {
                        const progress = Math.round((processedCount / totalToProcess) * 100);
                        progressCallback(progress, `Removing slivers: ${processedCount} of ${totalToProcess} features with slivers`);
                    }
                if (__autoCleanCancelled) throw new Error('Auto-Clean cancelled');
                    await delay(0);
                }
            }

            currentGeoJSON.features = newFeatures;
        }
        
        async function stageRemoveSmallPolygons(options, progressCallback = null) {
            if (!currentGeoJSON || !currentGeoJSON.features) return;
            
            const minAreaSquareMeters = options.smallpolygonsArea || 10; // Default to 10 square meters
            let removedCount = 0;
            const newFeatures = [];
            const total = currentGeoJSON.features.length;
            
            for (let fi = 0; fi < currentGeoJSON.features.length; fi++) {
                const f = currentGeoJSON.features[fi];
                if (!f || !f.geometry) {
                    newFeatures.push(f);
                    continue;
                }
                
                const g = f.geometry;
                let shouldKeep = true;
                
                try {
                    if (g.type === 'Polygon') {
                        const areaSqMeters = turf.area(f);
                        if (areaSqMeters < minAreaSquareMeters) {
                                shouldKeep = false;
                                removedCount++;
                        }
                    } else if (g.type === 'MultiPolygon') {
                        const polys = g.coordinates || [];
                        const keptPolys = [];
                        
                        for (const poly of polys) {
                            if (poly && poly[0]) {
                                // Calculate area for this individual polygon
                                const polyFeature = { type: 'Feature', geometry: { type: 'Polygon', coordinates: poly }, properties: {} };
                                const areaSqMeters = turf.area(polyFeature);
                                if (areaSqMeters >= minAreaSquareMeters) {
                                    keptPolys.push(poly);
                                } else {
                                    removedCount++;
                                }
                            }
                        }
                        
                        if (keptPolys.length === 0) {
                            shouldKeep = false; // Remove entire feature if no polygons left
                        } else if (keptPolys.length === 1) {
                            // Convert to single Polygon
                            const clone = JSON.parse(JSON.stringify(f));
                            clone.geometry = { type: 'Polygon', coordinates: keptPolys[0] };
                            newFeatures.push(clone);
                            shouldKeep = false; // Don't push original
                        } else {
                            // Keep as MultiPolygon with remaining polygons
                            const clone = JSON.parse(JSON.stringify(f));
                            clone.geometry = { type: 'MultiPolygon', coordinates: keptPolys };
                            newFeatures.push(clone);
                            shouldKeep = false; // Don't push original
                        }
                    }
                } catch (e) {
                    // On error, keep the original feature
                    console.warn(`Error processing polygon area for feature ${fi}:`, e);
                }
                
                if (shouldKeep) {
                    newFeatures.push(f);
                }
                
                // Report progress
                if ((fi % globalReportInterval) === 0 || fi === total - 1) {
                    if (progressCallback) {
                        const progress = Math.round(((fi + 1) / total) * 100);
                        progressCallback(progress, `Removing small polygons: feature ${fi + 1} of ${total}`);
                    }
                if (__autoCleanCancelled) throw new Error('Auto-Clean cancelled');
                    await delay(0);
                }
            }
            
            // Update the current GeoJSON with the processed features
            currentGeoJSON.features = newFeatures;
            
            // Report results
            if (removedCount > 0) {
                showErrorNotification(getText('smallPolygonRemovalCompleted', removedCount, minAreaSquareMeters), 'green');
            } else {
                showErrorNotification(getText('noSmallPolygonsFound', null, minAreaSquareMeters), 'green');
            }
        }
        
        async function stageRemovePointsInPolygons(options, progressCallback = null) {
            if (!currentGeoJSON || !currentGeoJSON.features) return;
            
            const features = currentGeoJSON.features;
            const polygonFeatures = [];
            const pointFeatures = [];
            const otherFeatures = [];
            let removedCount = 0;
            
            // Separate features by type
            for (const f of features) {
                if (!f || !f.geometry) {
                    otherFeatures.push(f);
                    continue;
                }
                
                const g = f.geometry;
                if (g.type === 'Polygon' || g.type === 'MultiPolygon') {
                    polygonFeatures.push(f);
                } else if (g.type === 'Point' || g.type === 'MultiPoint') {
                    pointFeatures.push(f);
                } else {
                    otherFeatures.push(f);
                }
            }
            
            if (polygonFeatures.length === 0 || pointFeatures.length === 0) {
                showErrorNotification(getText('noPolygonsOrPointsFound'), 'green');
                return;
            }
            
            // Test each point against all polygon features using Turf.js
            const keptPoints = [];
            const totalPoints = pointFeatures.length;
            for (let pi = 0; pi < pointFeatures.length; pi++) {
                const pf = pointFeatures[pi];
                
                if (pf.geometry.type === 'Point') {
                    // Handle single Point
                    let isInside = false;
                    
                    try {
                        for (const polygonFeature of polygonFeatures) {
                            if (turf.booleanPointInPolygon(pf, polygonFeature)) {
                                isInside = true;
                                break;
                            }
                        }
                    } catch (e) {
                        console.warn(`Error testing point ${pi} in polygon:`, e);
                    }
                    
                    if (!isInside) {
                        keptPoints.push(pf);
                    } else {
                        removedCount++;
                    }
                } else if (pf.geometry.type === 'MultiPoint') {
                    // Handle MultiPoint - check each coordinate individually
                    const filteredCoords = [];
                    
                    for (const coord of pf.geometry.coordinates) {
                        let isInside = false;
                        
                        try {
                            // Create a temporary Point feature for testing
                            const tempPoint = turf.point(coord);
                            for (const polygonFeature of polygonFeatures) {
                                if (turf.booleanPointInPolygon(tempPoint, polygonFeature)) {
                                    isInside = true;
                                    break;
                                }
                            }
                        } catch (e) {
                            console.warn(`Error testing MultiPoint coordinate in polygon:`, e);
                        }
                        
                        if (!isInside) {
                            filteredCoords.push(coord);
                        } else {
                            removedCount++;
                        }
                    }
                    
                    // If any points remain outside polygons, keep the feature with filtered coords
                    if (filteredCoords.length > 0) {
                        const updatedFeature = { ...pf };
                        
                        // If only one point remains, convert to Point geometry
                        if (filteredCoords.length === 1) {
                            updatedFeature.geometry = {
                                type: 'Point',
                                coordinates: filteredCoords[0]
                            };
                        } else {
                            // Multiple points remain, keep as MultiPoint
                            updatedFeature.geometry = {
                                type: 'MultiPoint',
                                coordinates: filteredCoords
                            };
                        }
                        
                        keptPoints.push(updatedFeature);
                    }
                    // If all points were inside polygons, the entire feature is removed (not added to keptPoints)
                }
                
                // Report progress
                if ((pi % globalReportInterval) === 0 || pi === totalPoints - 1) {
                    if (progressCallback) {
                        const progress = Math.round(((pi + 1) / totalPoints) * 100);
                        progressCallback(progress, `Removing points in polygons: feature ${pi + 1} of ${totalPoints}`);
                    }
                if (__autoCleanCancelled) throw new Error('Auto-Clean cancelled');
                    await delay(0);
                }
            }
            
            // Rebuild features list
            currentGeoJSON.features = [...polygonFeatures, ...keptPoints, ...otherFeatures];
            
            // Report results
            if (removedCount > 0) {
                showErrorNotification(getText('pointsInPolygonsRemovalCompleted', removedCount), 'green');
            } else {
                showErrorNotification(getText('noPointsInPolygonsFound'), 'green');
            }
        }
        

        // Geometry utilities for self-intersection fixing
        // Using 1e-6 tolerance (6 decimal places) as specified
        function __gr_pointsEqual(a, b, tol = 1e-6) {
            return Math.abs(a[0] - b[0]) <= tol && Math.abs(a[1] - b[1]) <= tol;
        }
        function __gr_isClosedRing(ring) {
            if (!ring || ring.length < 4) return false;
            return __gr_pointsEqual(ring[0], ring[ring.length - 1]);
        }
        function __gr_closeRing(ring) {
            if (!ring || ring.length === 0) return ring;
            const closed = ring.slice();
            if (!__gr_isClosedRing(closed)) {
                closed.push([closed[0][0], closed[0][1]]);
            }
            return closed;
        }
        
        /**
         * Chooses the better ring between two options based on vertex count and area.
         * First compares by vertex count (excluding closing vertex).
         * If counts are equal, compares by area using turf.js.
         * Falls back to first ring if area calculation fails.
         * 
         * @param {Array} ringA - First ring (array of [lng, lat] coordinates)
         * @param {Array} ringB - Second ring (array of [lng, lat] coordinates)
         * @returns {Array} The chosen ring
         */
        function __gr_chooseBetterRing(ringA, ringB) {
            const countA = ringA.length - 1;
            const countB = ringB.length - 1;
            
            // If vertex counts differ, choose the one with more vertices
            if (countA > countB) {
                return ringA;
            } else if (countB > countA) {
                return ringB;
            }
            
            // Vertex counts are equal - compare by area
            try {
                // Convert rings to GeoJSON Polygon features for turf.area
                const polyA = {
                    type: 'Feature',
                    geometry: {
                        type: 'Polygon',
                        coordinates: [ringA]
                    },
                    properties: {}
                };
                
                const polyB = {
                    type: 'Feature',
                    geometry: {
                        type: 'Polygon',
                        coordinates: [ringB]
                    },
                    properties: {}
                };
                
                // Calculate areas
                const areaA = turf.area(polyA);
                const areaB = turf.area(polyB);
                
                // Choose the ring with larger area
                return (areaA >= areaB) ? ringA : ringB;
                
            } catch (e) {
                // If area calculation fails, fall back to first ring
                console.warn('Area comparison failed, keeping first ring:', e);
                return ringA;
            }
        }
        function __gr_removeConsecutiveDuplicates(ring, precision = null) {
            if (!ring || ring.length === 0) return ring;
            
            // If precision is null, preserve original coordinates (high-precision mode)
            // If precision is specified, round for backward compatibility with old code
            if (precision === null) {
                // High-precision mode: compare at 6 decimals but keep original coords
                const result = [ring[0]];
                const multiplier = 1e6; // Compare at 6 decimal precision
                
                for (let i = 1; i < ring.length; i++) {
                    const prev = ring[i - 1];
                    const curr = ring[i];
                    
                    const prevRounded = [
                        Math.round(prev[0] * multiplier) / multiplier,
                        Math.round(prev[1] * multiplier) / multiplier
                    ];
                    const currRounded = [
                        Math.round(curr[0] * multiplier) / multiplier,
                        Math.round(curr[1] * multiplier) / multiplier
                    ];
                    
                    if (prevRounded[0] !== currRounded[0] || prevRounded[1] !== currRounded[1]) {
                        result.push(curr); // Keep original high-precision coordinate
                    }
                }
                return result;
            } else {
                // Legacy mode: round coordinates to specified precision
                const multiplier = Math.pow(10, precision);
                const workingRing = ring.map(coord => [
                    Math.round(coord[0] * multiplier) / multiplier,
                    Math.round(coord[1] * multiplier) / multiplier
                ]);
            
            const result = [workingRing[0]];
            for (let i = 1; i < workingRing.length; i++) {
                const prev = result[result.length - 1];
                const curr = workingRing[i];
                if (prev[0] !== curr[0] || prev[1] !== curr[1]) {
                    result.push(curr);
                }
            }
            return result;
            }
        }
        function __gr_removeNonAdjacentDuplicates(ring, precision = null) {
            if (!ring || ring.length === 0) return ring;
            
            // If precision is null, preserve original coordinates (high-precision mode)
            // If precision is specified, round for backward compatibility with old code
            if (precision === null) {
                // High-precision mode: compare at 6 decimals but keep original coords
                const closed = __gr_closeRing(ring);
                const multiplier = 1e6; // Compare at 6 decimal precision
                const first = closed[0];
                const body = closed.slice(0, closed.length - 1); // exclude closing
                const kept = [];
                const seen = new Map(); // Use Map for faster lookups
                
                for (let i = 0; i < body.length; i++) {
                    const pt = body[i];
                    const rounded = [
                        Math.round(pt[0] * multiplier) / multiplier,
                        Math.round(pt[1] * multiplier) / multiplier
                    ];
                    const key = `${rounded[0]},${rounded[1]}`;
                    
                    if (!seen.has(key)) {
                        seen.set(key, true);
                        kept.push(pt); // Keep original high-precision coordinate
                    }
                }
                
                // Ensure closure with original precision
                if (kept.length === 0) {
                    kept.push(first);
                } else if (kept[0][0] !== first[0] || kept[0][1] !== first[1]) {
                    kept.unshift(first);
                }
                const last = kept[kept.length - 1];
                const firstRounded = [
                    Math.round(first[0] * multiplier) / multiplier,
                    Math.round(first[1] * multiplier) / multiplier
                ];
                const lastRounded = [
                    Math.round(last[0] * multiplier) / multiplier,
                    Math.round(last[1] * multiplier) / multiplier
                ];
                if (lastRounded[0] !== firstRounded[0] || lastRounded[1] !== firstRounded[1]) {
                    kept.push([first[0], first[1]]);
                }
                return kept;
            } else {
                // Legacy mode: round coordinates to specified precision
                const multiplier = Math.pow(10, precision);
                const workingRing = ring.map(coord => [
                    Math.round(coord[0] * multiplier) / multiplier,
                    Math.round(coord[1] * multiplier) / multiplier
                ]);
            
            const closed = __gr_closeRing(workingRing);
            const first = closed[0];
            const body = closed.slice(0, closed.length - 1); // exclude closing
            const kept = [];
            const seen = new Map(); // Use Map for faster lookups with string keys
            for (let i = 0; i < body.length; i++) {
                const pt = body[i];
                const key = `${pt[0]},${pt[1]}`;
                if (!seen.has(key)) {
                    seen.set(key, true);
                    kept.push(pt);
                }
            }
            // Ensure closure
            if (kept.length === 0) {
                kept.push(first);
            } else if (kept[0][0] !== first[0] || kept[0][1] !== first[1]) {
                kept.unshift(first);
            }
            const last = kept[kept.length - 1];
            if (last[0] !== first[0] || last[1] !== first[1]) {
                kept.push([first[0], first[1]]);
            }
            return kept;
            }
        }
        function __gr_cross(p, q, r) {
            return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0]);
        }
        function __gr_removeCollinear(ring, tol = 1e-6) {
            if (!ring || ring.length < 4) return ring;
            const closed = __gr_closeRing(ring);
            const n = closed.length;
            
            // For a closed ring, the last point equals the first point
            // We need to process the body vertices (excluding the closing duplicate)
            const bodyLength = n - 1; // Process only the body (first point will be repeated as closing)
            
            const keep = [];
            
            // ALWAYS keep the first point
            keep.push(closed[0]);
            
            // Check middle points for collinearity (indices 1 to bodyLength-2)
            for (let i = 1; i < bodyLength - 1; i++) {
                const prev = closed[i - 1];
                const curr = closed[i];
                const next = closed[i + 1];
                const cross = __gr_cross(prev, curr, next);
                
                // Keep if NOT collinear
                if (Math.abs(cross) > tol) {
                    keep.push(curr);
                }
            }
            
            // ALWAYS keep the last body point (before closing)
            if (bodyLength > 1) {
                keep.push(closed[bodyLength - 1]);
            }
            
            // ALWAYS add closing point (copy of first point)
            keep.push([keep[0][0], keep[0][1]]);
            
            return keep;
        }

        // Shared geometry helpers for normalization and overlap/diff (used by cleaner and validator)
        const __GR_OPS_TOL = 1e-12; // numeric tolerance for ring cleanup prior to topology ops
        const __GR_OVERLAP_AREA_TOL = 1e-10; // minimal area to consider a true overlap

        function __gr_normalizeRingForOps(ring, precision = null) {
            if (!Array.isArray(ring) || ring.length < 4) return ring;
            
            // Use null precision to preserve high-precision coordinates
            // Duplicates are detected at 6 decimals but original coords are kept
            const noDup = __gr_removeConsecutiveDuplicates(ring, null) || ring;
            const closed = __gr_closeRing(noDup);
            
            // DO NOT truncate - preserve original high-precision coordinates
            // Old code truncated to 8 decimals, but this caused precision loss
            return closed.length >= 4 ? closed : ring;
        }


        // Helper to round a coordinate to 6 decimal places
        function __gr_roundCoord(coord) {
            return [
                Math.round(coord[0] * 1e6) / 1e6,
                Math.round(coord[1] * 1e6) / 1e6
            ];
        }

        /**
         * Find consecutive duplicate vertices in a ring (comparing at specified precision)
         * Returns array of indices to REMOVE (preserves first occurrence)
         * @param {Array} ring - Array of [lng, lat] coordinates
         * @param {number} precision - Number of decimal places for comparison (default: 6)
         * @returns {Array<number>} - Array of indices to remove
         */
        function __gr_findConsecutiveDuplicates(ring, precision = 6) {
            if (!ring || ring.length < 2) return [];
            
            const indicesToRemove = [];
            const multiplier = Math.pow(10, precision);
            
            // Compare each coordinate with the next one
            for (let i = 0; i < ring.length - 1; i++) {
                const curr = ring[i];
                const next = ring[i + 1];
                
                // Round to specified precision for comparison
                const currRounded = [
                    Math.round(curr[0] * multiplier) / multiplier,
                    Math.round(curr[1] * multiplier) / multiplier
                ];
                const nextRounded = [
                    Math.round(next[0] * multiplier) / multiplier,
                    Math.round(next[1] * multiplier) / multiplier
                ];
                
                // If they match at this precision, mark the second one for removal
                if (currRounded[0] === nextRounded[0] && currRounded[1] === nextRounded[1]) {
                    indicesToRemove.push(i + 1);
                }
            }
            
            return indicesToRemove;
        }

        /**
         * Find non-consecutive duplicate vertices in a ring (comparing at specified precision)
         * Returns array of indices to REMOVE (preserves first occurrence, excludes closing point)
         * @param {Array} ring - Array of [lng, lat] coordinates
         * @param {number} precision - Number of decimal places for comparison (default: 6)
         * @returns {Array<number>} - Array of indices to remove
         */
        function __gr_findNonConsecutiveDuplicates(ring, precision = 6) {
            if (!ring || ring.length < 2) return [];
            
            const indicesToRemove = [];
            const multiplier = Math.pow(10, precision);
            const seen = new Map(); // Map of "lng,lat" key  first occurrence index
            
            // Check if ring is closed
            const first = ring[0];
            const last = ring[ring.length - 1];
            const firstRounded = [
                Math.round(first[0] * multiplier) / multiplier,
                Math.round(first[1] * multiplier) / multiplier
            ];
            const lastRounded = [
                Math.round(last[0] * multiplier) / multiplier,
                Math.round(last[1] * multiplier) / multiplier
            ];
            const isClosed = firstRounded[0] === lastRounded[0] && firstRounded[1] === lastRounded[1];
            
            // Process body (excluding closing point if closed)
            const bodyLength = isClosed ? ring.length - 1 : ring.length;
            
            for (let i = 0; i < bodyLength; i++) {
                const coord = ring[i];
                const rounded = [
                    Math.round(coord[0] * multiplier) / multiplier,
                    Math.round(coord[1] * multiplier) / multiplier
                ];
                const key = `${rounded[0]},${rounded[1]}`;
                
                if (seen.has(key)) {
                    // This is a duplicate (non-consecutive), mark for removal
                    indicesToRemove.push(i);
                } else {
                    // First occurrence, track it
                    seen.set(key, i);
                }
            }
            
            return indicesToRemove;
        }

        // Find pairs of non-consecutive duplicate vertices (for B-shaped ring detection)
        // Returns array of {i, j} where ring[i] == ring[j] and j > i+1
        function __gr_findDuplicateVertexPairs(ring, precision = 6) {
            if (!ring || ring.length < 4) return [];
            
            const pairs = [];
            const multiplier = Math.pow(10, precision);
            const n = ring.length - 1; // Assuming closed ring
            
            for (let i = 0; i < n; i++) {
                for (let j = i + 2; j < n; j++) {
                    // Skip adjacent vertices
                    if (j === i + 1) continue;
                    
                    const p1 = ring[i];
                    const p2 = ring[j];
                    const r1 = [
                        Math.round(p1[0] * multiplier) / multiplier,
                        Math.round(p1[1] * multiplier) / multiplier
                    ];
                    const r2 = [
                        Math.round(p2[0] * multiplier) / multiplier,
                        Math.round(p2[1] * multiplier) / multiplier
                    ];
                    
                    if (r1[0] === r2[0] && r1[1] === r2[1]) {
                        pairs.push({ i, j, point: p1 });
                        break; // Only find first duplicate for each i
                    }
                }
            }
            
            return pairs;
        }
        
        // Check if point p lies on segment (p1, p2) within tolerance
        function __gr_pointOnSegment(p, p1, p2, tol = 1e-6) {
            // Check if p is collinear with segment using cross product
            const cross = Math.abs((p2[1] - p1[1]) * (p[0] - p1[0]) - (p2[0] - p1[0]) * (p[1] - p1[1]));
            // Scale based on actual segment length (use small minimum for degenerate segments)
            const scale = Math.max(tol, Math.abs(p2[0] - p1[0]), Math.abs(p2[1] - p1[1]));
            if (cross > tol * scale) {
                return false; // Not collinear
            }
            
            // Check if p is within the bounding box of the segment (with tolerance)
            const minX = Math.min(p1[0], p2[0]) - tol;
            const maxX = Math.max(p1[0], p2[0]) + tol;
            const minY = Math.min(p1[1], p2[1]) - tol;
            const maxY = Math.max(p1[1], p2[1]) + tol;
            
            return p[0] >= minX && p[0] <= maxX && p[1] >= minY && p[1] <= maxY;
        }

        // Check if two segments overlap (are collinear and share a common portion)
        function __gr_segmentsOverlap(p1, p2, p3, p4, tol = 1e-6, debug = false) {
            // First check if segments are collinear
            const cross1 = Math.abs((p2[1] - p1[1]) * (p3[0] - p1[0]) - (p2[0] - p1[0]) * (p3[1] - p1[1]));
            const cross2 = Math.abs((p2[1] - p1[1]) * (p4[0] - p1[0]) - (p2[0] - p1[0]) * (p4[1] - p1[1]));
            // Scale based on actual segment length (use small minimum for degenerate segments)
            const scale = Math.max(tol, Math.abs(p2[0] - p1[0]), Math.abs(p2[1] - p1[1]));
            
            const isCollinear = !(cross1 > tol * scale || cross2 > tol * scale);
            
            if (!isCollinear) {
                return false; // Not collinear
            }
            
            // Check if segments overlap on the line
            // Project onto dominant axis
            const dx = Math.abs(p2[0] - p1[0]);
            const dy = Math.abs(p2[1] - p1[1]);
            
            if (dx >= dy) {
                // Use x-axis
                const min1 = Math.min(p1[0], p2[0]);
                const max1 = Math.max(p1[0], p2[0]);
                const min2 = Math.min(p3[0], p4[0]);
                const max2 = Math.max(p3[0], p4[0]);
                const overlaps = !(max1 < min2 - tol || max2 < min1 - tol);
                return overlaps;
            } else {
                // Use y-axis
                const min1 = Math.min(p1[1], p2[1]);
                const max1 = Math.max(p1[1], p2[1]);
                const min2 = Math.min(p3[1], p4[1]);
                const max2 = Math.max(p3[1], p4[1]);
                const overlaps = !(max1 < min2 - tol || max2 < min1 - tol);
                return overlaps;
            }
        }

        function __gr_segmentIntersection(p1, p2, p3, p4, tol = 1e-6) {
            // Based on standard parametric segment intersection
            const s1x = p2[0] - p1[0];
            const s1y = p2[1] - p1[1];
            const s2x = p4[0] - p3[0];
            const s2y = p4[1] - p3[1];
            const denom = (-s2x * s1y + s1x * s2y);
            
            // Only reject if truly parallel at machine precision (not just nearly parallel)
            // Nearly-parallel segments can still intersect at a point
            if (Math.abs(denom) < 1e-15) {
                return { intersects: false };
            }
            
            const s = (-s1y * (p1[0] - p3[0]) + s1x * (p1[1] - p3[1])) / denom;
            const t = ( s2x * (p1[1] - p3[1]) - s2y * (p1[0] - p3[0])) / denom;
            if (s >= -tol && s <= 1 + tol && t >= -tol && t <= 1 + tol) {
                const ix = p1[0] + (t * s1x);
                const iy = p1[1] + (t * s1y);
                return { intersects: true, point: [ix, iy], t1: t, t2: s };
            }
            return { intersects: false };
        }

        // Find all intersections in a ring (including point-on-segment and overlaps)
        // Returns array of intersection objects: { type, point, segmentIndices: [i, j], ... }
        function __gr_findAllIntersections(ring, tol = 1e-6, debug = false) {
            const intersections = [];
            const n = ring.length - 1; // Assuming closed ring (last == first)
            const seen = new Set(); // Deduplication
            
            // Check all pairs of non-adjacent segments (including wrap-around)
            for (let i = 0; i < n; i++) {
                const a1 = ring[i];
                const a2 = ring[i + 1];
                
                for (let j = 0; j < n; j++) {
                    // Skip self and adjacent segments
                    if (j === i || j === i + 1 || j === i - 1) continue;
                    // First and last segments are adjacent in a closed ring
                    if (i === 0 && j === n - 1) continue;
                    if (i === n - 1 && j === 0) continue;
                    // Avoid checking the same pair twice
                    if (j < i) continue;
                    
                    const b1 = ring[j];
                    const b2_idx = (j + 1 === n) ? 0 : (j + 1);
                    const b2 = ring[b2_idx];
                    
                    // Check for overlapping segments (collinear and overlapping)
                    if (__gr_segmentsOverlap(a1, a2, b1, b2, tol, debug)) {
                        intersections.push({
                            type: 'overlap',
                            segmentIndices: [i, j],
                            segments: [[a1, a2], [b1, b2]]
                        });
                        continue;
                    }
                    
                    // Check for segment intersection
                    const inter = __gr_segmentIntersection(a1, a2, b1, b2, tol);
                        if (inter.intersects) {
                        // Filter out endpoint touches - these are not true crossings
                        const isAtEndpoint = (
                            __gr_pointsEqual(inter.point, a1, tol) ||
                            __gr_pointsEqual(inter.point, a2, tol) ||
                            __gr_pointsEqual(inter.point, b1, tol) ||
                            __gr_pointsEqual(inter.point, b2, tol)
                        );
                        
                        if (!isAtEndpoint) {
                            // Check if already seen (deduplication)
                            const key = `cross-${i}-${j}`;
                            if (!seen.has(key)) {
                                seen.add(key);
                                intersections.push({
                                    type: 'crossing',
                                    point: inter.point,
                                    segmentIndices: [i, j],
                                    parameters: { t1: inter.t1, t2: inter.t2 }
                                });
                            }
                        }
                        continue;
                    }
                    
                    // Check if vertices lie on opposite segments (but not at endpoints)
                    // a1 on segment [b1, b2]
                    if (__gr_pointOnSegment(a1, b1, b2, tol) && 
                        !__gr_pointsEqual(a1, b1, tol) && 
                        !__gr_pointsEqual(a1, b2, tol)) {
                        // FALSE POSITIVE CHECK: Don't flag closing vertex on adjacent segments
                        const isClosingVertex = (i === 0 || i === n);
                        const isAdjacentToClosing = (j === n - 1 || j === n - 2);
                        if (!(isClosingVertex && isAdjacentToClosing)) {
                            const key = `pos-${i}-${j}`;
                            if (!seen.has(key)) {
                                seen.add(key);
                                intersections.push({
                                    type: 'point-on-segment',
                                    point: a1,
                                    vertexIndex: i,
                                    segmentIndex: j
                                });
                            }
                        }
                    }
                    
                    // a2 on segment [b1, b2]
                    if (__gr_pointOnSegment(a2, b1, b2, tol) && 
                        !__gr_pointsEqual(a2, b1, tol) && 
                        !__gr_pointsEqual(a2, b2, tol)) {
                        // FALSE POSITIVE CHECK: Don't flag closing vertex on adjacent segments
                        const vertexIdx = i + 1;
                        const isClosingVertex = (vertexIdx === 0 || vertexIdx === n);
                        const isAdjacentToClosing = (j === n - 1 || j === n - 2);
                        if (!(isClosingVertex && isAdjacentToClosing)) {
                            const key = `pos-${vertexIdx}-${j}`;
                            if (!seen.has(key)) {
                                seen.add(key);
                                intersections.push({
                                    type: 'point-on-segment',
                                    point: a2,
                                    vertexIndex: vertexIdx,
                                    segmentIndex: j
                                });
                            }
                        }
                    }
                    
                    // b1 on segment [a1, a2]
                    if (__gr_pointOnSegment(b1, a1, a2, tol) && 
                        !__gr_pointsEqual(b1, a1, tol) && 
                        !__gr_pointsEqual(b1, a2, tol)) {
                        // FALSE POSITIVE CHECK: Don't flag closing vertex on adjacent segments
                        const isClosingVertex = (j === 0 || j === n);
                        const isAdjacentToClosing = (i === n - 1 || i === n - 2);
                        if (!(isClosingVertex && isAdjacentToClosing)) {
                            const key = `pos-${j}-${i}`;
                            if (!seen.has(key)) {
                                seen.add(key);
                                intersections.push({
                                    type: 'point-on-segment',
                                    point: b1,
                                    vertexIndex: j,
                                    segmentIndex: i
                                });
                            }
                        }
                    }
                    
                    // b2 on segment [a1, a2]
                    if (__gr_pointOnSegment(b2, a1, a2, tol) && 
                        !__gr_pointsEqual(b2, a1, tol) && 
                        !__gr_pointsEqual(b2, a2, tol)) {
                        // FALSE POSITIVE CHECK: Don't flag closing vertex on adjacent segments
                        const isClosingVertex = (b2_idx === 0 || b2_idx === n);
                        const isAdjacentToClosing = (i === n - 1 || i === n - 2);
                        if (!(isClosingVertex && isAdjacentToClosing)) {
                            const key = `pos-${b2_idx}-${i}`;
                            if (!seen.has(key)) {
                                seen.add(key);
                                intersections.push({
                                    type: 'point-on-segment',
                                    point: b2,
                                    vertexIndex: b2_idx,
                                    segmentIndex: i
                                });
                            }
                        }
                    }
                }
            }
            
            return intersections;
        }

        /**
         * Fixes self-intersecting rings by collecting ALL possible simple polygons
         * and returning the best one (largest area, or most vertices if area is equal).
         * This ensures we always select the optimal polygon, not just the best from the last comparison.
         */
        function __gr_fixRingSelfIntersections(ring, maxIterations = 20) {
            if (!ring || ring.length < 4) return ring;
            
            // Use helper function to collect all valid simple polygon candidates
            const candidates = __gr_collectAllSimplePolygons(ring, maxIterations);
            
            if (candidates.length === 0) {
                return []; // No valid polygons found
            }
            
            if (candidates.length === 1) {
                return candidates[0]; // Only one option
            }
            
            // Multiple candidates - choose the best one
            let best = candidates[0];
            for (let i = 1; i < candidates.length; i++) {
                best = __gr_chooseBetterRing(best, candidates[i]);
            }
            
            return best;
        }
        
        /**
         * Recursive helper that collects ALL valid simple polygons from a potentially
         * self-intersecting ring. Returns an array of all possible simple polygons.
         */
        function __gr_collectAllSimplePolygons(ring, maxIterations = 20) {
            if (!ring || ring.length < 4) return [];
            
            // Guard against infinite recursion
            if (maxIterations <= 0) {
                console.warn('Max iterations (20) reached - feature likely needs manual review');
                console.log('Problematic ring coordinates:', JSON.stringify(ring));
                return []; // Return empty - no valid candidates
            }
            
            // STEP 1: Clean at HIGH PRECISION - preserve original coordinates
            // Only remove consecutive duplicates, keep non-consecutive for B-shape detection
            let current = __gr_closeRing(__gr_removeConsecutiveDuplicates(ring, null));
            
            // STEP 1.5: Check for degenerate rings (< 3 unique vertices)
            // Count unique vertices (excluding closing vertex)
            const n = current.length - 1;
            const uniqueVertices = new Set();
            const multiplier = 1e6; // Compare at 6 decimal precision
            for (let i = 0; i < n; i++) {
                const rounded = [
                    Math.round(current[i][0] * multiplier) / multiplier,
                    Math.round(current[i][1] * multiplier) / multiplier
                ];
                uniqueVertices.add(`${rounded[0]},${rounded[1]}`);
            }
            if (uniqueVertices.size < 3) {
                console.warn(`Ring has only ${uniqueVertices.size} unique vertices - dismissing degenerate ring`);
                return []; // No valid candidates
            }
            
            // STEP 2: Check for B-shaped rings (non-consecutive duplicate vertices)
            // If found, split at duplicate and collect candidates from BOTH portions
            const duplicatePairs = __gr_findDuplicateVertexPairs(current, 6);
            if (duplicatePairs.length > 0) {
                const { i, j } = duplicatePairs[0]; // Handle first duplicate pair
                const n = current.length - 1;
                
                // Split ring into two portions at duplicate vertices
                // Portion A: from i to j (inclusive)
                // Portion B: from j to i (wrapping around)
                const portionA = current.slice(i, j + 1);
                const portionB = [...current.slice(j), ...current.slice(0, i + 1)];
                
                // Clean both portions
                const cleanedA = __gr_closeRing(__gr_removeConsecutiveDuplicates(portionA, null));
                const cleanedB = __gr_closeRing(__gr_removeConsecutiveDuplicates(portionB, null));
                
                // Recursively collect candidates from BOTH portions
                const countA = cleanedA.length - 1;
                const countB = cleanedB.length - 1;
                
                const candidatesA = (countA >= 3) ? __gr_collectAllSimplePolygons(cleanedA, maxIterations - 1) : [];
                const candidatesB = (countB >= 3) ? __gr_collectAllSimplePolygons(cleanedB, maxIterations - 1) : [];
                
                // Return all candidates from both portions
                return [...candidatesA, ...candidatesB];
            }
            
            // STEP 3: Check if ring became degenerate after cleaning
            if (current.length < 4) {
                console.warn('Ring became degenerate after cleaning - dismissing ring');
                return []; // No valid candidates
            }
            
            // STEP 4: DUAL-PASS INTERSECTION DETECTION
            // Pass A: Find intersections at HIGH PRECISION (real geometric intersections)
            const hpIntersections = __gr_findAllIntersections(current, 1e-9);
            
            // Pass B: Find intersections at LOW PRECISION (6 decimals)
            // These are intersections that appear after rounding to 6 decimals
            const lpRing = current.map(coord => [
                Math.round(coord[0] * 1e6) / 1e6,
                Math.round(coord[1] * 1e6) / 1e6
            ]);
            const lpIntersections = __gr_findAllIntersections(lpRing, 1e-6);
            
            // STEP 5: Process intersections
            // Prioritize HP intersections (most accurate), fall back to LP if HP finds none
            
            if (hpIntersections.length === 0 && lpIntersections.length === 0) {
                // No intersections at either level - ring is valid simple polygon
                return [current]; // Return as single candidate
            }
            
            // Process the first detected intersection
            let intersection = null;
            if (hpIntersections.length > 0) {
                intersection = hpIntersections[0];
            } else if (lpIntersections.length > 0) {
                intersection = lpIntersections[0];
            }
            
            if (!intersection) {
                return [current]; // No intersection to process, return as valid candidate
            }
            
            // STEP 5: Handle the detected intersection using HP coordinates
            // Note: segment indices from LP map directly to HP (same length rings)
            
            if (intersection.type === 'overlap') {
                // Handle overlapping segments (double-back paths)
                const [i, j] = intersection.segmentIndices;
                const n = current.length - 1;
                
                // Split into two loops at HP precision
                const loopA = [
                    ...current.slice(0, i + 1),
                    ...current.slice(j + 1, n)
                ];
                const loopB = current.slice(i + 1, j + 1);
                
                // Close and clean both loops (HP coords preserved)
                const closedA = __gr_closeRing(__gr_removeConsecutiveDuplicates(loopA, null));
                const closedB = __gr_closeRing(__gr_removeConsecutiveDuplicates(loopB, null));
                
                // Recursively collect candidates from BOTH loops
                const countA = closedA.length - 1;
                const countB = closedB.length - 1;
                
                const candidatesA = (countA >= 3) ? __gr_collectAllSimplePolygons(closedA, maxIterations - 1) : [];
                const candidatesB = (countB >= 3) ? __gr_collectAllSimplePolygons(closedB, maxIterations - 1) : [];
                
                // Return all candidates from both loops
                return [...candidatesA, ...candidatesB];
            }
            
            if (intersection.type === 'crossing') {
                // Handle crossing intersections
                const [i, j] = intersection.segmentIndices;
                const n = current.length - 1;
                
                // Compute intersection point at HIGH PRECISION
                // (even if intersection was detected on LP ring, we use HP segment coords)
                const a1 = current[i];
                const a2 = current[i + 1];
                const b1 = current[j];
                const b2_idx = (j + 1 >= n) ? 0 : (j + 1);
                const b2 = current[b2_idx];
                
                const hpInter = __gr_segmentIntersection(a1, a2, b1, b2, 1e-9);
                const intersectionPoint = (hpInter && hpInter.intersects) ? hpInter.point : a2;
                
                // Split into two loops at the intersection point (HP coords)
                const loop1 = [
                    ...current.slice(0, i + 1),
                    intersectionPoint,
                    ...current.slice(j + 1, n)
                ];
                const loop2 = [
                    ...current.slice(i + 1, j + 1),
                    intersectionPoint
                ];
                
                // Close and clean both loops (HP coords preserved)
                const closed1 = __gr_closeRing(__gr_removeConsecutiveDuplicates(loop1, null));
                const closed2 = __gr_closeRing(__gr_removeConsecutiveDuplicates(loop2, null));
                
                // Recursively collect candidates from BOTH loops
                const count1 = closed1.length - 1;
                const count2 = closed2.length - 1;
                
                const candidates1 = (count1 >= 3) ? __gr_collectAllSimplePolygons(closed1, maxIterations - 1) : [];
                const candidates2 = (count2 >= 3) ? __gr_collectAllSimplePolygons(closed2, maxIterations - 1) : [];
                
                // Return all candidates from both loops
                return [...candidates1, ...candidates2];
            }
            
            if (intersection.type === 'point-on-segment') {
                // Handle point-on-segment cases
                const vertexIdx = intersection.vertexIndex;
                const segmentIdx = intersection.segmentIndex;
                const n = current.length - 1;
                
                // FALSE POSITIVE CHECK: In a closed ring, vertex 0 and vertex n are the same
                // If vertex 0/n is detected as lying on a segment adjacent to the closing,
                // this is NOT a self-intersection, just a properly closed ring
                const isClosingVertex = (vertexIdx === 0 || vertexIdx === n);
                const isAdjacentToClosing = (segmentIdx === n - 1 || segmentIdx === n - 2);
                
                if (isClosingVertex && isAdjacentToClosing) {
                    // This is a false positive - ring is properly closed, not self-intersecting
                    return [current]; // Return as valid candidate
                }
                
                // The vertex at vertexIdx lies on segment [segmentIdx, segmentIdx+1]
                // Split into two loops and collect candidates from both
                
                if (vertexIdx <= segmentIdx) {
                    // Vertex comes before segment
                    const loopA = [
                        ...current.slice(0, vertexIdx + 1),
                        ...current.slice(segmentIdx + 1, n)
                    ];
                    const loopB = current.slice(vertexIdx, segmentIdx + 2);
                    
                    const closedA = __gr_closeRing(__gr_removeConsecutiveDuplicates(loopA, null));
                    const closedB = __gr_closeRing(__gr_removeConsecutiveDuplicates(loopB, null));
                    
                    // Recursively collect candidates from BOTH loops
                    const countA = closedA.length - 1;
                    const countB = closedB.length - 1;
                    
                    const candidatesA = (countA >= 3) ? __gr_collectAllSimplePolygons(closedA, maxIterations - 1) : [];
                    const candidatesB = (countB >= 3) ? __gr_collectAllSimplePolygons(closedB, maxIterations - 1) : [];
                    
                    return [...candidatesA, ...candidatesB];
                } else {
                    // Vertex comes after segment
                    const loopA = [
                        ...current.slice(0, segmentIdx + 1),
                        ...current.slice(vertexIdx, n)
                    ];
                    const loopB = current.slice(segmentIdx + 1, vertexIdx + 1);
                    
                    const closedA = __gr_closeRing(__gr_removeConsecutiveDuplicates(loopA, null));
                    const closedB = __gr_closeRing(__gr_removeConsecutiveDuplicates(loopB, null));
                    
                    // Recursively collect candidates from BOTH loops
                    const countA = closedA.length - 1;
                    const countB = closedB.length - 1;
                    
                    const candidatesA = (countA >= 3) ? __gr_collectAllSimplePolygons(closedA, maxIterations - 1) : [];
                    const candidatesB = (countB >= 3) ? __gr_collectAllSimplePolygons(closedB, maxIterations - 1) : [];
                    
                    return [...candidatesA, ...candidatesB];
                }
            }
            
            // Fallback: return current ring as-is (already cleaned at start)
            return [current]; // Return as single candidate
        }

        // Implemented stage: Fix Polygon Self-Intersection
        async function stageFixSelfIntersection(options, featureIndices = null, progressCallback = null) {
            if (!currentGeoJSON || !currentGeoJSON.features) return;
            
            const features = currentGeoJSON.features;
            
            // If featureIndices provided, only process those; otherwise process all
            const indicesToProcess = featureIndices !== null ? featureIndices : features.map((_, i) => i);
            const totalToProcess = indicesToProcess.length;
            
            if (totalToProcess === 0) {
                if (progressCallback) progressCallback(100, getText('noSelfIntersectionsToFix'));
                return;
            }
            
            let processedCount = 0;
            
            // Process only the specified features
            for (const idx of indicesToProcess) {
                const f = features[idx];
                if (!f || !f.geometry) {
                    processedCount++;
                    continue;
                }
                
                try {
                    if (f.geometry.type === 'Polygon') {
                        const rings = f.geometry.coordinates || [];
                        const cleaned = [];
                        for (let r = 0; r < rings.length; r++) {
                            const ring = rings[r];
                            if (!Array.isArray(ring) || ring.length < 4) continue;
                            const fixed = __gr_fixRingSelfIntersections(ring);
                            if (Array.isArray(fixed) && fixed.length >= 4) cleaned.push(fixed);
                        }
                        if (cleaned.length > 0) {
                            f.geometry.coordinates = cleaned;
                        } else {
                            // All rings were unfixable - mark feature for removal
                            f.__markedForRemoval = true;
                        }
                    } else if (f.geometry.type === 'MultiPolygon') {
                        const polys = f.geometry.coordinates || [];
                        const cleanedPolys = [];
                        for (let p = 0; p < polys.length; p++) {
                            const polyRings = polys[p] || [];
                            const cleanedRings = [];
                            for (let r = 0; r < polyRings.length; r++) {
                                const ring = polyRings[r];
                                if (!Array.isArray(ring) || ring.length < 4) continue;
                                const fixed = __gr_fixRingSelfIntersections(ring);
                                if (Array.isArray(fixed) && fixed.length >= 4) cleanedRings.push(fixed);
                            }
                            if (cleanedRings.length > 0) cleanedPolys.push(cleanedRings);
                        }
                        if (cleanedPolys.length > 0) {
                            f.geometry.coordinates = cleanedPolys;
                        } else {
                            // All polygons were unfixable - mark feature for removal
                            f.__markedForRemoval = true;
                        }
                    }
                } catch (e) {
                    showErrorNotification(getText('selfIntersectionFixFailed', idx, e.message || e), 'amber');
                }
                
                processedCount++;
                
                // Report progress
                if (progressCallback && (processedCount % globalReportInterval === 0 || processedCount === totalToProcess)) {
                    const progress = Math.round((processedCount / totalToProcess) * 100);
                    progressCallback(progress, `Fixing self-intersections: ${processedCount} of ${totalToProcess}`);
                }
                
                if ((processedCount % globalReportInterval) === 0) await delay(0); // yield
                if (__autoCleanCancelled) throw new Error('Auto-Clean cancelled');
            }
            
            // Remove features that were marked for removal (all rings unfixable)
            const beforeCount = currentGeoJSON.features.length;
            currentGeoJSON.features = currentGeoJSON.features.filter(f => !f.__markedForRemoval);
            const afterCount = currentGeoJSON.features.length;
            const removedCount = beforeCount - afterCount;
            
            if (removedCount > 0) {
                console.log(`Removed ${removedCount} features with unfixable self-intersections`);
            }
        }

        async function startAutoClean() {
            // Snapshot current data to allow revert on cancel (before any operations)
            const snapshot = currentGeoJSON ? JSON.parse(JSON.stringify(currentGeoJSON)) : null;
            
            try {
                // Close selection modal and open progress
                closeAutoCleanModal();
                // Ensure any active selection/edit and validation overlays are cleared before cleaning
                if (typeof resetEditingAndSelectionState === 'function') resetEditingAndSelectionState();
                if (typeof deactivateGeometryValidation === 'function') deactivateGeometryValidation(true);
                // Snapshot before auto-clean modifies geometries
                pushUndoSnapshot('auto-clean');
                openAutoCleanProgress();
                __autoCleanCancelled = false;
                const options = readAutoCleanOptions();

                // Map UI options to validation stages
                const stageMap = {
                    duplicates: 'duplicates',
                    selfIntersect: 'selfIntersections',
                    holes: 'holes',
                    slivers: 'slivers',
                    smallpolygons: 'smallPolygons',
                    overlap: 'overlaps',
                    pointsinpolygons: 'pointsInPolygons',
                    collinear: 'collinear'
                };
                
                const requestedStages = Object.keys(options)
                    .filter(key => options[key] && stageMap[key])
                    .map(key => stageMap[key]);
                
                // Note: Even if requestedStages is empty, mandatory stages (ring closing, duplicate vertices)
                // will be automatically included by the validation pipeline when fix=true
                
                // Run validation pipeline with fix=true
                const results = await runValidationPipeline(currentGeoJSON, {
                    stages: requestedStages,
                    fix: true,
                    progressCallback: (progress, msg) => setProgress(progress, msg),
                    autoCleanOptions: options // Pass through area thresholds etc.
                });
                
                // Update currentGeoJSON with cleaned features
                currentGeoJSON.features = results.features;

                // Finish: re-render map with updated data
                try {
                    if (currentGeoJSON) {
                        processGeoJSON(currentGeoJSON, true);
                    }
                } catch (re) { 
                    showErrorNotification(getText('autoCleanRenderUpdateFailed', re.message || re), 'amber');
                }
                setProgress(100, 'Completed');
                await delay(400);
                closeAutoCleanProgress();
            } catch (err) {
                // Revert if cancelled or failed
                if (err && ('' + err).toLowerCase().includes('cancel')) {
                    // cancelled
                } else {
                    showErrorNotification(getText('autoCleanErrorOccurred', err.message || err), 'red');
                }
                closeAutoCleanProgress();
                // Revert to snapshot
                try {
                    if (snapshot) {
                        processGeoJSON(snapshot, true);
                    }
                } catch (re) { 
                    showErrorNotification(getText('autoCleanRevertFailed', re.message || re), 'red');
                }
            } finally {
                __autoCleanCancelled = false;
            }
        }

        // Reset snap UI and internal state to known defaults, defeating browser form restore
        function resetSnapControlsToDefaults() {
            try {
                const chk = document.getElementById('snap-enabled');
                const rng = document.getElementById('snap-radius');
                const lbl = document.getElementById('snap-radius-value');
                if (chk) {
                    chk.checked = false;
                }
                if (rng) {
                    rng.value = '10';
                }
                if (lbl) {
                    lbl.textContent = '10';
                }
                // Update internal variables
                snapEnabled = false;
                snapRadius = 10;
            } catch (err) {
                console.warn('Failed to reset snap controls', err);
            }
        }


        function setEditingTool(tool) {
            // Only allow tool changes when in EDIT mode
            if (currentMode !== MODES.EDIT) {
                console.warn('Cannot set tool when not in EDIT mode');
                return;
            }
            
            currentTool = tool;
            
            // Close any open popups when switching tools
            if (map && typeof map.closePopup === 'function') {
                map.closePopup();
            }
            
            // Update button states using the centralized function
            updateToolButtonStates();
            
            // Tool visibility rules
            if (isEditingVertices) {
                if (tool === EDIT_TOOLS.VERTEX) {
                    // Show edge markers for adding vertices
                    edgeMarkers.forEach(marker => {
                        if (!map.hasLayer(marker)) marker.addTo(map);
                    });
                } else if (tool === EDIT_TOOLS.SELECT) {
                    // Hide edge markers, keep vertex markers
                    edgeMarkers.forEach(marker => { if (map.hasLayer(marker)) map.removeLayer(marker); });
                } else if (tool === EDIT_TOOLS.PROPERTIES) {
                    // Hide both vertex and edge markers for a clean properties selection mode
                    edgeMarkers.forEach(marker => { if (map.hasLayer(marker)) map.removeLayer(marker); });
                    vertexMarkers.forEach(marker => { if (map.hasLayer(marker)) map.removeLayer(marker); });
                    // Also unselect the currently edited polygon (remove orange overlay)
                    disableVertexEditing();
                }
            }
            
            // Any tool switch should cancel point relocation edit
            disablePointEditing();
            
            // Stop any active polygon drawing when switching tools
            if (typeof window.__stopPolygonDrawing === 'function') {
                window.__stopPolygonDrawing();
            }
            
            // Set appropriate cursor and map dragging based on tool
            if (tool === EDIT_TOOLS.ADD_POINT || tool === EDIT_TOOLS.ADD_POLYGON) {
                setCursorCrosshair(true);
                if (map && map.dragging && map.dragging.disable) map.dragging.disable();
            } else {
            setCursorCrosshair(false);
            if (map && map.dragging && map.dragging.enable) map.dragging.enable();
            }
            
            // Setup interactions based on new tool
            setupInteraction();
        }

        // Properties modal functions
        function openPropertiesModal(feature) {
            selectedFeature = feature;
            const modal = document.getElementById('propertiesModal');
            const propertiesList = document.getElementById('properties-list');
            
            // Clear existing properties
            propertiesList.innerHTML = '';
            
            // Add existing properties
            if (feature.properties) {
                for (const [key, value] of Object.entries(feature.properties)) {
                    addPropertyRow(key, value);
                }
            }
            
            // Update header title to include feature number and geometry type
            try {
                const header = modal.querySelector('.properties-header h3');
                const idx = (typeof feature.__persistentId === 'number') ? feature.__persistentId : '';
                const geometryType = (feature && feature.geometry && feature.geometry.type) ? feature.geometry.type : 'Unknown';
                if (header) header.textContent = `Edit Properties  Feature ${idx} - ${geometryType}`;
            } catch(_) {}
            modal.classList.add('show');
        }

        function closePropertiesModal() {
            document.getElementById('propertiesModal').classList.remove('show');
            selectedFeature = null;
        }

        function addPropertyRow(key = '', value = '') {
            const propertiesList = document.getElementById('properties-list');
            const row = document.createElement('div');
            row.className = 'property-row';
            
            row.innerHTML = `
                <input type="text" class="property-key" placeholder="Key" value="${key}">
                <input type="text" class="property-value" placeholder="Value" value="${value}">
                <button class="property-remove" onclick="removePropertyRow(this)"></button>
            `;
            
            propertiesList.appendChild(row);
        }

        function removePropertyRow(button) {
            button.parentElement.remove();
        }

        function saveProperties() {
            if (!selectedFeature) return;
            
            const properties = {};
            const rows = document.querySelectorAll('.property-row');
            
            rows.forEach(row => {
                const key = row.querySelector('.property-key').value.trim();
                const value = row.querySelector('.property-value').value.trim();
                if (key) {
                    properties[key] = value;
                }
            });
            
            selectedFeature.properties = properties;
            closePropertiesModal();
            
            // Update the popup if it's open
            updateFeaturePopup(selectedFeature);
        }

        function updateFeaturePopup(feature) {
            try {
                // Update point markers
                pointMarkerLayer.eachLayer(function(m){
                    if (m && m.feature === feature && m.getPopup) {
                        const popup = m.getPopup();
                        if (popup && popup.setContent) {
                            popup.setContent(createFeaturePopupContent(feature));
                        } else if (m.bindPopup) {
                            m.bindPopup(createFeaturePopupContent(feature));
                        }
                    }
                });
                // Update polygon centroid markers
                polygonMarkerLayer.eachLayer(function(m){
                    if (m && m.feature === feature && m.getPopup) {
                        const popup = m.getPopup();
                        if (popup && popup.setContent) {
                            popup.setContent(createFeaturePopupContent(feature));
                        } else if (m.bindPopup) {
                            m.bindPopup(createFeaturePopupContent(feature));
                        }
                    }
                });
            } catch(err) { console.warn('updateFeaturePopup failed', err); }
        }

        // Feature ID management for persistent numbering
        let nextFeatureId = 1;

        function ensureFeatureId(feature) {
            if (!feature || typeof feature !== 'object') return;
            if (typeof feature.__persistentId !== 'number') {
                feature.__persistentId = nextFeatureId++;
            }
        }

        function initializeFeatureIds(features) {
            if (!features || !Array.isArray(features)) return;
            
            // First pass: find the highest existing ID to avoid conflicts
            let maxId = 0;
            for (const feature of features) {
                if (feature && typeof feature.__persistentId === 'number') {
                    maxId = Math.max(maxId, feature.__persistentId);
                }
            }
            nextFeatureId = maxId + 1;
            
            // Second pass: assign IDs to features that don't have them
            for (const feature of features) {
                ensureFeatureId(feature);
            }
        }

        // Vertex editing functionality
        let editingLayer = null;
        let editingPolygonLayer = null;
        let vertexMarkers = [];
        let edgeMarkers = [];
        let isEditingVertices = false;
        let currentEditingFeature = null;
        let editingGeomType = null; // 'Polygon' | 'MultiPolygon'
        let editingPolyIndex = 0;   // for MultiPolygon: which polygon
        let editingRingIndex = 0;   // for Polygon/Multi: which ring
        let editingRingWasClosed = false; // remember closure state at edit start
        let editingOriginalFeatureRef = null; // original feature reference inside currentGeoJSON

        function getEditingRing(ringIndex) {
            // Support optional ringIndex parameter for multi-ring editing
            // If not provided, use the global editingRingIndex (default: 0)
            const idx = (ringIndex !== undefined) ? ringIndex : editingRingIndex;
            
            if (!currentEditingFeature || !currentEditingFeature.geometry) return [];
            const geom = currentEditingFeature.geometry;
            if (geom.type === 'Polygon') {
                return geom.coordinates[idx] || [];
            } else if (geom.type === 'MultiPolygon') {
                const poly = geom.coordinates[editingPolyIndex] || [];
                return poly[idx] || [];
            }
            return [];
        }

        function getAllEditingRings() {
            // Returns array of all rings: [outerRing, hole1, hole2, ...]
            if (!currentEditingFeature || !currentEditingFeature.geometry) return [];
            const geom = currentEditingFeature.geometry;
            
            if (geom.type === 'Polygon') {
                return geom.coordinates || [];
            } else if (geom.type === 'MultiPolygon') {
                const poly = geom.coordinates[editingPolyIndex] || [];
                return poly;
            }
            return [];
        }

        function setEditingRing(ringIndex, newRing) {
            // Support both old signature setEditingRing(newRing) and new setEditingRing(ringIndex, newRing)
            let idx, ring;
            if (newRing === undefined) {
                // Old signature: setEditingRing(newRing) - use global editingRingIndex
                ring = ringIndex; // first param is actually the ring
                idx = editingRingIndex;
            } else {
                // New signature: setEditingRing(ringIndex, newRing)
                idx = ringIndex;
                ring = newRing;
            }
            
            if (!currentEditingFeature || !currentEditingFeature.geometry) return;
            const geom = currentEditingFeature.geometry;
            if (geom.type === 'Polygon') {
                geom.coordinates[idx] = ring;
            } else if (geom.type === 'MultiPolygon') {
                if (!geom.coordinates[editingPolyIndex]) geom.coordinates[editingPolyIndex] = [];
                geom.coordinates[editingPolyIndex][idx] = ring;
            }
        }

        function removeEditingRing(ringIndex) {
            // Remove a hole (ringIndex > 0) from the current polygon
            if (ringIndex === 0) {
                console.error('Cannot remove outer ring');
                return;
            }
            
            if (!currentEditingFeature || !currentEditingFeature.geometry) return;
            const geom = currentEditingFeature.geometry;
            
            if (geom.type === 'Polygon') {
                if (geom.coordinates && geom.coordinates.length > ringIndex) {
                    geom.coordinates.splice(ringIndex, 1);
                }
            } else if (geom.type === 'MultiPolygon') {
                const poly = geom.coordinates[editingPolyIndex];
                if (poly && poly.length > ringIndex) {
                    poly.splice(ringIndex, 1);
                }
            }
        }

        function ringIsClosed(ring) {
            if (!ring || ring.length < 2) return false;
            const a = ring[0];
            const b = ring[ring.length - 1];
            return a[0] === b[0] && a[1] === b[1];
        }

        function getOpenRing(ringIndex) {
            // Support optional ringIndex parameter
            const ring = getEditingRing(ringIndex);
            if (!ring || ring.length === 0) return [];
            if (ringIsClosed(ring)) return ring.slice(0, ring.length - 1);
            return ring.slice();
        }

        function enableVertexEditing(layer, feature) {
            if (isEditingVertices) {
                disableVertexEditing();
            }
            
            editingLayer = layer;
            currentEditingFeature = JSON.parse(JSON.stringify(feature)); // Deep copy to avoid reference issues
            editingGeomType = currentEditingFeature.geometry.type;
            editingPolyIndex = 0;
            editingRingIndex = 0;
            
            // Setup MultiPolygon selection UI if needed
            if (editingGeomType === 'MultiPolygon') {
                setupMultiPolygonSelectors();
            } else {
                hideMultiPolygonSelectors();
            }
            
            editingRingWasClosed = ringIsClosed(getEditingRing());
            editingOriginalFeatureRef = feature;
            isEditingVertices = true;
            vertexMarkers = [];
            edgeMarkers = [];
            
            // Get all rings (outer + holes) from the feature
            const allRings = getAllEditingRings();
            
            // Create a simple polygon for editing overlay with all rings
            // Leaflet.polygon() accepts array of rings: [outerRing, hole1, hole2, ...]
            // Each ring must be closed for proper rendering
            const allLatLngs = allRings.map(ring => {
                const latLngs = ring.map(coord => [coord[1], coord[0]]);
                if (latLngs.length > 0) {
                    const first = latLngs[0];
                    const last = latLngs[latLngs.length - 1];
                    if (first[0] !== last[0] || first[1] !== last[1]) {
                        latLngs.push([first[0], first[1]]);
                    }
                }
                return latLngs;
            });
            
            editingPolygonLayer = L.polygon(allLatLngs, {
                fillColor: '#3388ff',
                fillRule: 'nonzero',
                weight: 3,
                opacity: 1,
                color: '#ff7800',
                fillOpacity: 0.2
            }).addTo(map);
            
            // Add click detection to the editing polygon layer for MultiPolygon switching
            if (editingGeomType === 'MultiPolygon') {
                editingPolygonLayer.on('click', function(e) {
                    const clickedPolyIndex = detectClickedPolygonInMultiPolygon(currentEditingFeature, e.latlng);
                    if (clickedPolyIndex >= 0 && clickedPolyIndex !== editingPolyIndex) {
                        switchToPolygonEditing(clickedPolyIndex);
                    }
                    // Stop propagation to prevent other click handlers
                    if (e && e.stopPropagation) e.stopPropagation();
                    if (e && e.originalEvent && e.originalEvent.stopPropagation) e.originalEvent.stopPropagation();
                });
            }
            
            // For MultiPolygon, create a visual overlay showing non-selected polygons
            if (editingGeomType === 'MultiPolygon') {
                createNonSelectedPolygonsOverlay(currentEditingFeature, editingPolyIndex);
                // Hide the original layer completely
                layer.setStyle({ opacity: 0, fillOpacity: 0 });
            } else {
                // For regular Polygon, hide the original layer
                layer.setStyle({ opacity: 0, fillOpacity: 0 });
            }
            
            // Create vertex markers for ALL rings (outer + holes)
            // Reuse allRings variable from above
            allRings.forEach((ring, ringIndex) => {
                const openRing = getOpenRing(ringIndex);
                openRing.forEach((coord, vertexIndex) => {
                    const latLng = L.latLng(coord[1], coord[0]);
                    const marker = createDraggableVertex(latLng, vertexIndex, currentEditingFeature, ringIndex);
                    marker.addTo(map);
                    vertexMarkers.push(marker);
                });
            });

            // Create edge markers for adding vertices for ALL rings
            allRings.forEach((ring, ringIndex) => {
                createEdgeMarkers(ring, ringIndex);
            });
        }

        function createDraggableVertex(latlng, index, feature, ringIndex = 0) {
            // Create a marker with custom HTML content that looks like a circle
            // Use different styling for holes (ringIndex > 0) vs outer ring (ringIndex = 0)
            const isHole = ringIndex > 0;
            const vertexIcon = L.divIcon({
                className: isHole ? 'vertex-marker vertex-marker-hole' : 'vertex-marker',
                html: '<div></div>',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
            
            const marker = L.marker(latlng, {
                icon: vertexIcon,
                draggable: true
            });
            
            marker.coordIndex = index;
            marker.ringIndex = ringIndex;
            marker.feature = feature;
            
            // Add event listeners
            marker.on('dragstart', onVertexDragStart);
            marker.on('drag', onVertexDrag);
            marker.on('dragend', onVertexDragEnd);
            marker.on('click', onVertexClick);
            
            return marker;
        }

        function createEdgeMarkers(coordinates, ringIndex = 0) {
            const n = coordinates.length;
            if (!n) return;
            // If ring is closed, avoid duplicating the closing segment twice
            const isClosed = coordinates[0][0] === coordinates[n-1][0] && coordinates[0][1] === coordinates[n-1][1];
            const iter = isClosed ? n - 1 : n;
            for (let i = 0; i < iter; i++) {
                const currentCoord = coordinates[i];
                const nextCoord = coordinates[(i + 1) % n];
                
                // Calculate midpoint
                const midLat = (currentCoord[1] + nextCoord[1]) / 2;
                const midLng = (currentCoord[0] + nextCoord[0]) / 2;
                
                // Create a smaller marker for adding vertices
                const edgeIcon = L.divIcon({
                    className: 'edge-marker',
                    html: '<div></div>',
                    iconSize: [10, 10],
                    iconAnchor: [5, 5]
                });
                
                const edgeMarker = L.marker([midLat, midLng], {
                    icon: edgeIcon
                });
                
                edgeMarker.edgeIndex = i;
                edgeMarker.ringIndex = ringIndex;
                edgeMarker.on('click', onEdgeClick);
                
                // Only add to map if vertex tool is active
                if (currentTool === EDIT_TOOLS.VERTEX) {
                    edgeMarker.addTo(map);
                }
                edgeMarkers.push(edgeMarker);
            }
        }

        function disableVertexEditing() {
            if (!isEditingVertices) return;
            
            console.log('Disabling vertex editing');
            
            // Remove vertex markers
            vertexMarkers.forEach(marker => {
                map.removeLayer(marker);
            });
            
            // Remove edge markers
            edgeMarkers.forEach(marker => {
                map.removeLayer(marker);
            });
            
            // Remove editing polygon layer
            if (editingPolygonLayer) {
                map.removeLayer(editingPolygonLayer);
                editingPolygonLayer = null;
            }
            
            // Update and restore original layer with final coordinates
            if (editingLayer && currentEditingFeature) {
                // Normalize winding order before saving final edited geometry
                normalizeFeatureWindingOrder(currentEditingFeature);
                
                // Copy the updated geometry back to the original feature
                if (editingOriginalFeatureRef) {
                    editingOriginalFeatureRef.geometry = JSON.parse(JSON.stringify(currentEditingFeature.geometry));
                }
                if (editingLayer.feature) {
                    editingLayer.feature.geometry = JSON.parse(JSON.stringify(currentEditingFeature.geometry));
                    
                    // Update the original layer's coordinates with ALL rings (outer + holes)
                    if (editingLayer.setLatLngs) {
                        // Rebuild full latLng structure for this layer from the feature geometry
                        const geom = currentEditingFeature.geometry;
                        if (geom.type === 'Polygon') {
                            // For Polygon, pass array of rings [outerRing, hole1, hole2, ...]
                            const allRingsLatLngs = geom.coordinates.map(ring => {
                                return ring.map(coord => [coord[1], coord[0]]);
                            });
                            editingLayer.setLatLngs(allRingsLatLngs);
                        } else if (geom.type === 'MultiPolygon') {
                            // For MultiPolygon, pass array of polygons, each with array of rings
                            const allPolygonsLatLngs = geom.coordinates.map(poly => {
                                return poly.map(ring => ring.map(coord => [coord[1], coord[0]]));
                            });
                            editingLayer.setLatLngs(allPolygonsLatLngs);
                        }
                    }
                }
                
                // Restore original layer visibility
                editingLayer.setStyle({ 
                    opacity: 0.8, 
                    fillOpacity: 0.15 
                });
            }
            
            vertexMarkers = [];
            edgeMarkers = [];
            editingLayer = null;
            currentEditingFeature = null;
            isEditingVertices = false;
            editingOriginalFeatureRef = null;
            
            // Hide MultiPolygon selectors and remove overlay
            hideMultiPolygonSelectors();
            removeNonSelectedPolygonsOverlay();
        }

        function setupMultiPolygonSelectors() {
            if (!currentEditingFeature || editingGeomType !== 'MultiPolygon') return;
            
            const selectionDiv = document.getElementById('multipolygon-selection');
            const polygonSelector = document.getElementById('polygon-selector');
            const ringSelector = document.getElementById('ring-selector');
            
            // Show the selection controls
            selectionDiv.style.display = 'block';
            
            // Populate polygon selector
            polygonSelector.innerHTML = '';
            const polygons = currentEditingFeature.geometry.coordinates || [];
            for (let i = 0; i < polygons.length; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Polygon ${i + 1}`;
                polygonSelector.appendChild(option);
            }
            polygonSelector.value = editingPolyIndex;
            
            // Populate ring selector for current polygon
            updateRingSelector();
            
            // Add event listeners if not already added
            if (!polygonSelector.hasAttribute('data-listeners-added')) {
                polygonSelector.addEventListener('change', onPolygonSelectorChange);
                ringSelector.addEventListener('change', onRingSelectorChange);
                polygonSelector.setAttribute('data-listeners-added', 'true');
                ringSelector.setAttribute('data-listeners-added', 'true');
            }
        }

        function updateRingSelector() {
            const ringSelector = document.getElementById('ring-selector');
            ringSelector.innerHTML = '';
            
            if (!currentEditingFeature || editingGeomType !== 'MultiPolygon') return;
            
            const polygon = currentEditingFeature.geometry.coordinates[editingPolyIndex] || [];
            for (let i = 0; i < polygon.length; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i === 0 ? 'Outer Ring' : `Hole ${i}`;
                ringSelector.appendChild(option);
            }
            ringSelector.value = editingRingIndex;
        }

        function hideMultiPolygonSelectors() {
            const selectionDiv = document.getElementById('multipolygon-selection');
            selectionDiv.style.display = 'none';
        }
        function onPolygonSelectorChange(e) {
            const newPolyIndex = parseInt(e.target.value);
            if (newPolyIndex !== editingPolyIndex) {
                editingPolyIndex = newPolyIndex;
                editingRingIndex = 0; // Reset to outer ring
                updateRingSelector();
                refreshVertexEditing();
            }
        }

        function onRingSelectorChange(e) {
            const newRingIndex = parseInt(e.target.value);
            if (newRingIndex !== editingRingIndex) {
                editingRingIndex = newRingIndex;
                refreshVertexEditing();
            }
        }

        function refreshVertexEditing() {
            // Remove current markers and polygon overlay
            vertexMarkers.forEach(marker => map.removeLayer(marker));
            edgeMarkers.forEach(marker => map.removeLayer(marker));
            if (editingPolygonLayer) {
                map.removeLayer(editingPolygonLayer);
            }
            
            // Reset arrays
            vertexMarkers = [];
            edgeMarkers = [];
            
            // Get new coordinates for the selected polygon/ring
            let coordinates = getEditingRing();
            editingRingWasClosed = ringIsClosed(coordinates);
            
            // Get all rings (outer + holes) from the feature
            const allRings = getAllEditingRings();
            
            // Create new editing polygon overlay with all rings
            const allLatLngs = allRings.map(ring => {
                const latLngs = ring.map(coord => [coord[1], coord[0]]);
                if (latLngs.length > 0) {
                    const first = latLngs[0];
                    const last = latLngs[latLngs.length - 1];
                    if (first[0] !== last[0] || first[1] !== last[1]) {
                        latLngs.push([first[0], first[1]]);
                    }
                }
                return latLngs;
            });
            
            editingPolygonLayer = L.polygon(allLatLngs, {
                fillColor: '#3388ff',
                fillRule: 'nonzero',
                weight: 3,
                opacity: 1,
                color: '#ff7800',
                fillOpacity: 0.2
            }).addTo(map);
            
            // Add click detection to the editing polygon layer for MultiPolygon switching
            if (editingGeomType === 'MultiPolygon') {
                editingPolygonLayer.on('click', function(e) {
                    const clickedPolyIndex = detectClickedPolygonInMultiPolygon(currentEditingFeature, e.latlng);
                    if (clickedPolyIndex >= 0 && clickedPolyIndex !== editingPolyIndex) {
                        switchToPolygonEditing(clickedPolyIndex);
                    }
                    // Stop propagation to prevent other click handlers
                    if (e && e.stopPropagation) e.stopPropagation();
                    if (e && e.originalEvent && e.originalEvent.stopPropagation) e.originalEvent.stopPropagation();
                });
            }
            
            // Update non-selected polygons overlay for MultiPolygon
            if (editingGeomType === 'MultiPolygon') {
                updateNonSelectedPolygonsOverlay(currentEditingFeature, editingPolyIndex);
            }
            
            // Create new vertex markers for ALL rings (outer + holes)
            const ringsForMarkers = getAllEditingRings();
            ringsForMarkers.forEach((ring, ringIndex) => {
                const openRing = getOpenRing(ringIndex);
                openRing.forEach((coord, vertexIndex) => {
                    const latLng = L.latLng(coord[1], coord[0]);
                    const marker = createDraggableVertex(latLng, vertexIndex, currentEditingFeature, ringIndex);
                    marker.addTo(map);
                    vertexMarkers.push(marker);
                });
            });
            
            // Create new edge markers for ALL rings
            ringsForMarkers.forEach((ring, ringIndex) => {
                createEdgeMarkers(ring, ringIndex);
            });
        }

        // Global variable to track the non-selected polygons overlay
        let nonSelectedPolygonsLayer = null;

        function createNonSelectedPolygonsOverlay(feature, selectedPolygonIndex) {
            // Remove existing overlay if any
            if (nonSelectedPolygonsLayer) {
                map.removeLayer(nonSelectedPolygonsLayer);
                nonSelectedPolygonsLayer = null;
            }
            
            if (!feature.geometry || feature.geometry.type !== 'MultiPolygon') return;
            
            const coordinates = feature.geometry.coordinates;
            const nonSelectedPolygons = [];
            
            // Create array of all polygons except the selected one
            for (let i = 0; i < coordinates.length; i++) {
                if (i !== selectedPolygonIndex) {
                    nonSelectedPolygons.push(coordinates[i]);
                }
            }
            
            if (nonSelectedPolygons.length > 0) {
                // Create a new MultiPolygon feature with only non-selected polygons
                const overlayFeature = {
                    type: 'Feature',
                    geometry: {
                        type: 'MultiPolygon',
                        coordinates: nonSelectedPolygons
                    },
                    properties: feature.properties || {}
                };
                
                // Create the overlay layer with click detection
                nonSelectedPolygonsLayer = L.geoJSON(overlayFeature, {
                    style: {
                        fillColor: '#3388ff',
                        fillRule: 'nonzero',
                        weight: 2,
                        opacity: 0.6,
                        color: '#3388ff',
                        fillOpacity: 0.1
                    },
                    onEachFeature: function(overlayFeature, overlayLayer) {
                        overlayLayer.on('click', function(e) {
                            // Detect which polygon in the overlay was clicked
                            const clickedPolyIndex = detectClickedPolygonInMultiPolygon(feature, e.latlng);
                            if (clickedPolyIndex >= 0) {
                                // Switch to editing the clicked polygon
                                switchToPolygonEditing(clickedPolyIndex);
                            }
                            // Stop propagation to prevent other click handlers
                            if (e && e.stopPropagation) e.stopPropagation();
                            if (e && e.originalEvent && e.originalEvent.stopPropagation) e.originalEvent.stopPropagation();
                        });
                    }
                }).addTo(map);
            }
        }

        function updateNonSelectedPolygonsOverlay(feature, selectedPolygonIndex) {
            createNonSelectedPolygonsOverlay(feature, selectedPolygonIndex);
        }

        function removeNonSelectedPolygonsOverlay() {
            if (nonSelectedPolygonsLayer) {
                map.removeLayer(nonSelectedPolygonsLayer);
                nonSelectedPolygonsLayer = null;
            }
        }

        function switchToPolygonEditing(newPolygonIndex) {
            if (!isEditingVertices || editingGeomType !== 'MultiPolygon' || newPolygonIndex === editingPolyIndex) {
                return; // Not editing MultiPolygon or already on the selected polygon
            }
            
            // Update the polygon index
            editingPolyIndex = newPolygonIndex;
            editingRingIndex = 0; // Reset to outer ring
            
            // Update the UI selectors
            const polygonSelector = document.getElementById('polygon-selector');
            const ringSelector = document.getElementById('ring-selector');
            if (polygonSelector) {
                polygonSelector.value = editingPolyIndex;
            }
            updateRingSelector();
            
            // Refresh the editing interface
            refreshVertexEditing();
        }

        function onVertexDragStart(e) {
            // Store original position for potential snapping
            e.target.originalPosition = e.target.getLatLng();
            // Initialize last valid position for hole constraint
            e.target.lastValidPosition = e.target.getLatLng();
            // Snapshot prior to vertex drag modification
            if (currentEditingFeature) {
                pushUndoSnapshot('vertex-drag', currentEditingFeature, 'edit');
            }
            __draggingVertexActive = true;
            suppressEmptyDeselect(1000);
        }

        function onVertexDrag(e) {
            const marker = e.target;
            let newPos = marker.getLatLng();
            
            // Apply snapping if enabled (points and segments)
            if (snapEnabled) {
                const result = findSnapPoint(newPos, marker);
                if (result && result.latlng) {
                    newPos = result.latlng;
                    marker.setLatLng(result.latlng);
                }
            }
            
            // Hole vertex constraint: prevent dragging outside the outer ring
            const ringIndex = marker.ringIndex || 0;
            if (ringIndex > 0) {
                // This is a hole vertex - check if it's still inside the outer ring
                const outerRing = getEditingRing(0);
                if (!isPointInsideRing(newPos, outerRing)) {
                    // Reject the drag - stay at last valid position
                    if (marker.lastValidPosition) {
                        marker.setLatLng(marker.lastValidPosition);
                        return; // Don't update geometry
                    }
                } else {
                    // Update last valid position since we're still inside
                    marker.lastValidPosition = newPos;
                }
            }
            
            // While dragging, keep suppression active so stray clicks don't clear selection
            suppressEmptyDeselect(1000);
            
            // Update the polygon geometry in real-time
            updatePolygonGeometryRealTime(marker, newPos);
        }

        function onVertexDragEnd(e) {
            const marker = e.target;
            
            // Reset update counter
            marker._updateCounter = 0;
            
            // Final update of edge markers
            updateEdgeMarkers();
            
            // Update the original feature in the main layer
            const feature = currentEditingFeature;
            
            // NOTE: Don't normalize winding order during editing - it causes vertex markers
            // to become disconnected because coordIndex values don't match reversed coordinates.
            // Winding order is normalized when editing completes in disableVertexEditing()
            
            // Update the original layer's geometry
            if (editingLayer && editingLayer.feature) {
                // Copy the updated geometry back to the original feature
                editingLayer.feature.geometry = JSON.parse(JSON.stringify(feature.geometry));
                
                // Update the original layer's coordinates with ALL rings (outer + holes)
                if (editingLayer.setLatLngs) {
                    if (feature.geometry.type === 'Polygon') {
                        // For Polygon, coordinates is array of rings [outerRing, hole1, hole2, ...]
                        const allRingsLatLngs = feature.geometry.coordinates.map(ring => {
                            let latLngs = ring.map(coord => [coord[1], coord[0]]);
                            if (latLngs.length > 0) {
                                const f = latLngs[0];
                                const l = latLngs[latLngs.length - 1];
                                if (f[0] !== l[0] || f[1] !== l[1]) {
                                    latLngs = [...latLngs, [f[0], f[1]]];
                                }
                            }
                            return latLngs;
                        });
                        editingLayer.setLatLngs(allRingsLatLngs);
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        // For MultiPolygon, need to update the specific polygon
                        const allPolygonsLatLngs = feature.geometry.coordinates.map(poly => {
                            return poly.map(ring => {
                                let latLngs = ring.map(coord => [coord[1], coord[0]]);
                                if (latLngs.length > 0) {
                                    const f = latLngs[0];
                                    const l = latLngs[latLngs.length - 1];
                                    if (f[0] !== l[0] || f[1] !== l[1]) {
                                        latLngs = [...latLngs, [f[0], f[1]]];
                                    }
                                }
                                return latLngs;
                            });
                        });
                        editingLayer.setLatLngs(allPolygonsLatLngs);
                    }
                }
            }
            
            // Update the polygon's centroid marker position (only on drag end for performance)
            try {
                // Get the correct ring based on geometry type
                let outerRing;
                if (feature.geometry.type === 'Polygon') {
                    outerRing = feature.geometry.coordinates[0];
                } else if (feature.geometry.type === 'MultiPolygon') {
                    // For MultiPolygon, get the outer ring of the first sub-polygon
                    outerRing = feature.geometry.coordinates[0][0];
                }
                
                const newCentroid = outerRing ? calculatePolygonCentroid(outerRing) : null;
                if (newCentroid) {
                    // Find and update the centroid marker using the editingLayer reference
                    let markerFound = false;
                    
                    // Check in polygonMarkerLayer
                    polygonMarkerLayer.eachLayer(function(m) {
                        if (m.feature === editingLayer.feature || m.feature === feature) {
                            m.setLatLng([newCentroid[1], newCentroid[0]]);
                            markerFound = true;
                        }
                    });
                    
                    // Also check in combinedClusterGroup if clustering is active
                    if (!markerFound && combinedClusterGroup) {
                        combinedClusterGroup.eachLayer(function(m) {
                            if (m.feature === editingLayer.feature || m.feature === feature) {
                                m.setLatLng([newCentroid[1], newCentroid[0]]);
                                markerFound = true;
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error updating polygon marker:', error);
            }
            
            __draggingVertexActive = false;
            suppressEmptyDeselect(500);
        }

        function onVertexClick(e) {
            if (currentTool === 'vertex') {
                // Remove vertex functionality
                const marker = e.target;
            if (vertexMarkers.length <= 3) {
                pendingDeletePolygon = true;
                openDeletePolygonModal();
                return;
            }
                if (currentEditingFeature) {
                    pushUndoSnapshot('remove-vertex', currentEditingFeature, 'edit');
                }
                
                removeVertex(marker);
                // Safe stopPropagation call
                if (e && typeof e.stopPropagation === 'function') {
                    e.stopPropagation();
                }
            }
        }

        function updatePolygonGeometryRealTime(draggedMarker, newPos) {
            if (!currentEditingFeature || !editingPolygonLayer) {
                console.error('Missing editing feature or polygon layer');
                return;
            }
            
            const feature = currentEditingFeature;
            const coordIndex = draggedMarker.coordIndex;
            const ringIndex = draggedMarker.ringIndex || 0;
            
            // Update the coordinate in the specified ring
            const ring = getEditingRing(ringIndex).slice();
            if (!ring || ring.length < 3) return;
            ring[coordIndex] = [newPos.lng, newPos.lat];
            // If moving first vertex and ring was closed, mirror to last
            const wasClosed = ringIsClosed(getEditingRing(ringIndex));
            if (coordIndex === 0 && wasClosed) {
                ring[ring.length - 1] = [newPos.lng, newPos.lat];
            }
            setEditingRing(ringIndex, ring);
            
            // Update ALL rings for rendering (outer + holes)
            const allRings = getAllEditingRings();
            const allLatLngs = allRings.map(r => {
                let latLngs = r.map(coord => [coord[1], coord[0]]);
                if (latLngs.length > 0) {
                    const f = latLngs[0];
                    const l = latLngs[latLngs.length - 1];
                    if (f[0] !== l[0] || f[1] !== l[1]) {
                        latLngs = [...latLngs, [f[0], f[1]]];
                    }
                }
                return latLngs;
            });
            
            // Update the polygon directly with all rings
            try {
                if (editingPolygonLayer && editingPolygonLayer.setLatLngs) {
                    editingPolygonLayer.setLatLngs(allLatLngs);
                } else {
                    console.error('editingPolygonLayer does not have setLatLngs method');
                }
            } catch (error) {
                console.error('Error updating polygon:', error);
            }
            
            
            // Update edge markers occasionally for performance
            if (draggedMarker._updateCounter === undefined) draggedMarker._updateCounter = 0;
            if ((++draggedMarker._updateCounter % 5) === 0) updateEdgeMarkers();
        }

        function updateEdgeMarkers() {
            // Remove old edge markers
            edgeMarkers.forEach(marker => map.removeLayer(marker));
            edgeMarkers = [];
            
            // Create new edge markers with updated positions for ALL rings
            const allRings = getAllEditingRings();
            allRings.forEach((ring, ringIndex) => {
                createEdgeMarkers(ring, ringIndex);
            });
        }

        // Build nearest snap candidate to points or segments across all polygons in polygonLayer
        function findSnapPoint(currentPos, excludeMarker) {
            if (!snapEnabled || !map) return null;

            const snapPx = snapRadius;
            const vertexSnapPx = snapPx * 1.5; // stronger vertex snap radius
            const p = map.latLngToContainerPoint(currentPos);

            // Track best vertex and best segment separately to prioritize vertices
            let bestPoint = null;
            let bestSegment = null;

            function considerPoint(candidateLatLng, meta) {
                const cp = map.latLngToContainerPoint(candidateLatLng);
                const dx = cp.x - p.x;
                const dy = cp.y - p.y;
                const dist = Math.hypot(dx, dy);
                if (dist <= vertexSnapPx && (!bestPoint || dist < bestPoint.dist)) {
                    bestPoint = { type: 'point', latlng: candidateLatLng, dist, meta };
                }
            }

            function considerSegment(a, b, meta) {
                const ap = map.latLngToContainerPoint(a);
                const bp = map.latLngToContainerPoint(b);
                const vx = bp.x - ap.x;
                const vy = bp.y - ap.y;
                const wx = p.x - ap.x;
                const wy = p.y - ap.y;
                const vv = vx*vx + vy*vy;
                if (vv === 0) return; // degenerate
                let t = (wx*vx + wy*vy) / vv;
                if (t < 0) t = 0; else if (t > 1) t = 1;
                const qx = ap.x + t * vx;
                const qy = ap.y + t * vy;
                const dist = Math.hypot(qx - p.x, qy - p.y);
                if (dist <= snapPx && (!bestSegment || dist < bestSegment.dist)) {
                    const qLatLng = map.containerPointToLatLng(L.point(qx, qy));
                    bestSegment = { type: 'segment', latlng: qLatLng, dist, meta: { ...meta, t } };
                }
            }

            // Identify the currently edited polygon to exclude it from snapping
            const excludeLayer = typeof editingLayer !== 'undefined' ? editingLayer : null;
            const excludeFeature = typeof editingOriginalFeatureRef !== 'undefined' ? editingOriginalFeatureRef : null;

            // Iterate all polygon parts
            polygonLayer.eachLayer(function(parent) {
                if (parent && parent.eachLayer) {
                    parent.eachLayer(function(child) {
                        if (!child || !child.getLatLngs) return;
                        const featureRef = child.feature || (parent.feature || null);

                        // Skip the polygon currently being edited (no self-snapping)
                        if ((excludeLayer && (child === excludeLayer || parent === excludeLayer)) ||
                            (excludeFeature && featureRef === excludeFeature)) {
                            return;
                        }

                        let rings = child.getLatLngs();
                        if (!Array.isArray(rings) || rings.length === 0) return;
                        // Normalize to array of rings of LatLng
                        // Handle MultiPolygon (array of polygons, each array of rings)
                        if (Array.isArray(rings[0]) && Array.isArray(rings[0][0])) {
                            // rings: polygons[] -> rings[] -> LatLng[]
                            rings.forEach((poly, polyIdx) => {
                                poly.forEach((ring, ringIdx) => {
                                    const n = ring.length;
                                    if (n === 0) return;
                                    // Consider vertices
                                    ring.forEach((latlng, vi) => considerPoint(latlng, { layer: child, feature: featureRef, ringIndex: ringIdx, vertexIndex: vi, polyIndex: polyIdx }));
                                    // Consider edges (closed)
                                    for (let i = 0; i < n; i++) {
                                        const a = ring[i];
                                        const b = ring[(i+1)%n];
                                        considerSegment(a, b, { layer: child, feature: featureRef, ringIndex: ringIdx, segIndex: i, polyIndex: polyIdx });
                                    }
                                });
                            });
                        } else {
                            // Polygon: rings[] -> LatLng[]
                            rings.forEach((ring, ringIdx) => {
                                const n = ring.length;
                                if (n === 0) return;
                                ring.forEach((latlng, vi) => considerPoint(latlng, { layer: child, feature: featureRef, ringIndex: ringIdx, vertexIndex: vi }));
                                for (let i = 0; i < n; i++) {
                                    const a = ring[i];
                                    const b = ring[(i+1)%n];
                                    considerSegment(a, b, { layer: child, feature: featureRef, ringIndex: ringIdx, segIndex: i });
                                }
                            });
                        }
                    });
                }
            });

            // Choose vertex over segment if available
            let best = bestPoint || bestSegment;

            // Exclude snapping to the exact same dragged vertex position
            if (excludeMarker && best && best.type === 'point') {
                const ex = excludeMarker.getLatLng();
                const bp = map.latLngToContainerPoint(best.latlng);
                const ep = map.latLngToContainerPoint(ex);
                if (Math.hypot(bp.x - ep.x, bp.y - ep.y) < 0.1) {
                    // ignore trivial same-point snap
                    return null;
                }
            }

            return best;
        }

        let pendingDeletePolygon = false;

        function removeVertex(marker) {
            const coordIndex = marker.coordIndex;
            const ringIndex = marker.ringIndex || 0;
            
            // Get the current ring
            let ring = getEditingRing(ringIndex).slice();
            
            // Check if ring is closed (first and last are same)
            const isClosed = ringIsClosed(ring);
            
            // For closed rings: need at least 4 vertices (3 unique + closing duplicate)
            // For open rings: need at least 3 vertices
            const minVertices = isClosed ? 4 : 3;
            
            // Check if removing this vertex would leave < minimum vertices
            if (ring.length <= minVertices) {
                if (ringIndex === 0) {
                    // Outer ring - open confirm modal to delete entire polygon
                    pendingDeletePolygon = true;
                    openDeletePolygonModal();
                    return;
                } else {
                    // Hole - just remove the hole entirely
                    removeEditingRing(ringIndex);
                    refreshVertexEditing(); // Rebuild markers and overlay
                    return;
                }
            }
            
            // Normal vertex removal
            ring.splice(coordIndex, 1);
            // Ensure closed ring stays closed if it was
            if (ring.length >= 3) {
                const wasClosed = ringIsClosed(getEditingRing(ringIndex));
                if (wasClosed) {
                    ring[ring.length - 1] = ring[0];
                }
            }
            setEditingRing(ringIndex, ring);
            
            // Remove the marker
            map.removeLayer(marker);
            const markerIndex = vertexMarkers.indexOf(marker);
            vertexMarkers.splice(markerIndex, 1);
            
            // Update indices for remaining markers in the same ring
            vertexMarkers.forEach((m) => {
                if (m.ringIndex === ringIndex && m.coordIndex > coordIndex) {
                    m.coordIndex--;
                }
            });
            
            // NOTE: Don't normalize winding order during editing - it causes vertex markers
            // to become disconnected. Winding order is normalized when editing completes.
            
            // Update the editing polygon with ALL rings
            if (editingPolygonLayer && editingPolygonLayer.setLatLngs) {
                const allRings = getAllEditingRings();
                const allLatLngs = allRings.map(r => {
                    const latLngs = r.map(coord => [coord[1], coord[0]]);
                    return latLngs;
                });
                editingPolygonLayer.setLatLngs(allLatLngs);
            }
            
            // Update edge markers
            updateEdgeMarkers();
        }

        function openDeletePolygonModal() {
            document.getElementById('deletePolygonModal').classList.add('show');
        }
        function closeDeletePolygonModal() {
            pendingDeletePolygon = false;
            document.getElementById('deletePolygonModal').classList.remove('show');
        }
        function confirmDeletePolygon() {
            try {
                // Capture references BEFORE disabling edit (which nulls them)
                const layerToRemove = editingLayer;
                const featureRef = editingOriginalFeatureRef || currentEditingFeature;
                
                // Determine operation type: edit for MultiPolygon (modifying coordinates), delete for regular Polygon
                const isMultiPolygonEdit = editingGeomType === 'MultiPolygon' && 
                                          featureRef && 
                                          featureRef.geometry && 
                                          featureRef.geometry.coordinates && 
                                          featureRef.geometry.coordinates.length > 1;
                
                if (featureRef) {
                    pushUndoSnapshot('remove-polygon', featureRef, isMultiPolygonEdit ? 'edit' : 'delete');
                }

                // Remove overlays and restore styles without re-adding the layer
                if (editingPolygonLayer) {
                    map.removeLayer(editingPolygonLayer);
                    editingPolygonLayer = null;
                }
                // Also remove vertex/edge markers if any still present
                vertexMarkers.forEach(m => map.removeLayer(m));
                edgeMarkers.forEach(m => map.removeLayer(m));
                vertexMarkers = [];
                edgeMarkers = [];

                if (editingGeomType === 'MultiPolygon') {
                    // Remove only the selected polygon from MultiPolygon
                    const coordinates = featureRef.geometry.coordinates;
                    if (coordinates && coordinates.length > 1) {
                        // Remove the selected polygon
                        coordinates.splice(editingPolyIndex, 1);
                        
                        // Update the layer with new coordinates
                        if (layerToRemove && layerToRemove.setLatLngs) {
                            const polys = coordinates.map(poly => poly[0].map(coord => [coord[1], coord[0]]));
                            layerToRemove.setLatLngs(polys);
                        }
                        
                        // Restore layer visibility and disable editing
                        if (layerToRemove) {
                            layerToRemove.setStyle({ 
                                opacity: 0.8, 
                                fillOpacity: 0.15 
                            });
                        }
                        
                        // Update currentGeoJSON
                        if (currentGeoJSON && currentGeoJSON.features) {
                            const idx = currentGeoJSON.features.indexOf(featureRef);
                            if (idx >= 0) {
                                currentGeoJSON.features[idx].geometry.coordinates = coordinates;
                            }
                        }
                    } else {
                        // Only one polygon left, remove entire feature
                        removeEntireFeature(featureRef, layerToRemove);
                    }
                } else {
                    // Regular Polygon, remove entire feature
                    removeEntireFeature(featureRef, layerToRemove);
                }

                // Clear editing refs
                editingLayer = null;
                currentEditingFeature = null;
                editingOriginalFeatureRef = null;
                hideMultiPolygonSelectors();
                removeNonSelectedPolygonsOverlay();

                // Close modal
                closeDeletePolygonModal();
            } catch (e) {
                console.error('Error deleting polygon:', e);
                closeDeletePolygonModal();
            }
        }
        
        function removeEntireFeature(featureRef, layerToRemove) {
            // Remove from currentGeoJSON
            if (currentGeoJSON && featureRef && currentGeoJSON.features && Array.isArray(currentGeoJSON.features)) {
                const idx = currentGeoJSON.features.indexOf(featureRef);
                if (idx >= 0) currentGeoJSON.features.splice(idx, 1);
            }

            // Remove the Leaflet layer from polygonLayer if present
            if (layerToRemove) {
                polygonLayer.removeLayer(layerToRemove);
            }
        }

        function onEdgeClick(e) {
            if (currentTool !== EDIT_TOOLS.VERTEX) return;
            
            const edgeMarker = e.target;
            const edgeIndex = edgeMarker.edgeIndex;
            const ringIndex = edgeMarker.ringIndex || 0;
            const newPos = edgeMarker.getLatLng();
            
            addVertex(newPos, edgeIndex, ringIndex);
            // Safe stopPropagation call
            if (e && typeof e.stopPropagation === 'function') {
                e.stopPropagation();
            }
        }

        function addVertex(position, edgeIndex, ringIndex = 0) {
            // Insert new coordinate into specified ring
            if (currentEditingFeature) {
                pushUndoSnapshot('add-vertex', currentEditingFeature, 'edit');
            }
            let ring = getEditingRing(ringIndex).slice();
            ring.splice(edgeIndex + 1, 0, [position.lng, position.lat]);
            // Maintain closure if ring was closed
            const wasClosed = ringIsClosed(getEditingRing(ringIndex));
            if (wasClosed && ring.length >= 4) {
                ring[ring.length - 1] = ring[0];
            }
            setEditingRing(ringIndex, ring);
            
            // Update all vertex indices that come after the insertion point in the same ring
            vertexMarkers.forEach(marker => {
                if (marker.ringIndex === ringIndex && marker.coordIndex > edgeIndex) {
                    marker.coordIndex++;
                }
            });
            
            // Create new vertex marker for the added vertex
            const newMarker = createDraggableVertex(position, edgeIndex + 1, currentEditingFeature, ringIndex);
            newMarker.addTo(map);
            
            // Insert the new marker in the correct position in the array
            // Find the correct position based on ringIndex and coordIndex
            let insertPos = 0;
            for (let i = 0; i < vertexMarkers.length; i++) {
                if (vertexMarkers[i].ringIndex < ringIndex || 
                    (vertexMarkers[i].ringIndex === ringIndex && vertexMarkers[i].coordIndex <= edgeIndex)) {
                    insertPos = i + 1;
                }
            }
            vertexMarkers.splice(insertPos, 0, newMarker);
            
            // NOTE: Don't normalize winding order during editing - it causes vertex markers
            // to become disconnected. Winding order is normalized when editing completes.
            
            // Update the editing polygon with ALL rings
            if (editingPolygonLayer && editingPolygonLayer.setLatLngs) {
                const allRings = getAllEditingRings();
                const allLatLngs = allRings.map(r => {
                    const latLngs = r.map(coord => [coord[1], coord[0]]);
                    return latLngs;
                });
                editingPolygonLayer.setLatLngs(allLatLngs);
            }
            
            // Update edge markers
            updateEdgeMarkers();
        }

        // Enhanced feature click handling
        function setupFeatureInteraction(layer, feature) {
            layer.on('click', function(e) {
                // High-priority tool actions first
                if (currentTool === EDIT_TOOLS.REMOVE) {
                    // Deselect any overlays first
                    if (isEditingVertices) disableVertexEditing();
                    try {
                        // If currently editing something, clear overlays
                        if (isEditingVertices) disableVertexEditing();
                        
                        // Handle MultiPolygon removal intelligently
                        if (feature.geometry && feature.geometry.type === 'MultiPolygon') {
                            const clickedPolyIndex = detectClickedPolygonInMultiPolygon(feature, e.latlng);
                            if (clickedPolyIndex >= 0) {
                                // Determine if this is an edit (other polygons remain) or delete (last polygon)
                                const willRemoveEntireFeature = !(feature.geometry.coordinates && feature.geometry.coordinates.length > 1);
                                
                                // Take snapshot with correct operation type
                                pushUndoSnapshot('remove-feature', feature, willRemoveEntireFeature ? 'delete' : 'edit');
                                
                                removePolygonFromMultiPolygon(feature, layer, clickedPolyIndex);
                            }
                            // No fallback - if detection fails, do nothing
                        } else {
                            // Regular polygon or other geometry - remove entire feature
                            pushUndoSnapshot('remove-feature', feature, 'delete');
                            removeEntireFeatureFromMap(feature);
                        }
                    } catch (err) { console.error('Remove feature error:', err); }
                    // keep remove mode until user toggles off, do not auto-disable here
                    if (e && e.stopPropagation) e.stopPropagation();
                    if (e && e.originalEvent && e.originalEvent.stopPropagation) e.originalEvent.stopPropagation();
                    return;
                }
                if (currentTool === EDIT_TOOLS.ADD_POINT) {
                    try {
                        const pt = { type: 'Feature', properties: {}, geometry: { type: 'Point', coordinates: [e.latlng.lng, e.latlng.lat] } };
                        ensureFeatureId(pt);
                        if (currentGeoJSON && currentGeoJSON.features) {
                            currentGeoJSON.features.push(pt);
                            
                            // Note: We intentionally do NOT clear __lastValidationStore here.
                            // New features won't have validation overlays (correct - they weren't validated)
                            
                            // Efficient addition: only process the new feature
                            const newFeatureCount = currentGeoJSON.features.length;
                            const oldFeatureCount = newFeatureCount - 1;
                            const shouldUseClustering = newFeatureCount >= CLUSTERING_FEATURE_LIMIT;
                            const wasUseClustering = oldFeatureCount >= CLUSTERING_FEATURE_LIMIT;
                            
                            if (wasUseClustering !== shouldUseClustering) {
                                // Crossed threshold - need to rebuild everything
                        processGeoJSON(currentGeoJSON, true);
                            } else {
                                // Just add the new feature without rebuilding everything
                                processPointFeature(pt, shouldUseClustering);
                                // Update layers if needed based on current zoom
                                if (shouldUseClustering && combinedClusterGroup && map.hasLayer(combinedClusterGroup)) {
                                    // Cluster is visible - force redraw to update counts
                                    map.removeLayer(combinedClusterGroup);
                                    map.addLayer(combinedClusterGroup);
                                }
                            }
                        }
                    } catch (err) { console.error('Add point error:', err); }
                    if (e && e.originalEvent) { try { L.DomEvent && L.DomEvent.stop ? L.DomEvent.stop(e.originalEvent) : (e.originalEvent.stopPropagation && e.originalEvent.stopPropagation()); } catch(_) {} }
                    if (e && e.stopPropagation) e.stopPropagation();
                    return;
                }
                if (currentMode === MODES.EDIT) {
                    // When switching polygons, ensure any point edit interaction is cancelled
                    disablePointEditing();
                    if (currentTool === EDIT_TOOLS.SELECT) {
                        // Check if we're clicking on the same MultiPolygon feature that's being edited
                        if (isEditingVertices && editingOriginalFeatureRef === feature && editingGeomType === 'MultiPolygon') {
                            // Switch to the clicked polygon within the same MultiPolygon
                            const clickedPolyIndex = detectClickedPolygonInMultiPolygon(feature, e.latlng);
                            if (clickedPolyIndex >= 0 && clickedPolyIndex !== editingPolyIndex) {
                                switchToPolygonEditing(clickedPolyIndex);
                                return;
                            }
                        }
                        // Persist any existing edit before switching to another polygon, without rerender/zoom
                        if (isEditingVertices) {
                            disableVertexEditing();
                        }
                        enableVertexEditingWithClickDetection(layer, feature, e.latlng);
                    } else if (currentTool === EDIT_TOOLS.PROPERTIES) {
                        // In properties tool, ensure any selection overlay is cleared, then open modal
                        if (isEditingVertices) disableVertexEditing();
                        openPropertiesModal(feature);
                    } else if (currentTool === EDIT_TOOLS.VERTEX) {
                        if (isEditingVertices && editingLayer === layer) {
                            // Add vertex at e.latlng
                        } else if (isEditingVertices && editingOriginalFeatureRef === feature && editingGeomType === 'MultiPolygon') {
                            // Switch to the clicked polygon within the same MultiPolygon
                            const clickedPolyIndex = detectClickedPolygonInMultiPolygon(feature, e.latlng);
                            if (clickedPolyIndex >= 0 && clickedPolyIndex !== editingPolyIndex) {
                                switchToPolygonEditing(clickedPolyIndex);
                                return;
                            }
                        } else {
                            // Persist and switch to the new polygon without zooming/reloading
                            disableVertexEditing();
                            enableVertexEditingWithClickDetection(layer, feature, e.latlng);
                        }
                    }
                }
                // Stop propagation so map-level empty-click handler doesn't fire
                if (e && e.originalEvent) { try { L.DomEvent && L.DomEvent.stop ? L.DomEvent.stop(e.originalEvent) : (e.originalEvent.stopPropagation && e.originalEvent.stopPropagation()); } catch(_) {} }
                if (e && e.stopPropagation) e.stopPropagation();
            });
        }

        // Point-in-polygon algorithm to detect which polygon was clicked in MultiPolygon
        function isPointInPolygon(point, polygon) {
            const x = point.lng;
            const y = point.lat;
            let inside = false;
            
            // Use the outer ring (first ring) of the polygon
            const ring = polygon[0];
            if (!ring || ring.length < 3) return false;
            
            for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                if (((ring[i][1] > y) !== (ring[j][1] > y)) &&
                    (x < (ring[j][0] - ring[i][0]) * (y - ring[i][1]) / (ring[j][1] - ring[i][1]) + ring[i][0])) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // Test if a LatLng point is inside a ring (array of [lng, lat] coordinates)
        function isPointInsideRing(latlng, ring) {
            if (!ring || ring.length < 3) return false;
            
            const x = latlng.lng;
            const y = latlng.lat;
            let inside = false;
            
            for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                const xi = ring[i][0], yi = ring[i][1];
                const xj = ring[j][0], yj = ring[j][1];
                
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function detectClickedPolygonInMultiPolygon(feature, clickPoint) {
            if (!feature.geometry || feature.geometry.type !== 'MultiPolygon') return -1;
            
            const coordinates = feature.geometry.coordinates;
            for (let i = 0; i < coordinates.length; i++) {
                if (isPointInPolygon(clickPoint, coordinates[i])) {
                    return i;
                }
            }
            return -1; // No polygon contains the click point
        }

        function enableVertexEditingWithClickDetection(layer, feature, clickPoint) {
            if (feature.geometry && feature.geometry.type === 'MultiPolygon') {
                const clickedPolyIndex = detectClickedPolygonInMultiPolygon(feature, clickPoint);
                if (clickedPolyIndex >= 0) {
                    // Found the clicked polygon, set it as the active one
                    enableVertexEditingWithPolygonIndex(layer, feature, clickedPolyIndex);
                    return;
                }
            }
            // Fallback to original behavior (regular polygon or detection failed)
            enableVertexEditing(layer, feature);
        }

        function enableVertexEditingWithPolygonIndex(layer, feature, polygonIndex = 0) {
            if (isEditingVertices) {
                disableVertexEditing();
            }
            
            editingLayer = layer;
            currentEditingFeature = JSON.parse(JSON.stringify(feature)); // Deep copy to avoid reference issues
            editingGeomType = currentEditingFeature.geometry.type;
            editingPolyIndex = polygonIndex; // Use the detected polygon index
            editingRingIndex = 0;
            
            // Setup MultiPolygon selection UI if needed
            if (editingGeomType === 'MultiPolygon') {
                setupMultiPolygonSelectors();
            } else {
                hideMultiPolygonSelectors();
            }
            
            editingRingWasClosed = ringIsClosed(getEditingRing());
            editingOriginalFeatureRef = feature;
            isEditingVertices = true;
            vertexMarkers = [];
            edgeMarkers = [];
            
            // Get all rings (outer + holes) from the feature
            const allRings = getAllEditingRings();
            
            // Create a simple polygon for editing overlay with all rings
            // Leaflet.polygon() accepts array of rings: [outerRing, hole1, hole2, ...]
            // Each ring must be closed for proper rendering
            const allLatLngs = allRings.map(ring => {
                const latLngs = ring.map(coord => [coord[1], coord[0]]);
                if (latLngs.length > 0) {
                    const first = latLngs[0];
                    const last = latLngs[latLngs.length - 1];
                    if (first[0] !== last[0] || first[1] !== last[1]) {
                        latLngs.push([first[0], first[1]]);
                    }
                }
                return latLngs;
            });
            
            editingPolygonLayer = L.polygon(allLatLngs, {
                fillColor: '#3388ff',
                fillRule: 'nonzero',
                weight: 3,
                opacity: 1,
                color: '#ff7800',
                fillOpacity: 0.2
            }).addTo(map);
            
            // Add click detection to the editing polygon layer for MultiPolygon switching
            if (editingGeomType === 'MultiPolygon') {
                editingPolygonLayer.on('click', function(e) {
                    const clickedPolyIndex = detectClickedPolygonInMultiPolygon(currentEditingFeature, e.latlng);
                    if (clickedPolyIndex >= 0 && clickedPolyIndex !== editingPolyIndex) {
                        switchToPolygonEditing(clickedPolyIndex);
                    }
                    // Stop propagation to prevent other click handlers
                    if (e && e.stopPropagation) e.stopPropagation();
                    if (e && e.originalEvent && e.originalEvent.stopPropagation) e.originalEvent.stopPropagation();
                });
            }
            
            // For MultiPolygon, create a visual overlay showing non-selected polygons
            if (editingGeomType === 'MultiPolygon') {
                createNonSelectedPolygonsOverlay(currentEditingFeature, editingPolyIndex);
                // Hide the original layer completely
                layer.setStyle({ opacity: 0, fillOpacity: 0 });
            } else {
                // For regular Polygon, hide the original layer
                layer.setStyle({ opacity: 0, fillOpacity: 0 });
            }
            
            // Create vertex markers for ALL rings (outer + holes)
            // Reuse allRings variable from above
            allRings.forEach((ring, ringIndex) => {
                const openRing = getOpenRing(ringIndex);
                openRing.forEach((coord, vertexIndex) => {
                    const latLng = L.latLng(coord[1], coord[0]);
                    const marker = createDraggableVertex(latLng, vertexIndex, currentEditingFeature, ringIndex);
                    marker.addTo(map);
                    vertexMarkers.push(marker);
                });
            });

            // Create edge markers for adding vertices for ALL rings
            allRings.forEach((ring, ringIndex) => {
                createEdgeMarkers(ring, ringIndex);
            });
        }

        function removePolygonFromMultiPolygon(feature, layer, polygonIndex) {
            const coordinates = feature.geometry.coordinates;
            
            if (coordinates.length > 1) {
                // Remove the specific polygon
                coordinates.splice(polygonIndex, 1);
                
                // Update the layer with new coordinates
                if (layer && layer.setLatLngs) {
                    const polys = coordinates.map(poly => poly[0].map(coord => [coord[1], coord[0]]));
                    layer.setLatLngs(polys);
                }
                
                // Update currentGeoJSON
                if (currentGeoJSON && currentGeoJSON.features) {
                    const idx = currentGeoJSON.features.indexOf(feature);
                    if (idx >= 0) {
                        currentGeoJSON.features[idx].geometry.coordinates = coordinates;
                    }
                }
            } else {
                // Only one polygon left, remove entire feature
                removeEntireFeatureFromMap(feature);
            }
        }

        function removeEntireFeatureFromMap(feature) {
            // Use unified removal system
            removeFeature(feature);
        }

        /**
         * Central feature removal function
         * Handles all feature types and manages threshold transitions
         * @param {Object} feature - The feature to remove
         * @param {Object} pointMarker - Optional: direct reference to the point marker (for point removal)
         * @param {Object} pointShape - Optional: direct reference to the highZoomShape (for point removal)
         */
        /**
         * Remove an individual point from a MultiPoint feature
         * @param {Object} feature - The MultiPoint feature
         * @param {number} pointIndex - Index of the point to remove
         * @param {Object} pointMarker - Optional marker reference
         * @param {Object} pointShape - Optional shape reference
         */
        function removePointFromMultiPoint(feature, pointIndex, pointMarker = null, pointShape = null) {
            if (!currentGeoJSON || !currentGeoJSON.features || !feature) return;
            if (feature.geometry.type !== 'MultiPoint') return;
            
            // Remove the specific point from coordinates
            const coords = feature.geometry.coordinates;
            if (pointIndex < 0 || pointIndex >= coords.length) return;
            
            // Take undo snapshot BEFORE modification
            // Determine operation type: if we'll have 0 points left after removal, it's a delete; otherwise it's an edit
            const willHavePointsLeft = coords.length > 1;
            pushUndoSnapshot('remove-multipoint-point', feature, willHavePointsLeft ? 'edit' : 'delete');
            
            coords.splice(pointIndex, 1);
            
            // Remove the marker and shape from layers
            if (pointMarker || pointShape) {
                removePointFromLayersDirect(pointMarker, pointShape);
            }
            
            // Handle conversion or removal based on remaining points
            if (coords.length === 0) {
                // No points left - remove entire feature
                const idx = currentGeoJSON.features.indexOf(feature);
                if (idx >= 0) {
                    currentGeoJSON.features.splice(idx, 1);
                }
                // Remove any remaining markers/shapes for this feature
                removePointFromLayers(feature);
                
                // Handle clustering threshold
                const newCount = currentGeoJSON.features.length;
                handleThresholdTransition(newCount + 1, newCount);
            } else if (coords.length === 1) {
                // Convert to Point
                feature.geometry = {
                    type: 'Point',
                    coordinates: coords[0]
                };
                // Refresh the display for this feature
                processGeoJSON(currentGeoJSON, true); // suppressFit = true
            } else {
                // Multiple points remain - just update the MultiPoint
                // Remove all old markers/shapes and re-render
                removePointFromLayers(feature);
                processGeoJSON(currentGeoJSON, true); // suppressFit = true
            }
        }
        
        function removeFeature(feature, pointMarker = null, pointShape = null) {
            if (!currentGeoJSON || !currentGeoJSON.features || !feature) return;
            
            // 1. Remove from data array
                const idx = currentGeoJSON.features.indexOf(feature);
            if (idx < 0) return;
            
            const oldFeatureCount = currentGeoJSON.features.length;
            currentGeoJSON.features.splice(idx, 1);
            const newFeatureCount = currentGeoJSON.features.length;
            
            // Note: We intentionally do NOT clear __lastValidationStore here.
            // This allows users to see previous validation results after making edits,
            // which helps them decide if they need to re-validate.
            
            // 2. Remove from appropriate layers based on geometry type
            const geometryType = feature.geometry ? feature.geometry.type : null;
            if (geometryType === 'Point' || geometryType === 'MultiPoint') {
                // Use direct references if provided, otherwise search by feature
                if (pointMarker || pointShape) {
                    removePointFromLayersDirect(pointMarker, pointShape);
                } else {
                    removePointFromLayers(feature);
                }
            } else if (geometryType === 'Polygon' || geometryType === 'MultiPolygon') {
                removePolygonFromLayers(feature);
            }
            
            // 3. Handle clustering threshold transition
            handleThresholdTransition(oldFeatureCount, newFeatureCount);
        }
        
        /**
         * Remove a point using direct references to marker and shape (faster, no search needed)
         */
        function removePointFromLayersDirect(pointMarker, pointShape) {
            // Remove marker if provided - try all possible parent layers
            if (pointMarker) {
                // Try removing from pointMarkerLayer
                if (pointMarkerLayer && pointMarkerLayer.hasLayer(pointMarker)) {
                    pointMarkerLayer.removeLayer(pointMarker);
                }
                // Try removing from cluster group
                if (combinedClusterGroup && combinedClusterGroup.hasLayer(pointMarker)) {
                    combinedClusterGroup.removeLayer(pointMarker);
                }
            }
            // Remove shape if provided
            if (pointShape && pointLayer && pointLayer.hasLayer(pointShape)) {
                pointLayer.removeLayer(pointShape);
            }
        }
        
        /**
         * Remove a point feature from all point-related layers (searches by feature reference)
         */
        function removePointFromLayers(feature) {
            // Use feature ID for comparison since feature objects may differ
            const featureId = feature.id || feature.__persistentId || feature.properties?.id;
            
            // Remove from point marker layer
            const toRemoveMarkers = [];
            pointMarkerLayer.eachLayer(m => {
                const mId = m.feature?.id || m.feature?.__persistentId || m.feature?.properties?.id;
                if (m.feature === feature || (featureId && mId === featureId)) {
                    toRemoveMarkers.push(m);
                }
            });
            toRemoveMarkers.forEach(m => pointMarkerLayer.removeLayer(m));
            
            // Remove from point layer (circles/circleMarkers)
            const toRemoveShapes = [];
            pointLayer.eachLayer(m => {
                const mId = m.feature?.id || m.feature?.__persistentId || m.feature?.properties?.id;
                if (m.feature === feature || (featureId && mId === featureId)) {
                    toRemoveShapes.push(m);
                }
            });
            toRemoveShapes.forEach(m => pointLayer.removeLayer(m));
            
            // Remove from cluster if present
            if (combinedClusterGroup) {
                const toRemoveCluster = [];
                combinedClusterGroup.eachLayer(m => {
                    const mId = m.feature?.id || m.feature?.__persistentId || m.feature?.properties?.id;
                    if (m.feature === feature || (featureId && mId === featureId)) {
                        toRemoveCluster.push(m);
                    }
                });
                toRemoveCluster.forEach(m => combinedClusterGroup.removeLayer(m));
            }
        }
        
        /**
         * Remove a polygon feature from all polygon-related layers
         */
        function removePolygonFromLayers(feature) {
            // Reuse existing polygon removal logic
            removeFeatureFromPolygonLayers(feature);
        }
        
        /**
         * Handle clustering threshold transitions when feature count changes
         */
        function handleThresholdTransition(oldCount, newCount) {
            const shouldUseClustering = newCount >= CLUSTERING_FEATURE_LIMIT;
            const wasUseClustering = oldCount >= CLUSTERING_FEATURE_LIMIT;
            
            if (wasUseClustering !== shouldUseClustering) {
                // Crossed threshold - need to rebuild everything to switch display mode
                processGeoJSON(currentGeoJSON, true); // suppressFit = true to keep current view
            } else if (shouldUseClustering && combinedClusterGroup && map.hasLayer(combinedClusterGroup)) {
                // Still using clustering - force redraw to update counts
                map.removeLayer(combinedClusterGroup);
                map.addLayer(combinedClusterGroup);
            }
        }

        function removeFeatureFromPolygonLayers(featureRef) {
            try {
                const toRemove = [];
                polygonLayer.eachLayer(function(parent) {
                    if (!parent) return;
                    if (parent.feature === featureRef) {
                        toRemove.push(parent);
                        return;
                    }
                    if (parent.eachLayer) {
                        let matched = false;
                        parent.eachLayer(function(child) {
                            if (child && child.feature === featureRef) matched = true;
                        });
                        if (matched) toRemove.push(parent);
                    }
                });
                toRemove.forEach(l => polygonLayer.removeLayer(l));
                // Also remove any centroid markers for this feature
                const toRemoveMarkers = [];
                polygonMarkerLayer.eachLayer(function(m) {
                    if (m && m.feature === featureRef) toRemoveMarkers.push(m);
                });
                toRemoveMarkers.forEach(m => polygonMarkerLayer.removeLayer(m));
                
                // Also check and remove from cluster group
                if (combinedClusterGroup) {
                    const toRemoveFromCluster = [];
                    combinedClusterGroup.eachLayer(function(m) {
                        if (m && m.feature === featureRef) toRemoveFromCluster.push(m);
                    });
                    toRemoveFromCluster.forEach(m => {
                        combinedClusterGroup.removeLayer(m);
                    });
                }
            } catch (err) {
                console.error('removeFeatureFromPolygonLayers error:', err);
            }
        }

        // Translation logic (copied and adapted from KML)
        let currentLanguage = 'en';
        let translations = {};
        function initializeTranslations() {
            translations.en = JSON.parse(document.getElementById('lang-en').textContent);
            translations.es = JSON.parse(document.getElementById('lang-es').textContent);
            translations.fr = JSON.parse(document.getElementById('lang-fr').textContent);
            translations.pt = JSON.parse(document.getElementById('lang-pt').textContent);
            translations.sw = JSON.parse(document.getElementById('lang-sw').textContent);
            translations.zh = JSON.parse(document.getElementById('lang-zh').textContent);
            translations.th = JSON.parse(document.getElementById('lang-th').textContent);
            translations.am = JSON.parse(document.getElementById('lang-am').textContent);
        }
        function changeLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('georoots-editor-language', lang);
            document.documentElement.lang = lang;
            updateAllText();
            // Update layer control names if map is initialized
            if (typeof map !== 'undefined' && map) {
                if (layerControl) {
                    layerControl.remove();
                }
                // Remove all base layers from map
                Object.values(baseLayers).forEach(layer => {
                    if (map.hasLayer(layer)) map.removeLayer(layer);
                });
                baseLayers = getBaseLayers();
                // Add the first base layer back to the map if not present
                const firstBaseLayer = Object.values(baseLayers)[0];
                if (!map.hasLayer(firstBaseLayer)) firstBaseLayer.addTo(map);
                currentBaseLayer = firstBaseLayer;
                const overlayMaps = getOverlayMaps();
                layerControl = L.control.layers(baseLayers, overlayMaps, { collapsed: false }).addTo(map);
            }
        }
        function updateAllText() {
            const elements = document.querySelectorAll('[data-i18n]');
            elements.forEach(element => {
                const key = element.getAttribute('data-i18n');
                const translation = translations[currentLanguage][key];
                if (translation) {
                    // Handle aria-label attributes
                    if (element.hasAttribute('aria-label') && element.getAttribute('aria-label') === '') {
                        element.setAttribute('aria-label', translation);
                    } else {
                        element.textContent = translation;
                    }
                }
            });
        }
        function getText(key, ...params) {
            let t = translations[currentLanguage][key] || translations.en[key] || key;
            if (params && params.length > 0) {
                // Replace parameters in order: {0}, {1}, {2}, etc.
                params.forEach((param, index) => {
                    t = t.replace(`{${index}}`, param);
                });
                // Also support named parameters for backward compatibility
                if (params.length === 1) {
                    t = t.replace('{i}', params[0]);
                }
            }
            return t;
        }

        // Validate Geometries placeholder trigger
        (function(){
            const btn = document.getElementById('btn-validate-geometries');
            if (btn) {
                btn.addEventListener('click', async function(){
                    try {
                        // Keep as placeholder: invoke validation stage function, then re-render
                        if (typeof stageValidateGeometries === 'function') {
                            await stageValidateGeometries({});
                        }
                        // Messaging handled inside stageValidateGeometries
                    } catch (e) {
                        showErrorNotification(getText('validationFailed', e && e.message ? e.message : e), 'red');
                    }
                });
            }
        })();

        // Simple polygon drawing: click to add vertices, right-click to finish
        let drawingPolygon = null;
        let drawingCoords = [];
        let drawingSnapMarker = null;
        let drawingSnapPoint = null;
        let drawingVertexMarkers = [];
        
        function startPolygonDrawing() {
            if (drawingPolygon) return;
            drawingCoords = [];
            drawingSnapPoint = null;
            drawingVertexMarkers = [];
            drawingPolygon = L.polygon([], { color: '#40916c', weight: 2, fillOpacity: 0.1 }).addTo(map);
            
            function onMapClick(e) {
                if (currentTool !== EDIT_TOOLS.ADD_POLYGON) { stop(); return; }
                
                // Use snap point if available, otherwise use click position
                const snapResult = snapEnabled ? findSnapPoint(e.latlng, null) : null;
                const finalLatLng = snapResult && snapResult.latlng ? snapResult.latlng : e.latlng;
                
                drawingCoords.push([finalLatLng.lat, finalLatLng.lng]);
                drawingPolygon.setLatLngs([drawingCoords.map(c => [c[0], c[1]])]);
                
                // Add green vertex marker for visual feedback
                const vertexMarker = L.circleMarker(finalLatLng, {
                    radius: 5,
                    color: '#40916c',
                    fillColor: '#40916c',
                    fillOpacity: 0.9,
                    weight: 2,
                    pane: 'markerPane'
                }).addTo(map);
                drawingVertexMarkers.push(vertexMarker);
            }
            
            function onMapMouseMove(e) {
                if (currentTool !== EDIT_TOOLS.ADD_POLYGON) { stop(); return; }
                
                // Check for snap point
                if (snapEnabled) {
                    const snapResult = findSnapPoint(e.latlng, null);
                    if (snapResult && snapResult.latlng) {
                        // Show snap marker
                        if (!drawingSnapMarker) {
                            drawingSnapMarker = L.circleMarker(snapResult.latlng, {
                                radius: 6,
                                color: '#FF8C00',
                                fillColor: '#FF8C00',
                                fillOpacity: 0.8,
                                weight: 2,
                                pane: 'markerPane'
                            }).addTo(map);
                        } else {
                            drawingSnapMarker.setLatLng(snapResult.latlng);
                        }
                        drawingSnapPoint = snapResult.latlng;
                    } else {
                        // Hide snap marker
                        if (drawingSnapMarker) {
                            map.removeLayer(drawingSnapMarker);
                            drawingSnapMarker = null;
                        }
                        drawingSnapPoint = null;
                    }
                } else {
                    // Snap disabled, hide marker if it exists
                    if (drawingSnapMarker) {
                        map.removeLayer(drawingSnapMarker);
                        drawingSnapMarker = null;
                    }
                    drawingSnapPoint = null;
                }
            }
            function onMapContextMenu(e) {
                if (currentTool !== EDIT_TOOLS.ADD_POLYGON) { stop(); return; }
                if (drawingCoords.length >= 3) {
                    const ring = drawingCoords.map(c => [c[1], c[0]]);
                    // Close ring
                    ring.push(ring[0]);
                    const feat = { type: 'Feature', properties: {}, geometry: { type: 'Polygon', coordinates: [ring] } };
                    ensureFeatureId(feat);
                    
                    // Normalize winding order for newly created polygon
                    normalizeFeatureWindingOrder(feat);
                    
                    if (currentGeoJSON && currentGeoJSON.features) {
                        const newIndex = currentGeoJSON.features.length;
                        currentGeoJSON.features.push(feat);
                        pushUndoSnapshot(EDIT_TOOLS.ADD_POLYGON, newIndex, 'add');
                        
                        // Note: We intentionally do NOT clear __lastValidationStore here.
                        // New features won't have validation overlays (correct - they weren't validated)
                        
                        // Efficient addition: only process the new feature
                        const newFeatureCount = currentGeoJSON.features.length;
                        const oldFeatureCount = newFeatureCount - 1;
                        const shouldUseClustering = newFeatureCount >= CLUSTERING_FEATURE_LIMIT;
                        const wasUseClustering = oldFeatureCount >= CLUSTERING_FEATURE_LIMIT;
                        
                        if (wasUseClustering !== shouldUseClustering) {
                            // Crossed threshold - need to rebuild everything
                    processGeoJSON(currentGeoJSON, true);
                        } else {
                            // Just add the new feature without rebuilding everything
                            processPolygonFeature(feat, shouldUseClustering);
                            // Update layers if needed based on current zoom
                            if (shouldUseClustering && combinedClusterGroup && map.hasLayer(combinedClusterGroup)) {
                                // Cluster is visible - force redraw to update counts
                                map.removeLayer(combinedClusterGroup);
                                map.addLayer(combinedClusterGroup);
                            }
                        }
                    }
                }
                // prevent browser context menu
                if (e && e.originalEvent) {
                    e.originalEvent.preventDefault && e.originalEvent.preventDefault();
                    e.originalEvent.stopPropagation && e.originalEvent.stopPropagation();
                }
                stop();
            }
            function stop() {
                map.off('click', onMapClick);
                map.off('contextmenu', onMapContextMenu);
                map.off('mousemove', onMapMouseMove);
                if (drawingPolygon) { map.removeLayer(drawingPolygon); drawingPolygon = null; }
                if (drawingSnapMarker) { map.removeLayer(drawingSnapMarker); drawingSnapMarker = null; }
                // Remove all vertex markers
                drawingVertexMarkers.forEach(marker => {
                    if (map.hasLayer(marker)) map.removeLayer(marker);
                });
                drawingVertexMarkers = [];
                drawingCoords = [];
                drawingSnapPoint = null;
                // Reset UI: hide hint, select & edit tool
                (function(){
                    const hintEl = document.getElementById('tool-hint');
                    if (hintEl) { hintEl.textContent = ''; hintEl.style.display = 'none'; }
                })();
                // Update tool state directly without triggering setupInteraction
                currentTool = EDIT_TOOLS.SELECT;
                updateToolButtonStates();
                setCursorCrosshair(false);
                if (map && map.dragging && map.dragging.enable) map.dragging.enable();
                // Expose stop to allow external cancel
                window.__stopPolygonDrawing = undefined;
            }
            map.on('click', onMapClick);
            map.on('contextmenu', onMapContextMenu);
            map.on('mousemove', onMapMouseMove);
            // expose cancel function
            window.__stopPolygonDrawing = stop;
        }

        // Export Modal Functions
        function showExportModal() {
            if (!currentGeoJSON || !currentGeoJSON.features || currentGeoJSON.features.length === 0) {
                showErrorNotification(getText('noFeaturesToExport') || 'No features to export', 'amber');
                return;
            }
            document.getElementById('exportModal').classList.add('show');
            // Set default filename
            const filenameInput = document.getElementById('export-filename');
            if (filenameInput && !filenameInput.value) {
                filenameInput.value = originalFilename ? originalFilename + '-edited' : 'editor-eudr-geodata';
            }
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('show');
        }

        /**
         * Export with specified format (geojson or csv)
         * @param {string} format - 'geojson' or 'csv'
         */
        async function exportWithFormat(format) {
            try {
                if (!currentGeoJSON || !currentGeoJSON.features) {
                    showErrorNotification(getText('noFeaturesToExport') || 'No features to export', 'amber');
                    return;
                }

                // Get filename from input
                const filenameInput = document.getElementById('export-filename');
                let filename = filenameInput ? filenameInput.value.trim() : '';
                if (!filename) filename = originalFilename ? originalFilename + '-edited' : 'editor-eudr-geodata';

                // Check if validation is requested
                const withValidation = document.getElementById('export-with-validation').checked;

                // Prepare data with validation if requested
                let dataToExport = JSON.parse(JSON.stringify(currentGeoJSON)); // Deep copy

                // Always add feature numbers to all features
                dataToExport.features.forEach((feature, i) => {
                    if (!feature.properties) feature.properties = {};
                    const featureNumber = (feature.__persistentId !== undefined) ? feature.__persistentId : i;
                    feature.properties.__feature_number = featureNumber;
                });

                if (withValidation) {
                    // Close the export modal before starting validation so progress bar is visible
                    closeExportModal();
                    // Run validation and add results to features
                    await addValidationToFeatures(dataToExport);
                } else {
                    // Close modal immediately if not validating
                    closeExportModal();
                }

                // Export based on format
                if (format === 'geojson') {
                    exportAsGeoJSON(dataToExport, filename, withValidation);
                } else if (format === 'csv') {
                    exportAsCSV(dataToExport, filename);
                }

                showErrorNotification(getText('exportCompleted') || 'Export completed successfully', 'green');
            } catch (err) {
                console.error('Export error:', err);
                showErrorNotification(getText('exportFailed') || 'Export failed: ' + (err.message || err), 'red');
            }
        }

        /**
         * Add validation results to each feature in the GeoJSON
         * @param {Object} geoJSON - The GeoJSON object to validate
         */
        async function addValidationToFeatures(geoJSON) {
            if (!geoJSON || !geoJSON.features) return;

            // Open progress modal
            openValidationProgress();

            try {
                // Run validation pipeline to detect all issues (but don't fix)
                const results = await runValidationPipeline(geoJSON, {
                    stages: ['geometricValidity', 'duplicates', 'selfIntersections', 'slivers', 'overlaps', 'holes'],
                    fix: false,
                    progressCallback: (progress, msg) => setValidationProgress(progress, msg)
                });

                // Build map of validation issues per feature index
                const issuesMap = new Map(); // featureIndex -> { valid: boolean, issues: [] }
                
                // Initialize all features as valid
                for (let i = 0; i < geoJSON.features.length; i++) {
                    issuesMap.set(i, { valid: true, issues: [] });
                }
                
                // Process geometric validity issues
                if (results.issues.geometricValidity && results.issues.geometricValidity.invalidFeatures) {
                    results.issues.geometricValidity.invalidFeatures.forEach(item => {
                        const idx = item.featureIndex;
                        if (issuesMap.has(idx)) {
                            issuesMap.get(idx).valid = false;
                            issuesMap.get(idx).issues.push(`Invalid geometry: ${item.reason}`);
                        }
                    });
                }
                
                // Process duplicate vertices
                if (results.issues.duplicateVertices && results.issues.duplicateVertices.invalidFeatures) {
                    results.issues.duplicateVertices.invalidFeatures.forEach(item => {
                        const idx = item.featureIndex;
                        if (issuesMap.has(idx)) {
                            issuesMap.get(idx).valid = false;
                            issuesMap.get(idx).issues.push(item.reason || 'Duplicate vertices detected');
                        }
                    });
                }
                
                // Process duplicates (exclude Point/MultiPoint - those are handled by duplicate points)
                if (results.issues.duplicates && results.issues.duplicates.duplicateFeatures) {
                    results.issues.duplicates.duplicateFeatures.forEach(item => {
                        const idx = item.featureIndex;
                        if (issuesMap.has(idx)) {
                            const feature = geoJSON.features[idx];
                            const geomType = feature?.geometry?.type;
                            // Skip Point/MultiPoint to avoid double-counting with duplicate points
                            if (geomType === 'Point' || geomType === 'MultiPoint') return;
                            
                            issuesMap.get(idx).valid = false;
                            issuesMap.get(idx).issues.push('Duplicate geometry');
                        }
                    });
                }
                
                // Process duplicate points (Point/MultiPoint specific)
                if (results.issues.duplicates && results.issues.duplicates.duplicatePointFeatures) {
                    results.issues.duplicates.duplicatePointFeatures.forEach(item => {
                        const idx = item.featureIndex;
                        if (issuesMap.has(idx)) {
                            issuesMap.get(idx).valid = false;
                            if (item.pointIndex === null) {
                                issuesMap.get(idx).issues.push(`Duplicate point (appears ${item.duplicateCount || 2} times)`);
                            } else {
                                issuesMap.get(idx).issues.push(`Point ${item.pointIndex + 1} is duplicate (appears ${item.duplicateCount || 2} times)`);
                            }
                        }
                    });
                }
                
                // Process self-intersections
                if (results.issues.selfIntersections && results.issues.selfIntersections.selfIntersectingFeatures) {
                    results.issues.selfIntersections.selfIntersectingFeatures.forEach(item => {
                        const idx = item.featureIndex;
                        if (issuesMap.has(idx)) {
                            issuesMap.get(idx).valid = false;
                            issuesMap.get(idx).issues.push('Self-intersection detected');
                        }
                    });
                }
                
                // Process slivers
                if (results.issues.slivers && results.issues.slivers.featuresWithSharpAngles) {
                    results.issues.slivers.featuresWithSharpAngles.forEach(item => {
                        const idx = item.featureIndex;
                        if (issuesMap.has(idx)) {
                            issuesMap.get(idx).valid = false;
                            const count = item.count || 0;
                            if (count >= 2) {
                                issuesMap.get(idx).issues.push('Sliver polygon: >= 2 acute angles < 4');
                            } else if (count === 1) {
                                issuesMap.get(idx).issues.push('Sliver vertex candidate: 1 acute angle < 4');
                            }
                        }
                    });
                }
                
                // Process overlaps
                if (results.issues.overlaps && results.issues.overlaps.overlappingPairs) {
                    const overlapsSet = new Set();
                    results.issues.overlaps.overlappingPairs.forEach(pair => {
                        overlapsSet.add(pair.indexA);
                        overlapsSet.add(pair.indexB);
                    });
                    overlapsSet.forEach(idx => {
                        if (issuesMap.has(idx)) {
                            issuesMap.get(idx).valid = false;
                            issuesMap.get(idx).issues.push('Overlaps with other features');
                        }
                    });
                }
                
                // Process holes
                if (results.issues.holes && results.issues.holes.featuresWithHoles) {
                    results.issues.holes.featuresWithHoles.forEach(item => {
                        const idx = item.featureIndex;
                        if (issuesMap.has(idx)) {
                            issuesMap.get(idx).valid = false;
                            const count = item.holesCount || 0;
                            issuesMap.get(idx).issues.push(`Polygon has ${count} hole(s)`);
                        }
                    });
                }
                
                // Add validation properties to all features
                for (let i = 0; i < geoJSON.features.length; i++) {
                    const f = geoJSON.features[i];
                    if (!f.properties) f.properties = {};
                    
                    // Add feature number (using persistent ID if available)
                    const featureNumber = (f.__persistentId !== undefined) ? f.__persistentId : i;
                    f.properties.__feature_number = featureNumber;
                    
                    const result = issuesMap.get(i);
                if (result && !result.valid && result.issues.length > 0) {
                        f.properties.__validation_status = 'FAILED';
                        f.properties.__validation_issues = result.issues.join('; ');
                } else {
                        f.properties.__validation_status = 'PASSED';
                        f.properties.__validation_issues = '';
                }
            }

            setValidationProgress(100, 'Completed');
            await delay(250);
            } catch (err) {
                console.error('Validation error during export:', err);
                throw err;
            } finally {
                closeValidationProgress();
            }
        }

        /** OLD IMPLEMENTATION REMOVED - Now uses runValidationPipeline() above
         * The old implementation (~250 lines) manually implemented all validation stages.
         * It has been replaced with the new pipeline for consistency and maintainability.
         */

        /**
         * Clean internal properties from features before export
         * @param {Object} geoJSON - The GeoJSON object to clean
         * @param {boolean} withValidation - Whether validation properties should be kept
         * @returns {Object} - Cleaned GeoJSON
         */
        function cleanInternalProperties(geoJSON, withValidation = false) {
            const cleaned = JSON.parse(JSON.stringify(geoJSON)); // Deep copy
            
            cleaned.features.forEach(feature => {
                // Remove internal feature-level properties
                delete feature.__persistentId;
                delete feature.__featureIndex;
                
                // Clean properties object
                if (feature.properties) {
                    if (withValidation) {
                        // Keep only __feature_number and validation properties
                        const keysToKeep = ['__feature_number', '__validation_status', '__validation_issues'];
                        Object.keys(feature.properties).forEach(key => {
                            if (key.startsWith('__') && !keysToKeep.includes(key)) {
                                delete feature.properties[key];
                            }
                        });
                    } else {
                        // Remove all internal properties (those starting with __)
                        Object.keys(feature.properties).forEach(key => {
                            if (key.startsWith('__')) {
                                delete feature.properties[key];
                            }
                        });
                    }
                }
            });
            
            return cleaned;
        }

        /**
         * Export data as GeoJSON file
         * @param {Object} geoJSON - The GeoJSON object to export
         * @param {string} filename - The filename (without extension)
         * @param {boolean} withValidation - Whether this export includes validation data
         */
        function exportAsGeoJSON(geoJSON, filename, withValidation = false) {
            // Clean internal properties before export
            const cleanedGeoJSON = cleanInternalProperties(geoJSON, withValidation);
            
            const blob = new Blob([JSON.stringify(cleanedGeoJSON, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename + '.geojson';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        /**
         * Export data as CSV file
         * @param {Object} geoJSON - The GeoJSON object to export
         * @param {string} filename - The filename (without extension)
         */
        function exportAsCSV(geoJSON, filename) {
            if (!geoJSON || !geoJSON.features || geoJSON.features.length === 0) {
                showErrorNotification(getText('noFeaturesToExport') || 'No features to export', 'amber');
                return;
            }

            // Collect all unique property keys
            const allKeys = new Set();
            geoJSON.features.forEach(feature => {
                if (feature.properties) {
                    Object.keys(feature.properties).forEach(key => allKeys.add(key));
                }
            });

            // Build CSV header
            const headers = ['geometry_type', 'geometry_wkt', 'point_latitude', 'point_longitude', ...Array.from(allKeys).sort()];
            
            // CSV escape function
            function escapeCSV(value) {
                if (value === null || value === undefined) return '';
                const str = String(value);
                // If contains comma, quote, or newline, wrap in quotes and escape quotes
                if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
                    return '"' + str.replace(/"/g, '""') + '"';
                }
                return str;
            }

            // Convert GeoJSON geometry to WKT (Well-Known Text)
            function geometryToWKT(geometry) {
                if (!geometry || !geometry.type) return '';
                
                try {
                    function coordsToWKT(coords) {
                        if (Array.isArray(coords) && coords.length === 2 && typeof coords[0] === 'number') {
                            return `${coords[0]} ${coords[1]}`;
                        }
                        return coords.map(c => coordsToWKT(c)).join(', ');
                    }
                    
                    switch (geometry.type) {
                        case 'Point':
                            return `POINT (${coordsToWKT(geometry.coordinates)})`;
                        case 'LineString':
                            return `LINESTRING (${coordsToWKT(geometry.coordinates)})`;
                        case 'Polygon':
                            return `POLYGON ((${coordsToWKT(geometry.coordinates[0])}))`;
                        case 'MultiPoint':
                            return `MULTIPOINT (${geometry.coordinates.map(c => coordsToWKT(c)).join(', ')})`;
                        case 'MultiLineString':
                            return `MULTILINESTRING (${geometry.coordinates.map(line => `(${coordsToWKT(line)})`).join(', ')})`;
                        case 'MultiPolygon':
                            return `MULTIPOLYGON (${geometry.coordinates.map(poly => `((${coordsToWKT(poly[0])}))`).join(', ')})`;
                        default:
                    return '';
                    }
                } catch (e) {
                    return '';
                }
            }

            // Build CSV rows
            const rows = [headers.map(escapeCSV).join(',')];
            
            geoJSON.features.forEach(feature => {
                const row = [];
                
                // Geometry type
                row.push(escapeCSV(feature.geometry ? feature.geometry.type : ''));
                
                // Geometry WKT
                row.push(escapeCSV(geometryToWKT(feature.geometry)));
                
                // Point latitude and longitude (for Point and MultiPoint geometries)
                if (feature.geometry && Array.isArray(feature.geometry.coordinates)) {
                    if (feature.geometry.type === 'Point') {
                        row.push(escapeCSV(feature.geometry.coordinates[1])); // latitude
                        row.push(escapeCSV(feature.geometry.coordinates[0])); // longitude
                    } else if (feature.geometry.type === 'MultiPoint' && feature.geometry.coordinates.length > 0) {
                        // For MultiPoint, export first point's coordinates
                        row.push(escapeCSV(feature.geometry.coordinates[0][1])); // latitude
                        row.push(escapeCSV(feature.geometry.coordinates[0][0])); // longitude
                    } else {
                        row.push('');
                        row.push('');
                    }
                } else {
                    row.push('');
                    row.push('');
                }
                
                // Properties
                Array.from(allKeys).sort().forEach(key => {
                    row.push(escapeCSV(feature.properties?.[key]));
                });
                
                rows.push(row.join(','));
            });

            // Add BOM (Byte Order Mark) for UTF-8 to ensure proper encoding recognition
            const csvContent = '\uFEFF' + rows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename + '.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }



        // Start Over button: full reload of the page
        (function(){
            const btn = document.getElementById('controlsToggle');
            if (btn) {
                btn.addEventListener('click', function(e){
                    if (e && e.preventDefault) e.preventDefault();
                    if (e && e.stopPropagation) e.stopPropagation();
                    if (e && e.stopImmediatePropagation) e.stopImmediatePropagation();
                    // Clear export filename input and original filename before reload
                    originalFilename = undefined;
                    const filenameInput = document.getElementById('export-filename');
                    if (filenameInput) filenameInput.value = '';
                    window.location.reload();
                }, true);
            }
        })();

        // Validation overlay state and staged validator (responsive with progress)
        let validationOverlayVisible = false;
        let validationOverlayGroup = null;
        let __validationCancelled = false;
        // Store complete validation snapshot: { validatedFeatures, violationStore, featuresWithErrors, timestamp, stats }
        let __lastValidationStore = null;
        let __usingPreviousValidation = false; // Flag to indicate we're using previous results

        function cancelValidation() { __validationCancelled = true; }
        
        /**
         * Cancel current validation and use previous results
         */
        function usePreviousValidation() {
            // Set flag to prevent switching to VIEW mode
            __usingPreviousValidation = true;
            
            // Cancel ongoing validation
            __validationCancelled = true;
            
            // Close the progress modal
            closeValidationProgress();
            
            // Restore previous results
            restorePreviousValidation();
        }
        
        /**
         * Restore previous validation results without re-running validation
         */
        function restorePreviousValidation() {
            if (!__lastValidationStore || !__lastValidationStore.validatedFeatures) {
                console.warn('No previous validation results to restore');
                return;
            }
            
            // Ensure we're in validation mode
            currentMode = MODES.VALIDATION;
            currentTool = null;
            
            // Update button states
            const viewBtn = document.getElementById('btn-pan-mode');
            const editBtn = document.getElementById('btn-edit-mode');
            const validateBtn = document.getElementById('btn-validate-mode');
            
            if (viewBtn) viewBtn.classList.remove('active');
            if (editBtn) editBtn.classList.remove('active');
            if (validateBtn) validateBtn.classList.add('active');
            
            // Clear existing overlays
            if (validationOverlayGroup) {
                validationOverlayGroup.clearLayers();
                if (map.hasLayer(validationOverlayGroup)) {
                    map.removeLayer(validationOverlayGroup);
                }
            }
            if (validationClusterGroup) {
                validationClusterGroup.clearLayers();
                if (map.hasLayer(validationClusterGroup)) {
                    map.removeLayer(validationClusterGroup);
                }
            }
            
            // Compare current features with validation snapshot and render overlays
            addValidationStatusMarkersFromSnapshot(__lastValidationStore);
            
            // Show navigation control
            showValidationNavigator();
            
            // Mark validation as visible
            validationOverlayVisible = true;
            
            // Explicitly add validation layers to the map based on zoom and clustering
            const zoom = map.getZoom();
            const featureCount = currentGeoJSON && currentGeoJSON.features ? currentGeoJSON.features.length : 0;
            const useClustering = featureCount >= CLUSTERING_FEATURE_LIMIT;
            
            if (useClustering) {
                if (zoom <= CLUSTERING_LEVEL) {
                    // Zoomed out with clustering: show validation cluster markers
                    if (validationClusterGroup && !map.hasLayer(validationClusterGroup)) {
                        map.addLayer(validationClusterGroup);
                    }
                } else {
                    // Zoomed in with clustering: show individual validation overlays
                    if (validationOverlayGroup && !map.hasLayer(validationOverlayGroup)) {
                        map.addLayer(validationOverlayGroup);
                    }
                }
            } else {
                // No clustering: always show validation overlays
                if (validationOverlayGroup && !map.hasLayer(validationOverlayGroup)) {
                    map.addLayer(validationOverlayGroup);
                }
            }
        }

        /**
         * Create a custom Leaflet control for navigating validation errors
         */
        L.Control.ValidationNavigator = L.Control.extend({
            options: {
                position: 'topleft'
            },
            
            onAdd: function(map) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control validation-navigator');
                container.style.backgroundColor = '#dc6575'; // Use danger color from CSS variables
                container.style.padding = '10px 14px';
                container.style.borderRadius = '8px'; // Rounded edges like buttons
                container.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)';
                container.style.display = 'flex';
                container.style.flexDirection = 'column';
                container.style.gap = '8px';
                container.style.marginLeft = '10px';
                container.style.marginTop = '10px';
                
                // Title
                const title = L.DomUtil.create('div', 'navigator-title', container);
                title.style.color = 'white';
                title.style.fontSize = '11px';
                title.style.fontWeight = '700';
                title.style.textTransform = 'uppercase';
                title.style.letterSpacing = '0.5px';
                title.style.textAlign = 'center';
                title.style.marginBottom = '4px';
                title.textContent = getText('identifiedIssues');
                
                // Controls row
                const controlsRow = L.DomUtil.create('div', 'navigator-controls', container);
                controlsRow.style.display = 'flex';
                controlsRow.style.alignItems = 'center';
                controlsRow.style.gap = '8px';
                
                // Counter display
                const counter = L.DomUtil.create('span', 'error-counter', controlsRow);
                counter.style.color = 'white';
                counter.style.fontSize = '13px';
                counter.style.fontWeight = '600';
                counter.style.minWidth = '60px';
                counter.style.textAlign = 'center';
                counter.textContent = '0 / 0';
                this._counter = counter;
                
                // Previous button
                const prevBtn = L.DomUtil.create('button', 'nav-btn', controlsRow);
                prevBtn.innerHTML = '';
                prevBtn.title = 'Previous Issue';
                prevBtn.style.backgroundColor = 'rgba(255,255,255,0.9)';
                prevBtn.style.border = 'none';
                prevBtn.style.borderRadius = '6px'; // Rounded edges
                prevBtn.style.padding = '6px 12px';
                prevBtn.style.cursor = 'pointer';
                prevBtn.style.fontSize = '14px';
                prevBtn.style.fontWeight = 'bold';
                
                // Next button
                const nextBtn = L.DomUtil.create('button', 'nav-btn', controlsRow);
                nextBtn.innerHTML = '';
                nextBtn.title = 'Next Issue';
                nextBtn.style.backgroundColor = 'rgba(255,255,255,0.9)';
                nextBtn.style.border = 'none';
                nextBtn.style.borderRadius = '6px'; // Rounded edges
                nextBtn.style.padding = '6px 12px';
                nextBtn.style.cursor = 'pointer';
                nextBtn.style.fontSize = '14px';
                nextBtn.style.fontWeight = 'bold';
                
                // Prevent map interactions on the control
                L.DomEvent.disableClickPropagation(container);
                L.DomEvent.disableScrollPropagation(container);
                
                // Event handlers
                L.DomEvent.on(prevBtn, 'click', this._onPrevious, this);
                L.DomEvent.on(nextBtn, 'click', this._onNext, this);
                
                // Hover effects
                prevBtn.onmouseenter = () => { prevBtn.style.backgroundColor = '#fff'; };
                prevBtn.onmouseleave = () => { prevBtn.style.backgroundColor = 'rgba(255,255,255,0.9)'; };
                nextBtn.onmouseenter = () => { nextBtn.style.backgroundColor = '#fff'; };
                nextBtn.onmouseleave = () => { nextBtn.style.backgroundColor = 'rgba(255,255,255,0.9)'; };
                
                this._prevBtn = prevBtn;
                this._nextBtn = nextBtn;
                this._container = container;
                
                return container;
            },
            
            onRemove: function(map) {
                L.DomEvent.off(this._prevBtn, 'click', this._onPrevious, this);
                L.DomEvent.off(this._nextBtn, 'click', this._onNext, this);
            },
            
            _onPrevious: function() {
                navigateToPreviousValidationError();
            },
            
            _onNext: function() {
                navigateToNextValidationError();
            },
            
            updateCounter: function(current, total) {
                if (this._counter) {
                    this._counter.textContent = `${current} / ${total}`;
                }
                // Keep buttons always enabled - clicking at boundaries re-zooms to current feature
                if (this._prevBtn) {
                    this._prevBtn.disabled = (total === 0);
                    this._prevBtn.style.opacity = (total === 0) ? '0.4' : '1';
                    this._prevBtn.style.cursor = (total === 0) ? 'not-allowed' : 'pointer';
                }
                if (this._nextBtn) {
                    this._nextBtn.disabled = (total === 0);
                    this._nextBtn.style.opacity = (total === 0) ? '0.4' : '1';
                    this._nextBtn.style.cursor = (total === 0) ? 'not-allowed' : 'pointer';
                }
            }
        });

        /**
         * Navigate to previous validation error
         * If already at first, re-zoom to same feature
         */
        function navigateToPreviousValidationError() {
            const errorList = Array.from(featuresWithValidationErrors).sort((a, b) => a - b);
            if (errorList.length === 0) return;
            
            // If not at first, move to previous; otherwise stay at first (re-zoom)
            if (currentValidationErrorIndex > 0) {
                currentValidationErrorIndex--;
            }
            
            zoomToValidationError(errorList[currentValidationErrorIndex]);
            updateValidationNavigatorCounter();
        }

        /**
         * Navigate to next validation error
         * If already at last, re-zoom to same feature
         */
        function navigateToNextValidationError() {
            const errorList = Array.from(featuresWithValidationErrors).sort((a, b) => a - b);
            if (errorList.length === 0) return;
            
            // If not at last, move to next; otherwise stay at last (re-zoom)
            if (currentValidationErrorIndex < errorList.length - 1) {
                currentValidationErrorIndex++;
            }
            
            const featureIndex = errorList[currentValidationErrorIndex];
            zoomToValidationError(featureIndex);
            updateValidationNavigatorCounter();
        }

        // Track current highlight layer and timeouts to prevent race conditions
        let currentValidationHighlight = null;
        let validationHighlightTimeout = null;
        let validationHighlightRemovalTimeout = null;

        /**
         * Zoom to a specific feature with validation error
         * If using previous validation and feature no longer exists, show message
         */
        function zoomToValidationError(featureIndex) {
            if (!currentGeoJSON || !currentGeoJSON.features) return;
            
            const feature = currentGeoJSON.features[featureIndex];
            if (!feature || !feature.geometry) {
                // Feature no longer exists (removed after validation)
                if (__usingPreviousValidation) {
                    alert(getText('featureNoLongerExists'));
                }
                return;
            }
            
            try {
                // Cancel any pending timeouts to prevent race conditions
                if (validationHighlightTimeout) {
                    clearTimeout(validationHighlightTimeout);
                    validationHighlightTimeout = null;
                }
                if (validationHighlightRemovalTimeout) {
                    clearTimeout(validationHighlightRemovalTimeout);
                    validationHighlightRemovalTimeout = null;
                }
                
                // Remove previous highlight if exists
                if (currentValidationHighlight && map.hasLayer(currentValidationHighlight)) {
                    map.removeLayer(currentValidationHighlight);
                    currentValidationHighlight = null;
                }
                
                // Create a temporary layer to get bounds
                const tempLayer = L.geoJSON(feature);
                const bounds = tempLayer.getBounds();
                
                if (bounds.isValid()) {
                    // Calculate the size of the feature to determine appropriate zoom
                    const boundsWidth = Math.abs(bounds.getEast() - bounds.getWest());
                    const boundsHeight = Math.abs(bounds.getNorth() - bounds.getSouth());
                    const boundsSize = Math.max(boundsWidth, boundsHeight);
                    
                    // For very small features, zoom in much closer
                    // For medium features, use moderate zoom
                    // For large features, use wide view
                    let maxZoom;
                    if (boundsSize < 0.001) {
                        maxZoom = 19; // Very small feature - zoom in very close
                    } else if (boundsSize < 0.01) {
                        maxZoom = 18; // Small feature - zoom in close
                    } else if (boundsSize < 0.1) {
                        maxZoom = 17; // Medium feature
                    } else {
                        maxZoom = 16; // Large feature
                    }
                    
                    // Zoom to feature with some padding
                    map.fitBounds(bounds, {
                        padding: [50, 50],
                        maxZoom: maxZoom
                    });
                    
                    // Add temporary highlight/pulse effect to show current feature
                    validationHighlightTimeout = setTimeout(() => {
                        const persistentId = feature.__persistentId || featureIndex;
                        const highlightLayer = L.geoJSON(feature, {
                            style: {
                                color: '#FF8C00', // Dark amber color
                                weight: 4,
                                fillColor: '#FF8C00',
                                fillOpacity: 0.3,
                                opacity: 1,
                                dashArray: '10, 5',
                                fillRule: 'nonzero'
                            },
                            pane: 'validationErrorPane'
                        });
                        
                        // Add tooltip showing feature number
                        highlightLayer.bindTooltip(`<div style="font-weight: bold; color: #FF8C00;">Current: Feature ${persistentId}</div>`, {
                            permanent: true,
                            direction: 'top',
                            className: 'current-feature-tooltip'
                        });
                        
                        highlightLayer.addTo(map);
                        currentValidationHighlight = highlightLayer;
                        validationHighlightTimeout = null;
                        
                        // Remove highlight after 3 seconds
                        validationHighlightRemovalTimeout = setTimeout(() => {
                            if (currentValidationHighlight === highlightLayer && map.hasLayer(highlightLayer)) {
                                map.removeLayer(highlightLayer);
                                currentValidationHighlight = null;
                            }
                            validationHighlightRemovalTimeout = null;
                        }, 3000);
                    }, 300); // Small delay to ensure zoom completes first
                }
            } catch (e) {
                console.error('Error zooming to validation error:', e);
            }
        }

        /**
         * Update the validation navigator counter display
         */
        function updateValidationNavigatorCounter() {
            if (validationErrorNavigator) {
                const errorList = Array.from(featuresWithValidationErrors).sort((a, b) => a - b);
                const current = errorList.length > 0 ? currentValidationErrorIndex + 1 : 0;
                validationErrorNavigator.updateCounter(current, errorList.length);
            }
        }

        /**
         * Show validation navigator control
         */
        function showValidationNavigator() {
            if (!map) return;
            
            // Remove existing control if present
            if (validationErrorNavigator) {
                map.removeControl(validationErrorNavigator);
            }
            
            // Only show if there are errors
            if (featuresWithValidationErrors.size > 0) {
                validationErrorNavigator = new L.Control.ValidationNavigator();
                map.addControl(validationErrorNavigator);
                currentValidationErrorIndex = 0;
                updateValidationNavigatorCounter();
            }
        }

        /**
         * Hide validation navigator control
         */
        function hideValidationNavigator() {
            if (validationErrorNavigator && map) {
                map.removeControl(validationErrorNavigator);
                validationErrorNavigator = null;
            }
            
            // Cancel any pending timeouts
            if (validationHighlightTimeout) {
                clearTimeout(validationHighlightTimeout);
                validationHighlightTimeout = null;
            }
            if (validationHighlightRemovalTimeout) {
                clearTimeout(validationHighlightRemovalTimeout);
                validationHighlightRemovalTimeout = null;
            }
            
            // Remove any current highlight
            if (currentValidationHighlight && map && map.hasLayer(currentValidationHighlight)) {
                map.removeLayer(currentValidationHighlight);
                currentValidationHighlight = null;
            }
            currentValidationErrorIndex = 0;
        }

        /**
         * Add polygons for all features showing validation status
         * Features with errors show red polygons, features without errors show green polygons
         */
        function addValidationStatusMarkers(violationStore) {
            if (!currentGeoJSON || !currentGeoJSON.features || !validationOverlayGroup) {
                return;
            }
            
            // Determine if clustering should be used
            const featureCount = currentGeoJSON.features.length;
            const useClustering = featureCount >= CLUSTERING_FEATURE_LIMIT;
            
            // Clear validation cluster group if it exists
            if (validationClusterGroup) validationClusterGroup.clearLayers();
            
            // Reset validation errors tracking
            featuresWithValidationErrors.clear();
            
            // Create a Set of features with violations for quick lookup
            // violationStore is keyed by feature index
            const featuresWithViolations = new Set();
            currentGeoJSON.features.forEach((feature, idx) => {
                if (!feature.geometry) return;
                
                // Check if this feature has any violations (violationStore uses feature index as key)
                const hasViolation = violationStore.has(idx);
                
                if (hasViolation) {
                    featuresWithViolations.add(idx);
                    featuresWithValidationErrors.add(idx);
                }
            });
            
            // Ensure dedicated panes and renderers for OK (green) and ERROR (red) overlays
            if (!map.getPane('validationOkPane')) {
                map.createPane('validationOkPane');
                const okp = map.getPane('validationOkPane');
                okp.style.zIndex = '610';
                okp.style.pointerEvents = 'auto';
            }
            if (!map.getPane('validationErrorPane')) {
                map.createPane('validationErrorPane');
                const errp = map.getPane('validationErrorPane');
                errp.style.zIndex = '620';
                errp.style.pointerEvents = 'auto';
            }
            if (!window.__validationOkRenderer) {
                window.__validationOkRenderer = L.svg({ pane: 'validationOkPane' });
                window.__validationOkRenderer.addTo(map);
            }
            if (!window.__validationErrorRenderer) {
                window.__validationErrorRenderer = L.svg({ pane: 'validationErrorPane' });
                window.__validationErrorRenderer.addTo(map);
            }
            
            // Create validation overlays for ALL features (both clustering and non-clustering modes)
            currentGeoJSON.features.forEach((feature, idx) => {
                if (!feature.geometry) return;
                
                const hasViolation = featuresWithViolations.has(idx);
                
                // Create polygon overlay for polygons (both valid and invalid)
                if (feature.geometry.type === 'Polygon') {
                    const geoJSONLayer = L.geoJSON(feature, {
                        style: {
                            color: hasViolation ? '#dc6575' : '#40916c',
                            weight: 2,
                            fillColor: hasViolation ? '#dc6575' : '#40916c',
                            fillOpacity: hasViolation ? 0.3 : 0.2,
                            opacity: 0.8,
                            fillRule: 'nonzero'
                        },
                        pane: hasViolation ? 'validationErrorPane' : 'validationOkPane'
                    });
                    
                    // Add tooltip with detailed violation messages
                    const persistentId = (feature && typeof feature.__persistentId === 'number') ? feature.__persistentId : idx;
                    const geometryType = 'Polygon';
                    const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                    
                    let message;
                    if (hasViolation && violationStore.has(idx)) {
                        // Show detailed violation messages
                        const violations = violationStore.get(idx);
                        if (violations && violations.messages && violations.messages.length > 0) {
                            message = violations.messages.map(msg => 
                                `<div style="color: #dc6575; margin: 4px 0;"> ${msg}</div>`
                            ).join('');
                        } else {
                            message = '<div style="color: #dc6575; font-weight: 600;"> Validation issues detected</div>';
                        }
                    } else {
                        message = '<div style="color: #40916c; font-weight: 600;"> No validation issues detected</div>';
                    }
                    
                    const __tooltipOptions = { direction: 'top', sticky: true, opacity: 0.95, className: 'validation-tooltip' };
                    geoJSONLayer.bindTooltip(`<div class="tooltip-content">${header}${message}</div>`, __tooltipOptions);
                    
                    geoJSONLayer.on('mouseover', function(e) { geoJSONLayer.openTooltip(e.latlng); });
                    geoJSONLayer.on('mousemove', function(e) { geoJSONLayer.openTooltip(e.latlng); });
                    geoJSONLayer.on('mouseout', function() { geoJSONLayer.closeTooltip(); });
                    
                    validationOverlayGroup.addLayer(geoJSONLayer);
                } else if (feature.geometry.type === 'MultiPolygon') {
                    // For MultiPolygons, render each sub-polygon individually
                    // This allows showing which specific sub-polygons have violations
                    const persistentId = (feature && typeof feature.__persistentId === 'number') ? feature.__persistentId : idx;
                    
                    // Note: addViolationPolygon() created red overlays for sub-polygons with issues.
                    // We need to show green overlays on sub-polygons WITHOUT issues.
                    
                    // Get the sub-polygon specific issues if tracked
                    const violationData = violationStore.has(idx) ? violationStore.get(idx) : null;
                    const subPolygonIssues = violationData?.subPolygonIssues || new Map();
                    const hasGeneralMessages = violationData?.messages && violationData.messages.length > 0;
                    
                    // Iterate through each sub-polygon
                    feature.geometry.coordinates.forEach((polyCoords, polyIdx) => {
                        // If we have sub-polygon specific tracking, use it
                        if (subPolygonIssues.size > 0) {
                            // Skip this sub-polygon if it has specific issues (already has red overlay)
                            if (subPolygonIssues.has(polyIdx)) {
                                return;
                            }
                        } else if (hasGeneralMessages) {
                            // Fallback: if there are general messages without sub-polygon tracking,
                            // all sub-polygons have red overlays, so skip all green rendering
                            return;
                        }
                        
                        // Show green overlay for valid sub-polygons
                        
                        // Create a temporary Polygon feature for this sub-polygon
                        const subPolygonFeature = {
                            type: 'Feature',
                            geometry: {
                                type: 'Polygon',
                                coordinates: polyCoords
                            },
                            properties: feature.properties || {}
                        };
                        
                        // Render valid sub-polygon in green
                        const geoJSONLayer = L.geoJSON(subPolygonFeature, {
                            style: {
                                color: '#40916c',
                                weight: 2,
                                fillColor: '#40916c',
                                fillOpacity: 0.2,
                                opacity: 0.8,
                                fillRule: 'nonzero'
                            },
                            pane: 'validationOkPane'
                        });
                        
                        // Add tooltip
                        const geometryType = `MultiPolygon [${polyIdx + 1}/${feature.geometry.coordinates.length}]`;
                        const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                        const message = hasViolation 
                            ? '<div style="color: #40916c; font-weight: 600;"> No validation issues detected on this part</div>'
                            : '<div style="color: #40916c; font-weight: 600;"> No validation issues detected</div>';
                        
                        const __tooltipOptions = { direction: 'top', sticky: true, opacity: 0.95, className: 'validation-tooltip' };
                        geoJSONLayer.bindTooltip(`<div class="tooltip-content">${header}${message}</div>`, __tooltipOptions);
                        
                        geoJSONLayer.on('mouseover', function(e) { geoJSONLayer.openTooltip(e.latlng); });
                        geoJSONLayer.on('mousemove', function(e) { geoJSONLayer.openTooltip(e.latlng); });
                        geoJSONLayer.on('mouseout', function() { geoJSONLayer.closeTooltip(); });
                        
                        validationOverlayGroup.addLayer(geoJSONLayer);
                    });
                } else if (feature.geometry.type === 'Point' || feature.geometry.type === 'MultiPoint') {
                    // For points, create a circle marker (both clustering and non-clustering)
                    // Always render validation overlays in validation mode
                    
                    // Get violation data for sub-point tracking
                    const violationData = violationStore.has(idx) ? violationStore.get(idx) : null;
                    const subPointIssues = violationData?.subPolygonIssues || new Map(); // Reusing subPolygonIssues map for points
                    
                    // Handle both Point and MultiPoint
                    if (feature.geometry.type === 'Point') {
                        // Single point - render if has violation
                        const coords = feature.geometry.coordinates;
                        const pointHasViolation = hasViolation;
                        
                        const marker = L.circleMarker([coords[1], coords[0]], {
                            radius: 6,
                            fillColor: pointHasViolation ? '#dc6575' : '#40916c',
                            color: '#fff',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.8,
                            pane: pointHasViolation ? 'validationErrorPane' : 'validationOkPane'
                        });
                        
                        // Add tooltip with detailed violation messages
                        const persistentId = (feature && typeof feature.__persistentId === 'number') ? feature.__persistentId : idx;
                        const geometryType = feature.geometry.type;
                        const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                        
                        let message;
                        if (pointHasViolation && violationData && violationData.messages && violationData.messages.length > 0) {
                            message = violationData.messages.map(msg => 
                                `<div style="color: #dc6575; margin: 4px 0;"> ${msg}</div>`
                            ).join('');
                        } else if (pointHasViolation) {
                            message = '<div style="color: #dc6575; font-weight: 600;"> Validation issues detected</div>';
                        } else {
                            message = '<div style="color: #40916c; font-weight: 600;"> No validation issues detected</div>';
                        }
                        
                        marker.bindTooltip(`<div class="tooltip-content">${header}${message}</div>`, {
                            direction: 'top',
                            sticky: true,
                            opacity: 0.95,
                            className: 'validation-tooltip'
                        });
                        
                        marker.on('mouseover', function(e) { marker.openTooltip(); });
                        marker.on('mouseout', function() { marker.closeTooltip(); });
                        
                        validationOverlayGroup.addLayer(marker);
                        
                    } else if (feature.geometry.type === 'MultiPoint') {
                        // For MultiPoint, render each point individually with sub-point tracking
                        const persistentId = (feature && typeof feature.__persistentId === 'number') ? feature.__persistentId : idx;
                        
                        feature.geometry.coordinates.forEach((coords, pointIdx) => {
                            // Check if this specific point has issues
                            const pointHasIssue = subPointIssues.has(pointIdx);
                            
                            // Always render in validation mode - red for issues, green for valid
                            
                            const marker = L.circleMarker([coords[1], coords[0]], {
                                radius: 6,
                                fillColor: pointHasIssue ? '#dc6575' : '#40916c',
                                color: '#fff',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.8,
                                pane: pointHasIssue ? 'validationErrorPane' : 'validationOkPane'
                            });
                            
                            // Add tooltip
                            const geometryType = `MultiPoint [${pointIdx + 1}/${feature.geometry.coordinates.length}]`;
                            const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                            
                            let message;
                            if (pointHasIssue) {
                                // Show sub-point specific messages
                                const subPointMessages = subPointIssues.get(pointIdx);
                                if (subPointMessages && subPointMessages.length > 0) {
                                    message = subPointMessages.map(msg => 
                                        `<div style="color: #dc6575; margin: 4px 0;"> ${msg}</div>`
                                    ).join('');
                                } else {
                                    message = '<div style="color: #dc6575; font-weight: 600;"> Validation issues detected</div>';
                                }
                            } else if (hasViolation && subPointIssues.size > 0) {
                                // Feature has issues but not on this point
                                message = '<div style="color: #40916c; font-weight: 600;"> No validation issues on this point</div>';
                            } else {
                                message = '<div style="color: #40916c; font-weight: 600;"> No validation issues detected</div>';
                            }
                            
                            marker.bindTooltip(`<div class="tooltip-content">${header}${message}</div>`, {
                                direction: 'top',
                                sticky: true,
                                opacity: 0.95,
                                className: 'validation-tooltip'
                            });
                            
                            marker.on('mouseover', function(e) { marker.openTooltip(); });
                            marker.on('mouseout', function() { marker.closeTooltip(); });
                            
                            validationOverlayGroup.addLayer(marker);
                        });
                    }
                }
            });
            
            // For large datasets with clustering, also create markers for the cluster group
            if (useClustering) {
                currentGeoJSON.features.forEach((feature, idx) => {
                    if (!feature.geometry) return;
                    
                    const hasViolation = featuresWithViolations.has(idx);
                    let markerLatLng;
                    
                    // Get marker position (centroid for polygons, actual coords for points)
                    if (feature.geometry.type === 'Point') {
                        const coords = feature.geometry.coordinates;
                        markerLatLng = [coords[1], coords[0]];
                    } else if (feature.geometry.type === 'MultiPoint') {
                        // For MultiPoint, use the first point as the marker position
                        const coords = feature.geometry.coordinates[0];
                        markerLatLng = [coords[1], coords[0]];
                    } else if (feature.geometry.type === 'Polygon') {
                        const centroid = calculatePolygonCentroid(feature.geometry.coordinates[0]);
                        if (centroid) markerLatLng = [centroid[1], centroid[0]];
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        const centroid = calculatePolygonCentroid(feature.geometry.coordinates[0][0]);
                        if (centroid) markerLatLng = [centroid[1], centroid[0]];
                    }
                    
                    if (!markerLatLng) return;
                    
                    // Create marker with appropriate color
                    const marker = L.marker(markerLatLng, {
                        icon: L.divIcon({
                            className: hasViolation ? 'validation-marker-error' : 'validation-marker-valid',
                            html: hasViolation ? '<div style="background: #dc6575; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>' : 
                                                 '<div style="background: #40916c; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
                            iconSize: [16, 16]
                        }),
                        validationError: hasViolation  // Mark for cluster coloring
                    });
                    
                    // Add tooltip
                    const persistentId = (feature && typeof feature.__persistentId === 'number') ? feature.__persistentId : idx;
                    const geometryType = (feature && feature.geometry && feature.geometry.type) ? feature.geometry.type : 'Unknown';
                    const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                    const message = hasViolation ? 
                        '<div style="color: #dc6575; font-weight: 600;"> Validation issues detected</div>' :
                        '<div style="color: #40916c; font-weight: 600;"> No validation issues detected</div>';
                    
                    marker.bindPopup(`<div class="tooltip-content">${header}${message}</div>`);
                    
                    // Add to cluster group
                    validationClusterGroup.addLayer(marker);
                });
            }
            
            
            // Helper function to create normalized key for coords - MUST match the one in stageValidateGeometries
            function keyForCoords(coords) {
                try { 
                    const tol = 1e-10;
                    const normPoint = (pt) => [ Math.round(pt[0] / tol) * tol, Math.round(pt[1] / tol) * tol ];
                    // Use the same normalization as when creating violations
                    const normalized = __gr_normalizeRingForOps(coords);
                    return JSON.stringify(normalized.map(normPoint));
                } catch(_) { return ''; }
            }
        }

        /**
         * Add validation overlays from snapshot - compares current features with validated snapshot
         * Shows original overlays for unchanged features, amber "outdated" indicators for edited features
         * @param {Object} snapshot - The validation snapshot { validatedFeatures, violationStore, featuresWithErrors, timestamp, stats }
         */
        function addValidationStatusMarkersFromSnapshot(snapshot) {
            if (!currentGeoJSON || !currentGeoJSON.features || !validationOverlayGroup) {
                return;
            }
            
            // Determine if clustering should be used
            const featureCount = currentGeoJSON.features.length;
            const useClustering = featureCount >= CLUSTERING_FEATURE_LIMIT;
            
            // Clear validation cluster group if it exists
            if (validationClusterGroup) validationClusterGroup.clearLayers();
            
            // Reset validation errors tracking
            featuresWithValidationErrors.clear();
            
            // Build lookup map: __persistentId -> validated feature
            const validatedFeatureMap = new Map();
            snapshot.validatedFeatures.forEach(feature => {
                if (feature.__persistentId !== undefined) {
                    validatedFeatureMap.set(feature.__persistentId, feature);
                }
            });
            
            // Build lookup map: __persistentId -> original feature index in validated array
            const persistentIdToValidatedIndex = new Map();
            snapshot.validatedFeatures.forEach((feature, idx) => {
                if (feature.__persistentId !== undefined) {
                    persistentIdToValidatedIndex.set(feature.__persistentId, idx);
                }
            });
            
            // Helper function to compare geometries (simplified check)
            function geometriesMatch(geom1, geom2) {
                return JSON.stringify(geom1) === JSON.stringify(geom2);
            }
            
            // Ensure panes exist
            if (!map.getPane('validationOkPane')) {
                map.createPane('validationOkPane');
                const okp = map.getPane('validationOkPane');
                okp.style.zIndex = '610';
                okp.style.pointerEvents = 'auto';
            }
            if (!map.getPane('validationErrorPane')) {
                map.createPane('validationErrorPane');
                const errp = map.getPane('validationErrorPane');
                errp.style.zIndex = '620';
                errp.style.pointerEvents = 'auto';
            }
            if (!map.getPane('validationOutdatedPane')) {
                map.createPane('validationOutdatedPane');
                const outp = map.getPane('validationOutdatedPane');
                outp.style.zIndex = '615'; // Between OK and ERROR
                outp.style.pointerEvents = 'auto';
            }
            if (!window.__validationOkRenderer) {
                window.__validationOkRenderer = L.svg({ pane: 'validationOkPane' });
                window.__validationOkRenderer.addTo(map);
            }
            if (!window.__validationErrorRenderer) {
                window.__validationErrorRenderer = L.svg({ pane: 'validationErrorPane' });
                window.__validationErrorRenderer.addTo(map);
            }
            if (!window.__validationOutdatedRenderer) {
                window.__validationOutdatedRenderer = L.svg({ pane: 'validationOutdatedPane' });
                window.__validationOutdatedRenderer.addTo(map);
            }
            
            // Process each current feature
            currentGeoJSON.features.forEach((currentFeature, currentIdx) => {
                if (!currentFeature.geometry) return;
                
                const persistentId = currentFeature.__persistentId;
                
                // Check if this feature existed during validation
                const validatedFeature = persistentId !== undefined ? validatedFeatureMap.get(persistentId) : null;
                
                if (!validatedFeature) {
                    // Feature was added AFTER validation - no overlay
                    return;
                }
                
                // Check if geometry has changed
                const geometryChanged = !geometriesMatch(currentFeature.geometry, validatedFeature.geometry);
                
                // Get validation status from snapshot
                const validatedIdx = persistentIdToValidatedIndex.get(persistentId);
                const hasViolation = validatedIdx !== undefined && snapshot.violationStore.has(validatedIdx);
                const violationData = hasViolation ? snapshot.violationStore.get(validatedIdx) : null;
                
                // If geometry changed, show amber "outdated" overlay
                if (geometryChanged) {
                    renderOutdatedOverlay(currentFeature, currentIdx, hasViolation);
                } else {
                    // Geometry unchanged - show original validation overlay
                    renderOriginalValidationOverlay(currentFeature, currentIdx, hasViolation, violationData);
                    
                    // Track errors for navigator
                    if (hasViolation) {
                        featuresWithValidationErrors.add(currentIdx);
                    }
                }
            });
            
            // Helper: Render amber "outdated validation" overlay
            function renderOutdatedOverlay(feature, idx, hadViolation) {
                const persistentId = (feature && typeof feature.__persistentId === 'number') ? feature.__persistentId : idx;
                
                if (feature.geometry.type === 'Polygon') {
                    const geoJSONLayer = L.geoJSON(feature, {
                        style: {
                            color: '#d9a31c', // Amber
                            weight: 2,
                            fillColor: '#d9a31c',
                            fillOpacity: 0.25,
                            opacity: 0.8,
                            fillRule: 'nonzero'
                        },
                        pane: 'validationOutdatedPane'
                    });
                    
                    const geometryType = 'Polygon';
                    const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                    const message = `<div style="color: #d9a31c; font-weight: 600;"> Outdated Validation</div><div style="color: #666; margin-top: 4px; font-size: 0.9em;">This feature was modified after validation. Original status: ${hadViolation ? 'Invalid' : 'Valid'}</div>`;
                    
                    geoJSONLayer.bindTooltip(`<div class="tooltip-content">${header}${message}</div>`, {
                        direction: 'top', sticky: true, opacity: 0.95, className: 'validation-tooltip'
                    });
                    
                    geoJSONLayer.on('mouseover', function(e) { geoJSONLayer.openTooltip(e.latlng); });
                    geoJSONLayer.on('mousemove', function(e) { geoJSONLayer.openTooltip(e.latlng); });
                    geoJSONLayer.on('mouseout', function() { geoJSONLayer.closeTooltip(); });
                    
                    validationOverlayGroup.addLayer(geoJSONLayer);
                } else if (feature.geometry.type === 'MultiPolygon') {
                    feature.geometry.coordinates.forEach((polyCoords, polyIdx) => {
                        const subPolygonFeature = {
                            type: 'Feature',
                            geometry: { type: 'Polygon', coordinates: polyCoords },
                            properties: feature.properties || {}
                        };
                        
                        const geoJSONLayer = L.geoJSON(subPolygonFeature, {
                            style: {
                                color: '#d9a31c',
                                weight: 2,
                                fillColor: '#d9a31c',
                                fillOpacity: 0.25,
                                opacity: 0.8,
                                fillRule: 'nonzero'
                            },
                            pane: 'validationOutdatedPane'
                        });
                        
                        const geometryType = `MultiPolygon [${polyIdx + 1}/${feature.geometry.coordinates.length}]`;
                        const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                        const message = `<div style="color: #d9a31c; font-weight: 600;"> Outdated Validation</div><div style="color: #666; margin-top: 4px; font-size: 0.9em;">This feature was modified after validation. Original status: ${hadViolation ? 'Invalid' : 'Valid'}</div>`;
                        
                        geoJSONLayer.bindTooltip(`<div class="tooltip-content">${header}${message}</div>`, {
                            direction: 'top', sticky: true, opacity: 0.95, className: 'validation-tooltip'
                        });
                        
                        geoJSONLayer.on('mouseover', function(e) { geoJSONLayer.openTooltip(e.latlng); });
                        geoJSONLayer.on('mousemove', function(e) { geoJSONLayer.openTooltip(e.latlng); });
                        geoJSONLayer.on('mouseout', function() { geoJSONLayer.closeTooltip(); });
                        
                        validationOverlayGroup.addLayer(geoJSONLayer);
                    });
                } else if (feature.geometry.type === 'Point') {
                    const coords = feature.geometry.coordinates;
                    const marker = L.circleMarker([coords[1], coords[0]], {
                        radius: 6,
                        fillColor: '#d9a31c',
                        color: '#fff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8,
                        pane: 'validationOutdatedPane'
                    });
                    
                    const geometryType = 'Point';
                    const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                    const message = `<div style="color: #d9a31c; font-weight: 600;"> Outdated Validation</div><div style="color: #666; margin-top: 4px; font-size: 0.9em;">This feature was modified after validation. Original status: ${hadViolation ? 'Invalid' : 'Valid'}</div>`;
                    
                    marker.bindTooltip(`<div class="tooltip-content">${header}${message}</div>`, {
                        direction: 'top', sticky: true, opacity: 0.95, className: 'validation-tooltip'
                    });
                    
                    marker.on('mouseover', function() { marker.openTooltip(); });
                    marker.on('mouseout', function() { marker.closeTooltip(); });
                    
                    validationOverlayGroup.addLayer(marker);
                } else if (feature.geometry.type === 'MultiPoint') {
                    feature.geometry.coordinates.forEach((coords, pointIdx) => {
                        const marker = L.circleMarker([coords[1], coords[0]], {
                            radius: 6,
                            fillColor: '#d9a31c',
                            color: '#fff',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.8,
                            pane: 'validationOutdatedPane'
                        });
                        
                        const geometryType = `MultiPoint [${pointIdx + 1}/${feature.geometry.coordinates.length}]`;
                        const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                        const message = `<div style="color: #d9a31c; font-weight: 600;"> Outdated Validation</div><div style="color: #666; margin-top: 4px; font-size: 0.9em;">This feature was modified after validation. Original status: ${hadViolation ? 'Invalid' : 'Valid'}</div>`;
                        
                        marker.bindTooltip(`<div class="tooltip-content">${header}${message}</div>`, {
                            direction: 'top', sticky: true, opacity: 0.95, className: 'validation-tooltip'
                        });
                        
                        marker.on('mouseover', function() { marker.openTooltip(); });
                        marker.on('mouseout', function() { marker.closeTooltip(); });
                        
                        validationOverlayGroup.addLayer(marker);
                    });
                }
            }
            
            // Helper: Render original validation overlay (unchanged feature)
            function renderOriginalValidationOverlay(feature, idx, hasViolation, violationData) {
                const persistentId = (feature && typeof feature.__persistentId === 'number') ? feature.__persistentId : idx;
                
                if (feature.geometry.type === 'Polygon') {
                    const geoJSONLayer = L.geoJSON(feature, {
                        style: {
                            color: hasViolation ? '#dc6575' : '#40916c',
                            weight: 2,
                            fillColor: hasViolation ? '#dc6575' : '#40916c',
                            fillOpacity: hasViolation ? 0.3 : 0.2,
                            opacity: 0.8,
                            fillRule: 'nonzero'
                        },
                        pane: hasViolation ? 'validationErrorPane' : 'validationOkPane'
                    });
                    
                    const geometryType = 'Polygon';
                    const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                    
                    let message;
                    if (hasViolation && violationData && violationData.messages && violationData.messages.length > 0) {
                        message = violationData.messages.map(msg => 
                            `<div style="color: #dc6575; margin: 4px 0;"> ${msg}</div>`
                        ).join('');
                    } else if (hasViolation) {
                        message = '<div style="color: #dc6575; font-weight: 600;"> Validation issues detected</div>';
                    } else {
                        message = '<div style="color: #40916c; font-weight: 600;"> No validation issues detected</div>';
                    }
                    
                    geoJSONLayer.bindTooltip(`<div class="tooltip-content">${header}${message}</div>`, {
                        direction: 'top', sticky: true, opacity: 0.95, className: 'validation-tooltip'
                    });
                    
                    geoJSONLayer.on('mouseover', function(e) { geoJSONLayer.openTooltip(e.latlng); });
                    geoJSONLayer.on('mousemove', function(e) { geoJSONLayer.openTooltip(e.latlng); });
                    geoJSONLayer.on('mouseout', function() { geoJSONLayer.closeTooltip(); });
                    
                    validationOverlayGroup.addLayer(geoJSONLayer);
                } else if (feature.geometry.type === 'MultiPolygon') {
                    const subPolygonIssues = violationData?.subPolygonIssues || new Map();
                    const hasGeneralMessages = violationData?.messages && violationData.messages.length > 0;
                    
                    feature.geometry.coordinates.forEach((polyCoords, polyIdx) => {
                        let polyHasIssue = false;
                        let polyMessages = [];
                        
                        if (subPolygonIssues.size > 0) {
                            polyHasIssue = subPolygonIssues.has(polyIdx);
                            polyMessages = subPolygonIssues.get(polyIdx) || [];
                        } else if (hasGeneralMessages) {
                            // All sub-polygons have issues
                            polyHasIssue = true;
                            polyMessages = violationData.messages;
                        }
                        
                        const subPolygonFeature = {
                            type: 'Feature',
                            geometry: { type: 'Polygon', coordinates: polyCoords },
                            properties: feature.properties || {}
                        };
                        
                        const geoJSONLayer = L.geoJSON(subPolygonFeature, {
                            style: {
                                color: polyHasIssue ? '#dc6575' : '#40916c',
                                weight: 2,
                                fillColor: polyHasIssue ? '#dc6575' : '#40916c',
                                fillOpacity: polyHasIssue ? 0.3 : 0.2,
                                opacity: 0.8,
                                fillRule: 'nonzero'
                            },
                            pane: polyHasIssue ? 'validationErrorPane' : 'validationOkPane'
                        });
                        
                        const geometryType = `MultiPolygon [${polyIdx + 1}/${feature.geometry.coordinates.length}]`;
                        const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                        
                        let message;
                        if (polyHasIssue && polyMessages.length > 0) {
                            message = polyMessages.map(msg => 
                                `<div style="color: #dc6575; margin: 4px 0;"> ${msg}</div>`
                            ).join('');
                        } else if (polyHasIssue) {
                            message = '<div style="color: #dc6575; font-weight: 600;"> Validation issues detected</div>';
                        } else if (hasViolation) {
                            message = '<div style="color: #40916c; font-weight: 600;"> No validation issues on this part</div>';
                        } else {
                            message = '<div style="color: #40916c; font-weight: 600;"> No validation issues detected</div>';
                        }
                        
                        geoJSONLayer.bindTooltip(`<div class="tooltip-content">${header}${message}</div>`, {
                            direction: 'top', sticky: true, opacity: 0.95, className: 'validation-tooltip'
                        });
                        
                        geoJSONLayer.on('mouseover', function(e) { geoJSONLayer.openTooltip(e.latlng); });
                        geoJSONLayer.on('mousemove', function(e) { geoJSONLayer.openTooltip(e.latlng); });
                        geoJSONLayer.on('mouseout', function() { geoJSONLayer.closeTooltip(); });
                        
                        validationOverlayGroup.addLayer(geoJSONLayer);
                    });
                } else if (feature.geometry.type === 'Point') {
                    const coords = feature.geometry.coordinates;
                    const marker = L.circleMarker([coords[1], coords[0]], {
                        radius: 6,
                        fillColor: hasViolation ? '#dc6575' : '#40916c',
                        color: '#fff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8,
                        pane: hasViolation ? 'validationErrorPane' : 'validationOkPane'
                    });
                    
                    const geometryType = 'Point';
                    const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                    
                    let message;
                    if (hasViolation && violationData && violationData.messages && violationData.messages.length > 0) {
                        message = violationData.messages.map(msg => 
                            `<div style="color: #dc6575; margin: 4px 0;"> ${msg}</div>`
                        ).join('');
                    } else if (hasViolation) {
                        message = '<div style="color: #dc6575; font-weight: 600;"> Validation issues detected</div>';
                    } else {
                        message = '<div style="color: #40916c; font-weight: 600;"> No validation issues detected</div>';
                    }
                    
                    marker.bindTooltip(`<div class="tooltip-content">${header}${message}</div>`, {
                        direction: 'top', sticky: true, opacity: 0.95, className: 'validation-tooltip'
                    });
                    
                    marker.on('mouseover', function() { marker.openTooltip(); });
                    marker.on('mouseout', function() { marker.closeTooltip(); });
                    
                    validationOverlayGroup.addLayer(marker);
                } else if (feature.geometry.type === 'MultiPoint') {
                    const subPointIssues = violationData?.subPolygonIssues || new Map(); // Reusing for points
                    
                    feature.geometry.coordinates.forEach((coords, pointIdx) => {
                        const pointHasIssue = subPointIssues.has(pointIdx);
                        
                        const marker = L.circleMarker([coords[1], coords[0]], {
                            radius: 6,
                            fillColor: pointHasIssue ? '#dc6575' : '#40916c',
                            color: '#fff',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.8,
                            pane: pointHasIssue ? 'validationErrorPane' : 'validationOkPane'
                        });
                        
                        const geometryType = `MultiPoint [${pointIdx + 1}/${feature.geometry.coordinates.length}]`;
                        const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                        
                        let message;
                        if (pointHasIssue) {
                            const subPointMessages = subPointIssues.get(pointIdx);
                            if (subPointMessages && subPointMessages.length > 0) {
                                message = subPointMessages.map(msg => 
                                    `<div style="color: #dc6575; margin: 4px 0;"> ${msg}</div>`
                                ).join('');
                            } else {
                                message = '<div style="color: #dc6575; font-weight: 600;"> Validation issues detected</div>';
                            }
                        } else if (hasViolation && subPointIssues.size > 0) {
                            message = '<div style="color: #40916c; font-weight: 600;"> No validation issues on this point</div>';
                        } else {
                            message = '<div style="color: #40916c; font-weight: 600;"> No validation issues detected</div>';
                        }
                        
                        marker.bindTooltip(`<div class="tooltip-content">${header}${message}</div>`, {
                            direction: 'top', sticky: true, opacity: 0.95, className: 'validation-tooltip'
                        });
                        
                        marker.on('mouseover', function() { marker.openTooltip(); });
                        marker.on('mouseout', function() { marker.closeTooltip(); });
                        
                        validationOverlayGroup.addLayer(marker);
                    });
                }
            }
            
            // For clustering, create cluster markers (simplified - all features shown as valid/invalid based on snapshot)
            if (useClustering) {
                currentGeoJSON.features.forEach((feature, idx) => {
                    if (!feature.geometry) return;
                    
                    const persistentId = feature.__persistentId;
                    const validatedFeature = persistentId !== undefined ? validatedFeatureMap.get(persistentId) : null;
                    
                    if (!validatedFeature) return; // Skip new features
                    
                    const validatedIdx = persistentIdToValidatedIndex.get(persistentId);
                    const hasViolation = validatedIdx !== undefined && snapshot.violationStore.has(validatedIdx);
                    
                    let markerLatLng;
                    if (feature.geometry.type === 'Point') {
                        const coords = feature.geometry.coordinates;
                        markerLatLng = [coords[1], coords[0]];
                    } else if (feature.geometry.type === 'MultiPoint') {
                        const coords = feature.geometry.coordinates[0];
                        markerLatLng = [coords[1], coords[0]];
                    } else if (feature.geometry.type === 'Polygon') {
                        const centroid = calculatePolygonCentroid(feature.geometry.coordinates[0]);
                        if (centroid) markerLatLng = [centroid[1], centroid[0]];
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        const centroid = calculatePolygonCentroid(feature.geometry.coordinates[0][0]);
                        if (centroid) markerLatLng = [centroid[1], centroid[0]];
                    }
                    
                    if (!markerLatLng) return;
                    
                    const marker = L.marker(markerLatLng, {
                        icon: L.divIcon({
                            className: hasViolation ? 'validation-marker-error' : 'validation-marker-valid',
                            html: hasViolation ? '<div style="background: #dc6575; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>' : 
                                                 '<div style="background: #40916c; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
                            iconSize: [16, 16]
                        }),
                        validationError: hasViolation
                    });
                    
                    const geometryType = (feature && feature.geometry && feature.geometry.type) ? feature.geometry.type : 'Unknown';
                    const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                    const message = hasViolation ? 
                        '<div style="color: #dc6575; font-weight: 600;"> Validation issues detected</div>' :
                        '<div style="color: #40916c; font-weight: 600;"> No validation issues detected</div>';
                    
                    marker.bindPopup(`<div class="tooltip-content">${header}${message}</div>`);
                    
                    validationClusterGroup.addLayer(marker);
                });
            }
        }

        // Toggle Validate Geometries: show/hide overlay; when showing, run validation procedure with progress
        async function stageValidateGeometries(options) {
            try {
                if (!map) return;
                
                // Clear any existing validation overlay
                if (validationOverlayGroup) {
                    map.removeLayer(validationOverlayGroup);
                    validationOverlayGroup = null;
                }
                
                // Prepare validation
                __validationCancelled = false;
                openValidationProgress();
                validationOverlayGroup = L.featureGroup().addTo(map);

                if (!currentGeoJSON || !currentGeoJSON.features) { 
                    closeValidationProgress(); 
                    return; 
                }

                // Run validation pipeline to detect all issues (but don't fix)
                const results = await runValidationPipeline(currentGeoJSON, {
                    stages: ['geometricValidity', 'duplicateVertices', 'duplicates', 'selfIntersections', 'holes', 'slivers', 'overlaps'],
                    fix: false,
                    progressCallback: (progress, msg) => setValidationProgress(Math.round(progress * 0.7), msg) // Use 70% for detection
                });

                // Check for cancellation
                if (__validationCancelled) throw new Error('Validation cancelled');

                setValidationProgress(70, 'Processing validation results...');
                await delay(0);
                if (__validationCancelled) throw new Error('Validation cancelled');

                // Extract results from pipeline
                const invalidGeometries = results.issues.geometricValidity?.invalidFeatures || [];
                const duplicateVertices = results.issues.duplicateVertices?.invalidFeatures || [];
                const duplicateFeatures = results.issues.duplicates?.duplicateFeatures || [];
                const duplicatePointFeatures = results.issues.duplicates?.duplicatePointFeatures || [];
                const selfIntersectingFeatures = results.issues.selfIntersections?.selfIntersectingFeatures || [];
                const featuresWithHoles = results.issues.holes?.featuresWithHoles || [];
                const featuresWithSharpAngles = results.issues.slivers?.featuresWithSharpAngles || [];
                const overlappingPairs = results.issues.overlaps?.overlappingPairs || [];

                // For backward compatibility, also get invalidFeatures from cleanFeatureSet
                const { cleanGeoJSON, invalidFeatures } = cleanFeatureSet(currentGeoJSON);

                // Accumulate all violations per feature first
                const __violationStore = new Map();
                const __tooltipOptions = { direction: 'top', sticky: true, opacity: 0.95, className: 'validation-tooltip' };
                let anyViolations = false;
                
                // Helper to add violation message to a feature
                function addViolationMessage(featureIndex, message, subPolygonIndex = null) {
                    if (!__violationStore.has(featureIndex)) {
                        __violationStore.set(featureIndex, { messages: [], subPolygonIssues: new Map() });
                    }
                    const existing = __violationStore.get(featureIndex);
                    
                    // If this is for a specific sub-polygon, track it separately
                    if (subPolygonIndex !== null) {
                        if (!existing.subPolygonIssues.has(subPolygonIndex)) {
                            existing.subPolygonIssues.set(subPolygonIndex, []);
                        }
                        const subPolyMessages = existing.subPolygonIssues.get(subPolygonIndex);
                        if (!subPolyMessages.includes(message)) {
                            subPolyMessages.push(message);
                        }
                    } else {
                        // General feature-level message
                        if (!existing.messages.includes(message)) {
                            existing.messages.push(message);
                        }
                    }
                }

                function addViolationPolygon(coords, messages, featureIndex) {
                    try {
                        anyViolations = true;
                        // Ensure dedicated panes and renderers for ERROR (red) overlays
                        if (!map.getPane('validationErrorPane')) {
                            map.createPane('validationErrorPane');
                            const errp = map.getPane('validationErrorPane');
                            errp.style.zIndex = '620';
                            errp.style.pointerEvents = 'auto';
                        }
                        if (!window.__validationErrorRenderer) {
                            window.__validationErrorRenderer = L.svg({ pane: 'validationErrorPane' });
                            window.__validationErrorRenderer.addTo(map);
                        }

                        // Create new overlay for this polygon
                        const latlngs = coords.map(c => [c[1], c[0]]);
                        const poly = L.polygon(latlngs, {
                            renderer: window.__validationErrorRenderer,
                            pane: 'validationErrorPane',
                            interactive: true,
                            bubblingMouseEvents: false,
                            color: '#dc3545',
                            weight: 2,
                            fillColor: '#dc3545',
                            fillOpacity: 0.35,
                            opacity: 0.9,
                            fillRule: 'nonzero'
                        });
                        const text = Array.isArray(messages) ? messages.join('<br>') : String(messages || 'Invalid geometry');
                        const feature = currentGeoJSON.features[featureIndex];
                        const persistentId = (feature && typeof feature.__persistentId === 'number') ? feature.__persistentId : featureIndex;
                        const geometryType = (feature && feature.geometry && feature.geometry.type) ? feature.geometry.type : 'Unknown';
                        const header = `<div class="tooltip-header">Feature ${typeof persistentId==='number'?persistentId:''} - ${geometryType}</div>`;
                        poly.bindTooltip(`<div class="tooltip-content">${header}${text}</div>`, __tooltipOptions);
                        poly.on('mouseover', function(e){ poly.openTooltip(e.latlng); });
                        poly.on('mousemove', function(e){ poly.openTooltip(e.latlng); });
                        poly.on('mouseout', function(){ poly.closeTooltip(); });
                        // Prevent clicks from triggering underlying edit/property handlers
                        poly.on('click', function(e){
                            if (e && e.originalEvent) {
                                e.originalEvent.preventDefault && e.originalEvent.preventDefault();
                                e.originalEvent.stopPropagation && e.originalEvent.stopPropagation();
                                e.originalEvent.stopImmediatePropagation && e.originalEvent.stopImmediatePropagation();
                            }
                        });
                        validationOverlayGroup.addLayer(poly);
                        if (poly.bringToFront) poly.bringToFront();
                        
                        // Add to violation store to track this feature as having violations
                        // This ensures it won't be shown as green in addValidationStatusMarkers
                        if (!__violationStore.has(featureIndex)) {
                            __violationStore.set(featureIndex, { messages: [] });
                        }
                        const existing = __violationStore.get(featureIndex);
                        const newMsgs = Array.isArray(messages) ? messages : [messages];
                        for (const msg of newMsgs) {
                            if (!existing.messages.includes(msg)) {
                                existing.messages.push(msg);
                            }
                        }
                        
                        return poly;
                    } catch (e) { /* ignore */ }
                }

                // Collect violation messages for geometrically invalid features (from pipeline)
                setValidationProgress(70, 'Collecting geometric validity violations...');
                for (let i = 0; i < invalidGeometries.length; i++) {
                    if (__validationCancelled) throw new Error('Validation cancelled');
                    const invalidItem = invalidGeometries[i];
                    if (!invalidItem) continue;
                    const idx = invalidItem.featureIndex;
                    const reason = invalidItem.reason || 'Invalid geometry structure';
                    addViolationMessage(idx, `Validity check failed: ${reason}`);
                    if ((i % globalReportInterval) === 0) await delay(0);
                }
                
                // Also collect violations from legacy invalidFeatures (for backward compatibility)
                for (let i = 0; i < invalidFeatures.length; i++) {
                    if (__validationCancelled) throw new Error('Validation cancelled');
                    const invalidFeature = invalidFeatures[i];
                    if (!invalidFeature || !invalidFeature.geometry) continue;
                    addViolationMessage(i, 'Invalid geometry (legacy check)');
                    if ((i % globalReportInterval) === 0) await delay(0);
                }

                // Collect duplicate vertices violation messages
                setValidationProgress(70.5, 'Collecting duplicate vertices violations...');
                for (let i = 0; i < duplicateVertices.length; i++) {
                    if (__validationCancelled) throw new Error('Validation cancelled');
                    const dupVertItem = duplicateVertices[i];
                    if (!dupVertItem) continue;
                    const idx = dupVertItem.featureIndex;
                    const reason = dupVertItem.reason || 'Duplicate vertices detected';
                    // If this is a MultiPolygon with specific sub-polygon issues, add messages for each
                    if (dupVertItem.subPolygonIndices && dupVertItem.subPolygonIndices.length > 0) {
                        for (const subPolyIdx of dupVertItem.subPolygonIndices) {
                            addViolationMessage(idx, reason, subPolyIdx);
                        }
                    } else {
                        addViolationMessage(idx, reason);
                    }
                    anyViolations = true;
                    if ((i % globalReportInterval) === 0) await delay(0);
                }

                // Collect duplicate violation messages
                setValidationProgress(71, 'Collecting duplicate violations...');
                for (let i = 0; i < duplicateFeatures.length; i++) {
                    if (__validationCancelled) throw new Error('Validation cancelled');
                    const duplicateItem = duplicateFeatures[i];
                    if (!duplicateItem || !duplicateItem.feature) continue;
                    
                    // Skip Point/MultiPoint - those are handled by duplicate point violations
                    const geomType = duplicateItem.feature.geometry?.type;
                    if (geomType === 'Point' || geomType === 'MultiPoint') continue;
                    
                    // For sub-polygon duplicates, pass the polyIndex for sub-polygon tracking
                    if (duplicateItem.polyIndex !== undefined && duplicateItem.polyIndex !== null) {
                        addViolationMessage(duplicateItem.featureIndex, `Sub-polygon ${duplicateItem.polyIndex + 1} is duplicate`, duplicateItem.polyIndex);
                    } else {
                        addViolationMessage(duplicateItem.featureIndex, 'Duplicate geometry detected');
                    }
                    if ((i % globalReportInterval) === 0) await delay(0);
                }

                // Collect duplicate point violation messages
                setValidationProgress(71.5, 'Collecting duplicate point violations...');
                for (let i = 0; i < duplicatePointFeatures.length; i++) {
                    if (__validationCancelled) throw new Error('Validation cancelled');
                    const dupPoint = duplicatePointFeatures[i];
                    if (!dupPoint) continue;
                    
                    const feature = currentGeoJSON.features[dupPoint.featureIndex];
                    if (!feature) continue;
                    
                    // Create message based on geometry type
                    let message;
                    if (dupPoint.pointIndex === null) {
                        // Standalone Point
                        message = `Duplicate point (appears ${dupPoint.duplicateCount} times)`;
                    } else {
                        // Point within MultiPoint
                        message = `Point ${dupPoint.pointIndex + 1} is duplicate (appears ${dupPoint.duplicateCount} times)`;
                    }
                    
                    // Add message with point index for MultiPoint sub-point tracking
                    if (dupPoint.pointIndex !== null) {
                        addViolationMessage(dupPoint.featureIndex, message, dupPoint.pointIndex);
                    } else {
                        addViolationMessage(dupPoint.featureIndex, message);
                    }
                    
                    if ((i % globalReportInterval) === 0) await delay(0);
                }

                // Collect self-intersection violation messages
                setValidationProgress(72, 'Collecting self-intersection violations...');
                for (let i = 0; i < selfIntersectingFeatures.length; i++) {
                    if (__validationCancelled) throw new Error('Validation cancelled');
                    const selfIntersectingItem = selfIntersectingFeatures[i];
                    if (!selfIntersectingItem || !selfIntersectingItem.feature) continue;
                    const featureIndex = selfIntersectingItem.featureIndex;
                    const kinkCount = selfIntersectingItem.kinkCount || 0;
                    const message = kinkCount > 1 
                        ? `Self-intersecting geometry (${kinkCount} intersection points)`
                        : 'Self-intersecting geometry';
                    // If this is a MultiPolygon with specific sub-polygon issues, add messages for each
                    if (selfIntersectingItem.subPolygonIndices && selfIntersectingItem.subPolygonIndices.length > 0) {
                        for (const subPolyIdx of selfIntersectingItem.subPolygonIndices) {
                            addViolationMessage(featureIndex, message, subPolyIdx);
                        }
                    } else {
                        addViolationMessage(featureIndex, message);
                    }
                    anyViolations = true;
                    if ((i % globalReportInterval) === 0) await delay(0);
                }

                // Collect holes violation messages
                setValidationProgress(73, 'Collecting holes violations...');
                for (let i = 0; i < featuresWithHoles.length; i++) {
                    if (__validationCancelled) throw new Error('Validation cancelled');
                    const item = featuresWithHoles[i];
                    const idx = item.featureIndex;
                    const msg = item.holesCount === 1 ? 'Polygon has a hole' : `Polygon has ${item.holesCount} holes`;
                    addViolationMessage(idx, msg);
                    if ((i % globalReportInterval) === 0) await delay(0);
                }

                // Collect sharp angle violation messages
                setValidationProgress(74, 'Collecting sliver violations...');
                for (let i = 0; i < featuresWithSharpAngles.length; i++) {
                    if (__validationCancelled) throw new Error('Validation cancelled');
                    const item = featuresWithSharpAngles[i];
                    const idx = item.featureIndex;
                    const msg = item.count === 1 ? 'Sharp angle below 4' : `${item.count} sharp angles below 4`;
                    // If this is a MultiPolygon with specific sub-polygon issues, add messages for each
                    if (item.subPolygonIndices && item.subPolygonIndices.length > 0) {
                        for (const subPolyIdx of item.subPolygonIndices) {
                            addViolationMessage(idx, msg, subPolyIdx);
                        }
                    } else {
                        addViolationMessage(idx, msg);
                    }
                    if ((i % globalReportInterval) === 0) await delay(0);
                }

                // Collect overlap violation messages with sub-polygon tracking
                setValidationProgress(75, 'Collecting overlap violations...');
                
                // Track overlaps: featureIndex -> { subPolygonIndex -> Set of overlapping feature IDs }
                const featureOverlaps = new Map();
                
                for (let i = 0; i < overlappingPairs.length; i++) {
                    if (__validationCancelled) throw new Error('Validation cancelled');
                    const pair = overlappingPairs[i];
                    if (!pair) continue;
                    
                    const displayIdA = pair.persistentIdA !== undefined ? pair.persistentIdA : pair.indexA;
                    const displayIdB = pair.persistentIdB !== undefined ? pair.persistentIdB : pair.indexB;
                    
                    // Add to feature A's overlap list (with sub-polygon tracking)
                    if (!featureOverlaps.has(pair.indexA)) {
                        featureOverlaps.set(pair.indexA, new Map());
                    }
                    const subPolyMapA = featureOverlaps.get(pair.indexA);
                    const subPolyIdxA = pair.subPolygonIndexA !== null ? pair.subPolygonIndexA : -1; // -1 for non-MultiPolygon
                    if (!subPolyMapA.has(subPolyIdxA)) {
                        subPolyMapA.set(subPolyIdxA, new Set());
                    }
                    subPolyMapA.get(subPolyIdxA).add(displayIdB);
                    
                    // Add to feature B's overlap list (with sub-polygon tracking)
                    if (!featureOverlaps.has(pair.indexB)) {
                        featureOverlaps.set(pair.indexB, new Map());
                    }
                    const subPolyMapB = featureOverlaps.get(pair.indexB);
                    const subPolyIdxB = pair.subPolygonIndexB !== null ? pair.subPolygonIndexB : -1; // -1 for non-MultiPolygon
                    if (!subPolyMapB.has(subPolyIdxB)) {
                        subPolyMapB.set(subPolyIdxB, new Set());
                    }
                    subPolyMapB.get(subPolyIdxB).add(displayIdA);
                    
                    if ((i % globalReportInterval) === 0) await delay(0);
                }
                
                // Add overlap messages to violation store
                for (const [featureIndex, subPolyMap] of featureOverlaps.entries()) {
                    for (const [subPolyIdx, overlapSet] of subPolyMap.entries()) {
                        const overlapIds = Array.from(overlapSet).sort((a, b) => a - b);
                        for (const id of overlapIds) {
                            // If subPolyIdx is -1, it's a regular Polygon (no sub-polygon tracking)
                            // Otherwise, it's a MultiPolygon with specific sub-polygon index
                            if (subPolyIdx === -1) {
                                addViolationMessage(featureIndex, `Overlaps with feature #${id}`);
                            } else {
                                addViolationMessage(featureIndex, `Overlaps with feature #${id}`, subPolyIdx);
                            }
                        }
                    }
                }
                
                // Now create overlays for all features with violations (one overlay per feature, all messages combined)
                setValidationProgress(80, 'Creating violation overlays...');
                let overlayIdx = 0;
                for (const [featureIndex, violationData] of __violationStore.entries()) {
                        if (__validationCancelled) throw new Error('Validation cancelled');
                    const feature = currentGeoJSON.features[featureIndex];
                    if (!feature || !feature.geometry) continue;
                    
                    try {
                        const g = feature.geometry;
                        if (g.type === 'Polygon' && g.coordinates && g.coordinates[0]) {
                            const ring = g.coordinates[0];
                            if (Array.isArray(ring) && ring.length >= 4) {
                                addViolationPolygon(ring, violationData.messages, featureIndex);
                            }
                        } else if (g.type === 'MultiPolygon' && g.coordinates) {
                            // For MultiPolygons, render red overlay only on sub-polygons with issues
                            const subPolygonIssues = violationData.subPolygonIssues || new Map();
                            
                            // If we have sub-polygon specific tracking, use it
                            if (subPolygonIssues.size > 0) {
                                for (let polyIdx = 0; polyIdx < g.coordinates.length; polyIdx++) {
                                    const poly = g.coordinates[polyIdx];
                                    if (poly && poly[0] && Array.isArray(poly[0]) && poly[0].length >= 4) {
                                        // Only render if this specific sub-polygon has issues
                                        if (subPolygonIssues.has(polyIdx)) {
                                            const subPolyMessages = subPolygonIssues.get(polyIdx);
                                            addViolationPolygon(poly[0], subPolyMessages, featureIndex);
                                        }
                                    }
                                }
                            } else if (violationData.messages && violationData.messages.length > 0) {
                                // Fallback: if there are general feature-level messages without sub-polygon tracking
                                // (e.g., overlaps, duplicate features), show on ALL sub-polygons
                                // Note: This is conservative - we can't determine which specific sub-polygon
                                // has the issue, so we flag all to avoid missing problems
                                for (let polyIdx = 0; polyIdx < g.coordinates.length; polyIdx++) {
                                    const poly = g.coordinates[polyIdx];
                                    if (poly && poly[0] && Array.isArray(poly[0]) && poly[0].length >= 4) {
                                        addViolationPolygon(poly[0], violationData.messages, featureIndex);
                                    }
                                }
                            }
                        }
                    } catch (_) {}
                    
                    overlayIdx++;
                    if ((overlayIdx % globalReportInterval) === 0) await delay(0);
                }

                setValidationProgress(100, getText('renderingValidationResults'));
                await delay(250);
                closeValidationProgress();
                
                // Don't overwrite restored results if user chose to use previous validation
                if (!__usingPreviousValidation) {
                    // Add markers for all features showing validation status
                    addValidationStatusMarkers(__violationStore);
                    
                    // Store COMPLETE validation snapshot for accurate re-display
                    __lastValidationStore = {
                        validatedFeatures: JSON.parse(JSON.stringify(currentGeoJSON.features)), // Deep copy
                        violationStore: new Map(__violationStore),
                        featuresWithErrors: Array.from(featuresWithValidationErrors),
                        timestamp: Date.now(),
                        stats: {
                            total: currentGeoJSON.features.length,
                            withErrors: featuresWithValidationErrors.size
                        }
                    };
                }
                
                // Show navigation control for errors (if any)
                showValidationNavigator();
                
                // Stay in validation mode regardless of whether there are violations
                validationOverlayVisible = true;
                
                // Detect unsupported geometry types
                const unsupportedTypes = [];
                if (currentGeoJSON && currentGeoJSON.features) {
                    for (const feature of currentGeoJSON.features) {
                        if (feature && feature.geometry) {
                            const geomType = feature.geometry.type;
                            if (geomType === 'LineString' || geomType === 'MultiLineString') {
                                if (!unsupportedTypes.includes(geomType)) {
                                    unsupportedTypes.push(geomType);
                                }
                            }
                        }
                    }
                }
                
                // Prepare validation report data
                const totalFeatures = currentGeoJSON.features.length;
                const invalidCount = invalidGeometries.length;
                const duplicateVerticesCount = duplicateVertices.length;
                const duplicatePointsCount = duplicatePointFeatures.length;
                // Exclude Point/MultiPoint from duplicateCount to avoid double-counting with duplicatePointsCount
                const duplicateCount = duplicateFeatures.filter(dup => {
                    const feature = results.features[dup.featureIndex];
                    const geomType = feature?.geometry?.type;
                    return geomType !== 'Point' && geomType !== 'MultiPoint';
                }).length;
                const selfIntersectionCount = selfIntersectingFeatures.length;
                const holesCount = featuresWithHoles.length;
                const sliversCount = featuresWithSharpAngles.length;
                const overlapCount = overlappingPairs.length;
                
                const featuresWithIssuesSet = new Set();
                invalidGeometries.forEach(item => featuresWithIssuesSet.add(item.featureIndex));
                duplicateVertices.forEach(item => featuresWithIssuesSet.add(item.featureIndex));
                duplicatePointFeatures.forEach(item => featuresWithIssuesSet.add(item.featureIndex));
                duplicateFeatures.forEach(item => featuresWithIssuesSet.add(item.featureIndex));
                selfIntersectingFeatures.forEach(item => featuresWithIssuesSet.add(item.featureIndex));
                featuresWithHoles.forEach(item => featuresWithIssuesSet.add(item.featureIndex));
                featuresWithSharpAngles.forEach(item => featuresWithIssuesSet.add(item.featureIndex));
                // Note: overlaps are pairs, not individual features, so we don't add them to the set
                
                const validationData = {
                    totalFeatures: totalFeatures,
                    validFeatures: totalFeatures - featuresWithIssuesSet.size,
                    featuresWithIssues: featuresWithIssuesSet.size,
                    hasIssues: anyViolations,
                    invalidGeometries: invalidCount,
                    duplicateVertices: duplicateVerticesCount,
                    duplicates: duplicateCount,
                    duplicatePoints: duplicatePointsCount,
                    selfIntersections: selfIntersectionCount,
                    holes: holesCount,
                    slivers: sliversCount,
                    overlaps: overlapCount,
                    unsupportedTypes: unsupportedTypes
                };
                
                // Show validation report modal
                openValidationReportModal(validationData);
            } catch (err) {
                closeValidationProgress();
                
                // Don't switch to VIEW mode if we're using previous validation results
                if (!__usingPreviousValidation) {
                    hideValidationNavigator();
                    validationOverlayVisible = false;
                    switchMode(MODES.VIEW);
                }
                
                if ((""+err).toLowerCase().includes('cancel')) return;
                showErrorNotification(getText('validationErrorOccurred', err && err.message ? err.message : err), 'red');
            } finally {
                __validationCancelled = false;
                __usingPreviousValidation = false; // Clear the flag here
            }
        }


        // Undo/Redo stacks for geometry changes only
        const __UNDO_LIMIT = 10;
        let __undoStack = [];
        let __redoStack = [];
        let __isUndoing = false;
        let __isRedoing = false;
        
        // Helper to find feature index by reference or __persistentId
        function __findFeatureIndex(feature) {
            if (!currentGeoJSON || !currentGeoJSON.features) return -1;
            const features = currentGeoJSON.features;
            
            // Try direct reference match first (fastest)
            for (let i = 0; i < features.length; i++) {
                if (features[i] === feature) return i;
            }
            
            // Try __persistentId match
            if (typeof feature.__persistentId === 'number') {
                for (let i = 0; i < features.length; i++) {
                    if (features[i].__persistentId === feature.__persistentId) return i;
                }
            }
            
            return -1;
        }
        
        function pushUndoSnapshot(reason, featureOrIndex = null, operation = null) {
            try {
                if (__isUndoing || __isRedoing) return;
                if (!currentGeoJSON || !currentGeoJSON.features) return;
                
                // Determine if this should be a delta snapshot
                const isDelta = featureOrIndex !== null && operation !== null;
                
                let snapshot;
                if (!isDelta) {
                    // Full snapshot (for auto-clean and other bulk operations)
                    snapshot = {
                        type: 'full',
                        reason: reason,
                        data: JSON.parse(JSON.stringify(currentGeoJSON))
                    };
                } else {
                    // Delta snapshot (for single-feature edits)
                    const featureIndex = typeof featureOrIndex === 'number' ? featureOrIndex : __findFeatureIndex(featureOrIndex);
                    if (featureIndex === -1) {
                        console.warn('pushUndoSnapshot: feature not found for delta, using full snapshot');
                        snapshot = {
                            type: 'full',
                            reason: reason,
                            data: JSON.parse(JSON.stringify(currentGeoJSON))
                        };
                    } else {
                        snapshot = {
                            type: 'delta',
                            reason: reason,
                            operation: operation,
                            featureIndex: featureIndex,
                            beforeFeature: operation === 'add' ? null : JSON.parse(JSON.stringify(currentGeoJSON.features[featureIndex])),
                            afterFeature: null // Will be set during undo when we save current state
                        };
                    }
                }
                
                if (__undoStack.length >= __UNDO_LIMIT) __undoStack.shift();
                __undoStack.push(snapshot);
                // Clear redo stack when new action is performed
                __redoStack = [];
            } catch (err) { console.warn('pushUndoSnapshot failed', err); }
        }
        function undoLastChange() {
            try {
                if (!__undoStack.length) {
                    showErrorNotification(getText('noUndoAvailable'), 'amber');
                    return;
                }
                __isUndoing = true;
                // Deselect any active editing overlays to avoid mismatch
                try { if (typeof disableVertexEditing === 'function') disableVertexEditing(); } catch(_) {}
                try { if (typeof disablePointEditing === 'function') disablePointEditing(); } catch(_) {}
                
                const snapshot = __undoStack.pop();
                
                if (snapshot.type === 'full') {
                    // Full snapshot: save current state to redo stack and restore full snapshot
                    if (currentGeoJSON && currentGeoJSON.features) {
                        const currentSnapshot = {
                            type: 'full',
                            reason: snapshot.reason,
                            data: JSON.parse(JSON.stringify(currentGeoJSON))
                        };
                        if (__redoStack.length >= __UNDO_LIMIT) __redoStack.shift();
                        __redoStack.push(currentSnapshot);
                    }
                    currentGeoJSON = JSON.parse(JSON.stringify(snapshot.data));
                } else if (snapshot.type === 'delta') {
                    // Delta snapshot: apply inverse operation
                    const idx = snapshot.featureIndex;
                    const features = currentGeoJSON.features;
                    
                    // For redo, we need to save what's necessary to reapply the original operation
                    let redoSnapshot;
                    
                    // Apply inverse operation and capture state for redo
                    if (snapshot.operation === 'edit') {
                        // Save current (edited) state for redo
                        redoSnapshot = {
                            type: 'delta',
                            reason: snapshot.reason,
                            operation: 'edit',
                            featureIndex: idx,
                            beforeFeature: JSON.parse(JSON.stringify(features[idx])),
                            afterFeature: null
                        };
                        // Restore the before state
                        features[idx] = JSON.parse(JSON.stringify(snapshot.beforeFeature));
                    } else if (snapshot.operation === 'add') {
                        // Save the added feature for redo
                        redoSnapshot = {
                            type: 'delta',
                            reason: snapshot.reason,
                            operation: 'add',
                            featureIndex: idx,
                            beforeFeature: JSON.parse(JSON.stringify(features[idx])),
                            afterFeature: null
                        };
                        // Remove the added feature
                        features.splice(idx, 1);
                    } else if (snapshot.operation === 'delete') {
                        // Save the deleted feature for redo
                        redoSnapshot = {
                            type: 'delta',
                            reason: snapshot.reason,
                            operation: 'delete',
                            featureIndex: idx,
                            beforeFeature: JSON.parse(JSON.stringify(snapshot.beforeFeature)),
                            afterFeature: null
                        };
                        // Re-insert the deleted feature
                        features.splice(idx, 0, JSON.parse(JSON.stringify(snapshot.beforeFeature)));
                    }
                    
                    if (__redoStack.length >= __UNDO_LIMIT) __redoStack.shift();
                    __redoStack.push(redoSnapshot);
                }
                
                // Re-render without panning/zooming; tools/mode unchanged
                processGeoJSON(currentGeoJSON, true);
            } catch (err) {
                console.warn('Undo failed', err);
            } finally {
                __isUndoing = false;
            }
        }

        function redoLastChange() {
            try {
                if (!__redoStack.length) {
                    showErrorNotification(getText('noRedoAvailable'), 'amber');
                    return;
                }
                __isRedoing = true;
                // Deselect any active editing overlays to avoid mismatch
                try { if (typeof disableVertexEditing === 'function') disableVertexEditing(); } catch(_) {}
                try { if (typeof disablePointEditing === 'function') disablePointEditing(); } catch(_) {}
                
                const snapshot = __redoStack.pop();
                
                if (snapshot.type === 'full') {
                    // Full snapshot: save current state to undo stack and restore full snapshot
                    if (currentGeoJSON && currentGeoJSON.features) {
                        const currentSnapshot = {
                            type: 'full',
                            reason: snapshot.reason,
                            data: JSON.parse(JSON.stringify(currentGeoJSON))
                        };
                        if (__undoStack.length >= __UNDO_LIMIT) __undoStack.shift();
                        __undoStack.push(currentSnapshot);
                    }
                    currentGeoJSON = JSON.parse(JSON.stringify(snapshot.data));
                } else if (snapshot.type === 'delta') {
                    // Delta snapshot: apply forward operation (reapply what was undone)
                    const idx = snapshot.featureIndex;
                    const features = currentGeoJSON.features;
                    
                    // For undo of a redo, save what's necessary to undo again
                    let undoSnapshot;
                    
                    // Apply forward operation and capture state for undo
                    if (snapshot.operation === 'edit') {
                        // Save current state for undo
                        undoSnapshot = {
                            type: 'delta',
                            reason: snapshot.reason,
                            operation: 'edit',
                            featureIndex: idx,
                            beforeFeature: JSON.parse(JSON.stringify(features[idx])),
                            afterFeature: null
                        };
                        // Apply the edited state
                        features[idx] = JSON.parse(JSON.stringify(snapshot.beforeFeature));
                    } else if (snapshot.operation === 'add') {
                        // Re-add the feature
                        features.splice(idx, 0, JSON.parse(JSON.stringify(snapshot.beforeFeature)));
                        // Save for undo (no before state since it's an add)
                        undoSnapshot = {
                            type: 'delta',
                            reason: snapshot.reason,
                            operation: 'add',
                            featureIndex: idx,
                            beforeFeature: null,
                            afterFeature: null
                        };
                    } else if (snapshot.operation === 'delete') {
                        // Save the feature being deleted for undo
                        undoSnapshot = {
                            type: 'delta',
                            reason: snapshot.reason,
                            operation: 'delete',
                            featureIndex: idx,
                            beforeFeature: JSON.parse(JSON.stringify(features[idx])),
                            afterFeature: null
                        };
                        // Re-delete the feature
                        features.splice(idx, 1);
                    }
                    
                    if (__undoStack.length >= __UNDO_LIMIT) __undoStack.shift();
                    __undoStack.push(undoSnapshot);
                }
                
                // Re-render without panning/zooming; tools/mode unchanged
                processGeoJSON(currentGeoJSON, true);
            } catch (err) {
                console.warn('Redo failed', err);
            } finally {
                __isRedoing = false;
            }
        }

        let __lastToggleWasUndo = false;
        function toggleLastStep() {
            try {
                // If we just did an undo, do a redo; if we just did a redo, do an undo
                // If neither, default to undo (go back one step)
                if (__lastToggleWasUndo && __redoStack.length > 0) {
                    redoLastChange();
                    __lastToggleWasUndo = false;
                } else if (__undoStack.length > 0) {
                    undoLastChange();
                    __lastToggleWasUndo = true;
                }
            } catch (err) {
                console.warn('Toggle last step failed', err);
            }
        }

        function setCursorCrosshair(enabled) {
            try {
                const el = (map && map.getContainer && map.getContainer()) || document.getElementById('map');
                if (!el) return;
                if (enabled) {
                    el.classList.add('cursor-crosshair');
                    document.body.classList.add('crosshair-mode');
                    // Force inline cursor on key Leaflet panes
                    const panes = el.querySelectorAll('.leaflet-container, .leaflet-pane, .leaflet-overlay-pane, .leaflet-map-pane, .leaflet-marker-pane, .leaflet-popup-pane, .leaflet-tile-pane');
                    panes.forEach(n => { try { n.style.setProperty('cursor', 'crosshair', 'important'); } catch(_) {} });
                } else {
                    el.classList.remove('cursor-crosshair');
                    document.body.classList.remove('crosshair-mode');
                    const panes = el.querySelectorAll('.leaflet-container, .leaflet-pane, .leaflet-overlay-pane, .leaflet-map-pane, .leaflet-marker-pane, .leaflet-popup-pane, .leaflet-tile-pane');
                    panes.forEach(n => { try { n.style.removeProperty('cursor'); } catch(_) {} });
                }
            } catch(_) {}
        }

        // Suppress empty-map deselection briefly during/after vertex dragging/snapping
        let __draggingVertexActive = false;
        let __suppressEmptyDeselect = false;
        function suppressEmptyDeselect(ms = 300) {
            __suppressEmptyDeselect = true;
            try { clearTimeout(window.__suppressEmptyDeselectTimer); } catch(_) {}
            window.__suppressEmptyDeselectTimer = setTimeout(function(){ __suppressEmptyDeselect = false; }, ms);
        }
    </script>
</body>